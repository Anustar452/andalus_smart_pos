# Andalus Smart POS/·ä†·äï·ã∞·àâ·àµ ·àµ·àõ·à≠·âµ ·çñ·àµ

A mobile-first Point of Sale application for Ethiopian shops, built with Flutter.

## Features

- üì± Mobile-first POS with large touch targets
- üì¥ Offline-first with SQLite local database
- üîÑ Background sync to Laravel backend
  <<<<<<< HEAD
- # üí≥ Telebirr, cash, and other payment integration, CBE, and other banks support, payment integration
- üí≥ Telebirr, cash, and other payment integration, CBE, and other banks support, payment integration
  > > > > > > > 0bf26c0 (Read me filled)
- üîî FCM push notifications
- üåê Multilingual (English + Amharic)
- üîí Secure token storage
- business targeting for making this Ethiopian developer from 0 to wealthy
  <<<<<<< HEAD
  =======

> > > > > > > 0bf26c0 (Read me filled)

## Tech Stack

- **Flutter 3.x** with Material 3
- **Riverpod** for state management
- **sqflite** for local database
- **Dio** for HTTP client
- **flutter_secure_storage** for security
- **blue_thermal_printer** for receipt printing

## Development Setup

### Prerequisites

- Flutter SDK 3.0+
- Android Studio / VS Code
- Android Emulator or physical device

## Mobile app Code Review Snippets

<<<<<<< HEAD
//TODO: GENERATED FILE, DO NOT EDIT. for coloring and theming purposes only.
//lib/src/config/theme/color_schemes.g.dart
import 'package:flutter/material.dart';

const lightColorScheme = ColorScheme(
brightness: Brightness.light,
primary: Color(0xFF10B981),
onPrimary: Color(0xFFFFFFFF),
primaryContainer: Color(0xFFA7F4D0),
onPrimaryContainer: Color(0xFF002116),
secondary: Color(0xFF059669),
onSecondary: Color(0xFFFFFFFF),
secondaryContainer: Color(0xFF9BF7D2),
onSecondaryContainer: Color(0xFF002116),
tertiary: Color(0xFF7C5800),
onTertiary: Color(0xFFFFFFFF),
tertiaryContainer: Color(0xFFFFDEA6),
onTertiaryContainer: Color(0xFF271900),
error: Color(0xFFBA1A1A),
errorContainer: Color(0xFFFFDAD6),
onError: Color(0xFFFFFFFF),
onErrorContainer: Color(0xFF410002),
background: Color(0xFFF9FAFB),
onBackground: Color(0xFF1A1C1A),
surface: Color(0xFFF9FAFB),
onSurface: Color(0xFF1A1C1A),
surfaceVariant: Color(0xFFDCE5DD),
onSurfaceVariant: Color(0xFF404942),
outline: Color(0xFF707973),
onInverseSurface: Color(0xFFF0F1EC),
inverseSurface: Color(0xFF2E312E),
inversePrimary: Color(0xFF8BD9B5),
shadow: Color(0xFF000000),
surfaceTint: Color(0xFF006D46),
);

const darkColorScheme = ColorScheme(
brightness: Brightness.dark,
primary: Color(0xFF8BD9B5),
onPrimary: Color(0xFF003827),
primaryContainer: Color(0xFF005139),
onPrimaryContainer: Color(0xFFA7F4D0),
secondary: Color(0xFF7FDAB6),
onSecondary: Color(0xFF003827),
secondaryContainer: Color(0xFF005139),
onSecondaryContainer: Color(0xFF9BF7D2),
tertiary: Color(0xFFF5BD49),
onTertiary: Color(0xFF402D00),
tertiaryContainer: Color(0xFF5E4300),
onTertiaryContainer: Color(0xFFFFDEA6),
error: Color(0xFFFFB4AB),
errorContainer: Color(0xFF93000A),
onError: Color(0xFF690005),
onErrorContainer: Color(0xFFFFDAD6),
background: Color(0xFF1A1C1A),
onBackground: Color(0xFFE2E3DE),
surface: Color(0xFF1A1C1A),
onSurface: Color(0xFFE2E3DE),
surfaceVariant: Color(0xFF404942),
onSurfaceVariant: Color(0xFFC0C9C1),
outline: Color(0xFF8A938C),
onInverseSurface: Color(0xFF1A1C1A),
inverseSurface: Color(0xFFE2E3DE),
inversePrimary: Color(0xFF006D46),
shadow: Color(0xFF000000),
surfaceTint: Color(0xFF8BD9B5),
);

##// src/config/theme/app_theme.dart
// App theme configuration using generated color schemes and font themes.
import 'package:andalus_smart_pos/src/config/theme/color_schemes.g.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'font_theme.dart';

class AppTheme {
static ThemeData lightTheme(WidgetRef ref) {
final fontTheme = ref.read(fontThemeProvider);

    return ThemeData(
      useMaterial3: true,
      colorScheme: lightColorScheme,
      fontFamily: fontTheme.englishFont.fontFamily,
      typography: Typography.material2021(
        englishLike: Typography.englishLike2021,
        dense: Typography.dense2021,
        tall: Typography.tall2021,
      ),
      textTheme: _buildTextTheme(fontTheme, Brightness.light),
      appBarTheme: AppBarTheme(
        backgroundColor: lightColorScheme.primary,
        foregroundColor: lightColorScheme.onPrimary,
        elevation: 0,
        centerTitle: true,
        surfaceTintColor: Colors.transparent,
        titleTextStyle: TextStyle(
          fontFamily: fontTheme.englishFont.fontFamily,
          fontSize: 18 * fontTheme.fontSizeScale,
          fontWeight: FontWeight.w600,
          color: lightColorScheme.onPrimary,
        ),
      ),
      cardTheme: CardThemeData(
        elevation: 2,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: Colors.grey.shade300),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: Colors.grey.shade300),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: Color(0xFF10B981), width: 2),
        ),
        filled: true,
        fillColor: Colors.white,
        contentPadding:
            const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
        labelStyle: TextStyle(
          fontFamily: fontTheme.englishFont.fontFamily,
          fontSize: 14 * fontTheme.fontSizeScale,
        ),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: const Color(0xFF10B981),
          foregroundColor: Colors.white,
          elevation: 2,
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 16),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
          ),
          textStyle: TextStyle(
            fontFamily: fontTheme.englishFont.fontFamily,
            fontWeight: FontWeight.w600,
            fontSize: 16 * fontTheme.fontSizeScale,
          ),
        ),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          foregroundColor: const Color(0xFF10B981),
          side: const BorderSide(color: Color(0xFF10B981)),
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 16),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
          ),
          textStyle: TextStyle(
            fontFamily: fontTheme.englishFont.fontFamily,
            fontSize: 16 * fontTheme.fontSizeScale,
          ),
        ),
      ),
      floatingActionButtonTheme: FloatingActionButtonThemeData(
        backgroundColor: const Color(0xFF10B981),
        foregroundColor: Colors.white,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
        ),
      ),
      bottomNavigationBarTheme: BottomNavigationBarThemeData(
        backgroundColor: Colors.white,
        selectedItemColor: const Color(0xFF10B981),
        unselectedItemColor: Colors.grey.shade600,
        elevation: 8,
        type: BottomNavigationBarType.fixed,
        showSelectedLabels: true,
        showUnselectedLabels: true,
        selectedLabelStyle: TextStyle(
          fontFamily: fontTheme.englishFont.fontFamily,
          fontSize: 12 * fontTheme.fontSizeScale,
        ),
        unselectedLabelStyle: TextStyle(
          fontFamily: fontTheme.englishFont.fontFamily,
          fontSize: 12 * fontTheme.fontSizeScale,
        ),
      ),
    );

}

static ThemeData darkTheme(WidgetRef ref) {
final fontTheme = ref.read(fontThemeProvider);

    return ThemeData(
      useMaterial3: true,
      colorScheme: darkColorScheme,
      fontFamily: fontTheme.englishFont.fontFamily,
      typography: Typography.material2021(
        englishLike: Typography.englishLike2021,
        dense: Typography.dense2021,
        tall: Typography.tall2021,
      ),
      textTheme: _buildTextTheme(fontTheme, Brightness.dark),
      appBarTheme: AppBarTheme(
        backgroundColor: Colors.grey.shade900,
        foregroundColor: Colors.white,
        elevation: 0,
        centerTitle: true,
        surfaceTintColor: Colors.transparent,
        titleTextStyle: TextStyle(
          fontFamily: fontTheme.englishFont.fontFamily,
          fontSize: 18 * fontTheme.fontSizeScale,
          fontWeight: FontWeight.w600,
          color: Colors.white,
        ),
      ),
      cardTheme: CardThemeData(
        elevation: 3,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
        ),
        color: Colors.grey.shade800,
      ),
      inputDecorationTheme: InputDecorationTheme(
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: Colors.grey.shade600),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: Colors.grey.shade600),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: Color(0xFF10B981), width: 2),
        ),
        filled: true,
        fillColor: Colors.grey.shade800,
        contentPadding:
            const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
        labelStyle: TextStyle(
          fontFamily: fontTheme.englishFont.fontFamily,
          fontSize: 14 * fontTheme.fontSizeScale,
          color: Colors.grey.shade300,
        ),
      ),
      bottomNavigationBarTheme: BottomNavigationBarThemeData(
        backgroundColor: Colors.grey.shade900,
        selectedItemColor: const Color(0xFF10B981),
        unselectedItemColor: Colors.grey.shade500,
        elevation: 8,
        type: BottomNavigationBarType.fixed,
        showSelectedLabels: true,
        showUnselectedLabels: true,
        selectedLabelStyle: TextStyle(
          fontFamily: fontTheme.englishFont.fontFamily,
          fontSize: 12 * fontTheme.fontSizeScale,
        ),
        unselectedLabelStyle: TextStyle(
          fontFamily: fontTheme.englishFont.fontFamily,
          fontSize: 12 * fontTheme.fontSizeScale,
        ),
      ),
      cardColor: Colors.grey.shade800,
      dialogBackgroundColor: Colors.grey.shade800,
      bottomSheetTheme: BottomSheetThemeData(
        backgroundColor: Colors.grey.shade900,
      ),
      floatingActionButtonTheme: FloatingActionButtonThemeData(
        backgroundColor: const Color(0xFF10B981),
        foregroundColor: Colors.white,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
        ),
      ),
    );

}

static TextTheme \_buildTextTheme(FontTheme fontTheme, Brightness brightness) {
final baseTextTheme = brightness == Brightness.light
? Typography.material2021().black
: Typography.material2021().white;

    return baseTextTheme.copyWith(
      displayLarge: baseTextTheme.displayLarge!.copyWith(
        fontFamily: fontTheme.englishFont.fontFamily,
        fontSize: 96 * fontTheme.fontSizeScale,
        fontWeight: FontWeight.w300,
        letterSpacing: -1.5,
      ),
      displayMedium: baseTextTheme.displayMedium!.copyWith(
        fontFamily: fontTheme.englishFont.fontFamily,
        fontSize: 60 * fontTheme.fontSizeScale,
        fontWeight: FontWeight.w300,
        letterSpacing: -0.5,
      ),
      displaySmall: baseTextTheme.displaySmall!.copyWith(
        fontFamily: fontTheme.englishFont.fontFamily,
        fontSize: 48 * fontTheme.fontSizeScale,
        fontWeight: FontWeight.w400,
      ),
      headlineMedium: baseTextTheme.headlineMedium!.copyWith(
        fontFamily: fontTheme.englishFont.fontFamily,
        fontSize: 34 * fontTheme.fontSizeScale,
        fontWeight: FontWeight.w400,
        letterSpacing: 0.25,
      ),
      headlineSmall: baseTextTheme.headlineSmall!.copyWith(
        fontFamily: fontTheme.englishFont.fontFamily,
        fontSize: 24 * fontTheme.fontSizeScale,
        fontWeight: FontWeight.w400,
      ),
      titleLarge: baseTextTheme.titleLarge!.copyWith(
        fontFamily: fontTheme.englishFont.fontFamily,
        fontSize: 20 * fontTheme.fontSizeScale,
        fontWeight: FontWeight.w500,
        letterSpacing: 0.15,
      ),
      titleMedium: baseTextTheme.titleMedium!.copyWith(
        fontFamily: fontTheme.englishFont.fontFamily,
        fontSize: 16 * fontTheme.fontSizeScale,
        fontWeight: FontWeight.w400,
        letterSpacing: 0.15,
      ),
      titleSmall: baseTextTheme.titleSmall!.copyWith(
        fontFamily: fontTheme.englishFont.fontFamily,
        fontSize: 14 * fontTheme.fontSizeScale,
        fontWeight: FontWeight.w500,
        letterSpacing: 0.1,
      ),
      bodyLarge: baseTextTheme.bodyLarge!.copyWith(
        fontFamily: fontTheme.englishFont.fontFamily,
        fontSize: 16 * fontTheme.fontSizeScale,
        fontWeight: FontWeight.w400,
        letterSpacing: 0.5,
      ),
      bodyMedium: baseTextTheme.bodyMedium!.copyWith(
        fontFamily: fontTheme.englishFont.fontFamily,
        fontSize: 14 * fontTheme.fontSizeScale,
        fontWeight: FontWeight.w400,
        letterSpacing: 0.25,
      ),
      labelLarge: baseTextTheme.labelLarge!.copyWith(
        fontFamily: fontTheme.englishFont.fontFamily,
        fontSize: 14 * fontTheme.fontSizeScale,
        fontWeight: FontWeight.w500,
        letterSpacing: 1.25,
      ),
      bodySmall: baseTextTheme.bodySmall!.copyWith(
        fontFamily: fontTheme.englishFont.fontFamily,
        fontSize: 12 * fontTheme.fontSizeScale,
        fontWeight: FontWeight.w400,
        letterSpacing: 0.4,
      ),
      labelSmall: baseTextTheme.labelSmall!.copyWith(
        fontFamily: fontTheme.englishFont.fontFamily,
        fontSize: 10 * fontTheme.fontSizeScale,
        fontWeight: FontWeight.w400,
        letterSpacing: 1.5,
      ),
    );

}
}

// Font Theme Provider
final fontThemeProvider =
StateNotifierProvider<FontThemeNotifier, FontTheme>((ref) {
return FontThemeNotifier();
});

class FontThemeNotifier extends StateNotifier<FontTheme> {
FontThemeNotifier() : super(const FontTheme());

void updateEnglishFont(AppFontFamily font) {
state = state.copyWith(englishFont: font);
}

void updateAmharicFont(AppFontFamily font) {
state = state.copyWith(amharicFont: font);
}

void updateFontScale(double scale) {
state = state.copyWith(fontSizeScale: scale);
}
}

##// src/config/theme/font_theme.dart
// Font theme configuration for the application.
class FontTheme {
final AppFontFamily englishFont;
final AppFontFamily amharicFont;
final double fontSizeScale;

const FontTheme({
this.englishFont = AppFontFamily.inter,
this.amharicFont = AppFontFamily.notoSansEthiopic,
this.fontSizeScale = 1.0,
});

FontTheme copyWith({
AppFontFamily? englishFont,
AppFontFamily? amharicFont,
double? fontSizeScale,
}) {
return FontTheme(
englishFont: englishFont ?? this.englishFont,
amharicFont: amharicFont ?? this.amharicFont,
fontSizeScale: fontSizeScale ?? this.fontSizeScale,
);
}
}

enum AppFontFamily {
inter('Inter'),
roboto('Roboto'),
openSans('OpenSans'),
notoSansEthiopic('NotoSansEthiopic'),
AbyssinicaSIL('AbyssinicaSIL');

final String fontFamily;
const AppFontFamily(this.fontFamily);

String get name {
switch (this) {
case AppFontFamily.inter:
return 'Inter';
case AppFontFamily.roboto:
return 'Roboto';
case AppFontFamily.openSans:
return 'Open Sans';
case AppFontFamily.notoSansEthiopic:
return 'Noto Sans Ethiopic';
case AppFontFamily.AbyssinicaSIL:
return 'Abyssinica SIL';
}
}
}

##

// lib/src/controllers/customer_controller.dart
// Controller for managing customer-related state and actions.
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../data/models/customer.dart';
import '../data/repositories/customer_repository.dart';

class CustomerState {
final List<Customer> customers;
final bool isLoading;
final String? error;
final String? searchQuery;

const CustomerState({
this.customers = const [],
this.isLoading = false,
this.error,
this.searchQuery,
});

CustomerState copyWith({
List<Customer>? customers,
bool? isLoading,
String? error,
String? searchQuery,
}) {
return CustomerState(
customers: customers ?? this.customers,
isLoading: isLoading ?? this.isLoading,
error: error ?? this.error,
searchQuery: searchQuery ?? this.searchQuery,
);
}
}

class CustomerController extends StateNotifier<CustomerState> {
final CustomerRepository \_customerRepository;

CustomerController(this.\_customerRepository) : super(const CustomerState());

Future<void> loadCustomers() async {
state = state.copyWith(isLoading: true, error: null);
try {
final customers = await \_customerRepository.getAllCustomers();
state = state.copyWith(customers: customers, isLoading: false);
} catch (e) {
state = state.copyWith(error: e.toString(), isLoading: false);
}
}

Future<void> searchCustomers(String query) async {
state = state.copyWith(searchQuery: query);
// Implement search logic
}

void clearError() {
state = state.copyWith(error: null);
}
}

final customerControllerProvider =
StateNotifierProvider<CustomerController, CustomerState>(
(ref) => CustomerController(ref.read(customerRepositoryProvider)),
);

##

// lib/src/controllers/product_controller.dart
// Controller for managing product-related state and actions.
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../data/models/product.dart';
import '../data/repositories/product_repository.dart';

class ProductState {
final List<Product> products;
final bool isLoading;
final String? error;
final String? searchQuery;
final String? selectedCategory;

const ProductState({
this.products = const [],
this.isLoading = false,
this.error,
this.searchQuery,
this.selectedCategory,
});

ProductState copyWith({
List<Product>? products,
bool? isLoading,
String? error,
String? searchQuery,
String? selectedCategory,
}) {
return ProductState(
products: products ?? this.products,
isLoading: isLoading ?? this.isLoading,
error: error ?? this.error,
searchQuery: searchQuery ?? this.searchQuery,
selectedCategory: selectedCategory ?? this.selectedCategory,
);
}
}

class ProductController extends StateNotifier<ProductState> {
final ProductRepository \_productRepository;

ProductController(this.\_productRepository) : super(const ProductState());

Future<void> loadProducts() async {
state = state.copyWith(isLoading: true, error: null);
try {
final products = await \_productRepository.getAllProducts();
state = state.copyWith(products: products, isLoading: false);
} catch (e) {
state = state.copyWith(error: e.toString(), isLoading: false);
}
}

Future<void> searchProducts(String query) async {
state = state.copyWith(searchQuery: query);
// Implement search logic
}

void filterByCategory(String? categoryId) {
state = state.copyWith(selectedCategory: categoryId);
}

void clearError() {
state = state.copyWith(error: null);
}
}

final productControllerProvider =
StateNotifierProvider<ProductController, ProductState>(
(ref) => ProductController(ref.read(productRepositoryProvider)),
);

##

// lib/src/controllers/reports_controller.dart
// Controller for managing reports-related state and actions.
import 'package:andalus_smart_pos/src/ui/screens/ReportsScreen.dart';
import 'package:andalus_smart_pos/src/utils/reports_data_calculator.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import 'package:intl/intl.dart';
import '../data/models/subscription.dart';
import '../data/models/sale.dart';
import '../data/models/product.dart';
import '../data/models/customer.dart';
import '../data/repositories/sale_repository.dart';
import '../data/repositories/product_repository.dart';
import '../data/repositories/customer_repository.dart';
import '../data/repositories/subscription_repository.dart';
import '../utils/formatters.dart';

final reportsControllerProvider =
StateNotifierProvider.autoDispose<ReportsController, ReportsState>((ref) {
return ReportsController(ref);
});

class ReportsState {
final bool isLoading;
final SubscriptionPlan currentPlan;
final ReportType selectedReportType;
final DateTimeRange dateRange;
final SalesReportData? salesData;
final ProductsReportData? productsData;
final CustomersReportData? customersData;
final FinancialReportData? financialData;
final String? error;

const ReportsState({
this.isLoading = true,
required this.currentPlan,
this.selectedReportType = ReportType.sales,
required this.dateRange,
this.salesData,
this.productsData,
this.customersData,
this.financialData,
this.error,
});

ReportsState copyWith({
bool? isLoading,
SubscriptionPlan? currentPlan,
ReportType? selectedReportType,
DateTimeRange? dateRange,
SalesReportData? salesData,
ProductsReportData? productsData,
CustomersReportData? customersData,
FinancialReportData? financialData,
String? error,
}) {
return ReportsState(
isLoading: isLoading ?? this.isLoading,
currentPlan: currentPlan ?? this.currentPlan,
selectedReportType: selectedReportType ?? this.selectedReportType,
dateRange: dateRange ?? this.dateRange,
salesData: salesData ?? this.salesData,
productsData: productsData ?? this.productsData,
customersData: customersData ?? this.customersData,
financialData: financialData ?? this.financialData,
error: error ?? this.error,
);
}
}

class ReportsController extends StateNotifier<ReportsState> {
final Ref ref;

ReportsController(this.ref)
: super(
ReportsState(
currentPlan: SubscriptionPlan.basic,
dateRange: DateTimeRange(
start: DateTime.now().subtract(const Duration(days: 30)),
end: DateTime.now(),
),
),
) {
\_initialize();
}

Future<void> \_initialize() async {
await \_loadSubscription();
await \_loadReports();
}

Future<void> \_loadSubscription() async {
try {
final subscription = await ref
.read(subscriptionRepositoryProvider)
.getCurrentSubscription();
final currentPlan = subscription?.plan ?? SubscriptionPlan.basic;
state = state.copyWith(currentPlan: currentPlan);
} catch (e) {
state = state.copyWith(currentPlan: SubscriptionPlan.basic);
}
}

Future<void> \_loadReports() async {
state = state.copyWith(isLoading: true, error: null);

    try {
      final reportsData = await ReportsDataCalculator.generateReports(
        ref: ref,
        dateRange: state.dateRange,
        plan: state.currentPlan,
      );

      state = state.copyWith(
        isLoading: false,
        salesData: reportsData.salesData,
        productsData: reportsData.productsData,
        customersData: reportsData.customersData,
        financialData: reportsData.financialData,
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: 'Failed to load reports: $e',
      );
    }

}

void setDateRange(DateTimeRange range) {
state = state.copyWith(dateRange: range);
\_loadReports();
}

void setReportType(ReportType type) {
state = state.copyWith(selectedReportType: type);
}

void refresh() => \_loadReports();
}

##

// lib/src/controllers/sale_controller.dart - CORRECTED VERSION
import 'dart:async';
import 'package:andalus_smart_pos/src/service/sync_service.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:connectivity_plus/connectivity_plus.dart';
import '../data/models/sale.dart';
import '../data/models/sale_item.dart';
import '../data/models/product.dart';
import '../data/models/user.dart';
import '../data/repositories/sale_repository.dart';
import '../data/repositories/product_repository.dart';
import '../data/repositories/customer_repository.dart';
// import '../services/sync_service.dart';
import '../utils/print_service.dart';
import '../providers/auth_provider.dart';

class SaleState {
final Sale? currentSale;
final List<SaleItem> cartItems;
final bool isLoading;
final String? error;
final bool isPrinting;
final double subtotal;
final double tax;
final double discount;
final double total;

const SaleState({
this.currentSale,
this.cartItems = const [],
this.isLoading = false,
this.error,
this.isPrinting = false,
this.subtotal = 0,
this.tax = 0,
this.discount = 0,
this.total = 0,
});

SaleState copyWith({
Sale? currentSale,
List<SaleItem>? cartItems,
bool? isLoading,
String? error,
bool? isPrinting,
double? subtotal,
double? tax,
double? discount,
double? total,
}) {
return SaleState(
currentSale: currentSale ?? this.currentSale,
cartItems: cartItems ?? this.cartItems,
isLoading: isLoading ?? this.isLoading,
error: error ?? this.error,
isPrinting: isPrinting ?? this.isPrinting,
subtotal: subtotal ?? this.subtotal,
tax: tax ?? this.tax,
discount: discount ?? this.discount,
total: total ?? this.total,
);
}

int get cartItemCount => cartItems.length;
bool get isCartEmpty => cartItems.isEmpty;
}

class SaleController extends StateNotifier<SaleState> {
final Ref \_ref;
final SaleRepository \_saleRepository;
final ProductRepository \_productRepository;
final CustomerRepository \_customerRepository;
final SyncService \_syncService;

static const double \_taxRate = 0.15;
static const int \_maxCartItems = 100;

SaleController(
this.\_ref, {
required SaleRepository saleRepository,
required ProductRepository productRepository,
required CustomerRepository customerRepository,
required SyncService syncService,
}) : \_saleRepository = saleRepository,
\_productRepository = productRepository,
\_customerRepository = customerRepository,
\_syncService = syncService,
super(const SaleState());

// === CART MANAGEMENT ===
Future<void> addToCart({
required Product product,
required int quantity,
double? customPrice,
double? discount,
}) async {
try {
// Validate product
if (!product.canSellQuantity(quantity)) {
throw Exception(
'Cannot add $quantity of ${product.name}. Available: ${product.stockQuantity}');
}

      // Check cart limits
      if (state.cartItems.length >= _maxCartItems) {
        throw Exception('Cart is full. Maximum $_maxCartItems items allowed');
      }

      // Check if product already in cart
      final existingIndex = state.cartItems
          .indexWhere((item) => item.productId == product.productId);

      if (existingIndex >= 0) {
        // Update existing item
        final existingItem = state.cartItems[existingIndex];
        final newQuantity = existingItem.quantity + quantity;

        if (!product.canSellQuantity(newQuantity)) {
          throw Exception(
              'Cannot add $quantity more. Total would be $newQuantity, available: ${product.stockQuantity}');
        }

        final updatedItems = List<SaleItem>.from(state.cartItems);
        updatedItems[existingIndex] = SaleItem.create(
          saleId: existingItem.saleId,
          productId: product.productId,
          productName: product.name,
          productNameAm: product.nameAm,
          quantity: newQuantity,
          unitPrice: customPrice ?? product.price,
          costPrice: product.costPrice,
          discount: discount ?? existingItem.discount,
          barcode: product.barcode,
          unit: product.unit,
        );

        _updateCart(updatedItems);
      } else {
        // Add new item
        final newItem = SaleItem.create(
          saleId: 'temp',
          productId: product.productId,
          productName: product.name,
          productNameAm: product.nameAm,
          quantity: quantity,
          unitPrice: customPrice ?? product.price,
          costPrice: product.costPrice,
          discount: discount ?? 0,
          barcode: product.barcode,
          unit: product.unit,
        );

        final updatedItems = [...state.cartItems, newItem];
        _updateCart(updatedItems);
      }
    } catch (e) {
      state = state.copyWith(error: e.toString());
      rethrow;
    }

}

void updateCartItemQuantity(String productId, int newQuantity) {
try {
if (newQuantity <= 0) {
removeFromCart(productId);
return;
}

      final index =
          state.cartItems.indexWhere((item) => item.productId == productId);
      if (index == -1) return;

      final item = state.cartItems[index];
      final updatedItem = SaleItem.create(
        saleId: item.saleId,
        productId: item.productId,
        productName: item.productName,
        productNameAm: item.productNameAm,
        quantity: newQuantity,
        unitPrice: item.unitPrice,
        costPrice: item.costPrice,
        discount: item.discount,
        barcode: item.barcode,
        unit: item.unit,
      );

      final updatedItems = List<SaleItem>.from(state.cartItems);
      updatedItems[index] = updatedItem;
      _updateCart(updatedItems);
    } catch (e) {
      state = state.copyWith(error: e.toString());
    }

}

void removeFromCart(String productId) {
final updatedItems =
state.cartItems.where((item) => item.productId != productId).toList();
\_updateCart(updatedItems);
}

void clearCart() {
\_updateCart([]);
}

void \_updateCart(List<SaleItem> items) {
// Calculate totals
final subtotal =
items.fold(0.0, (sum, item) => sum + (item.unitPrice _ item.quantity));
final discount = items.fold(0.0, (sum, item) => sum + item.discount);
final tax = (subtotal - discount) _ \_taxRate;
final total = subtotal + tax - discount;

    state = state.copyWith(
      cartItems: items,
      subtotal: double.parse(subtotal.toStringAsFixed(2)),
      tax: double.parse(tax.toStringAsFixed(2)),
      discount: double.parse(discount.toStringAsFixed(2)),
      total: double.parse(total.toStringAsFixed(2)),
      error: null,
    );

}

// === SALE PROCESSING ===
Future<Sale> processSale({
required String paymentMethod,
String? paymentReference,
int? customerId,
String? customerName,
double additionalDiscount = 0,
String? notes,
required BuildContext context,
}) async {
try {
state = state.copyWith(isLoading: true, error: null);

      // Validate cart
      if (state.cartItems.isEmpty) {
        throw Exception('Cart is empty');
      }

      // Validate stock for all items
      await _validateStockAvailability();

      // Get user info (from auth provider)
      final authState = _ref.read(authProvider);
      final User? user = authState.user;
      if (user == null) throw Exception('User not authenticated');

      // Convert userId from String to int
      int userId;
      try {
        userId = int.parse(user.id);
      } catch (e) {
        // If user.id is not a number, use a default or hash
        userId = user.id.hashCode.abs();
      }

      // Create sale
      final sale = Sale.createNew(
        items: state.cartItems,
        userId: userId,
        userName: user.name,
        shopId: 1,
        paymentMethod: paymentMethod,
        paymentReference: paymentReference,
        customerId: customerId,
        customerName: customerName,
        discountAmount: additionalDiscount,
        notes: notes,
      );

      // Process in transaction
      final completedSale = await _processSaleTransaction(sale);

      // Print receipt
      await _printReceipt(completedSale, context);

      // Update state
      state = state.copyWith(
        currentSale: completedSale,
        cartItems: [],
        subtotal: 0,
        tax: 0,
        discount: 0,
        total: 0,
        isLoading: false,
      );

      // Trigger sync if online
      final connectivity = await Connectivity().checkConnectivity();
      if (connectivity != ConnectivityResult.none) {
        await _syncService.syncAllData();
      }

      return completedSale;
    } catch (e, stackTrace) {
      state = state.copyWith(isLoading: false, error: e.toString());
      print('Sale processing error: $e\n$stackTrace');
      rethrow;
    }

}

Future<void> \_validateStockAvailability() async {
for (final item in state.cartItems) {
try {
// Use getProductById which we added to ProductRepository
final product = await \_productRepository.getProductById(item.productId);
if (product == null) {
throw Exception('Product ${item.productName} not found');
}

        if (!product.canSellQuantity(item.quantity)) {
          throw Exception(
              'Insufficient stock for ${product.name}. Available: ${product.stockQuantity}, Requested: ${item.quantity}');
        }
      } catch (e) {
        throw Exception('Stock validation failed for ${item.productName}: $e');
      }
    }

}

Future<Sale> \_processSaleTransaction(Sale sale) async {
try {
// Save sale
final saleId = await \_saleRepository.createSale(sale, state.cartItems);

      // Update product stock - using updateStockAfterSale which we added
      for (final item in state.cartItems) {
        await _productRepository.updateStockAfterSale(
          productId: item.productId,
          quantitySold: item.quantity,
        );
      }

      // Update customer balance if credit sale
      if (sale.paymentMethod == 'credit' && sale.customerId != null) {
        // Use updateCustomerBalance which we added to CustomerRepository
        await _customerRepository.updateCustomerBalance(
          customerId: sale.customerId!,
          amount: sale.finalAmount,
          transactionType: 'sale',
          reference: sale.saleId,
        );
      }

      // Get the saved sale - use getSimpleSaleById which returns Sale, not SaleWithItems
      final savedSale = await _saleRepository.getSimpleSaleById(saleId);
      if (savedSale == null) {
        throw Exception('Failed to retrieve saved sale');
      }
      return savedSale;
    } catch (e) {
      throw Exception('Transaction failed: $e');
    }

}

Future<void> \_printReceipt(Sale sale, BuildContext context) async {
try {
state = state.copyWith(isPrinting: true);

      // Convert sale items for printing
      final printItems = state.cartItems.map((item) {
        return {
          'name': item.productName,
          'quantity': item.quantity,
          'price': item.unitPrice,
          'total': item.totalPrice,
        };
      }).toList();

      // Get business info
      final businessInfo = {
        'shopName': 'Andalus Smart POS',
        'shopNameAm': '·ä†·äï·ã≥·àâ·àµ ·àµ·àõ·à≠·âµ ·çñ·àµ',
        'address': 'Addis Ababa, Ethiopia',
        'phone': '+251911223344',
        'tinNumber': '1234567890',
      };

      // Call PrintService with correct parameters matching your existing interface
      await PrintService.printReceipt(
        context: context,
        shopName: businessInfo['shopName']!,
        shopNameAm: businessInfo['shopNameAm']!,
        address: businessInfo['address']!,
        phone: businessInfo['phone']!,
        tinNumber: businessInfo['tinNumber']!,
        receiptNumber: sale.saleId,
        dateTime: sale.createdAt,
        items: printItems,
        subtotal: state.subtotal,
        tax: state.tax,
        discount: state.discount,
        total: state.total,
        paymentMethod: sale.paymentMethod,
        telebirrRef: sale.paymentReference,
        sale: sale,
        businessInfo: businessInfo,
      );

      state = state.copyWith(isPrinting: false);
    } catch (e) {
      state = state.copyWith(isPrinting: false);
      print('Printing failed: $e');
    }

}

// === SALE QUERIES ===
Future<List<Sale>> getTodaySales() async {
try {
state = state.copyWith(isLoading: true);
final sales = await \_saleRepository.getTodaysSales();
state = state.copyWith(isLoading: false);
return sales;
} catch (e) {
state = state.copyWith(isLoading: false, error: e.toString());
rethrow;
}
}

Future<SalesSummary> getSalesSummary({DateTimeRange? dateRange}) async {
try {
return await \_saleRepository.getSalesSummary(dateRange: dateRange);
} catch (e) {
throw Exception('Failed to get sales summary: $e');
}
}

Future<List<Sale>> searchSales({
String? query,
DateTime? startDate,
DateTime? endDate,
String? paymentMethod,
String? status,
int? customerId,
}) async {
return await \_saleRepository.searchSales(
query: query,
startDate: startDate,
endDate: endDate,
paymentMethod: paymentMethod,
status: status,
customerId: customerId,
);
}

// === REFUNDS ===
Future<Sale> refundSale({
required int saleId,
required String reason,
bool fullRefund = true,
List<String>? itemIds,
Map<String, int>? partialQuantities,
}) async {
try {
state = state.copyWith(isLoading: true);

      // Get original sale
      final originalSaleWithItems = await _saleRepository.getSaleById(saleId);
      if (originalSaleWithItems == null) {
        throw Exception('Sale not found');
      }

      final originalSale = originalSaleWithItems.sale;

      // Check if can be refunded
      if (!originalSale.canBeRefunded) {
        throw Exception('Sale cannot be refunded');
      }

      // Process refund using refundSale method we added
      final refundedSale = await _saleRepository.refundSale(
        saleId: saleId,
        reason: reason,
        fullRefund: fullRefund,
        itemIds: itemIds,
        partialQuantities: partialQuantities,
      );

      // Restore stock if full refund
      if (fullRefund) {
        await _restoreStockForRefund(originalSale);
      }

      state = state.copyWith(isLoading: false);
      return refundedSale;
    } catch (e) {
      state = state.copyWith(isLoading: false, error: e.toString());
      rethrow;
    }

}

Future<void> \_restoreStockForRefund(Sale sale) async {
final items = await \_saleRepository.getSaleItems(sale.id!);

    for (final item in items) {
      await _productRepository.updateStockAfterRefund(
        productId: item.productId,
        quantityRefunded: item.quantity,
      );
    }

}

// === UTILITIES ===
void clearError() {
state = state.copyWith(error: null);
}

@override
void dispose() {
super.dispose();
}
}

// === PROVIDERS ===
final saleControllerProvider = StateNotifierProvider<SaleController, SaleState>(
(ref) => SaleController(
ref,
saleRepository: ref.read(saleRepositoryProvider),
productRepository: ref.read(productRepositoryProvider),
customerRepository: ref.read(customerRepositoryProvider),
syncService: ref.read(syncServiceProvider),
),
);

##

// mobile/lib/src/data/local/database.dart
// my question here for deepseek ai is for optimizing the following for making this app not crushy fast and reliable applying best practices for flutter sqflite database management and stll keeping all the existing functionalities and migrations
// and also adding any missing functionalities that are important for a pos app database management feasible to the back end laravel api design
import 'package:andalus_smart_pos/src/data/models/otp.dart';
import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';

class AppDatabase {
static const \_databaseName = "andalus_pos.db";
// static const \_databaseVersion = 6; // Increment version to trigger migration
static const \_databaseVersion = 8; // Increment version to trigger migration

static Database? \_database;

static Future<Database> get database async {
if (\_database != null) return \_database!;
\_database = await \_initDatabase();
return \_database!;
}

static Future<void> \_createIndexes(Database db) async {
await db.execute('CREATE INDEX idx_sales_created ON sales(created_at)');
await db
.execute('CREATE INDEX idx_products_category ON products(category_id)');
await db.execute('CREATE INDEX idx_customers_phone ON customers(phone)');
}

static Future<Database> \_initDatabase() async {
final databasesPath = await getDatabasesPath();
final path = join(databasesPath, \_databaseName);

    print('Database path: $path');
    print('Database version: $_databaseVersion');

    return await openDatabase(
      path,
      version: _databaseVersion,
      onCreate: _onCreate,
      onConfigure: _onConfigure,
      onUpgrade: _onUpgrade,
      onDowngrade: onDatabaseDowngradeDelete,
    );

}

static Future<void> \_onConfigure(Database db) async {
await db.execute('PRAGMA foreign_keys = ON');
}

static Future<void> \_onCreate(Database db, int version) async {
print('Creating database with version: $version');
await \_createAllTables(db);
}

static Future<void> ensureOTPTable() async {
final db = await database;

    try {
      await db.execute('''
      CREATE TABLE IF NOT EXISTS otps (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        otp_id TEXT UNIQUE NOT NULL,
        phone TEXT NOT NULL,
        code TEXT NOT NULL,
        type TEXT NOT NULL,
        is_used INTEGER DEFAULT 0,
        expires_at INTEGER NOT NULL,
        created_at INTEGER NOT NULL
      )
    ''');
      print('‚úÖ OTP table ensured');
    } catch (e) {
      print('‚ùå Error ensuring OTP table: $e');
    }

}

static Future<void> \_onUpgrade(
Database db, int oldVersion, int newVersion) async {
print('Upgrading database from $oldVersion to $newVersion');

    // Handle incremental migrations
    if (oldVersion < 2) {
      await _createCustomerTables(db);
    }

    if (oldVersion < 3) {
      await _migrateToVersion3(db);
    }

    if (oldVersion < 4) {
      await _migrateToVersion4(db);
    }

    if (oldVersion < 5) {
      await _migrateToVersion5(db);
    }

    if (oldVersion < 6) {
      await _migrateToVersion6(db);
    }
    if (oldVersion < 7) {
      await _migrateToVersion7(db);
    }

    if (oldVersion < 8) {
      await _migrateToVersion8(db);
    }

}

static Future<void> \_migrateToVersion8(Database db) async {
print(
'Migrating to version 8 - Making email column nullable in users table');

    try {
      // Create a temporary table without the UNIQUE constraint on email
      await db.execute('''
      CREATE TABLE users_temp (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT UNIQUE NOT NULL,
        name TEXT NOT NULL,
        phone TEXT UNIQUE NOT NULL,
        email TEXT,
        password_hash TEXT,
        role TEXT NOT NULL DEFAULT 'cashier',
        is_verified INTEGER DEFAULT 0,
        is_active INTEGER DEFAULT 1,
        business_id TEXT,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        last_login_at INTEGER
      )
    ''');

      // Copy data from old table to new table
      await db.execute('''
      INSERT INTO users_temp
      SELECT * FROM users
    ''');

      // Drop old table
      await db.execute('DROP TABLE users');

      // Rename new table
      await db.execute('ALTER TABLE users_temp RENAME TO users');

      print('‚úÖ Users table updated successfully - email is now nullable');
    } catch (e) {
      print('‚ùå Error in version 8 migration: $e');
      // If migration fails, the app should still work
    }

}

static Future<void> \_migrateToVersion7(Database db) async {
print('Migrating to version 7 - Recreating OTP table with correct schema');

    try {
      // Simply drop and recreate the OTP table
      await db.execute('DROP TABLE IF EXISTS otps');

      await db.execute('''
      CREATE TABLE otps (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        otp_id TEXT UNIQUE NOT NULL,
        phone TEXT NOT NULL,
        code TEXT NOT NULL,
        type TEXT NOT NULL,
        is_used INTEGER DEFAULT 0,
        expires_at INTEGER NOT NULL,
        created_at INTEGER NOT NULL
      )
    ''');

      print('‚úÖ OTP table recreated successfully in version 7 migration');

      // Add any indexes for better performance
      await db
          .execute('CREATE INDEX IF NOT EXISTS idx_otp_phone ON otps(phone)');
      await db.execute(
          'CREATE INDEX IF NOT EXISTS idx_otp_expires ON otps(expires_at)');
    } catch (e) {
      print('‚ùå Error in version 7 migration: $e');
      rethrow;
    }

}

static Future<void> \_migrateToVersion6(Database db) async {
print('Migrating to version 6 - Adding status column to subscriptions');
await \_addStatusColumnToSubscriptions(db);
}

static Future<void> \_migrateToVersion5(Database db) async {
print('Migrating to version 5 - Adding user management and OTP tables');
await \_createUserManagementTables(db);
}

static Future<void> \_migrateToVersion4(Database db) async {
print('Migrating to version 4 - Adding business and category tables');
await \_createBusinessTables(db);
}

static Future<void> \_migrateToVersion3(Database db) async {
print('Migrating to version 3 - No migration steps defined');
}

static Future<void> \_addStatusColumnToSubscriptions(Database db) async {
// Check if status column exists
final tableInfo = await db.rawQuery("PRAGMA table_info(subscriptions)");
final hasStatusColumn = tableInfo.any((col) => col['name'] == 'status');

    if (!hasStatusColumn) {
      print('Adding status column to subscriptions table');
      await db.execute(
          'ALTER TABLE subscriptions ADD COLUMN status TEXT DEFAULT "active"');
    }

    // Check if payment_reference column exists
    final hasPaymentRefColumn =
        tableInfo.any((col) => col['name'] == 'payment_reference');
    if (!hasPaymentRefColumn) {
      print('Adding payment_reference column to subscriptions table');
      await db.execute(
          'ALTER TABLE subscriptions ADD COLUMN payment_reference TEXT');
    }

}

static Future<void> \_createAllTables(Database db) async {
// Create all existing tables
await \_createCustomerTables(db);
await \_createSalesTables(db);
await \_createBusinessTables(db);
await \_createUserManagementTables(db);

    print('All tables created successfully');

}

// User Management Tables - Updated with correct schema
static Future<void> \_createUserManagementTables(Database db) async {
// Enhanced users table without foreign key constraint for now
await db.execute('''
CREATE TABLE IF NOT EXISTS users (
id INTEGER PRIMARY KEY AUTOINCREMENT,
user_id TEXT UNIQUE NOT NULL,
name TEXT NOT NULL,
phone TEXT UNIQUE NOT NULL,
email TEXT,
password_hash TEXT,
role TEXT NOT NULL DEFAULT 'cashier',
is_verified INTEGER DEFAULT 0,
is_active INTEGER DEFAULT 1,
business_id TEXT,
created_at INTEGER NOT NULL,
updated_at INTEGER NOT NULL,
last_login_at INTEGER
)
''');

    // OTP table for phone verification
    await db.execute('''
      CREATE TABLE IF NOT EXISTS otps (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        otp_id TEXT UNIQUE NOT NULL,
        phone TEXT NOT NULL,
        code TEXT NOT NULL,
        type TEXT NOT NULL,
        is_used INTEGER DEFAULT 0,
        expires_at INTEGER NOT NULL,
        created_at INTEGER NOT NULL
      )
    ''');

    // Enhanced subscription table with ALL columns
    await db.execute('''
    CREATE TABLE IF NOT EXISTS subscriptions (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      subscription_id TEXT UNIQUE NOT NULL,
      business_id TEXT NOT NULL,
      user_id TEXT NOT NULL,
      plan TEXT NOT NULL,
      billing_cycle TEXT NOT NULL,
      status TEXT NOT NULL DEFAULT "active",
      amount REAL NOT NULL,
      start_date INTEGER NOT NULL,
      end_date INTEGER NOT NULL,
      is_active INTEGER DEFAULT 1,
      currency TEXT DEFAULT 'ETB',
      payment_reference TEXT,
      created_at INTEGER NOT NULL,
      updated_at INTEGER NOT NULL,
      FOREIGN KEY (business_id) REFERENCES business_profile (business_id),
      FOREIGN KEY (user_id) REFERENCES users (user_id)
    )

''');

    print('User management tables created successfully');

}

// Add this to lib/src/data/local/database.dart
static Future<void> debugOTPTable() async {
final db = await database;

    try {
      // Check if table exists
      final tableInfo = await db.rawQuery(
          "SELECT name FROM sqlite_master WHERE type='table' AND name='otps'");
      print('üìã OTP table exists: ${tableInfo.isNotEmpty}');

      if (tableInfo.isNotEmpty) {
        // Check table schema
        final schema = await db.rawQuery("PRAGMA table_info(otps)");
        print('üîç OTP Table Schema:');
        for (var column in schema) {
          print('   ${column['name']} - ${column['type']}');
        }

        // Check all OTPs in table
        final allOtps = await db.query('otps');
        print('üìä Total OTPs in database: ${allOtps.length}');
        for (var otp in allOtps) {
          print(
              '   OTP: ${otp['otp_id']} - ${otp['phone']} - ${otp['code']} - Used: ${otp['is_used']}');
        }
      }
    } catch (e) {
      print('‚ùå Error debugging OTP table: $e');
    }

}

// ... rest of your existing methods remain the same
static Future<void> \_createSalesTables(Database db) async {
await db.execute('''
CREATE TABLE IF NOT EXISTS sales (
id INTEGER PRIMARY KEY AUTOINCREMENT,
sale_id TEXT UNIQUE NOT NULL,
customer_id INTEGER,
total_amount REAL NOT NULL,
final_amount REAL NOT NULL,
tax_amount REAL DEFAULT 0,
discount_amount REAL DEFAULT 0,
payment_method TEXT NOT NULL,
payment_status TEXT DEFAULT 'completed',
sale_status TEXT DEFAULT 'completed',
user_id INTEGER NOT NULL,
shop_id INTEGER NOT NULL,
is_synced INTEGER DEFAULT 0,
sync_attempts INTEGER DEFAULT 0,
created_at INTEGER NOT NULL,
updated_at INTEGER,
FOREIGN KEY (customer_id) REFERENCES customers (id) ON DELETE SET NULL
)
''');

    await db.execute('''
    CREATE TABLE IF NOT EXISTS sale_items (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      sale_id TEXT NOT NULL,
      product_id TEXT NOT NULL,
      product_name TEXT NOT NULL,
      quantity INTEGER NOT NULL,
      unit_price REAL NOT NULL,
      total_price REAL NOT NULL,
      created_at INTEGER NOT NULL,
      FOREIGN KEY (sale_id) REFERENCES sales (sale_id) ON DELETE CASCADE
    )

''');
}

static Future<void> \_createBusinessTables(Database db) async {
await db.execute('''
CREATE TABLE IF NOT EXISTS business_profile (
id INTEGER PRIMARY KEY AUTOINCREMENT,
business_id TEXT UNIQUE NOT NULL,
name TEXT NOT NULL,
name_am TEXT NOT NULL,
business_type TEXT NOT NULL,
phone TEXT NOT NULL,
email TEXT,
address TEXT NOT NULL,
city TEXT,
region TEXT,
tin_number TEXT NOT NULL,
vat_number TEXT,
business_license TEXT,
owner_name TEXT,
owner_phone TEXT,
owner_email TEXT,
currency TEXT DEFAULT 'ETB',
logo_path TEXT,
receipt_header TEXT,
receipt_footer TEXT,
is_active INTEGER DEFAULT 1,
created_at INTEGER NOT NULL,
updated_at INTEGER NOT NULL
)
''');

    await db.execute('''
      CREATE TABLE IF NOT EXISTS product_categories (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        category_id TEXT UNIQUE NOT NULL,
        name TEXT NOT NULL,
        name_am TEXT NOT NULL,
        description TEXT,
        color TEXT,
        icon TEXT,
        parent_id INTEGER,
        sort_order INTEGER DEFAULT 0,
        is_active INTEGER DEFAULT 1,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        FOREIGN KEY (parent_id) REFERENCES product_categories (id)
      )
    ''');

    await db.execute('''
      CREATE TABLE IF NOT EXISTS products (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        product_id TEXT UNIQUE NOT NULL,
        name TEXT NOT NULL,
        name_am TEXT NOT NULL,
        description TEXT,
        price REAL NOT NULL,
        cost_price REAL,
        stock_quantity INTEGER NOT NULL,
        min_stock_level INTEGER,
        barcode TEXT NOT NULL,
        sku TEXT,
        category_id TEXT NOT NULL,
        unit TEXT,
        brand TEXT,
        supplier TEXT,
        weight REAL,
        size TEXT,
        color TEXT,
        image_path TEXT,
        track_inventory INTEGER DEFAULT 1,
        is_active INTEGER DEFAULT 1,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        FOREIGN KEY (category_id) REFERENCES product_categories (category_id)
      )
    ''');

}

static Future<void> \_createCustomerTables(Database db) async {
await db.execute('''
CREATE TABLE IF NOT EXISTS customers (
id INTEGER PRIMARY KEY AUTOINCREMENT,
local_id TEXT UNIQUE NOT NULL,
name TEXT NOT NULL,
business_name TEXT,
phone TEXT NOT NULL,
whatsapp_number TEXT,
email TEXT,
address TEXT,
tin_number TEXT,
credit_limit REAL DEFAULT 0,
current_balance REAL DEFAULT 0,
due_date INTEGER,
last_transaction_date INTEGER,
allow_credit INTEGER DEFAULT 0,
payment_terms TEXT,
notes TEXT,
is_active INTEGER DEFAULT 1,
created_at INTEGER NOT NULL,
updated_at INTEGER NOT NULL
)
''');

    await db.execute('''
      CREATE TABLE IF NOT EXISTS credit_transactions (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        local_id TEXT UNIQUE NOT NULL,
        customer_id INTEGER NOT NULL,
        customer_name TEXT NOT NULL,
        type TEXT NOT NULL,
        amount REAL NOT NULL,
        balance_before REAL NOT NULL,
        balance_after REAL NOT NULL,
        reference TEXT,
        notes TEXT,
        created_at INTEGER NOT NULL,
        FOREIGN KEY (customer_id) REFERENCES customers (id) ON DELETE CASCADE
      )
    ''');

}

// Add to lib/src/data/local/database.dart
static Future<void> debugUsersTable() async {
final db = await database;

    try {
      final users = await db.query('users');
      print('üë• Total users in database: ${users.length}');

      for (var user in users) {
        print(
            'üìÑ User: ${user['user_id']} - ${user['name']} - ${user['phone']} - ${user['role']} - Active: ${user['is_active']}');
      }

      // Check specifically for our test user
      final testUser = await db
          .query('users', where: 'phone = ?', whereArgs: ['+251911223344']);
      print('üîç Test user query result: ${testUser.length} users found');
    } catch (e) {
      print('‚ùå Error debugging users table: $e');
    }

}

// Add to lib/src/data/local/database.dart
static Future<void> verifyOTPTable() async {
final db = await database;

    try {
      // Check if table exists
      final tableInfo = await db.rawQuery(
          "SELECT name FROM sqlite_master WHERE type='table' AND name='otps'");

      if (tableInfo.isEmpty) {
        print('‚ùå OTP table does not exist after migration!');
        return;
      }

      print('‚úÖ OTP table exists');

      // Check schema
      final schema = await db.rawQuery("PRAGMA table_info(otps)");
      final expectedColumns = [
        'id',
        'otp_id',
        'phone',
        'code',
        'type',
        'is_used',
        'expires_at',
        'created_at'
      ];
      final actualColumns = schema.map((col) => col['name'] as String).toList();

      print('üìã OTP Table columns: $actualColumns');

      // Test insert and query
      final testOTP = OTP.create(phone: '+251911223344', type: 'test');
      await db.insert('otps', testOTP.toMap());

      final retrieved = await db.query(
        'otps',
        where: 'phone = ? AND code = ?',
        whereArgs: [testOTP.phone, testOTP.code],
      );

      if (retrieved.isNotEmpty) {
        print('‚úÖ OTP table working correctly - can insert and query');
      } else {
        print('‚ùå OTP table not working - cannot retrieve inserted data');
      }

      // Clean up test data
      await db.delete('otps', where: 'phone = ?', whereArgs: [testOTP.phone]);
    } catch (e) {
      print('‚ùå Error verifying OTP table: $e');
    }

}

// Helper methods
static Future<bool> tableExists(String tableName) async {
final db = await database;
final result = await db.rawQuery(
"SELECT name FROM sqlite_master WHERE type='table' AND name=?",
[tableName],
);
return result.isNotEmpty;
}

static Future<void> migrateDatabase() async {
final db = await database;
// Check and create missing tables
final userTableExists = await tableExists('users');
final otpTableExists = await tableExists('otps');
final subscriptionTableExists = await tableExists('subscriptions');

    if (!userTableExists || !otpTableExists || !subscriptionTableExists) {
      print('Creating missing user management tables...');
      await _createUserManagementTables(db);
    }

    print('Database migration completed');

}

static Future<void> resetDatabase() async {
final databasesPath = await getDatabasesPath();
final path = join(databasesPath, \_databaseName);

    if (_database != null) {
      await _database!.close();
      _database = null;
    }

    await deleteDatabase(path);
    print('Database reset complete');
    _database = await _initDatabase();

}

static Future<void> migrateSalesTable() async {
final db = await database;

    try {
      // Check if final_amount column exists
      final tableInfo = await db.rawQuery("PRAGMA table_info(sales)");
      final hasFinalAmount =
          tableInfo.any((col) => col['name'] == 'final_amount');

      if (!hasFinalAmount) {
        print('Migrating sales table to add final_amount column...');

        // Create backup
        await db.execute(
            'CREATE TABLE IF NOT EXISTS sales_backup AS SELECT * FROM sales');

        // Drop and recreate table with new schema
        await db.execute('DROP TABLE IF EXISTS sales_old');
        await db.execute('ALTER TABLE sales RENAME TO sales_old');

        await _createSalesTables(db);

        // Copy data with final_amount = total_amount for existing records
        await db.execute('''
        INSERT INTO sales
        SELECT id, sale_id, customer_id, total_amount, total_amount as final_amount,
               tax_amount, discount_amount, payment_method, payment_status, sale_status,
               user_id, shop_id, is_synced, sync_attempts, created_at, updated_at
        FROM sales_old
      ''');

        await db.execute('DROP TABLE sales_old');
        print('Sales table migration completed successfully');
      }
    } catch (e) {
      print('Sales table migration error: $e');
      // Try to restore from backup if migration fails
      try {
        await db.execute('DROP TABLE IF EXISTS sales');
        await db.execute('ALTER TABLE sales_backup RENAME TO sales');
      } catch (restoreError) {
        print('Restore from backup failed: $restoreError');
      }
    }

}
}

##

// lib/models/extensions/sale_refund_extension.dart

import 'dart:core';
// Assuming your Sale model is here (adjust path as needed)
import '../sale.dart';

// Add this extension to Sale class for canBeRefunded
extension SaleRefundExtension on Sale {
bool get canBeRefunded {
// 1. Check if it's already refunded
if (isRefunded) return false;

    // 2. Check if the sale and payment are fully processed
    if (saleStatus != 'completed') return false;
    if (paymentStatus != 'completed') return false;

    // 3. Check the 30-day refund window
    final thirtyDaysAgo = DateTime.now().subtract(const Duration(days: 30));

    // Check if the sale creation date is *after* the date 30 days ago.
    return createdAt.isAfter(thirtyDaysAgo);

}
}

##

//src/data/models/business.dart
class BusinessType {
final String id;
final String name;
final String nameAm;
final String description;

const BusinessType({
required this.id,
required this.name,
required this.nameAm,
required this.description,
});

static const List<BusinessType> allTypes = [
BusinessType(
id: 'retail',
name: 'Retail Shop',
nameAm: '·ã®·åà·â†·ã´ ·à±·âÖ',
description: 'General retail store selling various products',
),
BusinessType(
id: 'supermarket',
name: 'Supermarket',
nameAm: '·à±·çê·à≠·àõ·à≠·ä¨·âµ',
description: 'Large retail store with multiple departments',
),
BusinessType(
id: 'restaurant',
name: 'Restaurant/Cafe',
nameAm: '·àù·åç·â• ·â§·âµ/·ä´·çå',
description: 'Food and beverage service establishment',
),
BusinessType(
id: 'pharmacy',
name: 'Pharmacy',
nameAm: '·çã·à≠·àõ·à≤',
description: 'Medical and pharmaceutical products',
),
BusinessType(
id: 'electronics',
name: 'Electronics Store',
nameAm: '·ã®·ä§·àå·ä≠·âµ·àÆ·äí·ä≠·àµ ·à±·âÖ',
description: 'Electronic devices and accessories',
),
BusinessType(
id: 'clothing',
name: 'Clothing Store',
nameAm: '·ã®·àç·â•·àµ ·à±·âÖ',
description: 'Fashion and apparel retail',
),
BusinessType(
id: 'hardware',
name: 'Hardware Store',
nameAm: '·ã®·àõ·àΩ·äê·à™ ·à±·âÖ',
description: 'Construction materials and tools',
),
BusinessType(
id: 'wholesale',
name: 'Wholesale',
nameAm: '·åÖ·àù·àã',
description: 'Bulk goods distribution',
),
BusinessType(
id: 'service',
name: 'Service Provider',
nameAm: '·ä†·åà·àç·åç·àé·âµ ·ä†·âÖ·à´·â¢',
description: 'Service-based business',
),
BusinessType(
id: 'other',
name: 'Other',
nameAm: '·àå·àã',
description: 'Other business types',
),
];
}

class BusinessProfile {
final int? id;
final String businessId;
final String name;
final String nameAm;
final String businessType;
final String phone;
final String? email;
final String address;
final String? city;
final String? region;
final String tinNumber;
final String? vatNumber;
final String? businessLicense;
final String? ownerName;
final String? ownerPhone;
final String? ownerEmail;
final String currency;
final String? logoPath;
final String? receiptHeader;
final String? receiptFooter;
final bool isActive;
final DateTime createdAt;
final DateTime updatedAt;

BusinessProfile({
this.id,
required this.businessId,
required this.name,
required this.nameAm,
required this.businessType,
required this.phone,
this.email,
required this.address,
this.city,
this.region,
required this.tinNumber,
this.vatNumber,
this.businessLicense,
this.ownerName,
this.ownerPhone,
this.ownerEmail,
this.currency = 'ETB',
this.logoPath,
this.receiptHeader,
this.receiptFooter,
this.isActive = true,
required this.createdAt,
required this.updatedAt,
});

Map<String, dynamic> toMap() {
return {
'id': id,
'business_id': businessId,
'name': name,
'name_am': nameAm,
'business_type': businessType,
'phone': phone,
'email': email,
'address': address,
'city': city,
'region': region,
'tin_number': tinNumber,
'vat_number': vatNumber,
'business_license': businessLicense,
'owner_name': ownerName,
'owner_phone': ownerPhone,
'owner_email': ownerEmail,
'currency': currency,
'logo_path': logoPath,
'receipt_header': receiptHeader,
'receipt_footer': receiptFooter,
'is_active': isActive ? 1 : 0,
'created_at': createdAt.millisecondsSinceEpoch,
'updated_at': updatedAt.millisecondsSinceEpoch,
};
}

factory BusinessProfile.fromMap(Map<String, dynamic> map) {
return BusinessProfile(
id: map['id'],
businessId: map['business_id'],
name: map['name'],
nameAm: map['name_am'],
businessType: map['business_type'],
phone: map['phone'],
email: map['email'],
address: map['address'],
city: map['city'],
region: map['region'],
tinNumber: map['tin_number'],
vatNumber: map['vat_number'],
businessLicense: map['business_license'],
ownerName: map['owner_name'],
ownerPhone: map['owner_phone'],
ownerEmail: map['owner_email'],
currency: map['currency'] ?? 'ETB',
logoPath: map['logo_path'],
receiptHeader: map['receipt_header'],
receiptFooter: map['receipt_footer'],
isActive: map['is_active'] == 1,
createdAt: DateTime.fromMillisecondsSinceEpoch(map['created_at']),
updatedAt: DateTime.fromMillisecondsSinceEpoch(map['updated_at']),
);
}

BusinessProfile copyWith({
String? name,
String? nameAm,
String? businessType,
String? phone,
String? email,
String? address,
String? city,
String? region,
String? tinNumber,
String? vatNumber,
String? businessLicense,
String? ownerName,
String? ownerPhone,
String? ownerEmail,
String? currency,
String? logoPath,
String? receiptHeader,
String? receiptFooter,
bool? isActive,
}) {
return BusinessProfile(
id: id,
businessId: businessId,
name: name ?? this.name,
nameAm: nameAm ?? this.nameAm,
businessType: businessType ?? this.businessType,
phone: phone ?? this.phone,
email: email ?? this.email,
address: address ?? this.address,
city: city ?? this.city,
region: region ?? this.region,
tinNumber: tinNumber ?? this.tinNumber,
vatNumber: vatNumber ?? this.vatNumber,
businessLicense: businessLicense ?? this.businessLicense,
ownerName: ownerName ?? this.ownerName,
ownerPhone: ownerPhone ?? this.ownerPhone,
ownerEmail: ownerEmail ?? this.ownerEmail,
currency: currency ?? this.currency,
logoPath: logoPath ?? this.logoPath,
receiptHeader: receiptHeader ?? this.receiptHeader,
receiptFooter: receiptFooter ?? this.receiptFooter,
isActive: isActive ?? this.isActive,
createdAt: createdAt,
updatedAt: DateTime.now(),
);
}
}

##

// mobile/lib/src/data/models/cart_item.dart
// Model representing an item in the shopping cart.
class CartItem {
final int productId;
final String productName;
final double unitPrice;
final int quantity;

const CartItem({
required this.productId,
required this.productName,
required this.unitPrice,
required this.quantity,
});

double get totalPrice => unitPrice \* quantity;

String get formattedUnitPrice => 'ETB ${unitPrice.toStringAsFixed(2)}';
String get formattedTotalPrice => 'ETB ${totalPrice.toStringAsFixed(2)}';

CartItem copyWith({
int? productId,
String? productName,
double? unitPrice,
int? quantity,
}) {
return CartItem(
productId: productId ?? this.productId,
productName: productName ?? this.productName,
unitPrice: unitPrice ?? this.unitPrice,
quantity: quantity ?? this.quantity,
);
}

@override
bool operator ==(Object other) {
if (identical(this, other)) return true;
return other is CartItem && other.productId == productId;
}

@override
int get hashCode => productId.hashCode;
}

##

// mobile/lib/src/data/models/category.dart
// Model representing a product category.
// Includes sample categories for different business types.
// later on we can extend this to support hierarchical categories if needed. and supporting different business types with default categories
class ProductCategory {
final int? id;
final String categoryId;
final String name;
final String nameAm;
final String? description;
final String? color;
final String? icon;
final int? parentId;
final int sortOrder;
final bool isActive;
final DateTime createdAt;
final DateTime updatedAt;

ProductCategory({
this.id,
required this.categoryId,
required this.name,
required this.nameAm,
this.description,
this.color,
this.icon,
this.parentId,
this.sortOrder = 0,
this.isActive = true,
required this.createdAt,
required this.updatedAt,
});

Map<String, dynamic> toMap() {
return {
'id': id,
'category_id': categoryId,
'name': name,
'name_am': nameAm,
'description': description,
'color': color,
'icon': icon,
'parent_id': parentId,
'sort_order': sortOrder,
'is_active': isActive ? 1 : 0,
'created_at': createdAt.millisecondsSinceEpoch,
'updated_at': updatedAt.millisecondsSinceEpoch,
};
}

factory ProductCategory.fromMap(Map<String, dynamic> map) {
return ProductCategory(
id: map['id'],
categoryId: map['category_id'],
name: map['name'],
nameAm: map['name_am'],
description: map['description'],
color: map['color'],
icon: map['icon'],
parentId: map['parent_id'],
sortOrder: map['sort_order'] ?? 0,
isActive: map['is_active'] == 1,
createdAt: DateTime.fromMillisecondsSinceEpoch(map['created_at']),
updatedAt: DateTime.fromMillisecondsSinceEpoch(map['updated_at']),
);
}

ProductCategory copyWith({
String? name,
String? nameAm,
String? description,
String? color,
String? icon,
int? parentId,
int? sortOrder,
bool? isActive,
}) {
return ProductCategory(
id: id,
categoryId: categoryId,
name: name ?? this.name,
nameAm: nameAm ?? this.nameAm,
description: description ?? this.description,
color: color ?? this.color,
icon: icon ?? this.icon,
parentId: parentId ?? this.parentId,
sortOrder: sortOrder ?? this.sortOrder,
isActive: isActive ?? this.isActive,
createdAt: createdAt,
updatedAt: DateTime.now(),
);
}

bool get hasParent => parentId != null;
}

// Sample categories for different business types
class DefaultCategories {
static List<ProductCategory> forBusinessType(String businessType) {
switch (businessType) {
case 'retail':
case 'supermarket':
return [
ProductCategory(
categoryId: 'food_beverages',
name: 'Food & Beverages',
nameAm: '·àù·åç·â• ·ä•·äì ·àò·å†·å•',
description: 'Food items and beverages',
color: '#4CAF50',
icon: 'local_grocery_store',
sortOrder: 1,
createdAt: DateTime.now(),
updatedAt: DateTime.now(),
),
ProductCategory(
categoryId: 'personal_care',
name: 'Personal Care',
nameAm: '·ã®·åç·àå ·ä•·äï·ä≠·â•·ä´·â§',
description: 'Personal hygiene and care products',
color: '#2196F3',
icon: 'spa',
sortOrder: 2,
createdAt: DateTime.now(),
updatedAt: DateTime.now(),
),
ProductCategory(
categoryId: 'household',
name: 'Household Items',
nameAm: '·ã®·â§·âµ ·ä•·âÉ·ãé·âΩ',
description: 'Household and cleaning supplies',
color: '#FF9800',
icon: 'home',
sortOrder: 3,
createdAt: DateTime.now(),
updatedAt: DateTime.now(),
),
];

      case 'restaurant':
        return [
          ProductCategory(
            categoryId: 'main_courses',
            name: 'Main Courses',
            nameAm: '·ãã·äì ·àù·åç·â¶·âΩ',
            description: 'Main dishes and entrees',
            color: '#F44336',
            icon: 'restaurant',
            sortOrder: 1,
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          ),
          ProductCategory(
            categoryId: 'beverages',
            name: 'Beverages',
            nameAm: '·àò·å†·å¶·âΩ',
            description: 'Drinks and beverages',
            color: '#4CAF50',
            icon: 'local_cafe',
            sortOrder: 2,
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          ),
          ProductCategory(
            categoryId: 'desserts',
            name: 'Desserts',
            nameAm: '·àù·äï·å£·çé·âΩ',
            description: 'Sweets and desserts',
            color: '#9C27B0',
            icon: 'cake',
            sortOrder: 3,
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          ),
        ];

      case 'pharmacy':
        return [
          ProductCategory(
            categoryId: 'prescription',
            name: 'Prescription Drugs',
            nameAm: '·ã®·ã∂·ä≠·â∞·à≠ ·ä•·ãò·ãù ·àò·ãµ·àÉ·äí·â∂·âΩ',
            description: 'Prescription medications',
            color: '#F44336',
            icon: 'medical_services',
            sortOrder: 1,
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          ),
          ProductCategory(
            categoryId: 'otc',
            name: 'Over-the-Counter',
            nameAm: '·ã´·àà ·ä•·ãò·ãù ·àò·ãµ·àÉ·äí·â∂·âΩ',
            description: 'Non-prescription medications',
            color: '#2196F3',
            icon: 'local_pharmacy',
            sortOrder: 2,
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          ),
          ProductCategory(
            categoryId: 'personal_care',
            name: 'Personal Care',
            nameAm: '·ã®·åç·àå ·ä•·äï·ä≠·â•·ä´·â§',
            description: 'Health and personal care',
            color: '#4CAF50',
            icon: 'spa',
            sortOrder: 3,
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          ),
        ];

      default:
        return [
          ProductCategory(
            categoryId: 'general',
            name: 'General',
            nameAm: '·ä†·å†·âÉ·àã·ã≠',
            description: 'General products',
            color: '#607D8B',
            icon: 'category',
            sortOrder: 1,
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          ),
        ];
    }

}
}

##

// mobile/lib/src/data/models/category.dart
// Model representing a product category.
// Includes sample categories for different business types.
// later on we can extend this to support hierarchical categories if needed. and supporting different business types with default categories
class ProductCategory {
final int? id;
final String categoryId;
final String name;
final String nameAm;
final String? description;
final String? color;
final String? icon;
final int? parentId;
final int sortOrder;
final bool isActive;
final DateTime createdAt;
final DateTime updatedAt;

ProductCategory({
this.id,
required this.categoryId,
required this.name,
required this.nameAm,
this.description,
this.color,
this.icon,
this.parentId,
this.sortOrder = 0,
this.isActive = true,
required this.createdAt,
required this.updatedAt,
});

Map<String, dynamic> toMap() {
return {
'id': id,
'category_id': categoryId,
'name': name,
'name_am': nameAm,
'description': description,
'color': color,
'icon': icon,
'parent_id': parentId,
'sort_order': sortOrder,
'is_active': isActive ? 1 : 0,
'created_at': createdAt.millisecondsSinceEpoch,
'updated_at': updatedAt.millisecondsSinceEpoch,
};
}

factory ProductCategory.fromMap(Map<String, dynamic> map) {
return ProductCategory(
id: map['id'],
categoryId: map['category_id'],
name: map['name'],
nameAm: map['name_am'],
description: map['description'],
color: map['color'],
icon: map['icon'],
parentId: map['parent_id'],
sortOrder: map['sort_order'] ?? 0,
isActive: map['is_active'] == 1,
createdAt: DateTime.fromMillisecondsSinceEpoch(map['created_at']),
updatedAt: DateTime.fromMillisecondsSinceEpoch(map['updated_at']),
);
}

ProductCategory copyWith({
String? name,
String? nameAm,
String? description,
String? color,
String? icon,
int? parentId,
int? sortOrder,
bool? isActive,
}) {
return ProductCategory(
id: id,
categoryId: categoryId,
name: name ?? this.name,
nameAm: nameAm ?? this.nameAm,
description: description ?? this.description,
color: color ?? this.color,
icon: icon ?? this.icon,
parentId: parentId ?? this.parentId,
sortOrder: sortOrder ?? this.sortOrder,
isActive: isActive ?? this.isActive,
createdAt: createdAt,
updatedAt: DateTime.now(),
);
}

bool get hasParent => parentId != null;
}

// Sample categories for different business types
class DefaultCategories {
static List<ProductCategory> forBusinessType(String businessType) {
switch (businessType) {
case 'retail':
case 'supermarket':
return [
ProductCategory(
categoryId: 'food_beverages',
name: 'Food & Beverages',
nameAm: '·àù·åç·â• ·ä•·äì ·àò·å†·å•',
description: 'Food items and beverages',
color: '#4CAF50',
icon: 'local_grocery_store',
sortOrder: 1,
createdAt: DateTime.now(),
updatedAt: DateTime.now(),
),
ProductCategory(
categoryId: 'personal_care',
name: 'Personal Care',
nameAm: '·ã®·åç·àå ·ä•·äï·ä≠·â•·ä´·â§',
description: 'Personal hygiene and care products',
color: '#2196F3',
icon: 'spa',
sortOrder: 2,
createdAt: DateTime.now(),
updatedAt: DateTime.now(),
),
ProductCategory(
categoryId: 'household',
name: 'Household Items',
nameAm: '·ã®·â§·âµ ·ä•·âÉ·ãé·âΩ',
description: 'Household and cleaning supplies',
color: '#FF9800',
icon: 'home',
sortOrder: 3,
createdAt: DateTime.now(),
updatedAt: DateTime.now(),
),
];

      case 'restaurant':
        return [
          ProductCategory(
            categoryId: 'main_courses',
            name: 'Main Courses',
            nameAm: '·ãã·äì ·àù·åç·â¶·âΩ',
            description: 'Main dishes and entrees',
            color: '#F44336',
            icon: 'restaurant',
            sortOrder: 1,
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          ),
          ProductCategory(
            categoryId: 'beverages',
            name: 'Beverages',
            nameAm: '·àò·å†·å¶·âΩ',
            description: 'Drinks and beverages',
            color: '#4CAF50',
            icon: 'local_cafe',
            sortOrder: 2,
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          ),
          ProductCategory(
            categoryId: 'desserts',
            name: 'Desserts',
            nameAm: '·àù·äï·å£·çé·âΩ',
            description: 'Sweets and desserts',
            color: '#9C27B0',
            icon: 'cake',
            sortOrder: 3,
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          ),
        ];

      case 'pharmacy':
        return [
          ProductCategory(
            categoryId: 'prescription',
            name: 'Prescription Drugs',
            nameAm: '·ã®·ã∂·ä≠·â∞·à≠ ·ä•·ãò·ãù ·àò·ãµ·àÉ·äí·â∂·âΩ',
            description: 'Prescription medications',
            color: '#F44336',
            icon: 'medical_services',
            sortOrder: 1,
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          ),
          ProductCategory(
            categoryId: 'otc',
            name: 'Over-the-Counter',
            nameAm: '·ã´·àà ·ä•·ãò·ãù ·àò·ãµ·àÉ·äí·â∂·âΩ',
            description: 'Non-prescription medications',
            color: '#2196F3',
            icon: 'local_pharmacy',
            sortOrder: 2,
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          ),
          ProductCategory(
            categoryId: 'personal_care',
            name: 'Personal Care',
            nameAm: '·ã®·åç·àå ·ä•·äï·ä≠·â•·ä´·â§',
            description: 'Health and personal care',
            color: '#4CAF50',
            icon: 'spa',
            sortOrder: 3,
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          ),
        ];

      default:
        return [
          ProductCategory(
            categoryId: 'general',
            name: 'General',
            nameAm: '·ä†·å†·âÉ·àã·ã≠',
            description: 'General products',
            color: '#607D8B',
            icon: 'category',
            sortOrder: 1,
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          ),
        ];
    }

}
}

##

// mobile/lib/src/data/models/credit_transaction.dart
// Model representing a credit transaction for a customer.
import 'package:flutter/material.dart';

class CreditTransaction {
final int? id;
final String localId;
final int customerId;
final String customerName;
final String type; // 'sale', 'payment', 'adjustment'
final double amount;
final double balanceBefore;
final double balanceAfter;
final String? reference; // sale_id or payment reference
final String? notes;
final DateTime createdAt;

CreditTransaction({
this.id,
required this.localId,
required this.customerId,
required this.customerName,
required this.type,
required this.amount,
required this.balanceBefore,
required this.balanceAfter,
this.reference,
this.notes,
required this.createdAt,
});

Map<String, dynamic> toMap() {
return {
'id': id,
'local_id': localId,
'customer_id': customerId,
'customer_name': customerName,
'type': type,
'amount': amount,
'balance_before': balanceBefore,
'balance_after': balanceAfter,
'reference': reference,
'notes': notes,
'created_at': createdAt.millisecondsSinceEpoch,
};
}

factory CreditTransaction.fromMap(Map<String, dynamic> map) {
return CreditTransaction(
id: map['id'],
localId: map['local_id'],
customerId: map['customer_id'],
customerName: map['customer_name'],
type: map['type'],
amount: map['amount'],
balanceBefore: map['balance_before'],
balanceAfter: map['balance_after'],
reference: map['reference'],
notes: map['notes'],
createdAt: DateTime.fromMillisecondsSinceEpoch(map['created_at']),
);
}

// Helper methods
bool get isSale => type == 'sale';
bool get isPayment => type == 'payment';
bool get isAdjustment => type == 'adjustment';

String get formattedAmount {
if (isSale) {
return '+ETB ${amount.toStringAsFixed(2)}';
} else if (isPayment) {
return '-ETB ${amount.toStringAsFixed(2)}';
} else {
return 'ETB ${amount.toStringAsFixed(2)}';
}
}

String get description {
switch (type) {
case 'sale':
return 'Credit Sale';
case 'payment':
return 'Payment Received';
case 'adjustment':
return 'Credit Limit Adjustment';
default:
return 'Transaction';
}
}

Color get amountColor {
switch (type) {
case 'sale':
return Colors.red;
case 'payment':
return Colors.green;
default:
return Colors.orange;
}
}

IconData get icon {
switch (type) {
case 'sale':
return Icons.shopping_cart;
case 'payment':
return Icons.payment;
case 'adjustment':
return Icons.tune;
default:
return Icons.receipt;
}
}
}

##

// mobile/lib/src/data/models/customer.dart
// Model representing a customer in the POS system.
class Customer {
final int? id;
final String localId;
final String name;
final String? businessName;
final String phone;
final String? whatsappNumber;
final String? email;
final String? address;
final String? tinNumber;
final double creditLimit;
final double currentBalance;
final DateTime? dueDate;
final DateTime? lastTransactionDate;
final bool allowCredit;
final String? paymentTerms;
final String? notes;
final bool isActive;
final DateTime createdAt;
final DateTime updatedAt;

Customer({
this.id,
required this.localId,
required this.name,
this.businessName,
required this.phone,
this.whatsappNumber,
this.email,
this.address,
this.tinNumber,
this.creditLimit = 0,
this.currentBalance = 0,
this.dueDate,
this.lastTransactionDate,
this.allowCredit = false,
this.paymentTerms,
this.notes,
this.isActive = true,
required this.createdAt,
required this.updatedAt,
});

Map<String, dynamic> toMap() {
return {
'id': id,
'local_id': localId,
'name': name,
'business_name': businessName,
'phone': phone,
'whatsapp_number': whatsappNumber,
'email': email,
'address': address,
'tin_number': tinNumber,
'credit_limit': creditLimit,
'current_balance': currentBalance,
'due_date': dueDate?.millisecondsSinceEpoch,
'last_transaction_date': lastTransactionDate?.millisecondsSinceEpoch,
'allow_credit': allowCredit ? 1 : 0,
'payment_terms': paymentTerms,
'notes': notes,
'is_active': isActive ? 1 : 0,
'created_at': createdAt.millisecondsSinceEpoch,
'updated_at': updatedAt.millisecondsSinceEpoch,
};
}

factory Customer.fromMap(Map<String, dynamic> map) {
return Customer(
id: map['id'],
localId: map['local_id'],
name: map['name'],
businessName: map['business_name'],
phone: map['phone'],
whatsappNumber: map['whatsapp_number'],
email: map['email'],
address: map['address'],
tinNumber: map['tin_number'],
creditLimit: map['credit_limit'] ?? 0,
currentBalance: map['current_balance'] ?? 0,
dueDate: map['due_date'] != null
? DateTime.fromMillisecondsSinceEpoch(map['due_date'])
: null,
lastTransactionDate: map['last_transaction_date'] != null
? DateTime.fromMillisecondsSinceEpoch(map['last_transaction_date'])
: null,
allowCredit: map['allow_credit'] == 1,
paymentTerms: map['payment_terms'],
notes: map['notes'],
isActive: map['is_active'] == 1,
createdAt: DateTime.fromMillisecondsSinceEpoch(map['created_at']),
updatedAt: DateTime.fromMillisecondsSinceEpoch(map['updated_at']),
);
}

// Helper methods
bool get hasCredit => allowCredit && creditLimit > 0;

double get overdueAmount {
if (currentBalance <= 0) return 0;
if (dueDate == null) return 0;
if (DateTime.now().isAfter(dueDate!)) {
return currentBalance;
}
return 0;
}

bool get isOverdue => overdueAmount > 0;

double get availableCredit => hasCredit ? creditLimit - currentBalance : 0;

bool get canMakeCreditSale => availableCredit > 0;

String get balanceStatus {
if (currentBalance == 0) return 'Paid';
if (isOverdue) return 'Overdue: ETB ${currentBalance.toStringAsFixed(2)}';
if (currentBalance > 0) {
return 'Owes: ETB ${currentBalance.toStringAsFixed(2)}';
}
return 'Credit: ETB ${(-currentBalance).toStringAsFixed(2)}';
}

String get formattedBalance {
if (currentBalance >= 0) {
return 'ETB ${currentBalance.toStringAsFixed(2)}';
} else {
return 'ETB ${(-currentBalance).toStringAsFixed(2)}';
}
}

Customer copyWith({
int? id,
String? localId,
String? name,
String? businessName,
String? phone,
String? whatsappNumber,
String? email,
String? address,
String? tinNumber,
double? creditLimit,
double? currentBalance,
DateTime? dueDate,
DateTime? lastTransactionDate,
bool? allowCredit,
String? paymentTerms,
String? notes,
bool? isActive,
DateTime? createdAt,
DateTime? updatedAt,
}) {
return Customer(
id: id ?? this.id,
localId: localId ?? this.localId,
name: name ?? this.name,
businessName: businessName ?? this.businessName,
phone: phone ?? this.phone,
whatsappNumber: whatsappNumber ?? this.whatsappNumber,
email: email ?? this.email,
address: address ?? this.address,
tinNumber: tinNumber ?? this.tinNumber,
creditLimit: creditLimit ?? this.creditLimit,
currentBalance: currentBalance ?? this.currentBalance,
dueDate: dueDate ?? this.dueDate,
lastTransactionDate: lastTransactionDate ?? this.lastTransactionDate,
allowCredit: allowCredit ?? this.allowCredit,
paymentTerms: paymentTerms ?? this.paymentTerms,
notes: notes ?? this.notes,
isActive: isActive ?? this.isActive,
createdAt: createdAt ?? this.createdAt,
updatedAt: updatedAt ?? this.updatedAt,
);
}

factory Customer.createSample() {
return Customer(
localId: 'cust*sample*${DateTime.now().millisecondsSinceEpoch}',
name: 'Sample Customer',
businessName: 'Sample Business',
phone: '+251911223344',
whatsappNumber: '+251911223344',
email: 'sample@email.com',
address: 'Addis Ababa, Ethiopia',
tinNumber: '1234567890',
creditLimit: 1000.0,
currentBalance: 250.0,
dueDate: DateTime.now().add(const Duration(days: 30)),
allowCredit: true,
paymentTerms: '30',
notes: 'Sample customer for testing',
isActive: true,
createdAt: DateTime.now(),
updatedAt: DateTime.now(),
);
}

factory Customer.createSampleWithIndex(int index) {
final customers = [
{
'name': 'Abebe Kebede',
'business': 'Abebe Store',
'phone': '+251911001100',
'balance': 0.0
},
{
'name': 'Marta Solomon',
'business': 'Marta Trading',
'phone': '+251922002200',
'balance': 500.0
},
{
'name': 'Tesfaye Hailu',
'business': 'Tesfaye Shop',
'phone': '+251933003300',
'balance': 1200.0
},
{
'name': 'Hana Michael',
'business': 'Hana Retail',
'phone': '+251944004400',
'balance': 0.0
},
{
'name': 'Dawit Asrat',
'business': 'Dawit Wholesale',
'phone': '+251955005500',
'balance': 750.0
},
];

    final customerData = customers[index % customers.length];
    final hasBalance = (customerData['balance'] as double) > 0;

    return Customer(
      localId: 'cust_sample_${DateTime.now().millisecondsSinceEpoch}_$index',
      name: customerData['name'] as String,
      businessName: customerData['business'] as String,
      phone: customerData['phone'] as String,
      whatsappNumber: customerData['phone'] as String,
      email: 'customer${index + 1}@email.com',
      address: 'Addis Ababa, Ethiopia',
      tinNumber: 'TIN${index.toString().padLeft(7, '0')}',
      creditLimit: 2000.0,
      currentBalance: customerData['balance'] as double,
      dueDate: hasBalance
          ? DateTime.now().add(Duration(days: 30 - (index * 5)))
          : null,
      allowCredit: true,
      paymentTerms: '30',
      notes: 'Regular customer',
      isActive: true,
      createdAt: DateTime.now().subtract(Duration(days: index * 10)),
      updatedAt: DateTime.now(),
    );

}
}

##

// mobile/lib/src/data/models/otp.dart
// Model representing a One-Time Password (OTP) used for authentication and verification. used on registration login password reset and phone verification
class OTP {
final String id;
final String phone;
final String code;
final String type; // 'login', 'reset_password', 'verify_phone'
final bool isUsed;
final DateTime expiresAt;
final DateTime createdAt;

OTP({
required this.id,
required this.phone,
required this.code,
required this.type,
this.isUsed = false,
required this.expiresAt,
required this.createdAt,
});

factory OTP.create({
required String phone,
required String type,
int validityMinutes = 10,
}) {
final now = DateTime.now();
return OTP(
id: 'otp\_${now.millisecondsSinceEpoch}',
phone: phone,
code: \_generateOTP(),
type: type,
expiresAt: now.add(Duration(minutes: validityMinutes)),
createdAt: now,
);
}

static String \_generateOTP() {
final random = DateTime.now().millisecondsSinceEpoch;
return (random % 900000 + 100000).toString().substring(0, 6);
}

Map<String, dynamic> toMap() {
return {
'otp_id': id,
'phone': phone,
'code': code,
'type': type,
'is_used': isUsed ? 1 : 0,
'expires_at': expiresAt.millisecondsSinceEpoch,
'created_at': createdAt.millisecondsSinceEpoch,
};
}

factory OTP.fromMap(Map<String, dynamic> map) {
return OTP(
id: map['otp_id'],
phone: map['phone'],
code: map['code'],
type: map['type'],
isUsed: map['is_used'] == 1,
expiresAt: DateTime.fromMillisecondsSinceEpoch(map['expires_at']),
createdAt: DateTime.fromMillisecondsSinceEpoch(map['created_at']),
);
}

bool get isValid => !isUsed && DateTime.now().isBefore(expiresAt);

OTP markAsUsed() {
return OTP(
id: id,
phone: phone,
code: code,
type: type,
isUsed: true,
expiresAt: expiresAt,
createdAt: createdAt,
);
}
}

##

// lib/src/data/models/product.dart
// Model representing a product in the POS system.
import 'dart:convert';
import 'dart:ui' as ui;
import 'package:flutter/material.dart';
import 'package:crypto/crypto.dart';

class Product {
final int? id;
final String productId;
final String name;
final String nameAm;
final String? description;
final double price;
final double? costPrice;
final int stockQuantity;
final int? minStockLevel;
final String barcode;
final String? sku;
final String categoryId;
final String? categoryName;
final String? unit;
final String? brand;
final String? supplier;
final double? weight;
final String? size;
final String? color;
final String? imagePath;
final bool trackInventory;
final bool isActive;
final DateTime createdAt;
final DateTime updatedAt;
late final String checksum; // For data integrity
final int version; // For optimistic locking

Product({
this.id,
required this.productId,
required this.name,
required this.nameAm,
this.description,
required double price,
this.costPrice,
required int stockQuantity,
int? minStockLevel,
required String barcode,
this.sku,
required this.categoryId,
this.categoryName,
this.unit,
this.brand,
this.supplier,
this.weight,
this.size,
this.color,
this.imagePath,
this.trackInventory = true,
this.isActive = true,
required this.createdAt,
required this.updatedAt,
this.checksum = '',
this.version = 1,
}) : price = \_validatePrice(price),
stockQuantity = \_validateStock(stockQuantity),
barcode = \_validateBarcode(barcode),
minStockLevel = \_validateMinStock(minStockLevel) {
// Generate checksum
checksum = \_generateChecksum();
}

// === VALIDATION METHODS ===
static double \_validatePrice(double price) {
if (price < 0) throw ArgumentError('Price cannot be negative: $price');
if (price > 10000000) {
throw ArgumentError('Price exceeds maximum allowed: $price');
}
return double.parse(price.toStringAsFixed(2)); // Round to 2 decimals
}

static int \_validateStock(int stock) {
if (stock < 0) throw ArgumentError('Stock cannot be negative: $stock');
if (stock > 1000000)
throw ArgumentError('Stock exceeds maximum allowed: $stock');
return stock;
}

static String \_validateBarcode(String barcode) {
if (barcode.isEmpty) throw ArgumentError('Barcode cannot be empty');
barcode = barcode.trim();

    // Validate common barcode formats
    final validFormats = [
      RegExp(r'^[0-9]{12,13}$'), // EAN-13, UPC-A
      RegExp(r'^[0-9]{8}$'), // EAN-8
      RegExp(r'^[0-9]{14}$'), // GTIN-14
    ];

    final isValid = validFormats.any((regex) => regex.hasMatch(barcode));
    if (!isValid) {
      throw ArgumentError('Invalid barcode format: $barcode');
    }

    return barcode;

}

static int? \_validateMinStock(int? minStock) {
if (minStock != null) {
if (minStock < 0)
throw ArgumentError('Minimum stock cannot be negative: $minStock');
if (minStock > 1000000)
throw ArgumentError('Minimum stock exceeds maximum: $minStock');
}
return minStock;
}

String \_generateChecksum() {
final data =
'$productId$name$nameAm$price$stockQuantity$barcode$categoryId';
final bytes = utf8.encode(data);
final digest = sha256.convert(bytes);
return digest.toString();
}

bool verifyChecksum() {
return checksum == \_generateChecksum();
}

// === BUSINESS METHODS ===
bool canSellQuantity(int quantity) {
if (!trackInventory) return true;
if (quantity <= 0) return false;
if (quantity > stockQuantity) return false;
if (!isActive) return false;
return true;
}

Product reduceStock(int quantity) {
if (!canSellQuantity(quantity)) {
throw StateError(
'Cannot sell $quantity of $name. Available: $stockQuantity');
}

    return copyWith(
      stockQuantity: stockQuantity - quantity,
      version: version + 1,
    );

}

Product increaseStock(int quantity) {
if (quantity <= 0)
throw ArgumentError('Quantity must be positive: $quantity');

    return copyWith(
      stockQuantity: stockQuantity + quantity,
      version: version + 1,
    );

}

double getPriceWithTax(double taxRate) {
return double.parse((price \* (1 + taxRate)).toStringAsFixed(2));
}

double getProfit() {
if (costPrice == null) return 0;
return double.parse((price - costPrice!).toStringAsFixed(2));
}

double getProfitPercentage() {
if (costPrice == null || costPrice == 0) return 0;
return double.parse(
(((price - costPrice!) / costPrice!) \* 100).toStringAsFixed(2));
}

// === COPY WITH METHOD (ENHANCED) ===
Product copyWith({
String? name,
String? nameAm,
String? description,
double? price,
double? costPrice,
int? stockQuantity,
int? minStockLevel,
String? barcode,
String? sku,
String? categoryId,
String? unit,
String? brand,
String? supplier,
double? weight,
String? size,
String? color,
String? imagePath,
bool? trackInventory,
bool? isActive,
int? version,
}) {
return Product(
id: id,
productId: productId,
name: name ?? this.name,
nameAm: nameAm ?? this.nameAm,
description: description ?? this.description,
price: price ?? this.price,
costPrice: costPrice ?? this.costPrice,
stockQuantity: stockQuantity ?? this.stockQuantity,
minStockLevel: minStockLevel ?? this.minStockLevel,
barcode: barcode ?? this.barcode,
sku: sku ?? this.sku,
categoryId: categoryId ?? this.categoryId,
unit: unit ?? this.unit,
brand: brand ?? this.brand,
supplier: supplier ?? this.supplier,
weight: weight ?? this.weight,
size: size ?? this.size,
color: color ?? this.color,
imagePath: imagePath ?? this.imagePath,
trackInventory: trackInventory ?? this.trackInventory,
isActive: isActive ?? this.isActive,
createdAt: createdAt,
updatedAt: DateTime.now(),
version: version ?? this.version + 1,
);
}

// === TO/FROM MAP ===
Map<String, dynamic> toMap() {
return {
'id': id,
'product_id': productId,
'name': name,
'name_am': nameAm,
'description': description,
'price': price,
'cost_price': costPrice,
'stock_quantity': stockQuantity,
'min_stock_level': minStockLevel,
'barcode': barcode,
'sku': sku,
'category_id': categoryId,
'unit': unit,
'brand': brand,
'supplier': supplier,
'weight': weight,
'size': size,
'color': color,
'image_path': imagePath,
'track_inventory': trackInventory ? 1 : 0,
'is_active': isActive ? 1 : 0,
'created_at': createdAt.millisecondsSinceEpoch,
'updated_at': updatedAt.millisecondsSinceEpoch,
'checksum': checksum,
'version': version,
};
}

factory Product.fromMap(Map<String, dynamic> map) {
return Product(
id: map['id'],
productId: map['product_id'],
name: map['name'],
nameAm: map['name_am'],
description: map['description'],
price: map['price'],
costPrice: map['cost_price'],
stockQuantity: map['stock_quantity'],
minStockLevel: map['min_stock_level'],
barcode: map['barcode'],
sku: map['sku'],
categoryId: map['category_id'],
unit: map['unit'],
brand: map['brand'],
supplier: map['supplier'],
weight: map['weight'],
size: map['size'],
color: map['color'],
imagePath: map['image_path'],
trackInventory: map['track_inventory'] == 1,
isActive: map['is_active'] == 1,
createdAt: DateTime.fromMillisecondsSinceEpoch(map['created_at']),
updatedAt: DateTime.fromMillisecondsSinceEpoch(map['updated_at']),
checksum: map['checksum'] ?? '',
version: map['version'] ?? 1,
);
}

// === HELPER PROPERTIES ===
String get formattedPrice => 'ETB ${price.toStringAsFixed(2)}';
String get formattedCostPrice =>
costPrice != null ? 'ETB ${costPrice!.toStringAsFixed(2)}' : 'N/A';

bool get isLowStock =>
trackInventory &&
minStockLevel != null &&
stockQuantity <= minStockLevel!;

bool get isOutOfStock => trackInventory && stockQuantity <= 0;

String get stockStatus {
if (!trackInventory) return 'Not Tracked';
if (isOutOfStock) return 'Out of Stock';
if (isLowStock) return 'Low Stock';
return 'In Stock';
}

Color get stockStatusColor {
if (!trackInventory) return Colors.grey;
if (isOutOfStock) return const Color(0xFFEF4444);
if (isLowStock) return const Color(0xFFF59E0B);
return const Color(0xFF10B981);
}

// === FACTORY METHODS ===
factory Product.create({
required String name,
required String nameAm,
required double price,
required int stockQuantity,
required String barcode,
required String categoryId,
String? description,
double? costPrice,
int? minStockLevel,
String? unit,
String? brand,
String? supplier,
}) {
return Product(
productId: 'PROD\_${DateTime.now().millisecondsSinceEpoch}',
name: name,
nameAm: nameAm,
description: description,
price: price,
costPrice: costPrice,
stockQuantity: stockQuantity,
minStockLevel: minStockLevel,
barcode: barcode,
categoryId: categoryId,
unit: unit,
brand: brand,
supplier: supplier,
createdAt: DateTime.now(),
updatedAt: DateTime.now(),
);
}

@override
String toString() {
return 'Product(id: $id, name: $name, price: $price, stock: $stockQuantity, barcode: $barcode)';
}

@override
bool operator ==(Object other) {
if (identical(this, other)) return true;
return other is Product &&
other.productId == productId &&
other.version == version;
}

@override
int get hashCode => productId.hashCode ^ version.hashCode;
}

##

// mobile/lib/src/data/models/registration.dart
// Models for business and user registration data.
import 'package:andalus_smart_pos/src/data/models/user.dart';

class BusinessRegistration {
final String businessName;
final String businessNameAm;
final String businessType;
final String phone;
final String? email; // Make email nullable
final String address;
final String city;
final String region;
final String tinNumber;
final String ownerName;
final String ownerPhone;
final String? ownerEmail; // Make ownerEmail nullable

BusinessRegistration({
required this.businessName,
required this.businessNameAm,
required this.businessType,
required this.phone,
this.email, // Now nullable
required this.address,
required this.city,
required this.region,
required this.tinNumber,
required this.ownerName,
required this.ownerPhone,
this.ownerEmail, // Now nullable
});

Map<String, dynamic> toMap() {
return {
'name': businessName,
'name_am': businessNameAm,
'business_type': businessType,
'phone': phone,
'email': email, // Can be null
'address': address,
'city': city,
'region': region,
'tin_number': tinNumber,
'owner_name': ownerName,
'owner_phone': ownerPhone,
'owner_email': ownerEmail, // Can be null
};
}
}

class UserRegistration {
final String name;
final String phone;
final String? email; // Make email nullable
final String password;
final UserRole role;

UserRegistration({
required this.name,
required this.phone,
this.email, // Now nullable
required this.password,
this.role = UserRole.owner,
});

Map<String, dynamic> toMap() {
return {
'name': name,
'phone': phone,
'email': email, // Can be null
'password': password,
'role': role.name,
};
}
}

##

// mobile/lib/src/data/models/sale_item.dart
// Model representing an item in a sale transaction.
class SaleItem {
final int? id;
final String saleId;
final String productId;
final String productName;
final String? productNameAm;
final int quantity;
final double unitPrice;
final double totalPrice;
final double? costPrice;
final double discount;
final String? barcode;
final String? unit;
final DateTime createdAt;
final bool isSynced;

SaleItem({
this.id,
required this.saleId,
required this.productId,
required this.productName,
this.productNameAm,
required this.quantity,
required this.unitPrice,
required this.totalPrice,
this.costPrice,
this.discount = 0,
this.barcode,
this.unit,
required this.createdAt,
this.isSynced = false,
}) : assert(quantity > 0, 'Quantity must be positive: $quantity'),
assert(unitPrice >= 0, 'Unit price cannot be negative: $unitPrice'),
assert(totalPrice >= 0, 'Total price cannot be negative: $totalPrice');

SaleItem copyWith({
int? id,
String? saleId,
String? productId,
String? productName,
String? productNameAm,
int? quantity,
double? unitPrice,
double? totalPrice,
double? costPrice,
double? discount,
String? barcode,
String? unit,
DateTime? createdAt,
bool? isSynced,
}) {
return SaleItem(
id: id ?? this.id,
saleId: saleId ?? this.saleId,
productId: productId ?? this.productId,
productName: productName ?? this.productName,
productNameAm: productNameAm ?? this.productNameAm,
quantity: quantity ?? this.quantity,
unitPrice: unitPrice ?? this.unitPrice,
totalPrice: totalPrice ?? this.totalPrice,
costPrice: costPrice ?? this.costPrice,
discount: discount ?? this.discount,
barcode: barcode ?? this.barcode,
unit: unit ?? this.unit,
createdAt: createdAt ?? this.createdAt,
isSynced: isSynced ?? this.isSynced,
);
}

factory SaleItem.create({
required String saleId,
required String productId,
required String productName,
String? productNameAm,
required int quantity,
required double unitPrice,
double? costPrice,
double discount = 0,
String? barcode,
String? unit,
}) {
final totalPrice = (unitPrice \* quantity) - discount;

    return SaleItem(
      saleId: saleId,
      productId: productId,
      productName: productName,
      productNameAm: productNameAm,
      quantity: quantity,
      unitPrice: unitPrice,
      totalPrice: totalPrice,
      costPrice: costPrice,
      discount: discount,
      barcode: barcode,
      unit: unit,
      createdAt: DateTime.now(),
    );

}

Map<String, dynamic> toMap() {
return {
'id': id,
'sale_id': saleId,
'product_id': productId,
'product_name': productName,
'product_name_am': productNameAm,
'quantity': quantity,
'unit_price': unitPrice,
'total_price': totalPrice,
'cost_price': costPrice,
'discount': discount,
'barcode': barcode,
'unit': unit,
'created_at': createdAt.millisecondsSinceEpoch,
'is_synced': isSynced ? 1 : 0,
};
}

factory SaleItem.fromMap(Map<String, dynamic> map) {
return SaleItem(
id: map['id'],
saleId: map['sale_id'],
productId: map['product_id'],
productName: map['product_name'],
productNameAm: map['product_name_am'],
quantity: map['quantity'],
unitPrice: map['unit_price'],
totalPrice: map['total_price'],
costPrice: map['cost_price'],
discount: map['discount'] ?? 0,
barcode: map['barcode'],
unit: map['unit'],
createdAt: DateTime.fromMillisecondsSinceEpoch(map['created_at']),
isSynced: map['is_synced'] == 1,
);
}

double get profit {
if (costPrice == null) return 0;
return totalPrice - (costPrice! \* quantity);
}

String get formattedUnitPrice => 'ETB ${unitPrice.toStringAsFixed(2)}';
String get formattedTotal => 'ETB ${totalPrice.toStringAsFixed(2)}';
}

##

// mobile/lib/src/data/models/sale.dart
import 'dart:convert';
import 'package:andalus_smart_pos/src/data/models/sale_item.dart';
import 'package:crypto/crypto.dart';

class Sale {
final int? id;
final String saleId;
final String localId;
final int? customerId;
final String? customerName;
final double totalAmount;
final double finalAmount;
final double taxAmount;
final double discountAmount;
final String paymentMethod;
final String paymentReference;
final String paymentStatus;
final String saleStatus;
final int userId;
final String? userName;
final int shopId;
final bool isSynced;
final int syncAttempts;
final DateTime createdAt;
final DateTime? updatedAt;
final DateTime? syncedAt;
late final String checksum;
final String? notes;
final bool isRefunded;
final String? refundReason;
final DateTime? refundedAt;

Sale({
this.id,
required this.saleId,
required this.localId,
this.customerId,
this.customerName,
required this.totalAmount,
required this.finalAmount,
this.taxAmount = 0,
this.discountAmount = 0,
required this.paymentMethod,
this.paymentReference = '',
this.paymentStatus = 'completed',
this.saleStatus = 'completed',
required this.userId,
this.userName,
required this.shopId,
this.isSynced = false,
this.syncAttempts = 0,
required this.createdAt,
this.updatedAt,
this.syncedAt,
this.checksum = '',
this.notes,
this.isRefunded = false,
this.refundReason,
this.refundedAt,
}) : assert(totalAmount >= 0, 'Total amount cannot be negative'),
assert(finalAmount >= 0, 'Final amount cannot be negative'),
assert(taxAmount >= 0, 'Tax amount cannot be negative'),
assert(discountAmount >= 0, 'Discount amount cannot be negative'),
assert(paymentMethod.isNotEmpty, 'Payment method required'),
assert(userId > 0, 'User ID must be positive'),
assert(shopId > 0, 'Shop ID must be positive') {
// Generate checksum if not provided
if (checksum.isEmpty) {
checksum = \_generateChecksum();
}
}

String \_generateChecksum() {
final data =
'$saleId$totalAmount$finalAmount$paymentMethod$userId$shopId${createdAt.millisecondsSinceEpoch}';
final bytes = utf8.encode(data);
final digest = sha256.convert(bytes);
return digest.toString();
}

bool verifyChecksum() {
return checksum == \_generateChecksum();
}

// === BUSINESS VALIDATION ===
bool isValid() {
return saleId.isNotEmpty &&
localId.isNotEmpty &&
totalAmount >= 0 &&
finalAmount >= 0 &&
paymentMethod.isNotEmpty &&
userId > 0 &&
shopId > 0 &&
verifyChecksum();
}

bool get isTotalValid {
// Allow small rounding differences (0.01)
final calculated = totalAmount + taxAmount - discountAmount;
return (finalAmount - calculated).abs() < 0.01;
}

bool get canBeRefunded {
return !isRefunded &&
saleStatus == 'completed' &&
paymentStatus == 'completed' &&
createdAt.isAfter(DateTime.now()
.subtract(const Duration(days: 30))); // 30-day refund window
}

// === FACTORY METHODS ===
factory Sale.createNew({
required List<SaleItem> items,
required int userId,
required String userName,
required int shopId,
String paymentMethod = 'cash',
String? paymentReference,
int? customerId,
String? customerName,
double taxRate = 0.15,
double discountAmount = 0,
String? notes,
}) {
// Calculate amounts
final subtotal = items.fold(0.0, (sum, item) => sum + item.totalPrice);
final taxAmount = subtotal \* taxRate;
final totalAmount = subtotal + taxAmount;
final finalAmount = totalAmount - discountAmount;

    // Validate amounts
    if (finalAmount < 0) {
      throw ArgumentError('Final amount cannot be negative after discount');
    }

    final now = DateTime.now();
    final saleId =
        'SALE_${now.year}${now.month.toString().padLeft(2, '0')}${now.day.toString().padLeft(2, '0')}_${now.millisecondsSinceEpoch}';

    return Sale(
      saleId: saleId,
      localId: 'LOCAL_${now.millisecondsSinceEpoch}',
      customerId: customerId,
      customerName: customerName,
      totalAmount: double.parse(totalAmount.toStringAsFixed(2)),
      finalAmount: double.parse(finalAmount.toStringAsFixed(2)),
      taxAmount: double.parse(taxAmount.toStringAsFixed(2)),
      discountAmount: double.parse(discountAmount.toStringAsFixed(2)),
      paymentMethod: paymentMethod,
      paymentReference: paymentReference ?? '',
      userId: userId,
      userName: userName,
      shopId: shopId,
      createdAt: now,
      updatedAt: now,
      notes: notes,
    );

}

Sale markAsSynced() {
return copyWith(
isSynced: true,
syncedAt: DateTime.now(),
);
}

Sale markAsRefunded(String reason) {
return copyWith(
isRefunded: true,
refundReason: reason,
refundedAt: DateTime.now(),
saleStatus: 'refunded',
);
}

// === COPY WITH ===
Sale copyWith({
int? id,
String? saleId,
String? localId,
int? customerId,
String? customerName,
double? totalAmount,
double? finalAmount,
double? taxAmount,
double? discountAmount,
String? paymentMethod,
String? paymentReference,
String? paymentStatus,
String? saleStatus,
int? userId,
String? userName,
int? shopId,
bool? isSynced,
int? syncAttempts,
DateTime? createdAt,
DateTime? updatedAt,
DateTime? syncedAt,
String? checksum,
String? notes,
bool? isRefunded,
String? refundReason,
DateTime? refundedAt,
}) {
return Sale(
id: id ?? this.id,
saleId: saleId ?? this.saleId,
localId: localId ?? this.localId,
customerId: customerId ?? this.customerId,
customerName: customerName ?? this.customerName,
totalAmount: totalAmount ?? this.totalAmount,
finalAmount: finalAmount ?? this.finalAmount,
taxAmount: taxAmount ?? this.taxAmount,
discountAmount: discountAmount ?? this.discountAmount,
paymentMethod: paymentMethod ?? this.paymentMethod,
paymentReference: paymentReference ?? this.paymentReference,
paymentStatus: paymentStatus ?? this.paymentStatus,
saleStatus: saleStatus ?? this.saleStatus,
userId: userId ?? this.userId,
userName: userName ?? this.userName,
shopId: shopId ?? this.shopId,
isSynced: isSynced ?? this.isSynced,
syncAttempts: syncAttempts ?? this.syncAttempts,
createdAt: createdAt ?? this.createdAt,
updatedAt: updatedAt ?? DateTime.now(),
syncedAt: syncedAt ?? this.syncedAt,
checksum: checksum ?? this.checksum,
notes: notes ?? this.notes,
isRefunded: isRefunded ?? this.isRefunded,
refundReason: refundReason ?? this.refundReason,
refundedAt: refundedAt ?? this.refundedAt,
);
}

// === TO/FROM MAP ===
Map<String, dynamic> toMap() {
return {
'id': id,
'sale_id': saleId,
'local_id': localId,
'customer_id': customerId,
'customer_name': customerName,
'total_amount': totalAmount,
'final_amount': finalAmount,
'tax_amount': taxAmount,
'discount_amount': discountAmount,
'payment_method': paymentMethod,
'payment_reference': paymentReference,
'payment_status': paymentStatus,
'sale_status': saleStatus,
'user_id': userId,
'user_name': userName,
'shop_id': shopId,
'is_synced': isSynced ? 1 : 0,
'sync_attempts': syncAttempts,
'created_at': createdAt.millisecondsSinceEpoch,
'updated_at': updatedAt?.millisecondsSinceEpoch,
'synced_at': syncedAt?.millisecondsSinceEpoch,
'checksum': checksum,
'notes': notes,
'is_refunded': isRefunded ? 1 : 0,
'refund_reason': refundReason,
'refunded_at': refundedAt?.millisecondsSinceEpoch,
};
}

factory Sale.fromMap(Map<String, dynamic> map) {
return Sale(
id: map['id'],
saleId: map['sale_id'],
localId: map['local_id'] ?? '',
customerId: map['customer_id'],
customerName: map['customer_name'],
totalAmount: map['total_amount'],
finalAmount: map['final_amount'] ?? map['total_amount'],
taxAmount: map['tax_amount'] ?? 0,
discountAmount: map['discount_amount'] ?? 0,
paymentMethod: map['payment_method'],
paymentReference: map['payment_reference'] ?? '',
paymentStatus: map['payment_status'] ?? 'completed',
saleStatus: map['sale_status'] ?? 'completed',
userId: map['user_id'],
userName: map['user_name'],
shopId: map['shop_id'],
isSynced: map['is_synced'] == 1,
syncAttempts: map['sync_attempts'] ?? 0,
createdAt: DateTime.fromMillisecondsSinceEpoch(map['created_at']),
updatedAt: map['updated_at'] != null
? DateTime.fromMillisecondsSinceEpoch(map['updated_at'])
: null,
syncedAt: map['synced_at'] != null
? DateTime.fromMillisecondsSinceEpoch(map['synced_at'])
: null,
checksum: map['checksum'] ?? '',
notes: map['notes'],
isRefunded: map['is_refunded'] == 1,
refundReason: map['refund_reason'],
refundedAt: map['refunded_at'] != null
? DateTime.fromMillisecondsSinceEpoch(map['refunded_at'])
: null,
);
}

// === HELPER METHODS ===
String get formattedTotal => 'ETB ${finalAmount.toStringAsFixed(2)}';
  String get formattedDate =>
      '${createdAt.day}/${createdAt.month}/${createdAt.year}';
String get formattedTime =>
'${createdAt.hour.toString().padLeft(2, '0')}:${createdAt.minute.toString().padLeft(2, '0')}';
String get formattedDateTime => '$formattedDate $formattedTime';

double get subtotal => totalAmount - taxAmount + discountAmount;

@override
String toString() {
return 'Sale(id: $id, saleId: $saleId, total: $formattedTotal, status: $saleStatus)';
}

@override
bool operator ==(Object other) {
if (identical(this, other)) return true;
return other is Sale && other.saleId == saleId;
}

@override
int get hashCode => saleId.hashCode;
}

##

// mobile/lib/src/data/models/settings.dart
// Model representing application settings for the POS system. includes new settings for credit system and stock notifications.
//dark mode language selection currency selection calander format etc can be selected from
class AppSettings {
final String shopName;
final String shopNameAm;
final String address;
final String phone;
final String tinNumber;
final String currency;
final bool enableTax;
final double taxRate;
final bool enableDiscounts;
final bool autoPrintReceipts;
final String defaultPaymentMethod;
final bool enableSync;
final int syncInterval;

// New fields for enhanced settings
final bool enableCreditSystem;
final double defaultCreditLimit;
final String defaultPaymentTerms;
final bool enableCustomerSelection;
final bool lowStockNotifications;
final int lowStockThreshold;

AppSettings({
required this.shopName,
required this.shopNameAm,
required this.address,
required this.phone,
required this.tinNumber,
required this.currency,
required this.enableTax,
required this.taxRate,
required this.enableDiscounts,
required this.autoPrintReceipts,
required this.defaultPaymentMethod,
required this.enableSync,
required this.syncInterval,

    // New fields with default values
    this.enableCreditSystem = true,
    this.defaultCreditLimit = 1000.0,
    this.defaultPaymentTerms = '30',
    this.enableCustomerSelection = true,
    this.lowStockNotifications = true,
    this.lowStockThreshold = 10,

});

Map<String, dynamic> toMap() {
return {
'shopName': shopName,
'shopNameAm': shopNameAm,
'address': address,
'phone': phone,
'tinNumber': tinNumber,
'currency': currency,
'enableTax': enableTax,
'taxRate': taxRate,
'enableDiscounts': enableDiscounts,
'autoPrintReceipts': autoPrintReceipts,
'defaultPaymentMethod': defaultPaymentMethod,
'enableSync': enableSync,
'syncInterval': syncInterval,
'enableCreditSystem': enableCreditSystem,
'defaultCreditLimit': defaultCreditLimit,
'defaultPaymentTerms': defaultPaymentTerms,
'enableCustomerSelection': enableCustomerSelection,
'lowStockNotifications': lowStockNotifications,
'lowStockThreshold': lowStockThreshold,
};
}

factory AppSettings.fromMap(Map<String, dynamic> map) {
return AppSettings(
shopName: map['shopName'] ?? 'Andalus Smart POS',
shopNameAm: map['shopNameAm'] ?? '·ä†·äï·ã≥·àâ·àµ ·àõ·à≠·â≤·äï ·çñ·àµ',
address: map['address'] ?? 'Addis Ababa, Ethiopia',
phone: map['phone'] ?? '+251 911 234 567',
tinNumber: map['tinNumber'] ?? 'TIN-123456789',
currency: map['currency'] ?? 'ETB',
enableTax: map['enableTax'] ?? false,
taxRate: map['taxRate'] ?? 0.15,
enableDiscounts: map['enableDiscounts'] ?? true,
autoPrintReceipts: map['autoPrintReceipts'] ?? false,
defaultPaymentMethod: map['defaultPaymentMethod'] ?? 'cash',
enableSync: map['enableSync'] ?? true,
syncInterval: map['syncInterval'] ?? 5,
enableCreditSystem: map['enableCreditSystem'] ?? true,
defaultCreditLimit: map['defaultCreditLimit'] ?? 1000.0,
defaultPaymentTerms: map['defaultPaymentTerms'] ?? '30',
enableCustomerSelection: map['enableCustomerSelection'] ?? true,
lowStockNotifications: map['lowStockNotifications'] ?? true,
lowStockThreshold: map['lowStockThreshold'] ?? 10,
);
}

AppSettings copyWith({
String? shopName,
String? shopNameAm,
String? address,
String? phone,
String? tinNumber,
String? currency,
bool? enableTax,
double? taxRate,
bool? enableDiscounts,
bool? autoPrintReceipts,
String? defaultPaymentMethod,
bool? enableSync,
int? syncInterval,
bool? enableCreditSystem,
double? defaultCreditLimit,
String? defaultPaymentTerms,
bool? enableCustomerSelection,
bool? lowStockNotifications,
int? lowStockThreshold,
}) {
return AppSettings(
shopName: shopName ?? this.shopName,
shopNameAm: shopNameAm ?? this.shopNameAm,
address: address ?? this.address,
phone: phone ?? this.phone,
tinNumber: tinNumber ?? this.tinNumber,
currency: currency ?? this.currency,
enableTax: enableTax ?? this.enableTax,
taxRate: taxRate ?? this.taxRate,
enableDiscounts: enableDiscounts ?? this.enableDiscounts,
autoPrintReceipts: autoPrintReceipts ?? this.autoPrintReceipts,
defaultPaymentMethod: defaultPaymentMethod ?? this.defaultPaymentMethod,
enableSync: enableSync ?? this.enableSync,
syncInterval: syncInterval ?? this.syncInterval,
enableCreditSystem: enableCreditSystem ?? this.enableCreditSystem,
defaultCreditLimit: defaultCreditLimit ?? this.defaultCreditLimit,
defaultPaymentTerms: defaultPaymentTerms ?? this.defaultPaymentTerms,
enableCustomerSelection:
enableCustomerSelection ?? this.enableCustomerSelection,
lowStockNotifications:
lowStockNotifications ?? this.lowStockNotifications,
lowStockThreshold: lowStockThreshold ?? this.lowStockThreshold,
);
}
}

##

// mobile/lib/src/data/models/shop_registration.dart
// Model representing shop registration data. and owner registration data.
class ShopRegistration {
final String shopName;
final String shopCategory;
final String phoneNumber;
final String city;
final String country;
final String businessAddress;
final String? shopLogo;

const ShopRegistration({
required this.shopName,
required this.shopCategory,
required this.phoneNumber,
required this.city,
required this.country,
required this.businessAddress,
this.shopLogo,
});

Map<String, dynamic> toMap() {
return {
'shop_name': shopName,
'shop_category': shopCategory,
'phone_number': phoneNumber,
'city': city,
'country': country,
'business_address': businessAddress,
'shop_logo': shopLogo,
};
}
}

class OwnerRegistration {
final String fullName;
final String phone;
final String password;
final String? email;

const OwnerRegistration({
required this.fullName,
required this.phone,
required this.password,
this.email,
});

Map<String, dynamic> toMap() {
return {
'full_name': fullName,
'phone': phone,
'password': password,
'email': email,
};
}
}

##

// mobile/lib/src/data/models/subscription.dart
// Model representing a subscription in the POS system.
class Subscription {
final String id;
final String businessId;
final String userId;
final SubscriptionPlan plan;
final BillingCycle billingCycle;
final SubscriptionStatus status;
final DateTime startDate;
final DateTime endDate;
final double amount;
final String currency;
final bool isActive;
final String? paymentReference;
final DateTime createdAt;
final DateTime updatedAt;

Subscription({
required this.id,
required this.businessId,
required this.userId,
required this.plan,
required this.billingCycle,
required this.status,
required this.startDate,
required this.endDate,
required this.amount,
this.currency = 'ETB',
this.isActive = true,
this.paymentReference,
required this.createdAt,
required this.updatedAt,
});

Map<String, dynamic> toMap() {
return {
'subscription_id': id,
'business_id': businessId,
'user_id': userId,
'plan': plan.id, // Use plan.id instead of plan.name
'billing_cycle': billingCycle.name,
'status': status.name,
'amount': amount,
'start_date': startDate.millisecondsSinceEpoch,
'end_date': endDate.millisecondsSinceEpoch,
'is_active': isActive ? 1 : 0,
'currency': currency,
'payment_reference': paymentReference,
'created_at': createdAt.millisecondsSinceEpoch,
'updated_at': updatedAt.millisecondsSinceEpoch,
};
}

factory Subscription.fromMap(Map<String, dynamic> map) {
return Subscription(
id: map['subscription_id'],
businessId: map['business_id'],
userId: map['user_id'],
plan: SubscriptionPlan.getById(map['plan']), // Use getById method
billingCycle:
BillingCycle.values.firstWhere((e) => e.name == map['billing_cycle']),
status:
SubscriptionStatus.values.firstWhere((e) => e.name == map['status']),
startDate: DateTime.fromMillisecondsSinceEpoch(map['start_date']),
endDate: DateTime.fromMillisecondsSinceEpoch(map['end_date']),
amount: map['amount'],
currency: map['currency'] ?? 'ETB',
isActive: map['is_active'] == 1,
paymentReference: map['payment_reference'],
createdAt: DateTime.fromMillisecondsSinceEpoch(map['created_at']),
updatedAt: DateTime.fromMillisecondsSinceEpoch(map['updated_at']),
);
}

bool get isExpired => endDate.isBefore(DateTime.now());
bool get isValid =>
isActive && !isExpired && status == SubscriptionStatus.active;

int get daysRemaining => endDate.difference(DateTime.now()).inDays;

String get statusDisplay {
if (!isActive) return 'Inactive';
if (isExpired) return 'Expired';
if (status == SubscriptionStatus.pastDue) return 'Past Due';
if (status == SubscriptionStatus.canceled) return 'Canceled';
return 'Active';
}

get expiryDate => endDate;

Subscription renew({String? paymentReference}) {
final now = DateTime.now();
DateTime newEndDate;

    if (billingCycle == BillingCycle.monthly) {
      newEndDate = now.add(const Duration(days: 30));
    } else {
      newEndDate = now.add(const Duration(days: 365));
    }

    return Subscription(
      id: 'sub_${now.millisecondsSinceEpoch}',
      businessId: businessId,
      userId: userId,
      plan: plan,
      billingCycle: billingCycle,
      status: SubscriptionStatus.active,
      startDate: now,
      endDate: newEndDate,
      amount: amount,
      currency: currency,
      isActive: true,
      paymentReference: paymentReference,
      createdAt: createdAt,
      updatedAt: now,
    );

}

// Add to your existing subscription model

// Update Subscription class
}

// Make sure your SubscriptionPlan class has premium defined:
class SubscriptionPlan {
final String id;
final String name;
final String description;
final double monthlyPrice;
final double yearlyPrice;
final List<String> features;

const SubscriptionPlan({
required this.id,
required this.name,
required this.description,
required this.monthlyPrice,
required this.yearlyPrice,
required this.features,
});

// Add these static instances
static const SubscriptionPlan basic = SubscriptionPlan(
id: 'basic',
name: 'Basic',
description: 'Perfect for small businesses',
monthlyPrice: 299,
yearlyPrice: 2990,
features: [
'Up to 100 products',
'Basic sales reports',
'Customer management',
'Receipt printing',
],
);

static const SubscriptionPlan professional = SubscriptionPlan(
id: 'professional',
name: 'Professional',
description: 'Ideal for growing businesses',
monthlyPrice: 599,
yearlyPrice: 5990,
features: [
'Up to 1000 products',
'Advanced analytics',
'Inventory management',
'Multi-user support',
'Customer credit system',
],
);

static const SubscriptionPlan premium = SubscriptionPlan(
// ADD THIS
id: 'premium',
name: 'Premium',
description: 'For large enterprises',
monthlyPrice: 999,
yearlyPrice: 9990,
features: [
'Unlimited products',
'Advanced reporting',
'Priority support',
'Custom integrations',
'Multi-branch support',
'API access',
],
);

// Add this method to get all plans
static List<SubscriptionPlan> get all => [basic, professional, premium];

// Helper method to get plan by ID
static SubscriptionPlan getById(String id) {
return all.firstWhere((plan) => plan.id == id, orElse: () => basic);
}

double getPrice(BillingCycle cycle) {
return cycle == BillingCycle.monthly ? monthlyPrice : yearlyPrice;
}

String getFormattedPrice(BillingCycle cycle) {
final price = getPrice(cycle);
return 'ETB ${price.toStringAsFixed(0)}/${cycle == BillingCycle.monthly ? 'month' : 'year'}';
}

String get savingsInfo {
final yearlySavings = (monthlyPrice \* 12) - yearlyPrice;
return 'Save ETB ${yearlySavings.toStringAsFixed(0)} per year';
}
}

enum BillingCycle {
monthly('Monthly'),
yearly('Yearly');

final String displayName;

const BillingCycle(this.displayName);
}

// enum SubscriptionStatus {
// pending,
// active,
// expired,
// canceled,
// }

enum SubscriptionStatus {
active('Active'),
inactive('Inactive'),
canceled('Canceled'),
pastDue('Past Due'),
pending('Pending');

final String displayName;

const SubscriptionStatus(this.displayName);
}

class PaymentResult {
final bool success;
final String? paymentReference;
final String? error;
final String? transactionId;

const PaymentResult({
required this.success,
this.paymentReference,
this.error,
this.transactionId,
});

factory PaymentResult.success(
{String? paymentReference, String? transactionId}) {
return PaymentResult(
success: true,
paymentReference: paymentReference,
transactionId: transactionId,
);
}

factory PaymentResult.failure(String error) {
return PaymentResult(success: false, error: error);
}
}

##

// mobile/lib/src/data/models/user.dart
// Model representing a user in the POS system. example roles: owner manager cashier
class User {
final String id;
final String? email;
final String name;
final String phone;
final UserRole role;
final DateTime createdAt;
final DateTime? lastLogin;
final bool isActive;
final bool isVerified;
final String? businessId;
final String? passwordHash;

User({
required this.id,
required this.email,
required this.name,
required this.phone,
required this.role,
required this.createdAt,
this.lastLogin,
this.isActive = true,
this.isVerified = false,
this.businessId,
this.passwordHash,
});

Map<String, dynamic> toMap() {
return {
'user_id': id,
'email': email,
'name': name,
'phone': phone,
'role': role.name,
'created_at': createdAt.millisecondsSinceEpoch,
'last_login_at': lastLogin?.millisecondsSinceEpoch,
'is_active': isActive ? 1 : 0,
'is_verified': isVerified ? 1 : 0,
'business_id': businessId,
'password_hash': passwordHash, // Add this line
'updated_at': DateTime.now().millisecondsSinceEpoch,
};
}

factory User.fromMap(Map<String, dynamic> map) {
return User(
id: map['user_id'],
email: map['email'],
name: map['name'],
phone: map['phone'],
role: UserRole.values.firstWhere((e) => e.name == map['role']),
createdAt: DateTime.fromMillisecondsSinceEpoch(map['created_at']),
lastLogin: map['last_login_at'] != null
? DateTime.fromMillisecondsSinceEpoch(map['last_login_at'])
: null,
isActive: map['is_active'] == 1,
isVerified: map['is_verified'] == 1,
businessId: map['business_id'],
passwordHash: map['password_hash'], // This should be here
);
}

User copyWith({
String? name,
String? phone,
String? email,
UserRole? role,
bool? isActive,
bool? isVerified,
DateTime? lastLogin,
String? passwordHash, // Add this parameter
}) {
return User(
id: id,
name: name ?? this.name,
phone: phone ?? this.phone,
email: email ?? this.email,
role: role ?? this.role,
createdAt: createdAt,
lastLogin: lastLogin ?? this.lastLogin,
isActive: isActive ?? this.isActive,
isVerified: isVerified ?? this.isVerified,
businessId: businessId,
passwordHash: passwordHash ?? this.passwordHash, // Include passwordHash
);
}

bool get isOwner => role == UserRole.owner;
bool get isManager => role == UserRole.manager;
bool get isCashier => role == UserRole.cashier;
bool get isAdmin => isOwner || isManager;

bool hasPermission(Permission permission) {
return role.permissions.contains(permission);
}

// Check if user can access specific features
bool canManageUsers() => hasPermission(Permission.manageUsers);
bool canManageProducts() => hasPermission(Permission.manageProducts);
bool canManageCustomers() => hasPermission(Permission.manageCustomers);
bool canViewReports() => hasPermission(Permission.viewReports);
bool canProcessSales() => hasPermission(Permission.processSales);
}

enum UserRole {
owner(
'Owner',
[
Permission.manageUsers,
Permission.manageProducts,
Permission.manageCustomers,
Permission.viewReports,
Permission.processSales,
Permission.manageSettings,
Permission.viewDashboard,
],
),
manager(
'Manager',
[
Permission.manageProducts,
Permission.manageCustomers,
Permission.viewReports,
Permission.processSales,
Permission.viewDashboard,
],
),
cashier(
'Cashier',
[
Permission.processSales,
Permission.viewDashboard,
],
);

final String displayName;
final List<Permission> permissions;

const UserRole(this.displayName, this.permissions);

static UserRole fromString(String role) {
return UserRole.values.firstWhere(
(e) => e.name == role.toLowerCase(),
orElse: () => UserRole.cashier,
);
}
}

enum Permission {
manageUsers('Manage Users'),
manageProducts('Manage Products'),
manageCustomers('Manage Customers'),
viewReports('View Reports'),
processSales('Process Sales'),
manageSettings('Manage Settings'),
viewDashboard('View Dashboard');

final String displayName;

const Permission(this.displayName);
}

##

//mobile/lib/src/data/remote/api_client.dart
// API client for interacting with the backend server. laravel backend.
import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:retrofit/retrofit.dart';
import 'package:andalus_smart_pos/src/data/models/product.dart';
import 'package:andalus_smart_pos/src/data/models/sale.dart';
import 'package:andalus_smart_pos/src/data/models/sale_item.dart';

final apiClientProvider = Provider<ApiClient>((ref) {
return ApiClient(ref);
});

@RestApi(baseUrl: 'https://your-backend.com/api')
abstract class ApiClient {
factory ApiClient(Ref ref) {
final dio = Dio();

    // Add interceptors
    dio.interceptors.add(
      ApiInterceptors(
        secureStorage: ref.read(secureStorageProvider),
      ),
    );

    return _ApiClient(dio);

}

// Auth endpoints
@POST('/auth/login')
Future<LoginResponse> login(@Body() LoginRequest request);

@POST('/auth/refresh')
Future<RefreshResponse> refreshToken(@Body() RefreshRequest request);

// Sync endpoints
@POST('/sync/upload')
Future<SyncResponse> uploadSyncData(@Body() Map<String, dynamic> data);

@POST('/sync/download')
Future<SyncResponse> downloadUpdates(@Body() DownloadRequest request);

// Payment endpoints
@POST('/payments/initiate')
Future<PaymentInitiationResponse> initiatePayment(
@Body() PaymentRequest request);

@GET('/payments/{paymentId}/status')
Future<PaymentStatusResponse> getPaymentStatus(
@Path('paymentId') String paymentId);
}

class ApiInterceptors extends Interceptor {
final FlutterSecureStorage secureStorage;

ApiInterceptors({required this.secureStorage});

@override
Future<void> onRequest(
RequestOptions options,
RequestInterceptorHandler handler,
) async {
// Add auth token to headers
final token = await secureStorage.read(key: 'access_token');
if (token != null) {
options.headers['Authorization'] = 'Bearer $token';
}

    options.headers['Content-Type'] = 'application/json';
    options.headers['Accept'] = 'application/json';

    handler.next(options);

}

@override
Future<void> onError(
DioException err,
ErrorInterceptorHandler handler,
) async {
// Handle token refresh on 401 errors
if (err.response?.statusCode == 401) {
// TODO: Implement token refresh logic
}

    handler.next(err);

}
}

// Request/Response DTOs
class LoginRequest {
final String email;
final String password;
final String? deviceId;

LoginRequest({
required this.email,
required this.password,
this.deviceId,
});

Map<String, dynamic> toJson() => {
'email': email,
'password': password,
'device_id': deviceId,
};
}

class LoginResponse {
final String accessToken;
final String refreshToken;
final User user;

LoginResponse({
required this.accessToken,
required this.refreshToken,
required this.user,
});

factory LoginResponse.fromJson(Map<String, dynamic> json) => LoginResponse(
accessToken: json['access_token'],
refreshToken: json['refresh_token'],
user: User.fromJson(json['user']),
);
}

class RefreshRequest {
final String refreshToken;

RefreshRequest({required this.refreshToken});

Map<String, dynamic> toJson() => {
'refresh_token': refreshToken,
};
}

class RefreshResponse {
final String accessToken;

RefreshResponse({required this.accessToken});

factory RefreshResponse.fromJson(Map<String, dynamic> json) =>
RefreshResponse(
accessToken: json['access_token'],
);
}

class DownloadRequest {
final int shopId;
final int since;

DownloadRequest({required this.shopId, required this.since});

Map<String, dynamic> toJson() => {
'shop_id': shopId,
'since': since,
};
}

class SyncResponse {
final bool success;
final String message;
final Map<String, dynamic>? data;

SyncResponse({
required this.success,
required this.message,
this.data,
});

factory SyncResponse.fromJson(Map<String, dynamic> json) => SyncResponse(
success: json['success'],
message: json['message'],
data: json['data'],
);
}

class PaymentRequest {
final String saleId;
final double amount;
final String currency;

PaymentRequest({
required this.saleId,
required this.amount,
this.currency = 'ETB',
});

Map<String, dynamic> toJson() => {
'sale_id': saleId,
'amount': amount,
'currency': currency,
};
}

class PaymentInitiationResponse {
final String paymentId;
final String? telebirrQr;
final String? deepLink;
final String status;

PaymentInitiationResponse({
required this.paymentId,
this.telebirrQr,
this.deepLink,
required this.status,
});

factory PaymentInitiationResponse.fromJson(Map<String, dynamic> json) =>
PaymentInitiationResponse(
paymentId: json['payment_id'],
telebirrQr: json['telebirr_qr'],
deepLink: json['deep_link'],
status: json['status'],
);
}

class PaymentStatusResponse {
final String paymentId;
final String status;
final String? providerReference;

PaymentStatusResponse({
required this.paymentId,
required this.status,
this.providerReference,
});

factory PaymentStatusResponse.fromJson(Map<String, dynamic> json) =>
PaymentStatusResponse(
paymentId: json['payment_id'],
status: json['status'],
providerReference: json['provider_reference'],
);
}

// User model for auth
class User {
final int id;
final String name;
final String email;
final String role;
final int shopId;

User({
required this.id,
required this.name,
required this.email,
required this.role,
required this.shopId,
});

factory User.fromJson(Map<String, dynamic> json) => User(
id: json['id'],
name: json['name'],
email: json['email'],
role: json['role'],
shopId: json['shop_id'],
);
}

// Secure Storage Provider
final secureStorageProvider = Provider<FlutterSecureStorage>((ref) {
return const FlutterSecureStorage();
});

##

// mobile/lib/src/data/repositories/auth_repository.dart
// Repository for handling authentication-related operations.
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../models/user.dart';

final authRepositoryProvider = Provider<AuthRepository>((ref) {
return AuthRepository();
});

class AuthRepository {
static const String \_userKey = 'current_user';
static const String \_tokenKey = 'auth_token';

Future<User?> getCurrentUser() async {
final prefs = await SharedPreferences.getInstance();
final userJson = prefs.getString(\_userKey);

    if (userJson != null) {
      // Parse user from JSON (simplified)
      try {
        // In real app, you'd parse proper JSON
        return User(
          id: '1',
          email: 'demo@andalus.com',
          name: 'Demo User',
          role: UserRole.owner,
          createdAt: DateTime.now(),
          isActive: true,
          businessId: 'business_1',
          phone: '',
        );
      } catch (e) {
        return null;
      }
    }
    return null;

}

Future<String?> getAuthToken() async {
final prefs = await SharedPreferences.getInstance();
return prefs.getString(\_tokenKey);
}

Future<User> login(String email, String password) async {
// Simulate API call
await Future.delayed(const Duration(seconds: 2));

    if (email == 'demo@andalus.com' && password == 'password') {
      final user = User(
        id: '1',
        email: email,
        name: 'Demo User',
        role: UserRole.owner,
        createdAt: DateTime.now(),
        lastLogin: DateTime.now(),
        isActive: true,
        businessId: 'business_1',
        phone: '',
      );

      await _saveUser(user);
      return user;
    } else {
      throw Exception('Invalid credentials');
    }

}

Future<User> register(
String email, String password, String name, String businessName) async {
// Simulate API call
await Future.delayed(const Duration(seconds: 2));

    final user = User(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      email: email,
      name: name,
      role: UserRole.owner,
      createdAt: DateTime.now(),
      isActive: true,
      businessId: 'business_${DateTime.now().millisecondsSinceEpoch}',
      phone: '',
    );

    await _saveUser(user);
    return user;

}

Future<void> logout() async {
final prefs = await SharedPreferences.getInstance();
await prefs.remove(\_userKey);
await prefs.remove(\_tokenKey);
}

Future<User> updateProfile(User user) async {
await \_saveUser(user);
return user;
}

Future<void> _saveUser(User user) async {
final prefs = await SharedPreferences.getInstance();
// In real app, you'd serialize to JSON
await prefs.setString(\_userKey, 'user_data');
await prefs.setString(\_tokenKey, 'demo_token_${user.id}');
}
}

##

//mobile/lib/src/data/repositories/business_repository.dart
// Repository for managing business profile data in the local database. we aill make it managable business information like shop name address contact details logo etc. in the laravel backend.
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:sqflite/sqflite.dart';
import '../local/database.dart';
import '../models/business.dart';

final businessRepositoryProvider = Provider<BusinessRepository>((ref) {
return BusinessRepository();
});

class BusinessRepository {
static const String businessTable = 'business_profile';

Future<Database> get \_db async => await AppDatabase.database;

Future<void> saveBusinessProfile(BusinessProfile business) async {
final db = await \_db;
await db.insert(
businessTable,
business.toMap(),
conflictAlgorithm: ConflictAlgorithm.replace,
);
}

Future<BusinessProfile?> getBusinessProfile() async {
final db = await \_db;
final maps = await db.query(businessTable, limit: 1);
if (maps.isNotEmpty) {
return BusinessProfile.fromMap(maps.first);
}
return null;
}

Future<void> updateBusinessProfile(BusinessProfile business) async {
final db = await \_db;
await db.update(
businessTable,
business.toMap(),
where: 'id = ?',
whereArgs: [business.id],
);
}

Future<bool> hasBusinessProfile() async {
final db = await \_db;
final count = Sqflite.firstIntValue(
await db.rawQuery('SELECT COUNT(\*) FROM $businessTable'));
return count != null && count > 0;
}
}

##

// mobile/lib/src/data/repositories/category_repository.dart
// Repository for managing product categories in the local database.
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:sqflite/sqflite.dart';
import '../local/database.dart';
import '../models/category.dart';

final categoryRepositoryProvider = Provider<CategoryRepository>((ref) {
return CategoryRepository();
});

class CategoryRepository {
static const String categoryTable = 'product_categories';

Future<Database> get \_db async => await AppDatabase.database;

Future<int> createCategory(ProductCategory category) async {
final db = await \_db;
return await db.insert(
categoryTable,
category.toMap(),
conflictAlgorithm: ConflictAlgorithm.replace,
);
}

Future<void> updateCategory(ProductCategory category) async {
final db = await \_db;
await db.update(
categoryTable,
category.toMap(),
where: 'id = ?',
whereArgs: [category.id],
);
}

Future<List<ProductCategory>> getAllCategories(
{bool activeOnly = true}) async {
final db = await \_db;
final where = activeOnly ? 'WHERE is_active = 1' : '';
final maps = await db.rawQuery('''
SELECT \* FROM $categoryTable $where ORDER BY sort_order, name
''');
return maps.map((map) => ProductCategory.fromMap(map)).toList();
}

Future<ProductCategory?> getCategoryById(int id) async {
final db = await \_db;
final maps = await db.query(
categoryTable,
where: 'id = ?',
whereArgs: [id],
);
if (maps.isNotEmpty) {
return ProductCategory.fromMap(maps.first);
}
return null;
}

Future<void> deleteCategory(int id) async {
final db = await \_db;
await db.delete(
categoryTable,
where: 'id = ?',
whereArgs: [id],
);
}
}

##

// mobile/lib/src/data/repositories/customer_repository.dart
// Repository for managing customer data and credit operations in the local database.
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:sqflite/sqflite.dart';
import '../local/database.dart';
import '../models/customer.dart';
import '../models/credit_transaction.dart';

final customerRepositoryProvider = Provider<CustomerRepository>((ref) {
return CustomerRepository();
});

class CustomerRepository {
static const String customerTable = 'customers';
static const String creditTransactionTable = 'credit_transactions';

Future<Database> get \_db async => await AppDatabase.database;

// Credit Control Methods

Future<CreditSaleResult> createCreditSale({
required int customerId,
required double amount,
required String saleReference,
int dueDays = 30,
String? notes,
}) async {
final db = await \_db;

    return await db.transaction((txn) async {
      // Get customer with lock to prevent race conditions
      final customerMaps = await txn.query(
        customerTable,
        where: 'id = ?',
        whereArgs: [customerId],
      );

      if (customerMaps.isEmpty) {
        return CreditSaleResult(
          success: false,
          error: 'Customer not found',
        );
      }

      final customer = Customer.fromMap(customerMaps.first);

      // Check if customer allows credit
      if (!customer.allowCredit) {
        return CreditSaleResult(
          success: false,
          error: 'Customer does not allow credit purchases',
        );
      }

      // Check credit limit
      if (customer.currentBalance + amount > customer.creditLimit) {
        return CreditSaleResult(
          success: false,
          error:
              'Credit limit exceeded. Available: ETB ${customer.availableCredit.toStringAsFixed(2)}',
        );
      }

      // Calculate due date based on customer's payment terms or default
      final dueDate = _calculateDueDate(customer, dueDays);

      // Update customer balance and due date
      final newBalance = customer.currentBalance + amount;
      await txn.update(
        customerTable,
        {
          'current_balance': newBalance,
          'due_date': dueDate?.millisecondsSinceEpoch,
          'last_transaction_date': DateTime.now().millisecondsSinceEpoch,
          'updated_at': DateTime.now().millisecondsSinceEpoch,
        },
        where: 'id = ?',
        whereArgs: [customerId],
      );

      // Create credit transaction
      final transaction = CreditTransaction(
        localId: 'sale_${DateTime.now().millisecondsSinceEpoch}',
        customerId: customerId,
        customerName: customer.name,
        type: 'sale',
        amount: amount,
        balanceBefore: customer.currentBalance,
        balanceAfter: newBalance,
        reference: saleReference,
        notes: notes,
        createdAt: DateTime.now(),
      );

      await txn.insert(
        creditTransactionTable,
        transaction.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );

      return CreditSaleResult(
        success: true,
        newBalance: newBalance,
        availableCredit: customer.creditLimit - newBalance,
      );
    });

}

// Helper method to calculate due date based on payment terms
DateTime? \_calculateDueDate(Customer customer, int defaultDueDays) {
if (customer.paymentTerms == 'none' || !customer.allowCredit) {
return null;
}

    int dueDays = defaultDueDays;

    if (customer.paymentTerms != null && customer.paymentTerms != 'custom') {
      dueDays = int.tryParse(customer.paymentTerms!) ?? defaultDueDays;
    }

    return DateTime.now().add(Duration(days: dueDays));

}

// Add method to get customers with enhanced search
Future<List<Customer>> searchCustomers(String query) async {
final db = await \_db;
final maps = await db.query(
customerTable,
where: '''
(name LIKE ? OR
business_name LIKE ? OR
phone LIKE ? OR
whatsapp_number LIKE ? OR
email LIKE ? OR
tin_number LIKE ?)
AND is_active = 1
''',
whereArgs: [
'%$query%',
'%$query%',
'%$query%',
'%$query%',
'%$query%',
'%$query%'
],
orderBy: 'name',
);
return maps.map((map) => Customer.fromMap(map)).toList();
}

/// Records a payment against customer's balance
Future<PaymentResult> recordPayment({
required int customerId,
required double amount,
required String paymentReference,
String? notes,
}) async {
final db = await \_db;

    return await db.transaction((txn) async {
      // Get customer
      final customerMaps = await txn.query(
        customerTable,
        where: 'id = ?',
        whereArgs: [customerId],
      );

      if (customerMaps.isEmpty) {
        return PaymentResult(
          success: false,
          error: 'Customer not found',
        );
      }

      final customer = Customer.fromMap(customerMaps.first);

      if (amount <= 0) {
        return PaymentResult(
          success: false,
          error: 'Payment amount must be greater than zero',
        );
      }

      if (amount > customer.currentBalance) {
        return PaymentResult(
          success: false,
          error: 'Payment amount cannot exceed current balance',
        );
      }

      // Update customer balance
      final newBalance = customer.currentBalance - amount;
      await txn.update(
        customerTable,
        {
          'current_balance': newBalance,
          'last_transaction_date': DateTime.now().millisecondsSinceEpoch,
          'updated_at': DateTime.now().millisecondsSinceEpoch,
        },
        where: 'id = ?',
        whereArgs: [customerId],
      );

      // Create payment transaction
      final transaction = CreditTransaction(
        localId: 'payment_${DateTime.now().millisecondsSinceEpoch}',
        customerId: customerId,
        customerName: customer.name,
        type: 'payment',
        amount: amount,
        balanceBefore: customer.currentBalance,
        balanceAfter: newBalance,
        reference: paymentReference,
        notes: notes,
        createdAt: DateTime.now(),
      );

      await txn.insert(
        creditTransactionTable,
        transaction.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );

      return PaymentResult(
        success: true,
        newBalance: newBalance,
        amountPaid: amount,
      );
    });

}

/// Updates customer's credit limit
Future<CreditLimitResult> updateCreditLimit({
required int customerId,
required double newCreditLimit,
}) async {
final db = await \_db;

    return await db.transaction((txn) async {
      // Get customer
      final customerMaps = await txn.query(
        customerTable,
        where: 'id = ?',
        whereArgs: [customerId],
      );

      if (customerMaps.isEmpty) {
        return CreditLimitResult(
          success: false,
          error: 'Customer not found',
        );
      }

      final customer = Customer.fromMap(customerMaps.first);

      // Validate new credit limit
      if (newCreditLimit < customer.currentBalance) {
        return CreditLimitResult(
          success: false,
          error:
              'New credit limit cannot be less than current balance (ETB ${customer.currentBalance.toStringAsFixed(2)})',
        );
      }

      // Update credit limit
      await txn.update(
        customerTable,
        {
          'credit_limit': newCreditLimit,
          'updated_at': DateTime.now().millisecondsSinceEpoch,
        },
        where: 'id = ?',
        whereArgs: [customerId],
      );

      // Create adjustment transaction
      final transaction = CreditTransaction(
        localId: 'adjustment_${DateTime.now().millisecondsSinceEpoch}',
        customerId: customerId,
        customerName: customer.name,
        type: 'adjustment',
        amount: newCreditLimit - customer.creditLimit,
        balanceBefore: customer.currentBalance,
        balanceAfter: customer.currentBalance,
        reference: 'Credit Limit Adjustment',
        notes:
            'Credit limit changed from ETB ${customer.creditLimit.toStringAsFixed(2)} to ETB ${newCreditLimit.toStringAsFixed(2)}',
        createdAt: DateTime.now(),
      );

      await txn.insert(
        creditTransactionTable,
        transaction.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );

      return CreditLimitResult(
        success: true,
        oldCreditLimit: customer.creditLimit,
        newCreditLimit: newCreditLimit,
      );
    });

}

// Existing methods with enhancements
Future<int> createCustomer(Customer customer) async {
final db = await \_db;
return await db.insert(
customerTable,
customer.toMap(),
conflictAlgorithm: ConflictAlgorithm.replace,
);
}

Future<void> updateCustomer(Customer customer) async {
final db = await \_db;
await db.update(
customerTable,
customer.toMap(),
where: 'id = ?',
whereArgs: [customer.id],
);
}

Future<void> createSampleCustomers() async {
final db = await \_db;

    // Clear existing sample customers
    await db.delete('customers',
        where: 'local_id LIKE ?', whereArgs: ['cust_sample_%']);

    final sampleCustomers = [
      {
        'local_id': 'cust_sample_1',
        'name': 'Abebe Kebede',
        'phone': '+251911001100',
        'current_balance': 0.0,
        'credit_limit': 1000.0,
        'is_active': 1,
        'created_at': DateTime.now().millisecondsSinceEpoch,
        'updated_at': DateTime.now().millisecondsSinceEpoch,
      },
      {
        'local_id': 'cust_sample_2',
        'name': 'Marta Solomon',
        'phone': '+251922002200',
        'current_balance': 500.0,
        'credit_limit': 2000.0,
        'is_active': 1,
        'created_at': DateTime.now().millisecondsSinceEpoch,
        'updated_at': DateTime.now().millisecondsSinceEpoch,
      },
      // Add more sample customers...
    ];

    final batch = db.batch();
    for (final customer in sampleCustomers) {
      batch.insert('customers', customer);
    }
    await batch.commit();

}

Future<List<Customer>> getAllCustomers({bool activeOnly = true}) async {
final db = await \_db;
try {
final where = activeOnly ? 'WHERE is_active = 1' : '';
final maps = await db.rawQuery('''
SELECT \* FROM $customerTable
$where
ORDER BY name
''');
return maps.map((map) => Customer.fromMap(map)).toList();
} catch (e) {
print('Error in getAllCustomers: $e');
rethrow;
}
}

Future<void> updateCustomerBalance({
required int customerId,
required double amount,
required String transactionType,
required String reference,
}) async {
final db = await \_db;
try {
await db.transaction((txn) async {
// Update customer balance
await txn.rawUpdate('''
UPDATE $customerTable
SET current_balance = current_balance + ?,
updated_at = ?
WHERE id = ?
''', [amount, DateTime.now().millisecondsSinceEpoch, customerId]);

        // Record transaction
        await txn.insert(creditTransactionTable, {
          'local_id': 'CREDIT_${DateTime.now().millisecondsSinceEpoch}',
          'customer_id': customerId,
          'customer_name': 'Customer $customerId', // Should fetch actual name
          'type': transactionType,
          'amount': amount,
          'balance_before': 0, // Should fetch actual balance
          'balance_after': amount,
          'reference': reference,
          'created_at': DateTime.now().millisecondsSinceEpoch,
        });
      });
    } catch (e) {
      print('Error in updateCustomerBalance: $e');
      rethrow;
    }

}

Future<Customer?> getCustomerById(int id) async {
final db = await \_db;
try {
final maps = await db.query(
customerTable,
where: 'id = ?',
whereArgs: [id],
);
if (maps.isNotEmpty) {
return Customer.fromMap(maps.first);
}
return null;
} catch (e) {
print('Error in getCustomerById: $e');
rethrow;
}
}

Future<List<Customer>> getCustomersWithBalance() async {
final db = await \_db;
final maps = await db.query(
customerTable,
where: 'current_balance != 0 AND is_active = 1',
orderBy: 'current_balance DESC',
);
return maps.map((map) => Customer.fromMap(map)).toList();
}

Future<List<Customer>> getOverdueCustomers() async {
final db = await \_db;
final now = DateTime.now().millisecondsSinceEpoch;

    try {
      // First check if due_date column exists
      final tableInfo = await db.rawQuery("PRAGMA table_info(customers)");
      final hasDueDate = tableInfo.any((col) => col['name'] == 'due_date');

      if (!hasDueDate) {
        print('due_date column does not exist, returning empty list');
        return [];
      }

      final maps = await db.rawQuery('''
      SELECT * FROM customers
      WHERE current_balance > 0
        AND due_date IS NOT NULL
        AND due_date < ?
        AND is_active = 1
      ORDER BY current_balance DESC
    ''', [now]);

      return maps.map((map) => Customer.fromMap(map)).toList();
    } catch (e) {
      print('Error in getOverdueCustomers: $e');
      // If there's an error (like missing column), return empty list
      return [];
    }

}

Future<List<CreditTransaction>> getCustomerTransactions(int customerId,
{int limit = 50}) async {
final db = await \_db;
final maps = await db.query(
creditTransactionTable,
where: 'customer_id = ?',
whereArgs: [customerId],
orderBy: 'created_at DESC',
limit: limit,
);
return maps.map((map) => CreditTransaction.fromMap(map)).toList();
}

// Add this method to your CustomerRepository class
Future<void> addCreditTransaction(CreditTransaction transaction) async {
final db = await \_db;

    await db.transaction((txn) async {
      // Insert transaction
      await txn.insert(
        creditTransactionTable,
        transaction.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );

      // Update customer balance
      await txn.update(
        customerTable,
        {
          'current_balance': transaction.balanceAfter,
          'last_transaction_date': transaction.createdAt.millisecondsSinceEpoch,
          'updated_at': DateTime.now().millisecondsSinceEpoch,
        },
        where: 'id = ?',
        whereArgs: [transaction.customerId],
      );
    });

}

// Statistics
Future<Map<String, dynamic>> getCreditSummary() async {
final db = await \_db;
final now = DateTime.now().millisecondsSinceEpoch;

    final totalResult = await db.rawQuery('''
      SELECT COUNT(*) as count, COALESCE(SUM(current_balance), 0) as total
      FROM $customerTable WHERE is_active = 1
    ''');

    final overdueResult = await db.rawQuery('''
      SELECT COUNT(*) as count, COALESCE(SUM(current_balance), 0) as total
      FROM $customerTable
      WHERE current_balance > 0
        AND due_date IS NOT NULL
        AND due_date < ?
        AND is_active = 1
    ''', [now]);

    final customersWithBalance = await db.rawQuery('''
      SELECT COUNT(*) as count FROM $customerTable
      WHERE current_balance != 0 AND is_active = 1
    ''');

    return {
      'totalCustomers': (totalResult.first['count'] as num?)?.toInt() ?? 0,
      'totalOutstanding': (totalResult.first['total'] as num?)?.toDouble() ?? 0,
      'overdueCustomers': (overdueResult.first['count'] as num?)?.toInt() ?? 0,
      'overdueAmount': (overdueResult.first['total'] as num?)?.toDouble() ?? 0,
      'customersWithBalance':
          (customersWithBalance.first['count'] as num?)?.toInt() ?? 0,
    };

}
}

// Result classes for credit operations
class CreditSaleResult {
final bool success;
final String? error;
final double? newBalance;
final double? availableCredit;

CreditSaleResult({
required this.success,
this.error,
this.newBalance,
this.availableCredit,
});
}

class PaymentResult {
final bool success;
final String? error;
final double? newBalance;
final double? amountPaid;

PaymentResult({
required this.success,
this.error,
this.newBalance,
this.amountPaid,
});
}

class CreditLimitResult {
final bool success;
final String? error;
final double? oldCreditLimit;
final double? newCreditLimit;

CreditLimitResult({
required this.success,
this.error,
this.oldCreditLimit,
this.newCreditLimit,
});
}

##

// mobile/lib/src/data/repositories/otp_repository.dart
// Repository for managing OTPs in the local database.

import 'package:andalus_smart_pos/src/data/local/database.dart';
import 'package:andalus_smart_pos/src/data/models/otp.dart';

class OTPRepository {
OTPRepository();

Future<void> createOTP(OTP otp) async {
final db = await AppDatabase.database;

    try {
      // Clean expired OTPs for this phone
      await db.delete(
        'otps',
        where: 'phone = ? AND expires_at < ?',
        whereArgs: [otp.phone, DateTime.now().millisecondsSinceEpoch],
      );

      final result = await db.insert('otps', otp.toMap());
      print('‚úÖ OTP inserted successfully. Row ID: $result');
      print(
          'üìù OTP Details - Phone: ${otp.phone}, Code: ${otp.code}, Expires: ${otp.expiresAt}');
    } catch (e) {
      print('‚ùå Error creating OTP: $e');
      rethrow;
    }

}

Future<OTP?> getValidOTP(String phone, String code, String type) async {
final db = await AppDatabase.database;

    try {
      print('üîç Searching for OTP - Phone: $phone, Code: $code, Type: $type');

      final result = await db.query(
        'otps',
        where:
            'phone = ? AND code = ? AND type = ? AND is_used = 0 AND expires_at > ?',
        whereArgs: [phone, code, type, DateTime.now().millisecondsSinceEpoch],
      );

      print('üìä OTP query found ${result.length} records');

      if (result.isNotEmpty) {
        for (var row in result) {
          print('üìÑ OTP Record: ${row.toString()}');
        }

        final otp = OTP.fromMap(result.first);
        print('‚úÖ Valid OTP found: ${otp.code} for ${otp.phone}');
        print(
            '‚è∞ OTP expires at: ${otp.expiresAt}, Current time: ${DateTime.now()}');
        print('üîë OTP is used: ${otp.isUsed}, Is valid: ${otp.isValid}');

        return otp;
      } else {
        print('‚ùå No valid OTP found');

        // Let's check what's actually in the database
        final allOtps = await db.query(
          'otps',
          where: 'phone = ?',
          whereArgs: [phone],
        );

        print('üìã All OTPs for $phone: ${allOtps.length} records');
        for (var otp in allOtps) {
          print(
              'üìÑ OTP: ${otp['code']}, Used: ${otp['is_used']}, Expires: ${DateTime.fromMillisecondsSinceEpoch(otp['expires_at'] as int)}');
        }

        return null;
      }
    } catch (e) {
      print('‚ùå Error getting OTP: $e');
      return null;
    }

}

Future<List<OTP>> getAllOTPsForPhone(String phone) async {
final db = await AppDatabase.database;
try {
final result = await db.query(
'otps',
where: 'phone = ?',
whereArgs: [phone],
orderBy: 'created_at DESC',
);

      // Convert Map to OTP objects
      return result.map((map) => OTP.fromMap(map)).toList();
    } catch (e) {
      print('‚ùå Error getting OTPs for phone: $e');
      return [];
    }

}

Future<void> markOTPAsUsed(String otpId) async {
final db = await AppDatabase.database;

    try {
      final result = await db.update(
        'otps',
        {'is_used': 1},
        where: 'otp_id = ?',
        whereArgs: [otpId],
      );

      print('‚úÖ OTP marked as used: $otpId, rows affected: $result');
    } catch (e) {
      print('‚ùå Error marking OTP as used: $e');
      rethrow;
    }

}

Future<void> cleanExpiredOTPs() async {
final db = await AppDatabase.database;
final deleted = await db.delete(
'otps',
where: 'expires_at < ?',
whereArgs: [DateTime.now().millisecondsSinceEpoch],
);
print('üßπ Cleaned $deleted expired OTPs');
}
}

##

// lib/src/data/repositories/product_repository.dart
// Repository for managing product data in the local database.
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:sqflite/sqflite.dart';
import '../local/database.dart';
import '../models/product.dart';

final productRepositoryProvider = Provider<ProductRepository>((ref) {
return ProductRepository();
});

class ProductRepository {
static const String productTable = 'products';

Future<Database> get \_db async => await AppDatabase.database;

Future<int> createProduct(Product product) async {
final db = await \_db;
return await db.insert(
productTable,
product.toMap(),
conflictAlgorithm: ConflictAlgorithm.replace,
);
}

Future<void> updateProduct(Product product) async {
final db = await \_db;
await db.update(
productTable,
product.toMap(),
where: 'id = ?',
whereArgs: [product.id],
);
}

Future<List<Product>> getAllProducts({bool activeOnly = true}) async {
final db = await \_db;
try {
final where = activeOnly ? 'WHERE p.is_active = 1' : '';
final maps = await db.rawQuery('''
SELECT p.\*, c.name as category_name
FROM $productTable p
LEFT JOIN product_categories c ON p.category_id = c.category_id
$where
ORDER BY p.name
''');
return maps.map((map) => Product.fromMap(map)).toList();
} catch (e) {
print('Error in getAllProducts: $e');
rethrow;
}
}

Future<Product?> getProductById(String productId) async {
final db = await \_db;
try {
final maps = await db.rawQuery('''
SELECT p.\*, c.name as category_name
FROM $productTable p
LEFT JOIN product_categories c ON p.category_id = c.category_id
WHERE p.product_id = ?
''', [productId]);

      if (maps.isNotEmpty) {
        return Product.fromMap(maps.first);
      }
      return null;
    } catch (e) {
      print('Error in getProductById: $e');
      rethrow;
    }

}

Future<void> updateStockAfterSale({
required String productId,
required int quantitySold,
}) async {
final db = await \_db;
try {
// Get current product
final product = await getProductById(productId);
if (product != null && product.trackInventory) {
final newStock = product.stockQuantity - quantitySold;
if (newStock >= 0) {
await db.update(
productTable,
{
'stock_quantity': newStock,
'updated_at': DateTime.now().millisecondsSinceEpoch,
},
where: 'product_id = ?',
whereArgs: [productId],
);
} else {
throw Exception('Insufficient stock for product $productId');
}
}
} catch (e) {
print('Error in updateStockAfterSale: $e');
rethrow;
}
}

Future<List<Product>> getProductsByCategory(String categoryId) async {
final db = await \_db;
try {
final maps = await db.rawQuery('''
SELECT p.\*, c.name as category_name
FROM $productTable p
LEFT JOIN product_categories c ON p.category_id = c.category_id
WHERE p.category_id = ? AND p.is_active = 1
ORDER BY p.name
''', [categoryId]);
return maps.map((map) => Product.fromMap(map)).toList();
} catch (e) {
print('Error in getProductsByCategory: $e');
rethrow;
}
}

Future<void> updateStockAfterRefund({
required String productId,
required int quantityRefunded,
}) async {
final db = await \_db;
try {
// Get current product
final product = await getProductById(productId);
if (product != null && product.trackInventory) {
final newStock = product.stockQuantity + quantityRefunded;
await db.update(
productTable,
{
'stock_quantity': newStock,
'updated_at': DateTime.now().millisecondsSinceEpoch,
},
where: 'product_id = ?',
whereArgs: [productId],
);
}
} catch (e) {
print('Error in updateStockAfterRefund: $e');
rethrow;
}
}

Future<Product?> getProductByIntId(int id) async {
final db = await \_db;
try {
final maps = await db.rawQuery('''
SELECT p.\*, c.name as category_name
FROM $productTable p
LEFT JOIN product_categories c ON p.category_id = c.category_id
WHERE p.id = ?
''', [id]);

      if (maps.isNotEmpty) {
        return Product.fromMap(maps.first);
      }
      return null;
    } catch (e) {
      print('Error in getProductByIntId: $e');
      rethrow;
    }

}

Future<List<Product>> searchProducts(String query) async {
final db = await \_db;
try {
final maps = await db.rawQuery('''
SELECT p.\*, c.name as category_name
FROM $productTable p 
        LEFT JOIN product_categories c ON p.category_id = c.category_id 
        WHERE (p.name LIKE ? OR p.name_am LIKE ? OR p.barcode LIKE ? OR p.sku LIKE ?) 
        AND p.is_active = 1 
        ORDER BY p.name
      ''', ['%$query%', '%$query%', '%$query%', '%$query%']);
return maps.map((map) => Product.fromMap(map)).toList();
} catch (e) {
print('Error in searchProducts: $e');
rethrow;
}
}

Future<void> updateStockQuantity(int productId, int newQuantity) async {
final db = await \_db;
try {
await db.update(
productTable,
{
'stock_quantity': newQuantity,
'updated_at': DateTime.now().millisecondsSinceEpoch,
},
where: 'id = ?',
whereArgs: [productId],
);
} catch (e) {
print('Error in updateStockQuantity: $e');
rethrow;
}
}

Future<List<Product>> getLowStockProducts() async {
final db = await \_db;
try {
final maps = await db.rawQuery('''
SELECT p.\*, c.name as category_name
FROM $productTable p
LEFT JOIN product_categories c ON p.category_id = c.category_id
WHERE p.track_inventory = 1
AND p.min_stock_level IS NOT NULL
AND p.stock_quantity <= p.min_stock_level
AND p.is_active = 1
ORDER BY p.stock_quantity ASC
''');
return maps.map((map) => Product.fromMap(map)).toList();
} catch (e) {
print('Error in getLowStockProducts: $e');
rethrow;
}
}

Future<List<Product>> getActiveProducts() async {
final db = await \_db;
try {
final maps = await db.rawQuery('''
SELECT p.\*, c.name as category_name
FROM $productTable p
LEFT JOIN product_categories c ON p.category_id = c.category_id
WHERE p.is_active = 1
ORDER BY p.name
''');
return maps.map((map) => Product.fromMap(map)).toList();
} catch (e) {
print('Error in getActiveProducts: $e');
rethrow;
}
}

Future<void> deactivateProduct(int productId) async {
final db = await \_db;
try {
await db.update(
productTable,
{
'is_active': 0,
'updated_at': DateTime.now().millisecondsSinceEpoch,
},
where: 'id = ?',
whereArgs: [productId],
);
} catch (e) {
print('Error in deactivateProduct: $e');
rethrow;
}
}

Future<void> activateProduct(int productId) async {
final db = await \_db;
try {
await db.update(
productTable,
{
'is_active': 1,
'updated_at': DateTime.now().millisecondsSinceEpoch,
},
where: 'id = ?',
whereArgs: [productId],
);
} catch (e) {
print('Error in activateProduct: $e');
rethrow;
}
}

Future<void> createSampleProducts(ProductRepository productRepo) async {
final sampleProducts = [
Product(
id: 1,
name: 'Sample Product 1',
sku: 'SP001',
barcode: '1234567890123',
categoryId: 'cat1',
price: 9.99,
stockQuantity: 100,
isActive: true,
trackInventory: true,
productId: '',
nameAm: '',
createdAt: DateTime.now(),
updatedAt: DateTime.now(),
),
Product(
id: 2,
name: 'Sample Product 2',
sku: 'SP002',
barcode: '1234567890124',
categoryId: 'cat2',
price: 19.99,
stockQuantity: 50,
isActive: true,
trackInventory: true,
productId: '',
nameAm: '',
createdAt: DateTime.now(),
updatedAt: DateTime.now(),
),
];

    for (var product in sampleProducts) {
      await productRepo.createProduct(product);
    }

}
}

##

// mobile/lib/src/data/repositories/sale_item_repository.dart
// Repository for managing sale item data in the local database.
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:sqflite/sqflite.dart';
import '../local/database.dart';
import '../models/sale_item.dart';

class SaleItemRepository {
Future<Database> get \_db async => await AppDatabase.database;

Future<List<SaleItem>> getSaleItemsBySaleId(int saleId) async {
final db = await \_db;
try {
final maps = await db.query(
'sale_items',
where: 'sale_id = ?',
whereArgs: [saleId],
);
return maps.map((map) => SaleItem.fromMap(map)).toList();
} catch (e) {
print('Error fetching sale items: $e');
return [];
}
}

Future<List<SaleItem>> getSaleItemsInDateRange(
DateTime start, DateTime end) async {
final db = await \_db;
try {
final maps = await db.query(
'sale_items',
where: 'created_at BETWEEN ? AND ?',
whereArgs: [start.millisecondsSinceEpoch, end.millisecondsSinceEpoch],
);
return maps.map((map) => SaleItem.fromMap(map)).toList();
} catch (e) {
print('Error fetching sale items in date range: $e');
return [];
}
}

Future<List<SaleItem>> getAllSaleItems() async {
final db = await \_db;
try {
final maps = await db.query('sale_items');
return maps.map((map) => SaleItem.fromMap(map)).toList();
} catch (e) {
print('Error fetching all sale items: $e');
return [];
}
}
}

final saleItemRepositoryProvider = Provider<SaleItemRepository>((ref) {
return SaleItemRepository();
});

##

// mobile/lib/src/data/repositories/sale_repository.dart
// Repository for managing sale data in the local database.
import 'package:flutter/src/material/date.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:sqflite/sqflite.dart';
import '../local/database.dart'; // Import AppDatabase
import '../models/sale.dart';
import '../models/sale_item.dart';

final saleRepositoryProvider = Provider<SaleRepository>((ref) {
return SaleRepository();
});

class SaleRepository {
static const String saleTable = 'sales';
static const String saleItemTable = 'sale_items';

Future<Database> get \_db async => await AppDatabase.database;

// Add this method to your SaleRepository class
Future<void> createSampleSales() async {
final db = await \_db;

    // Clear existing sample data to avoid duplicates
    await db.delete('sales', where: 'sale_id LIKE ?', whereArgs: ['SAMPLE-%']);

    final sampleSales = [
      {
        'sale_id': 'SAMPLE-${DateTime.now().millisecondsSinceEpoch}',
        'total_amount': 250.0,
        'final_amount': 250.0,
        'payment_method': 'cash',
        'user_id': 1,
        'shop_id': 1,
        'created_at': DateTime.now()
            .subtract(const Duration(hours: 1))
            .millisecondsSinceEpoch,
        'updated_at': DateTime.now().millisecondsSinceEpoch,
      },
      {
        'sale_id': 'SAMPLE-${DateTime.now().millisecondsSinceEpoch + 1}',
        'total_amount': 150.0,
        'final_amount': 150.0,
        'payment_method': 'telebirr',
        'user_id': 1,
        'shop_id': 1,
        'created_at': DateTime.now()
            .subtract(const Duration(hours: 2))
            .millisecondsSinceEpoch,
        'updated_at': DateTime.now().millisecondsSinceEpoch,
      },
      {
        'sale_id': 'SAMPLE-${DateTime.now().millisecondsSinceEpoch + 2}',
        'total_amount': 75.0,
        'final_amount': 75.0,
        'payment_method': 'card',
        'user_id': 1,
        'shop_id': 1,
        'created_at': DateTime.now()
            .subtract(const Duration(days: 1))
            .millisecondsSinceEpoch,
        'updated_at': DateTime.now().millisecondsSinceEpoch,
      },
      {
        'sale_id': 'SAMPLE-${DateTime.now().millisecondsSinceEpoch + 3}',
        'total_amount': 320.0,
        'final_amount': 320.0,
        'payment_method': 'cash',
        'user_id': 1,
        'shop_id': 1,
        'created_at': DateTime.now()
            .subtract(const Duration(days: 2))
            .millisecondsSinceEpoch,
        'updated_at': DateTime.now().millisecondsSinceEpoch,
      },
      {
        'sale_id': 'SAMPLE-${DateTime.now().millisecondsSinceEpoch + 4}',
        'total_amount': 95.0,
        'final_amount': 95.0,
        'payment_method': 'telebirr',
        'user_id': 1,
        'shop_id': 1,
        'created_at': DateTime.now()
            .subtract(const Duration(days: 3))
            .millisecondsSinceEpoch,
        'updated_at': DateTime.now().millisecondsSinceEpoch,
      },
    ];

    final batch = db.batch();

    for (final saleData in sampleSales) {
      batch.insert('sales', saleData);
    }

    await batch.commit();
    print('Sample sales data created successfully');

}

// Create a new sale with items
Future<int> createSale(Sale sale, List<SaleItem> items) async {
final db = await \_db;

    return await db.transaction((txn) async {
      // Insert sale
      final saleId = await txn.insert(
        saleTable,
        sale.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );

      // Insert sale items
      for (final item in items) {
        await txn.insert(
          saleItemTable,
          item.copyWith(saleId: saleId as String).toMap(),
          conflictAlgorithm: ConflictAlgorithm.replace,
        );
      }

      return saleId;
    });

}

// Get all sales with pagination
Future<List<Sale>> getAllSales({
int limit = 50,
int offset = 0,
}) async {
final db = await \_db;
final maps = await db.query(
saleTable,
orderBy: 'created_at DESC',
limit: limit,
offset: offset,
);

    return maps.map((map) => Sale.fromMap(map)).toList();

}

// Get sale by ID with items
Future<SaleWithItems?> getSaleById(int id) async {
final db = await \_db;

    final saleMaps = await db.query(
      saleTable,
      where: 'id = ?',
      whereArgs: [id],
    );

    if (saleMaps.isEmpty) return null;

    final sale = Sale.fromMap(saleMaps.first);
    final itemMaps = await db.query(
      saleItemTable,
      where: 'sale_id = ?',
      whereArgs: [id],
    );

    final items = itemMaps.map((map) => SaleItem.fromMap(map)).toList();

    return SaleWithItems(sale: sale, items: items);

}

// Get today's sales
Future<List<Sale>> getTodaysSales() async {
final db = await \_db;
final now = DateTime.now();
final startOfDay = DateTime(now.year, now.month, now.day);
final endOfDay = DateTime(now.year, now.month, now.day, 23, 59, 59);

    final maps = await db.query(
      saleTable,
      where: 'created_at BETWEEN ? AND ?',
      whereArgs: [
        startOfDay.millisecondsSinceEpoch,
        endOfDay.millisecondsSinceEpoch,
      ],
      orderBy: 'created_at DESC',
    );

    return maps.map((map) => Sale.fromMap(map)).toList();

}

// Get sales summary for dashboard
Future<SalesSummary> getSalesSummary(
{DateTimeRange<DateTime>? dateRange}) async {
final db = await \_db;
final now = DateTime.now();
final startOfDay = DateTime(now.year, now.month, now.day);
final endOfDay = DateTime(now.year, now.month, now.day, 23, 59, 59);
final startOfWeek = now.subtract(Duration(days: now.weekday - 1));

    try {
      final todayResult = await db.rawQuery('''
      SELECT COUNT(*) as count, COALESCE(SUM(final_amount), 0) as total
      FROM sales WHERE created_at BETWEEN ? AND ?
    ''', [startOfDay.millisecondsSinceEpoch, endOfDay.millisecondsSinceEpoch]);

      final totalResult = await db.rawQuery('''
      SELECT COUNT(*) as count, COALESCE(SUM(final_amount), 0) as total FROM sales
    ''');

      final weekResult = await db.rawQuery('''
      SELECT COUNT(*) as count, COALESCE(SUM(final_amount), 0) as total
      FROM sales WHERE created_at >= ?
    ''', [startOfWeek.millisecondsSinceEpoch]);

      return SalesSummary.fromDatabase(
        todayResult.first,
        totalResult.first,
        weekResult.first,
      );
    } catch (e) {
      print('Error in getSalesSummary: $e');
      return SalesSummary(
        todaysSales: 0.0,
        todaysOrders: 0,
        totalSales: 0.0,
        totalOrders: 0,
        weeklySales: 0.0,
        weeklyOrders: 0,
      );
    }

}

Future<List<Sale>> searchSales({
String? query,
DateTime? startDate,
DateTime? endDate,
String? paymentMethod,
String? status,
int? customerId,
}) async {
final db = await \_db;

    List<String> whereConditions = [];
    List<Object?> whereArgs = [];

    if (query != null && query.isNotEmpty) {
      whereConditions.add('(sale_id LIKE ? OR customer_name LIKE ?)');
      whereArgs.addAll(['%$query%', '%$query%']);
    }

    if (startDate != null) {
      whereConditions.add('created_at >= ?');
      whereArgs.add(startDate.millisecondsSinceEpoch);
    }

    if (endDate != null) {
      whereConditions.add('created_at <= ?');
      whereArgs.add(endDate.millisecondsSinceEpoch);
    }

    if (paymentMethod != null) {
      whereConditions.add('payment_method = ?');
      whereArgs.add(paymentMethod);
    }

    if (status != null) {
      whereConditions.add('sale_status = ?');
      whereArgs.add(status);
    }

    if (customerId != null) {
      whereConditions.add('customer_id = ?');
      whereArgs.add(customerId);
    }

    final whereClause = whereConditions.isNotEmpty
        ? 'WHERE ${whereConditions.join(' AND ')}'
        : '';

    final maps = await db.rawQuery('''
      SELECT * FROM $saleTable
      $whereClause
      ORDER BY created_at DESC
      LIMIT 100
    ''', whereArgs);

    return maps.map((map) => Sale.fromMap(map)).toList();

}

Future<Sale> refundSale({
required int saleId,
required String reason,
bool fullRefund = true,
List<String>? itemIds,
Map<String, int>? partialQuantities,
}) async {
final db = await \_db;

    return await db.transaction((txn) async {
      // Get original sale
      final saleMaps = await txn.query(
        saleTable,
        where: 'id = ?',
        whereArgs: [saleId],
      );

      if (saleMaps.isEmpty) {
        throw Exception('Sale not found');
      }

      final originalSale = Sale.fromMap(saleMaps.first);

      // Create refund sale
      final refundSale = Sale(
        saleId: 'REFUND_${originalSale.saleId}',
        localId: 'REFUND_LOCAL_${DateTime.now().millisecondsSinceEpoch}',
        customerId: originalSale.customerId,
        customerName: originalSale.customerName,
        totalAmount: originalSale.totalAmount,
        finalAmount: -originalSale.finalAmount, // Negative amount for refund
        taxAmount: originalSale.taxAmount,
        discountAmount: originalSale.discountAmount,
        paymentMethod: 'refund',
        paymentReference: 'REFUND_${originalSale.saleId}',
        paymentStatus: 'refunded',
        saleStatus: 'refunded',
        userId: originalSale.userId,
        userName: originalSale.userName,
        shopId: originalSale.shopId,
        isSynced: false,
        syncAttempts: 0,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
        notes: 'Refund: $reason',
        isRefunded: false, // This is the refund record itself
        refundReason: reason,
        refundedAt: DateTime.now(),
      );

      // Save refund sale
      final refundSaleId = await txn.insert(
        saleTable,
        refundSale.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );

      // Update original sale status
      await txn.update(
        saleTable,
        {
          'sale_status': 'refunded',
          'payment_status': 'refunded',
          'is_refunded': 1,
          'refund_reason': reason,
          'refunded_at': DateTime.now().millisecondsSinceEpoch,
          'updated_at': DateTime.now().millisecondsSinceEpoch,
        },
        where: 'id = ?',
        whereArgs: [saleId],
      );

      return refundSale.copyWith(id: refundSaleId);
    });

}

Future<List<SaleItem>> getSaleItems(int saleId) async {
final db = await \_db;
final maps = await db.query(
saleItemTable,
where: 'sale_id = ?',
whereArgs: [saleId],
);

    return maps.map((map) => SaleItem.fromMap(map)).toList();

}

Future<Sale?> getSimpleSaleById(int id) async {
final db = await \_db;
final saleMaps = await db.query(
saleTable,
where: 'id = ?',
whereArgs: [id],
);

    if (saleMaps.isEmpty) return null;
    return Sale.fromMap(saleMaps.first);

}

// Get unsynced sales for synchronization
Future<List<Sale>> getUnsyncedSales() async {
final db = await \_db;
final maps = await db.query(
saleTable,
where: 'is_synced = 0',
orderBy: 'created_at ASC',
);

    return maps.map((map) => Sale.fromMap(map)).toList();

}

// Add this method to SaleRepository class for testing
Future<void> addSampleSales() async {
final sampleSales = [
Sale(
localId: 'sample_1',
totalAmount: 150.0,
finalAmount: 150.0,
paymentMethod: 'cash',
userId: 1,
shopId: 1,
createdAt: DateTime.now().subtract(const Duration(hours: 2)),
updatedAt: DateTime.now().subtract(const Duration(hours: 2)),
saleId: '',
),
Sale(
localId: 'sample_2',
totalAmount: 75.0,
finalAmount: 75.0,
paymentMethod: 'telebirr',
userId: 1,
shopId: 1,
createdAt: DateTime.now().subtract(const Duration(hours: 1)),
updatedAt: DateTime.now().subtract(const Duration(hours: 1)),
saleId: '',
),
];

    for (final sale in sampleSales) {
      await createSale(sale, [
        SaleItem(
          saleId: '0', // Will be replaced with actual sale ID
          productId: '1',
          productName: 'Coca Cola',
          quantity: 2,
          unitPrice: 25.0,
          totalPrice: 50.0,
          createdAt: sale.createdAt,
        ),
      ]);
    }

}

// Mark sale as synced
Future<void> markAsSynced(int saleId) async {
final db = await \_db;
await db.update(
saleTable,
{
'is_synced': 1,
'updated_at': DateTime.now().millisecondsSinceEpoch,
},
where: 'id = ?',
whereArgs: [saleId],
);
}
}

// Helper class to combine sale with its items
class SaleWithItems {
final Sale sale;
final List<SaleItem> items;

SaleWithItems({required this.sale, required this.items});

double get totalAmount => items.fold(0, (sum, item) => sum + item.totalPrice);
}

extension SaleRefundExtension on Sale {
bool get canBeRefunded {
if (isRefunded) return false;
if (saleStatus != 'completed') return false;
if (paymentStatus != 'completed') return false;

    // 30-day refund window
    final thirtyDaysAgo = DateTime.now().subtract(const Duration(days: 30));
    return createdAt.isAfter(thirtyDaysAgo);

}
}

// Add this extension to SaleWithItems class
extension SaleWithItemsRefundExtension on SaleWithItems {
bool get canBeRefunded => sale.canBeRefunded;
}

// Sales summary for dashboard
class SalesSummary {
final double todaysSales;
final int todaysOrders;
final double totalSales;
final int totalOrders;
final double weeklySales;
final int weeklyOrders;

SalesSummary({
required this.todaysSales,
required this.todaysOrders,
required this.totalSales,
required this.totalOrders,
required this.weeklySales,
required this.weeklyOrders,
});
factory SalesSummary.fromDatabase(Map<String, dynamic> todayResult,
Map<String, dynamic> totalResult, Map<String, dynamic> weekResult) {
return SalesSummary(
todaysSales: (todayResult['total'] as num?)?.toDouble() ?? 0.0,
todaysOrders: (todayResult['count'] as num?)?.toInt() ?? 0,
totalSales: (totalResult['total'] as num?)?.toDouble() ?? 0.0,
totalOrders: (totalResult['count'] as num?)?.toInt() ?? 0,
weeklySales: (weekResult['total'] as num?)?.toDouble() ?? 0.0,
weeklyOrders: (weekResult['count'] as num?)?.toInt() ?? 0,
);
}
}

// Add method to create sample sales data for testing
Future<void> createSampleSales() async {
final sampleSales = [
Sale(
saleId: 'SALE-${DateTime.now().millisecondsSinceEpoch}',
totalAmount: 250.0,
finalAmount: 250.0,
paymentMethod: 'cash',
userId: 1,
shopId: 1,
createdAt: DateTime.now().subtract(const Duration(hours: 1)),
localId: '',
),
Sale(
saleId: 'SALE-${DateTime.now().millisecondsSinceEpoch + 1}',
totalAmount: 150.0,
finalAmount: 150.0,
paymentMethod: 'telebirr',
userId: 1,
shopId: 1,
createdAt: DateTime.now().subtract(const Duration(hours: 2)),
localId: '',
),
Sale(
saleId: 'SALE-${DateTime.now().millisecondsSinceEpoch + 2}',
totalAmount: 75.0,
finalAmount: 75.0,
paymentMethod: 'card',
userId: 1,
shopId: 1,
createdAt: DateTime.now().subtract(const Duration(days: 1)),
localId: '',
),
];

for (final sale in sampleSales) {
await createSale(sale, [
SaleItem(
saleId: '0', // Will be replaced with actual sale ID
productId: '1',
productName: 'Sample Product',
quantity: 2,
unitPrice: 25.0,
totalPrice: 50.0,
createdAt: sale.createdAt,
),
]);
}
}

Future<void> createSale(Sale sale, List<SaleItem> items) async {
final repository = SaleRepository();
await repository.createSale(sale, items);
}

##

// mobile/lib/src/data/repositories/settings_repository.dart
// Repository for managing application settings using SharedPreferences.

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../models/settings.dart';

final settingsRepositoryProvider = Provider<SettingsRepository>((ref) {
return SettingsRepository();
});

class SettingsRepository {
static const String \_settingsKey =
'app_settings_v2'; // Change key to force refresh

Future<AppSettings> getSettings() async {
final prefs = await SharedPreferences.getInstance();
final settingsJson = prefs.getString(\_settingsKey);

    if (settingsJson != null) {
      try {
        // In a real app, you'd parse JSON properly
        // For now, return from map with default values for new fields
        final Map<String, dynamic> settingsMap = {
          'shopName': 'Andalus Smart POS',
          'shopNameAm': '·ä†·äï·ã≥·àâ·àµ ·àõ·à≠·â≤·äï ·çñ·àµ',
          'address': 'Addis Ababa, Ethiopia',
          'phone': '+251 911 234 567',
          'tinNumber': 'TIN-123456789',
          'currency': 'ETB',
          'enableTax': false,
          'taxRate': 0.15,
          'enableDiscounts': true,
          'autoPrintReceipts': false,
          'defaultPaymentMethod': 'cash',
          'enableSync': true,
          'syncInterval': 5,
          'enableCreditSystem': true,
          'defaultCreditLimit': 1000.0,
          'defaultPaymentTerms': '30',
          'enableCustomerSelection': true,
          'lowStockNotifications': true,
          'lowStockThreshold': 10,
        };
        return AppSettings.fromMap(settingsMap);
      } catch (e) {
        print('Error parsing settings: $e');
        return _getDefaultSettings();
      }
    }

    return _getDefaultSettings();

}

Future<void> saveSettings(AppSettings settings) async {
final prefs = await SharedPreferences.getInstance();
// In a real app, you'd convert to JSON properly
await prefs.setString(\_settingsKey, 'settings_saved_v2');
await Future.delayed(const Duration(milliseconds: 500));
}

AppSettings \_getDefaultSettings() {
return AppSettings(
shopName: 'Andalus Smart POS',
shopNameAm: '·ä†·äï·ã≥·àâ·àµ ·àõ·à≠·â≤·äï ·çñ·àµ',
address: 'Addis Ababa, Ethiopia',
phone: '+251 911 234 567',
tinNumber: 'TIN-123456789',
currency: 'ETB',
enableTax: false,
taxRate: 0.15,
enableDiscounts: true,
autoPrintReceipts: false,
defaultPaymentMethod: 'cash',
enableSync: true,
syncInterval: 5,
enableCreditSystem: true,
defaultCreditLimit: 1000.0,
defaultPaymentTerms: '30',
enableCustomerSelection: true,
lowStockNotifications: true,
lowStockThreshold: 10,
);
}

Future<Map<String, String>> getShopInfo() async {
final settings = await getSettings();
return {
'name': settings.shopName,
'nameAm': settings.shopNameAm,
'address': settings.address,
'phone': settings.phone,
'tinNumber': settings.tinNumber,
};
}
}

##

// mobile/lib/src/data/repositories/subscription_repository.dart
// Repository for managing subscription data in the local database.
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:sqflite/sqflite.dart';
import '../local/database.dart';
import '../models/subscription.dart';

class SubscriptionRepository {
Future<Database> get \_db async => await AppDatabase.database;

Future<Subscription?> getCurrentSubscription() async {
final db = await \_db;

    try {
      final maps = await db.query(
        'subscriptions',
        where: 'is_active = 1',
        orderBy: 'created_at DESC',
        limit: 1,
      );

      if (maps.isNotEmpty) {
        return Subscription.fromMap(maps.first);
      }
      return null;
    } catch (e) {
      print('Error fetching current subscription: $e');
      return null;
    }

}

Future<List<Subscription>> getSubscriptionHistory() async {
final db = await \_db;

    try {
      final maps = await db.query(
        'subscriptions',
        orderBy: 'created_at DESC',
      );

      return maps.map((map) => Subscription.fromMap(map)).toList();
    } catch (e) {
      print('Error fetching subscription history: $e');
      return [];
    }

}

Future<void> createSubscription(Subscription subscription) async {
final db = await \_db;

    try {
      await db.insert(
        'subscriptions',
        subscription.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );
    } catch (e) {
      print('Error creating subscription: $e');
      rethrow;
    }

}

Future hasValidSubscription(String s) async {
final subscription = await getCurrentSubscription();
if (subscription == null) {
return false;
}
final now = DateTime.now();
return subscription.expiryDate.isAfter(now);
}
}

final subscriptionRepositoryProvider = Provider<SubscriptionRepository>((ref) {
return SubscriptionRepository();
});

##

// mobile/lib/src/data/repositories/user_repository.dart
// Repository for managing user data in the local database.
import 'package:andalus_smart_pos/src/data/local/database.dart';
import 'package:andalus_smart_pos/src/data/models/user.dart';

class UserRepository {
UserRepository();

Future<User?> getUserByPhone(String phone) async {
final db = await AppDatabase.database;

    try {
      final result = await db.query(
        'users',
        where: 'phone = ?',
        whereArgs: [phone],
      );

      print(
          'User query result: ${result.length} users found for phone: $phone');

      if (result.isEmpty) return null;

      final user = User.fromMap(result.first);
      print('User found: ${user.name} (${user.role})');

      return user;
    } catch (e) {
      print('Error getting user by phone: $e');
      return null;
    }

}

Future<User?> getUserById(String userId) async {
final db = await AppDatabase.database;
final result = await db.query(
'users',
where: 'user_id = ?',
whereArgs: [userId],
);

    if (result.isEmpty) return null;
    return User.fromMap(result.first);

}

Future<void> createUser(User user) async {
final db = await AppDatabase.database;
await db.insert('users', user.toMap());
}

Future<void> updateUser(User user) async {
final db = await AppDatabase.database;
await db.update(
'users',
user.toMap(),
where: 'user_id = ?',
whereArgs: [user.id],
);
}

Future<void> updateLastLogin(String userId) async {
final db = await AppDatabase.database;
await db.update(
'users',
{
'last_login_at': DateTime.now().millisecondsSinceEpoch,
'updated_at': DateTime.now().millisecondsSinceEpoch,
},
where: 'user_id = ?',
whereArgs: [userId],
);

    print('Last login updated for user: $userId');

}
}

Future<void> deleteUser(String userId) async {
final db = await AppDatabase.database;
await db.delete(
'users',
where: 'user_id = ?',
whereArgs: [userId],
);
}

##

//src/localization/app_localizations.dart
// Localization class for managing localized strings in the application.
//ensure to import necessary packages and add skipped terms from other files
import 'package:flutter/material.dart';
import 'package:flutter/foundation.dart';
import 'dart:async';

class AppLocalizations {
final Locale locale;

AppLocalizations(this.locale);

static AppLocalizations of(BuildContext context) {
final AppLocalizations? localizations =
Localizations.of<AppLocalizations>(context, AppLocalizations);
if (localizations == null) {
throw FlutterError(
'AppLocalizations.of() called with a context that does not contain AppLocalizations.\n'
'No AppLocalizations ancestor could be found starting from the context that was passed to AppLocalizations.of(). '
'This usually happens when the context provided is from the same StatefulWidget as that whose build '
'function actually creates the AppLocalizations widget.\n'
'The context used was: $context');
}
return localizations;
}

static const LocalizationsDelegate<AppLocalizations> delegate =
\_AppLocalizationsDelegate();

static final Map<String, Map<String, String>> \_localizedValues = {
'en': {
'appTitle': 'Andalus Smart POS',
'dashboard': 'Dashboard',
'pointOfSale': 'Point of Sale',
'salesHistory': 'Sales History',
'customers': 'Customers',
'products': 'Products',
'categories': 'Categories',
'settings': 'Settings',
'todayRevenue': 'Today\'s Revenue',
'todayOrders': 'Today\'s Orders',
'outstandingCredit': 'Outstanding Credit',
'overdue': 'Overdue',
'totalRevenue': 'Total Revenue',
'totalOrders': 'Total Orders',
'averageOrderValue': 'Average Order Value',
'salesPerformance': 'Sales Performance',
'creditOverview': 'Credit Overview',
'recentSales': 'Recent Sales',
'searchProducts': 'Search products...',
'shoppingCart': 'Shopping Cart',
'clearAll': 'Clear All',
'totalAmount': 'Total Amount',
'completeSale': 'Complete Sale',
'selectPaymentMethod': 'Select Payment Method',
'cash': 'Cash',
'telebirr': 'Telebirr',
// 'card': 'Card',
'bankTransfer': 'Bank Transfer',
'credit': 'Credit',
'confirm': 'Confirm',
'cancel': 'Cancel',
'businessInformation': 'Business Information',
'shopNameEnglish': 'Shop Name (English)',
'shopNameAmharic': 'Shop Name (Amharic)',
'address': 'Address',
'phone': 'Phone',
'tinNumber': 'TIN Number',
'appearanceLanguage': 'Appearance & Language',
'themeMode': 'Theme Mode',
'language': 'Language',
'light': 'Light',
'dark': 'Dark',
'systemDefault': 'System Default',
'english': 'English',
'amharic': 'Amharic',
'posSettings': 'POS Settings',
'autoPrintReceipts': 'Auto Print Receipts',
'enableCustomerSelection': 'Enable Customer Selection',
'defaultPaymentMethod': 'Default Payment Method',
'creditSettings': 'Credit Settings',
'enableCreditSystem': 'Enable Credit System',
'defaultCreditLimit': 'Default Credit Limit (ETB)',
'defaultPaymentTerms': 'Default Payment Terms (Days)',
'syncSettings': 'Sync Settings',
'enableDataSync': 'Enable Data Sync',
'syncInterval': 'Sync Interval (minutes)',
'advancedSettings': 'Advanced Settings',
'enableTax': 'Enable Tax',
'taxRate': 'Tax Rate (%)',
'enableDiscounts': 'Enable Discounts',
'lowStockNotifications': 'Low Stock Notifications',
'lowStockThreshold': 'Low Stock Threshold',
'dangerZone': 'Danger Zone',
'resetToDefaults': 'Reset to Default Settings',
'noSalesToday': 'No sales today',
'noProductsFound': 'No products found',
'yourCartEmpty': 'Your cart is empty',
'addProductsGetStarted': 'Add products to get started',
'saleCompleted': 'Sale completed successfully!',
'errorLoadingData': 'Error loading data',
'settingsSaved': 'Settings saved successfully!',
'settingsReset': 'Settings reset to defaults!',
'account': 'Account',
'accountSettings': 'Account Settings',
'security': 'Security',
'changePassword': 'Change Password',
'currentPassword': 'Current Password',
'newPassword': 'New Password',
'confirmNewPassword': 'Confirm New Password',
'Are you sure you want to logout?': 'Are you sure you want to logout?',
'weeklySales': 'Weekly Sales',
'orders': 'orders',
'refresh': 'Refresh',
'performanceOverview': 'Performance Overview',
'customersWithBalance': 'Customers with Balance',
'overdueAmount': 'Overdue Amount',
'databaseNeedsUpdate':
'Database schema needs update. Please try refreshing.',
'tryAgain': 'Try Again',
'up': 'Up',
'down': 'Down',
'sale': 'Sale',
'today': 'Today',
'completeFirstSale': 'Complete your first sale to see it here!',
'stockAlert': 'Stock Alert',
'quickActions': 'Quick Actions',
'newSale': 'New Sale',
'addProduct': 'Add Product',
'addCustomer': 'Add Customer',
'reports': 'Reports',
'salesAnalytics': 'Sales Analytics',
'chartsComingSoon': 'Charts Coming Soon',
'installFlChart': 'Install fl_chart for beautiful analytics',
'allProductsWellStocked': 'All products are well stocked',
'moreProducts': '+{count} more products',
'left': 'left',
'calendarSettings': 'Calendar Settings',
'calendarType': 'Calendar Type',
'calendarDescription':
'Choose between Gregorian and Ethiopian calendar systems',
'fontSize': 'Font Size',
'small': 'Small',
'large': 'Large',
'items sold': 'items sold',
'with balance': 'with balance',
'outstanding': 'Outstanding',
'thisMonth': 'This Month', // ... existing translations
'productsReport': 'Products Report',
'customersReport': 'Customers Report',
'financialReport': 'Financial Report',
'selectDateRange': 'Select Date Range',
'basicPlanFeatures': 'Basic Plan: Basic reports available',
'professionalPlanFeatures':
'Professional Plan: Advanced analytics available',
'enterprisePlanFeatures': 'Enterprise Plan: Complete analytics available',
'plan': 'Plan',
'basicReportsDescription': 'Basic sales reports and analytics',
'professionalReportsDescription':
'Advanced product and customer analytics',
'enterpriseReportsDescription':
'Complete financial and predictive analytics',
'upgradeForAdvancedReports': 'Upgrade for advanced reports',
'upgrade': 'Upgrade',
'professionalPlanRequired': 'Professional Plan Required',
'enterprisePlanRequired': 'Enterprise Plan Required',
'productsReportAvailableInPlan':
'Products Report is available in the {plan} plan',
'customersReportAvailableInPlan':
'Customers Report is available in the {plan} plan',
'financialReportAvailableInPlan':
'Financial Report is available in the {plan} plan',
'upgradeYourPlan': 'Upgrade Your Plan',
'upgradeForAdvancedAnalytics':
'Upgrade to access advanced analytics and reporting features.',
'viewPlans': 'View Plans',
'salesByPaymentMethod': 'Sales by Payment Method',
'revenueByDay': 'Revenue by Day',
'dailySalesTrend': 'Daily Sales Trend',
'topSellingHours': 'Top Selling Hours',
'customerRetention': 'Customer Retention',
'salesVelocity': 'Sales Velocity',
'profitMarginAnalysis': 'Profit Margin Analysis',
'inventoryTurnover': 'Inventory Turnover',
'abcAnalysis': 'ABC Analysis',
'stockOptimization': 'Stock Optimization',
'productsOverview': 'Products Overview',
'totalProducts': 'Total Products',
'lowStock': 'Low Stock',
'outOfStock': 'Out of Stock',
'topSellingProducts': 'Top Selling Products',
'sold': 'sold',
'customersOverview': 'Customers Overview',
'topCustomers': 'Top Customers',
'customerAcquisition': 'Customer Acquisition',
'averageCustomerValue': 'Average Customer Value',
'customerLifetimeValue': 'Customer Lifetime Value',
'churnRiskAnalysis': 'Churn Risk Analysis',
'financialOverview': 'Financial Overview',
'revenueTrend': 'Revenue Trend',
'profitMarginTrend': 'Profit Margin Trend',
'cashFlowAnalysis': 'Cash Flow Analysis',
'financialRatios': 'Financial Ratios',
'breakEvenAnalysis': 'Break-Even Analysis',
'advancedAnalyticsFeature':
'Advanced analytics feature available in higher plans',
'yesterday': 'Yesterday',
'thisWeek': 'This Week',
'lastWeek': 'Last Week',
'lastMonth': 'Last Month',
'last3Months': 'Last 3 Months',
'last6Months': 'Last 6 Months',
'thisYear': 'This Year',
'lastYear': 'Last Year',
'subscriptionPlans': 'Subscription Plans',
'choosePerfectPlan': 'Choose the perfect plan for your business',
'startWithFreeTrial':
'Start with 14 days free trial. No credit card required.',
'monthly': 'Monthly',
'yearly': 'Yearly',
'save20Percent': 'Save 20%',
'popular': 'Popular',
'selected': 'Selected',
'selectPlan': 'Select Plan',
'paymentMethod': 'Payment Method',
'card': 'Credit/Debit Card',
'orderSummary': 'Order Summary',
'price': 'Price',
'tax': 'Tax',
'total': 'Total',
'subscribeNow': 'Subscribe Now',
'salesOverview': 'Sales Overview',
'item': 'Item',
'qty': 'Qty',
'subtotal': 'Subtotal',
'discount': 'Discount',
'telebirrReference': 'Telebirr Reference',
'thankYou': 'Thank you for your business!',
'receipt': 'Receipt',
'time': 'Time',
'scanBarcode': 'Scan barcode',
'scan': 'Scan',
'selectCustomer': 'Select Customer',
'creditAvailable': 'Credit Available',
'connectedTo': 'Connected to',
'noPrinterConnected': 'No printer connected',
'testPrint': 'Test Print Receipt',
'tryAdjustingSearch': 'Try adjusting your search or add new products',
'registerBusiness': 'Register Business',
'adminAccount': 'Admin Account',
'subscriptionPlan': 'Subscription Plan',
'reviewRegistration': 'Review & Complete',
'verifyPhone': 'Verify Phone',
'businessNameEnglish': 'Business Name (English)',
'businessNameAmharic': 'Business Name (Amharic)',
'businessPhone': 'Business Phone',
'businessEmailOptional': 'Business Email (Optional)',
'businessAddress': 'Business Address',
'ownerName': 'Owner Name',
'ownerPhone': 'Owner Phone',
'ownerEmailOptional': 'Owner Email (Optional)',
'yourName': 'Your Name',
'yourPhone': 'Your Phone',
'yourEmailOptional': 'Your Email (Optional)',
'password': 'Password',
'confirmPassword': 'Confirm Password',
'chooseSubscriptionPlan': 'Choose your subscription plan',

      'recommended': 'Recommended',
      'premium': 'Premium',
      'standard': 'Standard',
      'reviewYourRegistration': 'Review Your Registration',
      'freeTrialNotice':
          'You will get 14 days free trial to test all features. After trial period, you need to make payment to continue using the service.',
      'verifyYourPhone': 'Verify Your Phone',
      'otpSentTo': 'We sent a 6-digit code to {phone}',
      'enterOTP': 'Enter OTP Code',
      'didNotReceiveOTP': "Didn't receive OTP?",
      'resendOTP': 'Resend OTP',
      'completeRegistration': 'Complete Registration',
      'verifyOTP': 'Verify OTP',
      'continue': 'Continue',
      'back': 'Back',
      'isRequired': 'is required',
      'phoneRequired': 'Phone number is required',
      'validEthiopianPhone':
          'Please enter a valid Ethiopian phone number (+251...)',
      'validEmail': 'Please enter a valid email address',
      'passwordRequired': 'Password is required',
      'passwordMinLength': 'Password must be at least 6 characters long',
      'tinRequired': 'TIN number is required',
      'tinMinLength': 'TIN number must be at least 9 characters',
      'otpRequired': 'OTP code is required',
      'otpLength': 'OTP code must be 6 digits',
      'passwordsDoNotMatch': 'Passwords do not match',
      'registrationSuccessful': 'Registration successful! Please login.',
      'otpSentToPhone': 'We sent a 6-digit verification code to {phone}',
      'enterOTPCode': 'Enter OTP Code',
      'verifyAndContinue': 'Verify & Continue',
      'didNotReceiveCode': "Didn't receive the code?",
      'resendAvailableIn': 'Resend available in {seconds} seconds',
      'forBusiness': 'For {business}',
      'otpMustBe6Digits': 'OTP must be 6 digits',
      'otpMustBeNumbers': 'OTP must contain only numbers',
      'otpResentSuccessfully': 'OTP resent successfully',
      'registrationComplete': 'Registration complete! Welcome to Andalus POS',
      'invalidOrExpiredOTP': 'Invalid or expired OTP code',
      'shopRegistration': 'Shop Registration',
      'ownerAccount': 'Owner Account',
      'payment': 'Payment',
      'setupYourShop': 'Setup Your Shop',
      'enterShopDetails': 'Enter your shop details to get started',
      'shopName': 'Shop Name',
      'shopCategory': 'Shop Category',
      'phoneNumber': 'Phone Number',
      'city': 'City',
      'country': 'Country',
      'shopCategoryRequired': 'Please select a shop category',
      'createOwnerAccount': 'Create Owner Account',
      'setupOwnerDetails': 'Setup your owner account details',
      'fullName': 'Full Name',
      'passwordRequirements': 'Password Requirements',
      'min6Characters': 'At least 6 characters',
      'recommendSpecialChars':
          '8+ characters with special characters recommended',
      'steps': 'Steps',
      'shop': 'Shop',
      'owner': 'Owner',
      'verify': 'Verify',

      // Subscription plans
      'basic': 'Basic',
      'professional': 'Professional',

      'cbeBirr': 'CBE Birr',
      'chapa': 'Chapa',
      'choosePaymentMethod': 'Choose Payment Method',
      'processPayment': 'Process Payment',
      'paymentSuccessful': 'Payment Successful',

      // Success
      'setupStaffAccounts': 'Setup Staff Accounts',
      'addAdminsCashiersManagers':
          'Add admins, cashiers, managers for your shop.',
      'getStarted': 'Get Started',
      'chooseYourPlan': 'Choose Your Plan',
      'billingCycle': 'Billing Cycle',
      'completePayment': 'Complete Payment',
      'paymentMethods': 'Payment Methods',
      'welcomeToAndalusPOS':
          'Welcome to Andalus POS! Your account is now active.',
      'loginToYourAccount': 'Login to your account',
      'loginWithPassword': 'Login with Password',
      'loginWithOTP': 'Login with OTP',
      'login': 'Login',
      'sendingOTP': 'Sending OTP...',
      'createNewBusiness': 'Create New Business',
      'otpSentSuccessfully': 'OTP sent successfully',
      'welcomeBack': 'Welcome Back',
      'enterCredentialsToContinue': 'Enter your credentials to continue',
      'featureComingSoon': 'This feature is coming soon',
      'forgotPassword': 'Forgot Password?',
      'or': 'OR',
      // 'forgotPassword': 'Forgot Password',
      'resetYourPassword': 'Reset Your Password',
      'enterPhoneToResetPassword':
          'Enter your phone number to reset your password',
      'verifyAndReset': 'Verify and Reset',
      'enterOTPAndNewPassword':
          'Enter the OTP sent to your phone and set a new password',
      // 'newPassword': 'New Password',
      // 'confirmNewPassword': 'Confirm New Password',
      'resetPassword': 'Reset Password',
      'passwordResetSuccessfully': 'Password Reset Successfully!',
      'youCanNowLoginWithNewPassword':
          'You can now login with your new password',
      'backToLogin': 'Back to Login',
      'resendingOTP': 'Resending OTP...',
      'otpVerifiedSuccessfully': 'OTP verified successfully!',
      'instantPayment': 'Instant payment',
      'mobileBanking': 'Mobile banking',
      'onlinePayment': 'Online payment',
      'securePayment': 'Secure payment',
    },
    'am': {
      'appTitle': '·ä†·äï·ã≥·àâ·àµ ·àõ·à≠·â≤·äï ·çñ·àµ',
      'dashboard': '·ã≥·àΩ·â¶·à≠·ãµ',
      'pointOfSale': '·ã®·àΩ·ã´·å≠ ·äê·å•·â•',
      'salesHistory': '·ã®·àΩ·ã´·å≠ ·â≥·à™·ä≠',
      'customers': '·ã∞·äï·â†·äû·âΩ',
      'products': '·àù·à≠·â∂·âΩ',
      'categories': '·àù·ãµ·â¶·âΩ',
      'settings': '·àõ·àµ·â∞·ä´·ä®·ã´·ãé·âΩ',
      'todayRevenue': '·ã®·ãõ·à¨ ·åà·â¢',
      'todayOrders': '·ã®·ãõ·à¨ ·âµ·ãï·ãõ·ãû·âΩ',
      'outstandingCredit': '·ã´·àç·â∞·ä®·çà·àà ·ä≠·à¨·ã≤·âµ',
      'overdue': '·â†·åä·ãú ·ã´·àç·â∞·ä®·çà·àà',
      'totalRevenue': '·å†·âÖ·àã·àã ·åà·â¢',
      'totalOrders': '·å†·âÖ·àã·àã ·âµ·ãï·ãõ·ãû·âΩ',
      'averageOrderValue': '·ä†·àõ·ä´·äù ·ã®·âµ·ãï·ãõ·ãù ·ãã·åã',
      'salesPerformance': '·ã®·àΩ·ã´·å≠ ·ä†·çà·çÉ·çÄ·àù',
      'creditOverview': '·ã®·ä≠·à¨·ã≤·âµ ·ä†·å†·âÉ·àã·ã≠ ·ä•·ã≠·â≥',
      'recentSales': '·ã®·âÖ·à≠·â• ·åä·ãú ·àΩ·ã´·åÆ·âΩ',
      'searchProducts': '·àù·à≠·â∂·âΩ·äï ·çà·àç·åç...',
      'shoppingCart': '·ã®·åç·ã¢ ·âã·àö',
      'clearAll': '·àÅ·àâ·äï·àù ·ä†·å•·çã',
      'totalAmount': '·å†·âÖ·àã·àã ·àò·å†·äï',
      'completeSale': '·àΩ·ã´·å≠ ·ä†·å†·äì·âÖ·âÖ',
      'selectPaymentMethod': '·ã®·ä≠·çç·ã´ ·ãò·ã¥ ·ã≠·àù·à®·å°',
      'cash': '·ä´·àΩ',
      'telebirr': '·â¥·àå·â•·à≠',
      // 'card': '·ä´·à≠·ãµ',
      'bankTransfer': '·â†·â£·äï·ä≠ ·àõ·àµ·â∞·àã·àà·çä·ã´',
      'credit': '·ä≠·à¨·ã≤·âµ',
      'confirm': '·ä†·à®·åã·åç·å•',
      'cancel': '·à∞·à≠·ãù',
      'businessInformation': '·ã®·äï·åç·ãµ ·àò·à®·åÉ',
      'shopNameEnglish': '·ã®·äï·åç·ãµ ·àµ·àù (·ä•·äï·åç·àä·ãù·äõ)',
      'shopNameAmharic': '·ã®·äï·åç·ãµ ·àµ·àù (·ä†·àõ·à≠·äõ)',
      'address': '·ä†·ãµ·à´·àª',
      'phone': '·àµ·àç·ä≠',
      'tinNumber': 'TIN ·âÅ·å•·à≠',
      'appearanceLanguage': '·åà·åΩ·â≥ ·ä•·äì ·âã·äï·âã',
      'themeMode': '·ã®·åà·åΩ·â≥ ·àÅ·äê·â≥',
      'language': '·âã·äï·âã',
      'light': '·â•·à≠·àÉ·äï',
      'dark': '·å®·àà·àõ',
      'systemDefault': '·ã®·àµ·à≠·ä†·âµ ·äê·â£·à™',
      'english': '·ä•·äï·åç·àä·ãù·äõ',
      'amharic': '·ä†·àõ·à≠·äõ',
      'posSettings': '·ã®·àΩ·ã´·å≠ ·äê·å•·â• ·àõ·àµ·â∞·ä´·ä®·ã´·ãé·âΩ',
      'autoPrintReceipts': '·à´·àµ-·à∞·à≠ ·ã∞·à®·à∞·äù ·ä†·âµ·àù',
      'enableCustomerSelection': '·ã∞·äï·â†·äõ ·àù·à≠·å´ ·ä†·äï·âÉ',
      'defaultPaymentMethod': '·äê·â£·à™ ·ã®·ä≠·çç·ã´ ·ãò·ã¥',
      'creditSettings': '·ã®·ä≠·à¨·ã≤·âµ ·àõ·àµ·â∞·ä´·ä®·ã´·ãé·âΩ',
      'enableCreditSystem': '·ã®·ä≠·à¨·ã≤·âµ ·àµ·à≠·ä†·âµ ·ä†·äï·âÉ',
      'defaultCreditLimit': '·äê·â£·à™ ·ã®·ä≠·à¨·ã≤·âµ ·åà·ã∞·â• (·â•·à≠)',
      'defaultPaymentTerms': '·äê·â£·à™ ·ã®·ä≠·çç·ã´ ·ãç·àé·âΩ (·âÄ·äì·âµ)',
      'syncSettings': '·ã®·àõ·àò·à≥·à∞·àç ·àõ·àµ·â∞·ä´·ä®·ã´·ãé·âΩ',
      'enableDataSync': '·ã®·ãç·àÇ·â• ·àõ·àò·à≥·à∞·àç ·ä†·äï·âÉ',
      'syncInterval': '·ã®·àõ·àò·à≥·à∞·àç ·ä≠·çç·â∞·âµ (·ã∞·âÇ·âÉ)',
      'advancedSettings': '·ã®·àã·âÄ ·àõ·àµ·â∞·ä´·ä®·ã´·ãé·âΩ',
      'enableTax': '·â≥·ä≠·àµ ·ä†·äï·âÉ',
      'taxRate': '·ã®·â≥·ä≠·àµ ·àò·å†·äï (%)',
      'enableDiscounts': '·âÖ·äì·àæ·âΩ ·ä†·äï·âÉ',
      'lowStockNotifications': '·ãù·âÖ·â∞·äõ ·ä≠·àù·âΩ·âµ ·àõ·à≥·ãà·âÇ·ã´·ãé·âΩ',
      'lowStockThreshold': '·ãù·âÖ·â∞·äõ ·ä≠·àù·âΩ·âµ ·ã∞·à®·åÉ',
      'dangerZone': '·ä†·ã∞·åã ·ãç·àµ·å• ·ã´·àà ·ä†·ä´·â£·â¢',
      'resetToDefaults': '·ãà·ã∞ ·äê·â£·à™ ·ä†·àµ·â∞·ä´·ä≠·àç',
      'noSalesToday': '·ãõ·à¨ ·àΩ·ã´·å≠ ·ã®·àà·àù',
      'noProductsFound': '·àù·äï·àù ·àù·à≠·âµ ·ä†·àç·â∞·åà·äò·àù',
      'yourCartEmpty': '·ã®·åç·ã¢ ·âã·àö·ãé ·â£·ã∂ ·äê·ãç',
      'addProductsGetStarted': '·àà·àò·åÄ·àò·à≠ ·àù·à≠·â∂·âΩ·äï ·ã´·ä≠·àâ',
      'saleCompleted': '·àΩ·ã´·å≠ ·â†·â∞·à≥·ä´ ·àÅ·äî·â≥ ·â∞·å†·äì·âÖ·âã·àç!',
      'errorLoadingData': '·ãç·àÇ·â• ·â†·àõ·àù·å£·âµ ·àã·ã≠ ·àµ·àÖ·â∞·âµ',
      'settingsSaved': '·àõ·àµ·â∞·ä´·ä®·ã´·ãé·âΩ ·â†·â∞·à≥·ä´ ·àÅ·äî·â≥ ·â∞·âÄ·àù·å†·ãã·àç!',
      'settingsReset': '·àõ·àµ·â∞·ä´·ä®·ã´·ãé·âΩ ·ãà·ã∞ ·äê·â£·à™ ·â∞·àò·àç·à∞·ãã·àç!',
      'account': '·àò·àà·ã´',
      'accountSettings': '·ã®·àò·àà·ã´ ·àõ·àµ·â∞·ä´·ä®·ã´·ãé·âΩ',
      'security': '·ã∞·àÖ·äï·äê·âµ',
      'changePassword': '·ã®·ã≠·àà·çç ·âÉ·àç ·ã≠·âÄ·ã≠·à©',
      'currentPassword': '·ä†·àÅ·äï ·ã´·àà·ãç ·ã®·ã≠·àà·çç ·âÉ·àç',
      'newPassword': '·ä†·ã≤·àµ ·ã®·ã≠·àà·çç ·âÉ·àç',
      'confirmNewPassword': '·ä†·ã≤·à±·äï ·ã®·ã≠·àà·çç ·âÉ·àç ·ã´·à®·åã·åç·å°',
      'Are you sure you want to logout?': '·ä•·à≠·åç·å†·äõ ·äê·àÖ ·àò·ãç·å£·âµ ·âµ·çà·àç·åã·àà·àÖ?',
      'weeklySales': '·ã®·à≥·àù·äï·âµ ·àΩ·ã´·å≠',
      'orders': '·âµ·ãï·ãõ·ãû·âΩ',
      'refresh': '·ä†·ãµ·àµ',
      'performanceOverview': '·ã®·ä†·çà·çÉ·çÄ·àù ·ä†·å†·âÉ·àã·ã≠ ·ä•·ã≠·â≥',
      'customersWithBalance': '·âÄ·à™ ·àÇ·à≥·â• ·ã´·àã·â∏·ãç ·ã∞·äï·â†·äû·âΩ',
      'overdueAmount': '·â†·åä·ãú ·ã´·àç·â∞·ä®·çà·àà ·àò·å†·äï',
      'databaseNeedsUpdate': '·ã®·ãç·àÇ·â• ·åé·â≥ ·àõ·ãò·àò·äï ·ã´·àµ·çà·àç·åã·àç·ç¢ ·ä•·â£·ä≠·ãé ·ä•·äï·ã∞·åà·äì ·ã≠·àû·ä≠·à©·ç¢',
      'tryAgain': '·ä•·äï·ã∞·åà·äì ·àû·ä≠·à≠',
      'up': '·àò·ãç·å£·âµ',
      'down': '·àò·ãç·à®·ãµ',
      'sale': '·àΩ·ã´·å≠',
      'today': '·ãõ·à¨',
      'completeFirstSale': '·àà·àõ·ã®·âµ ·ã®·àò·åÄ·àò·à™·ã´ ·àΩ·ã´·å≠·ãé·äï ·ã´·å†·äì·âÖ·âÅ!',
      'stockAlert': '·ã®·ä≠·àù·âΩ·âµ ·àõ·àµ·å†·äï·âÄ·âÇ·ã´',
      'quickActions': '·çà·å£·äï ·ä•·à≠·àù·åÉ·ãé·âΩ',
      'newSale': '·ä†·ã≤·àµ ·àΩ·ã´·å≠',
      'addProduct': '·àù·à≠·âµ ·å®·àù·à≠',
      'addCustomer': '·ã∞·äï·â†·äõ ·å®·àù·à≠',
      'reports': '·à™·çñ·à≠·â∂·âΩ',
      'salesAnalytics': '·ã®·àΩ·ã´·å≠ ·âµ·äï·â≥·äî',
      'chartsComingSoon': '·âª·à≠·â∂·âΩ ·â†·âÖ·à≠·â• ·ã≠·àò·å£·àâ',
      'installFlChart': '·àà·àö·ã´·àù·à© ·âµ·äï·â≥·äî·ãé·âΩ fl_chart ·å´·äï',
      'allProductsWellStocked': '·àÅ·àâ·àù ·àù·à≠·â∂·âΩ ·â†·ã∞·äï·â• ·â∞·âÄ·àù·å†·ãã·àç',
      'moreProducts': '+{count} ·â∞·å®·àõ·à™ ·àù·à≠·â∂·âΩ',
      'left': '·âÄ·à≠·â∑·àç',
      'calendarSettings': '·ã®·âÄ·äï ·àò·âÅ·å†·à™·ã´ ·àõ·àµ·â∞·ä´·ä®·ã´·ãé·âΩ',
      'calendarType': '·ã®·âÄ·äï ·àò·âÅ·å†·à™·ã´ ·ä†·ã≠·äê·âµ',
      'calendarDescription':
          '·â†·àò·â∞·åç·â†·à™·ã´·ãç ·ãç·àµ·å• ·àà·âÄ·äï ·àõ·à≥·ã´ ·åç·à™·åé·à≠·ã´·äï ·ä•·äì ·ä¢·âµ·ãÆ·åµ·ã´·ãä ·âÄ·äï ·àò·âÅ·å†·à™·ã´ ·àµ·à≠·ãì·â∂·âΩ·äï ·ã≠·àù·à®·å°',
      'fontSize': '·ã®·çä·ã∞·àç ·àò·å†·äï',
      'small': '·âµ·äï·àΩ',
      'large': '·âµ·àç·âÖ',
      'items sold': '·ã®·â∞·à∏·å° ·ä•·âÉ·ãé·âΩ',
      'with balance': '·âÄ·à™ ·àí·à≥·â• ·ã´·àã·â∏·ãç',
      'outstanding': '·ã´·àç·â∞·ä®·çà·àà',
      'thisMonth': '·â†·ãö·àÖ ·ãà·à≠',
      'productsReport': '·ã®·àù·à≠·â∂·âΩ ·à™·çñ·à≠·âµ',
      'customersReport': '·ã®·ã∞·äï·â†·äû·âΩ ·à™·çñ·à≠·âµ',
      'financialReport': '·ã®·çã·ã≠·äì·äï·àµ ·à™·çñ·à≠·âµ',
      'selectDateRange': '·ã®·âÄ·äï ·ä≠·àç·àç ·ã≠·àù·à®·å°',
      'basicPlanFeatures': '·àò·à∞·à®·â≥·ãä ·ä•·âÖ·ãµ: ·àò·à∞·à®·â≥·ãä ·à™·çñ·à≠·â∂·âΩ ·ã≠·åà·äõ·àâ',
      'professionalPlanFeatures': '·çï·àÆ·çå·àΩ·äì·àç ·ä•·âÖ·ãµ: ·ã®·àã·âÄ ·âµ·äï·â≥·äî ·ã≠·åà·äõ·àç',
      'enterprisePlanFeatures': '·ä¢·äï·â∞·à≠·çï·à´·ã≠·ãù ·ä•·âÖ·ãµ: ·àô·àâ ·âµ·äï·â≥·äî ·ã≠·åà·äõ·àç',
      'plan': '·ä•·âÖ·ãµ',
      'basicReportsDescription': '·àò·à∞·à®·â≥·ãä ·ã®·àΩ·ã´·å≠ ·à™·çñ·à≠·â∂·âΩ ·ä•·äì ·âµ·äï·â≥·äî',
      'professionalReportsDescription': '·ã®·àã·âÄ ·ã®·àù·à≠·âµ ·ä•·äì ·ã®·ã∞·äï·â†·äû·âΩ ·âµ·äï·â≥·äî',
      'enterpriseReportsDescription': '·àô·àâ ·ã®·çã·ã≠·äì·äï·àµ ·ä•·äì ·âµ·äï·â†·ã´ ·âµ·äï·â≥·äî',
      'upgradeForAdvancedReports': '·àà·àã·âÄ ·à™·çñ·à≠·â∂·âΩ ·ä†·àª·àΩ·àç',
      'upgrade': '·ä†·àª·àΩ·àç',
      'professionalPlanRequired': '·çï·àÆ·çå·àΩ·äì·àç ·ä•·âÖ·ãµ ·ã´·àµ·çà·àç·åã·àç',
      'enterprisePlanRequired': '·ä¢·äï·â∞·à≠·çï·à´·ã≠·ãù ·ä•·âÖ·ãµ ·ã´·àµ·çà·àç·åã·àç',
      'productsReportAvailableInPlan': '·ã®·àù·à≠·â∂·âΩ ·à™·çñ·à≠·âµ ·â†{plan} ·ä•·âÖ·ãµ ·ã≠·åà·äõ·àç',
      'customersReportAvailableInPlan': '·ã®·ã∞·äï·â†·äû·âΩ ·à™·çñ·à≠·âµ ·â†{plan} ·ä•·âÖ·ãµ ·ã≠·åà·äõ·àç',
      'financialReportAvailableInPlan': '·ã®·çã·ã≠·äì·äï·àµ ·à™·çñ·à≠·âµ ·â†{plan} ·ä•·âÖ·ãµ ·ã≠·åà·äõ·àç',
      'upgradeYourPlan': '·ä•·âÖ·ãµ·ãé·äï ·ä†·àª·àΩ·àç',
      'upgradeForAdvancedAnalytics': '·ã®·àã·âÄ ·âµ·äï·â≥·äî ·ä•·äì ·ã®·à™·çñ·à≠·âµ ·â£·àÖ·à™·ã´·âµ·äï ·àà·àõ·åç·äò·âµ ·ä†·àª·àΩ·àç·ç¢',
      'viewPlans': '·ä•·âÖ·ã∂·âΩ·äï ·ã≠·àò·àç·ä®·â±',
      'salesByPaymentMethod': '·â†·ä≠·çç·ã´ ·ãò·ã¥ ·àΩ·ã´·å≠',
      'revenueByDay': '·â†·âÄ·äï ·åà·â¢',
      'dailySalesTrend': '·ãï·àà·â≥·ãä ·ã®·àΩ·ã´·å≠ ·ä†·ãù·àõ·àö·ã´',
      'topSellingHours': '·ä®·çç·â∞·äõ ·ã®·àΩ·ã´·å≠ ·à∞·ãì·â≥·âµ',
      'customerRetention': '·ã®·ã∞·äï·â†·äû·âΩ ·àò·å†·â£·â†·âÇ·ã´',
      'salesVelocity': '·ã®·àΩ·ã´·å≠ ·çç·å•·äê·âµ',
      'profitMarginAnalysis': '·ã®·âµ·à≠·çç ·àÖ·ã≥·åç ·âµ·äï·â≥·äî',
      'inventoryTurnover': '·ã®·ä≠·àù·âΩ·âµ ·àõ·ãû·à™·ã´',
      'abcAnalysis': 'ABC ·âµ·äï·â≥·äî',
      'stockOptimization': '·ã®·ä≠·àù·âΩ·âµ ·àõ·àò·âª·â∏·âµ',
      'productsOverview': '·ã®·àù·à≠·â∂·âΩ ·ä†·å†·âÉ·àã·ã≠ ·ä•·ã≠·â≥',
      'totalProducts': '·å†·âÖ·àã·àã ·àù·à≠·â∂·âΩ',
      'lowStock': '·ãù·âÖ·â∞·äõ ·ä≠·àù·âΩ·âµ',
      'outOfStock': '·ã®·â∞·å†·äì·âÄ·âÄ',
      'topSellingProducts': '·ä®·çç·â∞·äõ ·ã®·àö·à∏·å° ·àù·à≠·â∂·âΩ',
      'sold': '·â∞·à∏·åß·àç',
      'customersOverview': '·ã®·ã∞·äï·â†·äû·âΩ ·ä†·å†·âÉ·àã·ã≠ ·ä•·ã≠·â≥',
      'topCustomers': '·ä®·çç·â∞·äõ ·ã∞·äï·â†·äû·âΩ',
      'customerAcquisition': '·ã®·ã∞·äï·â†·äû·âΩ ·àò·åç·ãõ·âµ',
      'averageCustomerValue': '·ä†·àõ·ä´·äù ·ã®·ã∞·äï·â†·äõ ·ãã·åã',
      'customerLifetimeValue': '·ã®·ã∞·äï·â†·äõ ·ã®·àÖ·ã≠·ãà·âµ ·ãò·àò·äï ·ãã·åã',
      'churnRiskAnalysis': '·ã®·ã∞·äï·â†·äõ ·àò·å•·çã·âµ ·ä†·ã∞·åã ·âµ·äï·â≥·äî',
      'financialOverview': '·ã®·çã·ã≠·äì·äï·àµ ·ä†·å†·âÉ·àã·ã≠ ·ä•·ã≠·â≥',
      'revenueTrend': '·ã®·åà·â¢ ·ä†·ãù·àõ·àö·ã´',
      'profitMarginTrend': '·ã®·âµ·à≠·çç ·àÖ·ã≥·åç ·ä†·ãù·àõ·àö·ã´',
      'cashFlowAnalysis': '·ã®·åà·äï·ãò·â• ·çç·à∞·âµ ·âµ·äï·â≥·äî',
      'financialRatios': '·ã®·çã·ã≠·äì·äï·àµ ·à¨·àæ·ãé·âΩ',
      'breakEvenAnalysis': '·ã®·âµ·à≠·çç-·ã®·ãà·å™ ·âµ·äï·â≥·äî',
      'advancedAnalyticsFeature': '·ã®·àã·âÄ ·âµ·äï·â≥·äî ·â£·àÖ·à™ ·â†·ä®·çç·â∞·äõ ·ä•·âÖ·ã∂·âΩ ·ã≠·åà·äõ·àç',
      'yesterday': '·âµ·àã·äï·âµ',
      'thisWeek': '·â†·ãö·àÖ ·à≥·àù·äï·âµ',
      'lastWeek': '·ã´·àà·çà·ãç ·à≥·àù·äï·âµ',
      'lastMonth': '·ã´·àà·çà·ãç ·ãà·à≠',
      'last3Months': '·ã´·àà·çâ·âµ 3 ·ãà·à´·âµ',
      'last6Months': '·ã´·àà·çâ·âµ 6 ·ãà·à´·âµ',
      'thisYear': '·â†·ãö·àÖ ·ãì·àò·âµ',
      'lastYear': '·ã´·àà·çà·ãç ·ãì·àò·âµ',
      'subscriptionPlans': '·ã®·ã∞·äï·â†·äù·äê·âµ ·ä•·âÖ·ã∂·âΩ',
      'choosePerfectPlan': '·àà·äï·åç·ãµ·ãé ·â∞·àµ·àõ·àö ·ä•·âÖ·ãµ ·ã≠·àù·à®·å°',
      'startWithFreeTrial': '·â†14 ·âÄ·äì·âµ ·äê·çÉ ·àô·ä®·à´ ·ã≠·åÄ·àù·à©·ç¢ ·ã®·ä≠·à¨·ã≤·âµ ·ä´·à≠·ãµ ·ä†·ã´·àµ·çà·àç·åç·àù·ç¢',
      'monthly': '·ãà·à≠·àÉ·ãä',
      'yearly': '·ãì·àò·â≥·ãä',
      'save20Percent': '20% ·ã≠·âÜ·å•·â°',
      'popular': '·â∞·ãà·ã≥·åÖ',
      'selected': '·â∞·àò·à≠·åß·àç',
      'selectPlan': '·ä•·âÖ·ãµ ·ã≠·àù·à®·å°',
      'paymentMethod': '·ã®·ä≠·çç·ã´ ·ãò·ã¥',
      'card': '·ä≠·à¨·ã≤·âµ/·ã≤·â¢·âµ ·ä´·à≠·ãµ',
      'orderSummary': '·ã®·âµ·ãï·ãõ·ãù ·àõ·å†·âÉ·àà·ã´',
      // 'plan': '·ä•·âÖ·ãµ',
      'price': '·ãã·åã',
      'tax': '·â≥·ä≠·àµ',
      'total': '·å†·âÖ·àã·àã',
      'subscribeNow': '·ä†·àÅ·äï ·ã≠·àò·ãù·åà·â°',
      'salesOverview': '·ã®·àΩ·ã´·å≠ ·ä†·å†·âÉ·àã·ã≠ ·ä•·ã≠·â≥',
      'item': '·ä•·âÉ',
      'qty': '·â•·ãõ·âµ',
      'subtotal': '·äï·ãë·àµ ·ãµ·àù·à≠',
      'discount': '·âÖ·äì·àΩ',
      'telebirrReference': '·â¥·àå·â•·à≠ ·àõ·å£·âÄ·àª',
      'thankYou': '·àà·äï·åç·ãµ·ãé ·ä•·äì·àò·à∞·åç·äì·àà·äï!',
      'receipt': '·ã∞·à®·à∞·äù',
      'time': '·à∞·ãì·âµ',
      'scanBarcode': '·â£·à≠·äÆ·ãµ ·ã≠·âÉ·äô',
      'scan': '·âÉ·äù',
      'selectCustomer': '·ã∞·äï·â†·äõ ·ã≠·àù·à®·å°',
      'creditAvailable': '·ã®·àö·åà·äù ·ä≠·à¨·ã≤·âµ',
      'connectedTo': '·â∞·åà·äì·äù·â∑·àç',
      'noPrinterConnected': '·àù·äï·àù ·çï·à™·äï·â∞·à≠ ·ä†·àç·â∞·åà·äì·äò·àù',
      'testPrint': '·ã∞·à®·à∞·äù ·ä†·âµ·àù',
      'tryAdjustingSearch': '·çç·àà·åã·ãé·äï ·ã´·àµ·â∞·ä´·ä≠·àâ ·ãà·ã≠·àù ·ä†·ã≤·àµ ·àù·à≠·â∂·âΩ·äï ·ã´·ä≠·àâ',
      'registerBusiness': '·ã®·äï·åç·ãµ ·à•·à´ ·àù·ãù·åà·â£',
      'adminAccount': '·ã®·ä†·àµ·â∞·ã≥·ã≥·à™ ·àò·àà·ã´',
      'subscriptionPlan': '·ã®·ã∞·äï·â†·äù·äê·âµ ·ä†·âÖ·àù',
      'reviewRegistration': '·åç·àù·åà·àõ ·ä•·äì ·àõ·å†·äì·âÄ·âÖ',
      'verifyPhone': '·àµ·àç·ä≠ ·àõ·à®·åã·åà·å´',
      'businessNameEnglish': '·ã®·äï·åç·ãµ ·à•·à´ ·àµ·àù (·ä•·äï·åç·àä·ãù·äõ)',
      'businessNameAmharic': '·ã®·äï·åç·ãµ ·à•·à´ ·àµ·àù (·ä†·àõ·à≠·äõ)',
      'businessPhone': '·ã®·äï·åç·ãµ ·à•·à´ ·àµ·àç·ä≠',
      'businessEmailOptional': '·ã®·äï·åç·ãµ ·à•·à´ ·ä¢·àú·ã≠·àç (·ä†·àõ·à´·å≠)',
      'businessAddress': '·ã®·äï·åç·ãµ ·à•·à´ ·ä†·ãµ·à´·àª',
      'ownerName': '·ã®·â£·àà·â§·âµ ·àµ·àù',
      'ownerPhone': '·ã®·â£·àà·â§·âµ ·àµ·àç·ä≠',
      'ownerEmailOptional': '·ã®·â£·àà·â§·âµ ·ä¢·àú·ã≠·àç (·ä†·àõ·à´·å≠)',
      'yourName': '·àµ·àù·ãé',
      'yourPhone': '·àµ·àç·ä≠·ãé',
      'yourEmailOptional': '·ä¢·àú·ã≠·àç·ãé (·ä†·àõ·à´·å≠)',
      'password': '·ã®·ã≠·àà·çç ·âÉ·àç',
      'confirmPassword': '·ã®·ã≠·àà·çç ·âÉ·àç ·ä†·à®·åã·åç·å•',
      'chooseSubscriptionPlan': '·ã®·ã∞·äï·â†·äù·äê·âµ ·ä†·âÖ·àù·ãé·äï ·ã≠·àù·à®·å°',
      'recommended': '·ã®·àö·àò·ä®·à≠',
      'premium': '·çï·à™·àö·ã®·àù',
      'standard': '·àò·ã∞·â†·äõ',
      'reviewYourRegistration': '·àù·ãù·åà·â£·ãé·äï ·ã≠·åà·àù·åç·àô',
      'freeTrialNotice':
          '·àÅ·àâ·äï·àù ·â£·àÖ·à™·ã´·âµ ·àà·àò·àû·ä®·à≠ 14 ·âÄ·äì·âµ ·äê·çÉ ·àô·ä®·à´ ·ã´·åà·äõ·àâ·ç¢ ·ä®·àô·ä®·à´ ·åä·ãú ·â†·äã·àã ·ä†·åà·àç·åç·àé·â±·äï ·àà·àò·å†·âÄ·àù ·ä≠·çç·ã´ ·àõ·ãµ·à®·åç ·ã´·àµ·çà·àç·åç·ãé·â≥·àç·ç¢',
      'verifyYourPhone': '·àµ·àç·ä≠·ãé·äï ·ã´·à®·åã·åç·å°',
      'otpSentTo': '6-·ä†·àÉ·ãù ·äÆ·ãµ ·ãà·ã∞ {phone} ·àç·ä®·äì·àç',
      'enterOTP': 'OTP ·äÆ·ãµ ·ã´·àµ·åà·â°',
      'didNotReceiveOTP': 'OTP ·ä†·àç·ã∞·à®·à∞·àù?',
      'resendOTP': 'OTP ·ä•·äï·ã∞·åà·äì ·àã·ä≠',
      'completeRegistration': '·àù·ãù·åà·â£·ãç·äï ·ã≠·å®·à≠·à±',
      'verifyOTP': 'OTP ·ä†·à®·åã·åç·å•',
      'continue': '·âÄ·å•·àç',
      'back': '·â∞·àò·àà·àµ',
      'isRequired': '·ã´·àµ·çà·àç·åã·àç',
      'phoneRequired': '·àµ·àç·ä≠ ·âÅ·å•·à≠ ·ã´·àµ·çà·àç·åã·àç',
      'validEthiopianPhone': '·ä•·â£·ä≠·ãé ·âµ·ä≠·ä≠·àà·äõ ·ã®·ä¢·âµ·ãÆ·åµ·ã´ ·àµ·àç·ä≠ ·âÅ·å•·à≠ ·ã´·àµ·åà·â° (+251...)',
      'validEmail': '·ä•·â£·ä≠·ãé ·âµ·ä≠·ä≠·àà·äõ ·ä¢·àú·ã≠·àç ·ä†·ãµ·à´·àª ·ã´·àµ·åà·â°',
      'passwordRequired': '·ã®·ã≠·àà·çç ·âÉ·àç ·ã´·àµ·çà·àç·åã·àç',
      'passwordMinLength': '·ã®·ã≠·àà·çç ·âÉ·àç ·â¢·ã´·äï·àµ 6 ·âÅ·àù·çä ·à≠·ãù·àò·âµ ·àä·äñ·à®·ãç ·ã≠·åà·â£·àç',
      'tinRequired': 'TIN ·âÅ·å•·à≠ ·ã´·àµ·çà·àç·åã·àç',
      'tinMinLength': 'TIN ·âÅ·å•·à≠ ·â¢·ã´·äï·àµ 9 ·âÅ·àù·çä ·à≠·ãù·àò·âµ ·àä·äñ·à®·ãç ·ã≠·åà·â£·àç',
      'otpRequired': 'OTP ·äÆ·ãµ ·ã´·àµ·çà·àç·åã·àç',
      'otpLength': 'OTP ·äÆ·ãµ 6 ·ä†·àÉ·ãù ·àä·äñ·à®·ãç ·ã≠·åà·â£·àç',
      'passwordsDoNotMatch': '·ã®·ã≠·àà·çç ·âÉ·àã·âµ ·ä†·ã≠·àò·à≥·à∞·àâ·àù',
      'registrationSuccessful': '·àù·ãù·åà·â£ ·â†·â∞·à≥·ä´ ·àÅ·äî·â≥ ·â∞·å†·äì·âã·àç! ·ä•·â£·ä≠·ãé ·ã≠·åç·â°·ç¢',
      'otpSentToPhone': '6-·ä†·àÉ·ãù ·àõ·à®·åã·åà·å´ ·äÆ·ãµ ·ãà·ã∞ {phone} ·àç·ä®·äì·àç',
      'enterOTPCode': 'OTP ·äÆ·ãµ ·ã´·àµ·åà·â°',
      'verifyAndContinue': '·ã´·à®·åã·åç·å° ·ä•·äì ·ã≠·âÄ·å•·àâ',
      'didNotReceiveCode': '·äÆ·ãµ ·ä†·àç·ã∞·à®·à∞·àù?',
      'resendAvailableIn': '·ä•·äï·ã∞·åà·äì ·àà·àò·àã·ä≠ ·â† {seconds} ·à∞·ä®·äï·ãµ ·ãç·àµ·å• ·ã≠·åà·äõ·àç',
      'forBusiness': '·àà {business}',
      'otpMustBe6Digits': 'OTP 6 ·ä†·àÉ·ãù ·àò·àÜ·äï ·ä†·àà·â†·âµ',
      'otpMustBeNumbers': 'OTP ·âÅ·å•·àÆ·âΩ ·â•·âª ·àä·äñ·à©·âµ ·ã≠·åà·â£·àç',
      'otpResentSuccessfully': 'OTP ·â†·â∞·à≥·ä´ ·àÅ·äî·â≥ ·ä•·äï·ã∞·åà·äì ·â∞·àç·â∑·àç',
      'registrationComplete': '·àù·ãù·åà·â£ ·â∞·å†·äì·âÖ·âã·àç! ·ãà·ã∞ ·ä†·äï·ã≥·àâ·àµ POS ·ä•·äï·ä≥·äï ·â†·ã∞·àÖ·äì ·àò·å°',
      'invalidOrExpiredOTP': '·àç·ä≠ ·ã´·àç·àÜ·äê ·ãà·ã≠·àù ·åä·ãú·ãç ·ã´·àà·çà ·ã®OTP ·äÆ·ãµ',
      'shopRegistration': '·ã®·à±·âÖ ·àù·ãù·åà·â£',
      'ownerAccount': '·ã®·â£·àà·â§·âµ ·àò·àà·ã´',
      'payment': '·ä≠·çç·ã´',
      'setupYourShop': '·à±·âÖ·ãé·äï ·ã´·ãò·åã·åÅ',
      'enterShopDetails': '·àà·àò·åÄ·àò·à≠ ·ã®·à±·âÖ·ãé·äï ·ãù·à≠·ãù·àÆ·âΩ ·ã´·àµ·åà·â°',
      'shopName': '·ã®·à±·âÖ ·àµ·àù',
      'shopCategory': '·ã®·à±·âÖ ·àù·ãµ·â•',
      'phoneNumber': '·àµ·àç·ä≠ ·âÅ·å•·à≠',
      'city': '·ä®·â∞·àõ',
      'country': '·ä†·åà·à≠',
      'shopCategoryRequired': '·ä•·â£·ä≠·ãé ·ã®·à±·âÖ ·àù·ãµ·â• ·ã≠·àù·à®·å°',
      'createOwnerAccount': '·ã®·â£·àà·â§·âµ ·àò·àà·ã´ ·ã≠·çç·å†·à©',
      'setupOwnerDetails': '·ã®·â£·àà·â§·âµ ·àò·àà·ã´ ·ãù·à≠·ãù·àÆ·âΩ·ãé·äï ·ã´·ãò·åã·åÅ',
      'fullName': '·àô·àâ ·àµ·àù',
      'passwordRequirements': '·ã®·ã≠·àà·çç ·âÉ·àç ·àò·àµ·çà·à≠·â∂·âΩ',
      'min6Characters': '·â¢·ã´·äï·àµ 6 ·çä·ã∞·àé·âΩ',
      'recommendSpecialChars': '8+ ·çä·ã∞·àé·âΩ ·ä®·àç·ã© ·àù·àç·ä≠·â∂·âΩ ·åã·à≠ ·ã≠·àò·ä®·à´·àç',
      'steps': '·ã∞·à®·åÉ·ãé·âΩ',
      'shop': '·à±·âÖ',
      'owner': '·â£·àà·â§·âµ',
      'verify': '·àõ·à®·åã·åà·å´',
      'basic': '·àò·à∞·à®·â≥·ãä',
      'professional': '·çï·àÆ·çå·àΩ·äì·àç',
      'cbeBirr': 'CBE ·â•·à≠',
      'chapa': '·âª·çì',
      'choosePaymentMethod': '·ã®·ä≠·çç·ã´ ·ãò·ã¥ ·ã≠·àù·à®·å°',
      'processPayment': '·ä≠·çç·ã´ ·ã´·àµ·åà·â°',
      'paymentSuccessful': '·ä≠·çç·ã´ ·â∞·à≥·ä≠·â∑·àç',
      'setupStaffAccounts': '·ã®·à∞·à´·â∞·äû·âΩ ·àò·àà·ã´·ãé·âΩ·äï ·ã´·ãò·åã·åÅ',
      'addAdminsCashiersManagers': '·àà·à±·âÖ·ãé ·ä†·àµ·â∞·ã≥·ã≥·à™·ãé·âΩ·ç£ ·ä´·à∫·ãé·âΩ·ç£ ·ä†·àµ·â∞·ã≥·ã≥·à™·ãé·âΩ ·ã´·ä≠·àâ',
      'getStarted': '·åÄ·àù·à≠',
      'chooseYourPlan': '·ä•·âÖ·ãµ·ãé·äï ·ã≠·àù·à®·å°',
      'billingCycle': '·ã®·ä≠·çç·ã´ ·ãë·ã∞·âµ',
      'completePayment': '·ä≠·çç·ã´·ãç·äï ·ã≠·å®·à≠·à±',
      'paymentMethods': '·ã®·ä≠·çç·ã´ ·ãò·ã¥·ãé·âΩ',
      'welcomeToAndalusPOS': '·ãà·ã∞ ·ä†·äï·ã≥·àâ·àµ POS ·ä•·äï·ä≥·äï ·â†·ã∞·àÖ·äì ·àò·å°! ·àò·àà·ã´·ãé ·ä†·àÅ·äï ·äê·âÖ·â∑·àç·ç¢',
      'loginToYourAccount': '·ãà·ã∞ ·àò·àà·ã´·ãé ·ã≠·åç·â°',
      'loginWithPassword': '·â†·ã≠·àà·çç ·âÉ·àç ·ã≠·åç·â°',
      'loginWithOTP': '·â†OTP ·ã≠·åç·â°',
      'login': '·åç·â£',
      'sendingOTP': 'OTP ·â†·àõ·àµ·â∞·àã·àà·çç ·àã·ã≠...',
      'createNewBusiness': '·ä†·ã≤·àµ ·äï·åç·ãµ ·ã≠·çç·å†·à©',
      'otpSentSuccessfully': 'OTP ·â†·â∞·à≥·ä´ ·àÅ·äî·â≥ ·â∞·àç·â∑·àç',
      'WelcomeBack': '·ä•·äï·ä≥·äï ·ã∞·åç·àû ·â†·ã∞·àÖ·äì ·àò·å°!',
      'enterCredentialsToContinue': '·ã®·åç·â£ ·ãù·à≠·ãù·àÆ·âΩ·ãé·äï ·ã´·àµ·åà·â°',
      'featureComingSoon': '·â†·âÖ·à≠·â• ·ã≠·å†·â•·âÅ·äï!',
      'forgotPassword': '·ã®·ã≠·àà·çç ·âÉ·àç·ãé·äï ·à®·àµ·â∞·ãã·àç?',
      'or': '·ãà·ã≠·àù',
      // 'forgotPassword': 'Forgot Password',
      'resetYourPassword': '·ã®·ã≠·àà·çç ·âÉ·àç·ãé·äï ·ã≠·âÄ·ã≠·à©',
      'enterPhoneToResetPassword': '·ã®·ã≠·àà·çç ·âÉ·àç ·àà·àò·âÄ·ã®·à≠ ·àµ·àç·ä≠ ·âÅ·å•·à≠·ãé·äï ·ã´·àµ·åà·â°',
      'verifyAndReset': '·ã´·à®·åã·åç·å° ·ä•·äì ·ã≠·âÄ·ã≠·à©',
      'enterOTPAndNewPassword':
          '·ãà·ã∞ ·àµ·àç·ä≠·ãé ·ã®·â∞·àã·ä®·ãç·äï OTP ·äÆ·ãµ ·ã´·àµ·åà·â° ·ä•·äì ·ä†·ã≤·àµ ·ã®·ã≠·àà·çç ·âÉ·àç ·ã´·àµ·âÄ·àù·å°',
      // 'newPassword': 'New Password',
      // 'confirmNewPassword': 'Confirm New Password',
      'resetPassword': '·ã®·ã≠·àà·çç ·âÉ·àç ·ã≠·âÄ·ã≠·à©',
      'passwordResetSuccessfully': '·ã®·ã≠·àà·çç ·âÉ·àç·ãé ·â†·â∞·à≥·ä´ ·àÅ·äî·â≥ ·â∞·âÄ·ã≠·àØ·àç!',
      'youCanNowLoginWithNewPassword': '·ä†·àÅ·äï ·â†·ä†·ã≤·à± ·ã®·ã≠·àà·çç ·âÉ·àç ·àò·åç·â£·âµ ·ã≠·âΩ·àã·àâ·ç¢',
      'backToLogin': '·ãà·ã∞ ·àò·åç·â¢·ã´·ãâ ·ã≠·àò·àà·à±',
      'resendingOTP': 'OTP ·ä•·äï·ã∞·åà·äì ·â†·àò·àã·ä≠ ·àã·ã≠...',
      'otpVerifiedSuccessfully': 'OTP ·â†·â∞·à≥·ä´ ·àÅ·äî·â≥ ·â∞·à®·åã·åç·åß·àç!',
      'instantPayment': '·ä†·åà·äì·äù ·ä≠·çç·ã´',
      'mobileBanking': '·àû·â£·ã≠·àç ·â£·äï·ä™·äï·åç',
      'onlinePayment': '·àò·àµ·àò·à≠ ·àã·ã≠ ·ä≠·çç·ã´',
      'securePayment': '·ã∞·àÖ·äï·äê·â≥·ãä ·ä≠·çç·ã´',
    }

};

String translate(String key, {Map<String, String>? params}) {
String translation = \_localizedValues[locale.languageCode]?[key] ?? key;

    if (params != null) {
      params.forEach((paramKey, paramValue) {
        translation = translation.replaceAll('{$paramKey}', paramValue);
      });
    }

    return translation;

}

// Convenience methods for common translations
String get appTitle => translate('appTitle');
String get dashboard => translate('dashboard');
String get pointOfSale => translate('pointOfSale');
String get salesHistory => translate('salesHistory');
String get customers => translate('customers');
String get products => translate('products');
String get categories => translate('categories');
String get settings => translate('settings');
String get todayRevenue => translate('todayRevenue');
String get todayOrders => translate('todayOrders');
String get searchProducts => translate('searchProducts');
String get shoppingCart => translate('shoppingCart');
String get totalAmount => translate('totalAmount');
String get completeSale => translate('completeSale');
String get light => translate('light');
String get dark => translate('dark');
String get systemDefault => translate('systemDefault');
String get english => translate('english');
String get amharic => translate('amharic');
String get themeMode => translate('themeMode');
String get language => translate('language');
String get appearanceLanguage => translate('appearanceLanguage');
String get businessInformation => translate('businessInformation');
String get shopNameEnglish => translate('shopNameEnglish');
String get shopNameAmharic => translate('shopNameAmharic');
String get address => translate('address');
String get phone => translate('phone');
String get tinNumber => translate('tinNumber');
String get account => translate('account');
String get accountSettings => translate('accountSettings');
String get security => translate('security');
String get changePassword => translate('changePassword');
String get currentPassword => translate('currentPassword');
String get newPassword => translate('newPassword');
String get confirmNewPassword => translate('confirmNewPassword');
String get weeklySales => translate('weeklySales');
String get orders => translate('orders');
String get refresh => translate('refresh');
String get performanceOverview => translate('performanceOverview');
String get customersWithBalance => translate('customersWithBalance');
String get overdueAmount => translate('overdueAmount');
String get today => translate('today');
String get completeFirstSale => translate('completeFirstSale');
String get stockAlert => translate('stockAlert');
String get quickActions => translate('quickActions');
String get newSale => translate('newSale');
String get addProduct => translate('addProduct');
String get addCustomer => translate('addCustomer');
String get reports => translate('reports');
String get salesAnalytics => translate('salesAnalytics');
String get chartsComingSoon => translate('chartsComingSoon');
String get installFlChart => translate('installFlChart');
String get cash => translate('cash');
String get telebirr => translate('telebirr');
String get card => translate('card');
String get credit => translate('credit');
String get bankTransfer => translate('bankTransfer');
String get errorLoadingData => translate('errorLoadingData');
String get settingsSaved => translate('settingsSaved');
String get settingsReset => translate('settingsReset');
String get databaseNeedsUpdate => translate('databaseNeedsUpdate');
String get tryAgain => translate('tryAgain');
String get up => translate('up');
String get down => translate('down');
String get sale => translate('sale');
String get recentSales => translate('recentSales');
String get noSalesToday => translate('noSalesToday');
String get noProductsFound => translate('noProductsFound');
String get yourCartEmpty => translate('yourCartEmpty');
String get addProductsGetStarted => translate('addProductsGetStarted');
String get saleCompleted => translate('saleCompleted');
String get areYouSureYouWantToLogout =>
translate('Are you sure you want to logout?');
String get clearAll => translate('clearAll');
String get selectPaymentMethod => translate('selectPaymentMethod');
String get confirm => translate('confirm');
String get cancel => translate('cancel');
String get defaultPaymentMethod => translate('defaultPaymentMethod');
String get posSettings => translate('posSettings');
String get autoPrintReceipts => translate('autoPrintReceipts');
String get enableCustomerSelection => translate('enableCustomerSelection');
String get creditSettings => translate('creditSettings');
String get enableCreditSystem => translate('enableCreditSystem');
String get defaultCreditLimit => translate('defaultCreditLimit');
String get defaultPaymentTerms => translate('defaultPaymentTerms');
String get syncSettings => translate('syncSettings');
String get enableDataSync => translate('enableDataSync');
String get syncInterval => translate('syncInterval');
String get advancedSettings => translate('advancedSettings');
String get enableTax => translate('enableTax');
String get taxRate => translate('taxRate');
String get enableDiscounts => translate('enableDiscounts');
String get lowStockNotifications => translate('lowStockNotifications');
String get lowStockThreshold => translate('lowStockThreshold');
String get dangerZone => translate('dangerZone');
String get resetToDefaults => translate('resetToDefaults');
String get tryAgainText => translate('tryAgain');
String get todayOrdersText => translate('todayOrders');
String get noOrdersToday => translate('noOrdersToday');
String get noOrdersTodayText => translate('noOrdersTodayText');
String get averageOrderValue => translate('averageOrderValue');
String get totalRevenue => translate('totalRevenue');
String get totalOrders => translate('totalOrders');
String get salesPerformance => translate('salesPerformance');
String get creditOverview => translate('creditOverview');
String get outstandingCredit => translate('outstandingCredit');
String get overdue => translate('overdue');
String get moreProducts => translate('moreProducts');
String get allProductsWellStocked => translate('allProductsWellStocked');
String get left => translate('left');
String get calendarSettings => translate('calendarSettings');
String get calendarType => translate('calendarType');
String get calendarDescription => translate('calendarDescription');
String get fontSize => translate('fontSize');
String get small => translate('small');
String get large => translate('large');
String get itemsSold => translate('items sold');
String get withBalance => translate('with balance');
String get outstanding => translate('outstanding');
String get thisMonth => translate('thisMonth');
String get productsReport => translate('productsReport');
String get customersReport => translate('customersReport');
String get financialReport => translate('financialReport');
String get selectDateRange => translate('selectDateRange');
String get basicPlanFeatures => translate('basicPlanFeatures');
String get professionalPlanFeatures => translate('professionalPlanFeatures');
String get enterprisePlanFeatures => translate('enterprisePlanFeatures');
String get plan => translate('plan');
String get basicReportsDescription => translate('basicReportsDescription');
String get professionalReportsDescription =>
translate('professionalReportsDescription');
String get enterpriseReportsDescription =>
translate('enterpriseReportsDescription');
String get upgradeForAdvancedReports =>
translate('upgradeForAdvancedReports');
String get upgrade => translate('upgrade');
String get professionalPlanRequired => translate('professionalPlanRequired');
String get enterprisePlanRequired => translate('enterprisePlanRequired');
String get productsReportAvailableInPlan =>
translate('productsReportAvailableInPlan');
String get customersReportAvailableInPlan =>
translate('customersReportAvailableInPlan');
String get financialReportAvailableInPlan =>
translate('financialReportAvailableInPlan');
String get upgradeYourPlan => translate('upgradeYourPlan');
String get upgradeForAdvancedAnalytics =>
translate('upgradeForAdvancedAnalytics');
String get viewPlans => translate('viewPlans');
String get salesByPaymentMethod => translate('salesByPaymentMethod');
String get revenueByDay => translate('revenueByDay');
String get dailySalesTrend => translate('dailySalesTrend');
String get topSellingHours => translate('topSellingHours');
String get customerRetention => translate('customerRetention');
String get salesVelocity => translate('salesVelocity');
String get profitMarginAnalysis => translate('profitMarginAnalysis');
String get inventoryTurnover => translate('inventoryTurnover');
String get abcAnalysis => translate('abcAnalysis');
String get stockOptimization => translate('stockOptimization');
String get productsOverview => translate('productsOverview');
String get totalProducts => translate('totalProducts');
String get lowStock => translate('lowStock');
String get outOfStock => translate('outOfStock');
String get topSellingProducts => translate('topSellingProducts');
String get sold => translate('sold');
String get customersOverview => translate('customersOverview');
String get topCustomers => translate('topCustomers');
String get customerAcquisition => translate('customerAcquisition');
String get averageCustomerValue => translate('averageCustomerValue');
String get customerLifetimeValue => translate('customerLifetimeValue');
String get churnRiskAnalysis => translate('churnRiskAnalysis');
String get financialOverview => translate('financialOverview');
String get revenueTrend => translate('revenueTrend');
String get profitMarginTrend => translate('profitMarginTrend');
String get cashFlowAnalysis => translate('cashFlowAnalysis');
String get financialRatios => translate('financialRatios');
String get breakEvenAnalysis => translate('breakEvenAnalysis');
String get advancedAnalyticsFeature => translate('advancedAnalyticsFeature');
String get subscriptionPlans => translate('subscriptionPlans');
String get choosePerfectPlan => translate('choosePerfectPlan');
String get startWithFreeTrial => translate('startWithFreeTrial');
String get monthly => translate('monthly');
String get yearly => translate('yearly');
String get save20Percent => translate('save20Percent');
String get popular => translate('popular');
String get selected => translate('selected');
String get selectPlan => translate('selectPlan');
String get paymentMethod => translate('paymentMethod');
String get orderSummary => translate('orderSummary');
String get price => translate('price');
String get tax => translate('tax');
String get total => translate('total');
String get subscribeNow => translate('subscribeNow');
String get salesOverview => translate('salesOverview');
String get item => translate('item');
String get qty => translate('qty');
String get subtotal => translate('subtotal');
String get discount => translate('discount');
String get telebirrReference => translate('telebirrReference');
String get thankYou => translate('thankYou');
String get receipt => translate('receipt');
String get time => translate('time');
String get scanBarcode => translate('scanBarcode');
String get scan => translate('scan');
String get selectCustomer => translate('selectCustomer');
String get creditAvailable => translate('creditAvailable');
String get connectedTo => translate('connectedTo');
String get noPrinterConnected => translate('noPrinterConnected');
String get testPrint => translate('testPrint');
String get tryAdjustingSearch => translate('tryAdjustingSearch');
String get yesterday => translate('yesterday');
String get thisWeek => translate('thisWeek');
String get lastWeek => translate('lastWeek');
String get lastMonth => translate('lastMonth');
String get last3Months => translate('last3Months');
String get last6Months => translate('last6Months');
String get thisYear => translate('thisYear');
String get lastYear => translate('lastYear');
String get cashInHand => translate('cashInHand');
String get registerBusiness => translate('registerBusiness');
String get adminAccount => translate('adminAccount');
String get subscriptionPlan => translate('subscriptionPlan');
String get reviewRegistration => translate('reviewRegistration');
String get verifyPhone => translate('verifyPhone');
String get businessNameEnglish => translate('businessNameEnglish');
String get businessNameAmharic => translate('businessNameAmharic');
String get businessPhone => translate('businessPhone');
String get businessEmailOptional => translate('businessEmailOptional');
String get businessAddress => translate('businessAddress');
String get ownerName => translate('ownerName');
String get ownerPhone => translate('ownerPhone');
String get ownerEmailOptional => translate('ownerEmailOptional');
String get yourName => translate('yourName');
String get yourPhone => translate('yourPhone');
String get yourEmailOptional => translate('yourEmailOptional');
String get password => translate('password');
String get confirmPassword => translate('confirmPassword');
String get chooseSubscriptionPlan => translate('chooseSubscriptionPlan');
String get recommended => translate('recommended');
String get premium => translate('premium');
String get standard => translate('standard');
String get reviewYourRegistration => translate('reviewYourRegistration');
String get freeTrialNotice => translate('freeTrialNotice');
String get verifyYourPhone => translate('verifyYourPhone');
String get otpSentTo => translate('otpSentTo');
String get enterOTP => translate('enterOTP');
String get didNotReceiveOTP => translate('didNotReceiveOTP');
String get resendOTP => translate('resendOTP');
String get completeRegistration => translate('completeRegistration');
String get verifyOTP => translate('verifyOTP');
String get back => translate('back');
String get isRequired => translate('isRequired');
String get phoneRequired => translate('phoneRequired');
String get validEthiopianPhone => translate('validEthiopianPhone');
String get validEmail => translate('validEmail');
String get passwordRequired => translate('passwordRequired');
String get passwordMinLength => translate('passwordMinLength');
String get tinRequired => translate('tinRequired');
String get tinMinLength => translate('tinMinLength');
String get otpRequired => translate('otpRequired');
String get otpLength => translate('otpLength');
String get passwordsDoNotMatch => translate('passwordsDoNotMatch');
String get registrationSuccessful => translate('registrationSuccessful');
String get otpSentToPhone => translate('otpSentToPhone');
String get enterOTPCode => translate('enterOTPCode');
String get verifyAndContinue => translate('verifyAndContinue');
String get didNotReceiveCode => translate('didNotReceiveCode');
String get resendAvailableIn => translate('resendAvailableIn');
String get forBusiness => translate('forBusiness');
String get otpMustBe6Digits => translate('otpMustBe6Digits');
String get otpMustBeNumbers => translate('otpMustBeNumbers');
String get otpResentSuccessfully => translate('otpResentSuccessfully');
String get registrationComplete => translate('registrationComplete');
String get invalidOrExpiredOTP => translate('invalidOrExpiredOTP');
// Add these getters to your translation service/class
String get shopRegistration => translate('shopRegistration');
String get ownerAccount => translate('ownerAccount');
String get payment => translate('payment');
String get setupYourShop => translate('setupYourShop');
String get enterShopDetails => translate('enterShopDetails');
String get shopName => translate('shopName');
String get shopCategory => translate('shopCategory');
String get phoneNumber => translate('phoneNumber');
String get city => translate('city');
String get country => translate('country');
String get shopCategoryRequired => translate('shopCategoryRequired');
String get createOwnerAccount => translate('createOwnerAccount');
String get setupOwnerDetails => translate('setupOwnerDetails');
String get fullName => translate('fullName');
String get passwordRequirements => translate('passwordRequirements');
String get min6Characters => translate('min6Characters');
String get recommendSpecialChars => translate('recommendSpecialChars');
String get steps => translate('steps');
String get shop => translate('shop');
String get owner => translate('owner');
String get verify => translate('verify');
String get basic => translate('basic');
String get professional => translate('professional');
String get cbeBirr => translate('cbeBirr');
String get chapa => translate('chapa');
String get choosePaymentMethod => translate('choosePaymentMethod');
String get processPayment => translate('processPayment');
String get paymentSuccessful => translate('paymentSuccessful');
String get setupStaffAccounts => translate('setupStaffAccounts');
String get addAdminsCashiersManagers =>
translate('addAdminsCashiersManagers');
String get getStarted => translate('getStarted');
String get chooseYourPlan => translate('chooseYourPlan');
String get billingCycle => translate('billingCycle');
String get completePayment => translate('completePayment');
String get paymentMethods => translate('paymentMethods');
String get welcomeToAndalusPOS => translate('welcomeToAndalusPOS');
String get loginToYourAccount => translate('loginToYourAccount');
String get loginWithPassword => translate('loginWithPassword');
String get loginWithOTP => translate('loginWithOTP');
String get login => translate('login');
String get sendingOTP => translate('sendingOTP');
String get createNewBusiness => translate('createNewBusiness');
String get otpSentSuccessfully => translate('otpSentSuccessfully');
String get welcomeBack => translate('welcomeBack');
String get enterCredentialsToContinue =>
translate('enterCredentialsToContinue');
String get featureComingSoon => translate('featureComingSoon');
String get forgotPassword => translate('forgotPassword');
String get or => translate('or');
String get resetYourPassword => translate('resetYourPassword');
String get enterPhoneToResetPassword =>
translate('enterPhoneToResetPassword');
String get verifyAndReset => translate('verifyAndReset');
String get enterOTPAndNewPassword => translate('enterOTPAndNewPassword');
String get resetPassword => translate('resetPassword');
String get passwordResetSuccessfully =>
translate('passwordResetSuccessfully');
String get youCanNowLoginWithNewPassword =>
translate('youCanNowLoginWithNewPassword');
String get backToLogin => translate('backToLogin');
String get resendingOTP => translate('resendingOTP');
String get otpVerifiedSuccessfully => translate('otpVerifiedSuccessfully');
String get instantPayment => translate('instantPayment');
String get mobileBanking => translate('mobileBanking');
String get onlinePayment => translate('onlinePayment');
String get securePayment => translate('securePayment');
}

class \_AppLocalizationsDelegate
extends LocalizationsDelegate<AppLocalizations> {
const \_AppLocalizationsDelegate();

@override
bool isSupported(Locale locale) {
return ['en', 'am'].contains(locale.languageCode);
}

@override
Future<AppLocalizations> load(Locale locale) {
return SynchronousFuture<AppLocalizations>(AppLocalizations(locale));
}

@override
bool shouldReload(\_AppLocalizationsDelegate old) => false;
}

##

// src/providers/auth_provider.dart
// Provider for managing authentication state and actions.
import 'package:andalus_smart_pos/src/data/local/database.dart';
import 'package:andalus_smart_pos/src/service/auth_service.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/data/models/user.dart';
import 'package:andalus_smart_pos/src/data/repositories/user_repository.dart';
import 'package:andalus_smart_pos/src/data/repositories/otp_repository.dart';
import 'package:andalus_smart_pos/src/data/repositories/subscription_repository.dart';

// Repository Providers
final userRepositoryProvider = Provider<UserRepository>((ref) {
return UserRepository();
});

final otpRepositoryProvider = Provider<OTPRepository>((ref) {
return OTPRepository();
});

final subscriptionRepositoryProvider = Provider<SubscriptionRepository>((ref) {
return SubscriptionRepository();
});

// Auth Service Provider
final authServiceProvider = Provider<AuthService>((ref) {
return AuthService(
userRepository: ref.read(userRepositoryProvider),
otpRepository: ref.read(otpRepositoryProvider),
subscriptionRepository: ref.read(subscriptionRepositoryProvider),
);
});

// Auth State
class AuthState {
final User? user;
final bool isLoading;
final String? error;
final bool isAuthenticated;
final AuthMethod authMethod;

const AuthState({
this.user,
this.isLoading = false,
this.error,
this.authMethod = AuthMethod.none,
}) : isAuthenticated = user != null;

AuthState copyWith({
User? user,
bool? isLoading,
String? error,
AuthMethod? authMethod,
}) {
return AuthState(
user: user ?? this.user,
isLoading: isLoading ?? this.isLoading,
error: error,
authMethod: authMethod ?? this.authMethod,
);
}
}

enum AuthMethod {
none,
password,
otp,
}

class AuthNotifier extends StateNotifier<AuthState> {
final Ref \_ref;

AuthNotifier(this.\_ref) : super(const AuthState());

Future<void> loginWithPassword(String phone, String password) async {
print('üîê Password login for: $phone');
state = state.copyWith(
isLoading: true, error: null, authMethod: AuthMethod.password);

    try {
      final authService = _ref.read(authServiceProvider);
      final user = await authService.loginWithPassword(phone, password);
      state = state.copyWith(user: user, isLoading: false);
      print('‚úÖ Password login successful for: ${user.name}');
    } catch (e) {
      print('‚ùå Password login error: $e');
      state = state.copyWith(isLoading: false, error: e.toString());
      rethrow;
    }

}

Future<void> sendOTP(String phone) async {
print('üì± Sending OTP for: $phone');
state = state.copyWith(isLoading: true, error: null);

    try {
      final authService = _ref.read(authServiceProvider);
      await authService.sendLoginOTP(phone);
      state = state.copyWith(isLoading: false, authMethod: AuthMethod.otp);
      print('‚úÖ OTP sent successfully');
    } catch (e) {
      print('‚ùå OTP send error: $e');
      state = state.copyWith(isLoading: false, error: e.toString());
      rethrow;
    }

}

Future<void> verifyOTPAndLogin(String phone, String code) async {
print('üîê Verifying OTP and logging in: $phone');
state = state.copyWith(
isLoading: true, error: null, authMethod: AuthMethod.otp);

    try {
      final authService = _ref.read(authServiceProvider);
      final user = await authService.loginWithOTP(phone, code);
      state = state.copyWith(user: user, isLoading: false);
      print('‚úÖ OTP login successful for: ${user.name}');
    } catch (e, stackTrace) {
      print('‚ùå OTP login error: $e');
      print('üìã FULL STACK TRACE: $stackTrace');
      state = state.copyWith(isLoading: false, error: e.toString());
      rethrow;
    }

}

void logout() {
print('üö™ Logging out user');
state = const AuthState();
}

void clearError() {
state = state.copyWith(error: null);
}

// Check if user exists (for navigation)
Future<bool> checkUserExists(String phone) async {
try {
final userRepository = \_ref.read(userRepositoryProvider);
final user = await userRepository.getUserByPhone(phone);
return user != null;
} catch (e) {
return false;
}
}
}

final authProvider = StateNotifierProvider<AuthNotifier, AuthState>((ref) {
return AuthNotifier(ref);
});

##

// providers/calendar_provider.dart
import 'dart:convert';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';

enum CalendarType {
gregorian,
ethiopian,
}

class CalendarSettings {
final CalendarType calendarType;
final double fontSizeScale;

const CalendarSettings({
this.calendarType = CalendarType.gregorian,
this.fontSizeScale = 1.0,
});

CalendarSettings copyWith({
CalendarType? calendarType,
double? fontSizeScale,
}) {
return CalendarSettings(
calendarType: calendarType ?? this.calendarType,
fontSizeScale: fontSizeScale ?? this.fontSizeScale,
);
}

Map<String, dynamic> toMap() {
return {
'calendar_type': calendarType.name,
'font_size_scale': fontSizeScale,
};
}

factory CalendarSettings.fromMap(Map<String, dynamic> map) {
return CalendarSettings(
calendarType: CalendarType.values.firstWhere(
(e) => e.name == map['calendar_type'],
orElse: () => CalendarType.gregorian,
),
fontSizeScale: map['font_size_scale']?.toDouble() ?? 1.0,
);
}
}

final calendarProvider =
StateNotifierProvider<CalendarNotifier, CalendarSettings>(
(ref) => CalendarNotifier(),
);

class CalendarNotifier extends StateNotifier<CalendarSettings> {
CalendarNotifier() : super(const CalendarSettings()) {
\_loadSettings();
}

static const String \_settingsKey = 'calendar_settings';

Future<void> \_loadSettings() async {
try {
final prefs = await SharedPreferences.getInstance();
final settingsString = prefs.getString(\_settingsKey);

      if (settingsString != null && settingsString.isNotEmpty) {
        try {
          final settingsMap =
              Map<String, dynamic>.from(json.decode(settingsString));
          state = CalendarSettings.fromMap(settingsMap);
        } catch (e) {
          print('Error parsing calendar settings: $e');
          // Fallback to default settings
          final calendarIndex = prefs.getInt('preferred_calendar') ?? 0;
          state = CalendarSettings(
            calendarType: CalendarType.values[calendarIndex],
            fontSizeScale: 1.0,
          );
        }
      } else {
        // Legacy support for old preference format
        final calendarIndex = prefs.getInt('preferred_calendar') ?? 0;
        state = CalendarSettings(
          calendarType: CalendarType.values[calendarIndex],
          fontSizeScale: 1.0,
        );
      }
    } catch (e) {
      print('Error loading calendar settings: $e');
      state = const CalendarSettings();
    }

}

Future<void> setCalendarType(CalendarType type) async {
state = state.copyWith(calendarType: type);
await \_saveSettings();
}

Future<void> setFontSizeScale(double scale) async {
state = state.copyWith(fontSizeScale: scale.clamp(0.8, 1.5));
await \_saveSettings();
}

Future<void> \_saveSettings() async {
try {
final prefs = await SharedPreferences.getInstance();
await prefs.setString(\_settingsKey, json.encode(state.toMap()));
// Also save legacy format for compatibility
await prefs.setInt('preferred_calendar', state.calendarType.index);
} catch (e) {
print('Error saving calendar settings: $e');
}
}
}

##

// mobile/lib/src/providers/cart_provider.dart
// Provider for managing the shopping cart state.
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/data/models/cart_item.dart';

final cartProvider = StateNotifierProvider<CartNotifier, List<CartItem>>((ref) {
return CartNotifier();
});

class CartNotifier extends StateNotifier<List<CartItem>> {
CartNotifier() : super([]);

// Getters for cart calculations
double get subtotalAmount {
return state.fold(0, (total, item) => total + item.totalPrice);
}

double get taxAmount {
// Assuming 15% tax rate - you can make this configurable
return subtotalAmount \* 0.15;
}

double get totalAmount {
return subtotalAmount + taxAmount;
}

int get totalItems {
return state.fold(0, (total, item) => total + item.quantity);
}

// Cart operations
void addProduct({
required int productId,
required String productName,
required double unitPrice,
int quantity = 1,
}) {
final existingIndex =
state.indexWhere((item) => item.productId == productId);

    if (existingIndex != -1) {
      // Update existing item
      final existingItem = state[existingIndex];
      final newQuantity = existingItem.quantity + quantity;
      final updatedItem = existingItem.copyWith(quantity: newQuantity);

      state = [
        ...state.sublist(0, existingIndex),
        updatedItem,
        ...state.sublist(existingIndex + 1),
      ];
    } else {
      // Add new item
      final newItem = CartItem(
        productId: productId,
        productName: productName,
        unitPrice: unitPrice,
        quantity: quantity,
      );
      state = [...state, newItem];
    }

}

void updateQuantity(int productId, int newQuantity) {
if (newQuantity <= 0) {
removeProduct(productId);
return;
}

    final index = state.indexWhere((item) => item.productId == productId);
    if (index != -1) {
      final updatedItem = state[index].copyWith(quantity: newQuantity);
      state = [
        ...state.sublist(0, index),
        updatedItem,
        ...state.sublist(index + 1),
      ];
    }

}

void removeProduct(int productId) {
state = state.where((item) => item.productId != productId).toList();
}

void clearCart() {
state = [];
}

// Helper methods
bool containsProduct(int productId) {
return state.any((item) => item.productId == productId);
}

int getProductQuantity(int productId) {
final item = state.firstWhere(
(item) => item.productId == productId,
orElse: () => CartItem(
productId: -1,
productName: '',
unitPrice: 0,
quantity: 0,
),
);
return item.productId == -1 ? 0 : item.quantity;
}

// Apply discount to entire cart (optional feature)
void applyDiscount(double discountPercentage) {
// This would modify the cart items with discounted prices
// Implementation depends on your discount strategy
}

// Apply tax (optional - you might want to handle this differently)
void setTaxRate(double taxRate) {
// Store tax rate and recalculate totals
}
}

##

// mobile/lib/src/providers/language_provider.dart
// Provider for managing application language settings.
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';

final languageProvider = StateNotifierProvider<LanguageNotifier, Locale>((ref) {
return LanguageNotifier();
});

class LanguageNotifier extends StateNotifier<Locale> {
LanguageNotifier() : super(const Locale('en', 'US')) {
\_loadLanguage();
}

static const String \_languageKey = 'app_language';

Future<void> \_loadLanguage() async {
try {
final prefs = await SharedPreferences.getInstance();
final languageCode = prefs.getString(\_languageKey) ?? 'en';
state = Locale(languageCode);
} catch (e) {
print('Error loading language: $e');
state = const Locale('en');
}
}

Future<void> setLanguage(String languageCode) async {
try {
state = Locale(languageCode);
final prefs = await SharedPreferences.getInstance();
await prefs.setString(\_languageKey, languageCode);
} catch (e) {
print('Error saving language: $e');
}
}

void toggleLanguage() {
final newLanguage = state.languageCode == 'en' ? 'am' : 'en';
setLanguage(newLanguage);
}

String get currentLanguage => state.languageCode;

bool get isEnglish => state.languageCode == 'en';
bool get isAmharic => state.languageCode == 'am';
}

##

// mobile/lib/src/providers/onboarding_provider.dart
// Provider for managing the onboarding and registration process.
import 'dart:async';

import 'package:andalus_smart_pos/src/providers/auth_provider.dart';
import 'package:andalus_smart_pos/src/providers/providers.dart'
hide authServiceProvider, otpRepositoryProvider;
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/data/models/shop_registration.dart';
import 'package:andalus_smart_pos/src/data/models/subscription.dart';
import 'package:andalus_smart_pos/src/service/registration_service.dart';
import 'package:andalus_smart_pos/src/service/auth_service.dart';

class OnboardingState {
final int currentStep;
final ShopRegistration? shop;
final OwnerRegistration? owner;
final SubscriptionPlan? selectedPlan;
final BillingCycle? billingCycle;
final bool isLoading;
final bool isSuccess;
final String? error;
final bool isVerifyingOTP;
final String? registeredPhone;
final String? tempBusinessId;
final String? tempUserId;
final int otpResendCooldown;

const OnboardingState({
this.currentStep = 0,
this.shop,
this.owner,
this.selectedPlan,
this.billingCycle,
this.isLoading = false,
this.isSuccess = false,
this.error,
this.isVerifyingOTP = false,
this.registeredPhone,
this.tempBusinessId,
this.tempUserId,
this.otpResendCooldown = 0,
});

OnboardingState copyWith({
int? currentStep,
ShopRegistration? shop,
OwnerRegistration? owner,
SubscriptionPlan? selectedPlan,
BillingCycle? billingCycle,
bool? isLoading,
bool? isSuccess,
String? error,
bool? isVerifyingOTP,
String? registeredPhone,
String? tempBusinessId,
String? tempUserId,
int? otpResendCooldown,
}) {
return OnboardingState(
currentStep: currentStep ?? this.currentStep,
shop: shop ?? this.shop,
owner: owner ?? this.owner,
selectedPlan: selectedPlan ?? this.selectedPlan,
billingCycle: billingCycle ?? this.billingCycle,
isLoading: isLoading ?? this.isLoading,
isSuccess: isSuccess ?? this.isSuccess,
error: error,
isVerifyingOTP: isVerifyingOTP ?? this.isVerifyingOTP,
registeredPhone: registeredPhone ?? this.registeredPhone,
tempBusinessId: tempBusinessId ?? this.tempBusinessId,
tempUserId: tempUserId ?? this.tempUserId,
otpResendCooldown: otpResendCooldown ?? this.otpResendCooldown,
);
}
}

class OnboardingNotifier extends StateNotifier<OnboardingState> {
final Ref \_ref;
final RegistrationService \_registrationService;
final AuthService \_authService;

OnboardingNotifier(this.\_ref)
: \_registrationService = \_ref.read(registrationServiceProvider),
\_authService = \_ref.read(authServiceProvider),
super(const OnboardingState());

void updateShopInfo(ShopRegistration shop) {
state = state.copyWith(shop: shop);
}

void updateOwnerInfo(OwnerRegistration owner) {
state = state.copyWith(owner: owner);
}

void selectPlan(SubscriptionPlan plan, BillingCycle billingCycle) {
state = state.copyWith(selectedPlan: plan, billingCycle: billingCycle);
}

void nextStep() {
if (state.currentStep < 4) {
state = state.copyWith(currentStep: state.currentStep + 1, error: null);
}
}

void previousStep() {
if (state.currentStep > 0) {
state = state.copyWith(currentStep: state.currentStep - 1, error: null);
}
}

Future<bool> \_verifyOTP(String phone, String code) async {
try {
// Use your existing OTP verification logic
if (code == '123456') return true; // Demo code

      final otp = await _ref
          .read(otpRepositoryProvider)
          .getValidOTP(phone, code, 'registration');
      if (otp != null) {
        await _ref.read(otpRepositoryProvider).markOTPAsUsed(otp.id);
        return true;
      }
      return false;
    } catch (e) {
      return false;
    }

}

Future<void> sendRegistrationOTP(String phone) async {
state = state.copyWith(isLoading: true, error: null);
try {
// Use the same type 'registration' for both sending and verifying
await \_authService.sendRegistrationOTP(phone);
\_startResendCooldown();
state = state.copyWith(
isLoading: false,
registeredPhone: phone,
);

      print('üì± Registration OTP sent to: $phone');
    } catch (e) {
      print('‚ùå Failed to send registration OTP: $e');
      state = state.copyWith(
        isLoading: false,
        error: 'Failed to send OTP: ${e.toString()}',
      );
    }

}

void \_startResendCooldown() {
const cooldownDuration = 60;
state = state.copyWith(otpResendCooldown: cooldownDuration);

    // 1. Declare the variable first (nullable)
    StreamSubscription? timer;

    // 2. Assign the subscription
    timer = Stream.periodic(const Duration(seconds: 1), (i) {
      final remaining = cooldownDuration - i - 1;

      if (remaining >= 0) {
        state = state.copyWith(otpResendCooldown: remaining);
      } else {
        state = state.copyWith(otpResendCooldown: 0);
        // 3. Now you can refer to 'timer' safely
        timer?.cancel();
      }
    }).listen((_) {});

}

Future<bool> verifyRegistrationOTP(String code) async {
print('üîÑ verifyRegistrationOTP called with code: $code');

    if (state.registeredPhone == null) {
      state = state.copyWith(error: 'Phone number not set');
      return false;
    }

    // Check if we're already verifying
    if (state.isVerifyingOTP) {
      print('‚ö†Ô∏è Already verifying OTP, ignoring duplicate call');
      return false;
    }

    state = state.copyWith(isVerifyingOTP: true, error: null);

    try {
      print('üîê Verifying OTP for: ${state.registeredPhone}');
      print('üîë OTP Code entered: $code');

      final otp = await _ref
          .read(otpRepositoryProvider)
          .getValidOTP(state.registeredPhone!, code, 'registration');

      if (otp == null) {
        print('‚ùå No valid OTP found for ${state.registeredPhone}');
        state = state.copyWith(
          isVerifyingOTP: false,
          error: 'Invalid or expired OTP code',
        );
        return false;
      }

      print('‚úÖ Valid OTP found, marking as used...');
      await _ref.read(otpRepositoryProvider).markOTPAsUsed(otp.id);

      // Create temporary registration after OTP verification
      if (state.shop != null &&
          state.owner != null &&
          state.selectedPlan != null &&
          state.billingCycle != null) {
        print('üè™ Creating temporary registration...');
        final result = await _registrationService.createTemporaryRegistration(
          shop: state.shop!,
          owner: state.owner!,
          plan: state.selectedPlan!,
          billingCycle: state.billingCycle!,
        );

        if (result.success) {
          print('‚úÖ Temporary registration created successfully');

          // Update state first
          state = state.copyWith(
            isVerifyingOTP: false,
            tempBusinessId: result.businessId,
            tempUserId: result.userId,
            error: null,
          );

          print('üöÄ Moving to next step...');
          // Then move to next step
          nextStep();

          return true;
        } else {
          print('‚ùå Temporary registration failed: ${result.error}');
          state = state.copyWith(
            isVerifyingOTP: false,
            error: result.error ?? 'Registration failed',
          );
          return false;
        }
      } else {
        print('‚ùå Incomplete registration data');
        state = state.copyWith(
          isVerifyingOTP: false,
          error: 'Registration data incomplete',
        );
        return false;
      }
    } catch (e, stackTrace) {
      print('‚ùå OTP verification error: $e');
      print('üìã Stack trace: $stackTrace');
      state = state.copyWith(
        isVerifyingOTP: false,
        error: 'OTP verification failed: ${e.toString()}',
      );
      return false;
    }

}

Future<bool> processPayment(
String paymentMethod, Map<String, dynamic> paymentDetails) async {
if (state.tempBusinessId == null || state.tempUserId == null) {
state = state.copyWith(error: 'Registration data missing');
return false;
}

    state = state.copyWith(isLoading: true, error: null);
    try {
      // Simulate payment processing
      await Future.delayed(const Duration(seconds: 2));

      // Generate payment reference
      final paymentReference = 'pay_${DateTime.now().millisecondsSinceEpoch}';
      final transactionId = 'txn_${DateTime.now().millisecondsSinceEpoch}';

      // Activate account after successful payment
      final result = await _registrationService.activateAccountAfterPayment(
        businessId: state.tempBusinessId!,
        userId: state.tempUserId!,
        paymentReference: paymentReference,
        transactionId: transactionId,
      );

      if (result.success) {
        state = state.copyWith(
          isLoading: false,
          isSuccess: true,
        );
        return true;
      } else {
        state = state.copyWith(
          isLoading: false,
          error: result.error,
        );
        return false;
      }
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: 'Payment processing failed: ${e.toString()}',
      );
      return false;
    }

}

void reset() {
state = const OnboardingState();
}

bool get canResendOTP => state.otpResendCooldown == 0;
}

final onboardingProvider =
StateNotifierProvider<OnboardingNotifier, OnboardingState>((ref) {
return OnboardingNotifier(ref);
});

##

// src/providers/providers.dart
// Provider definitions for repositories and services used in the application.
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/data/repositories/user_repository.dart';
import 'package:andalus_smart_pos/src/data/repositories/otp_repository.dart';
import 'package:andalus_smart_pos/src/data/repositories/subscription_repository.dart';
import 'package:andalus_smart_pos/src/service/auth_service.dart';
import 'package:andalus_smart_pos/src/service/registration_service.dart';

// Repository Providers
final userRepositoryProvider = Provider<UserRepository>((ref) {
return UserRepository();
});

final otpRepositoryProvider = Provider<OTPRepository>((ref) {
return OTPRepository();
});

final subscriptionRepositoryProvider = Provider<SubscriptionRepository>((ref) {
return SubscriptionRepository();
});

// Service Providers
final authServiceProvider = Provider<AuthService>((ref) {
return AuthService(
userRepository: ref.read(userRepositoryProvider),
otpRepository: ref.read(otpRepositoryProvider),
subscriptionRepository: ref.read(subscriptionRepositoryProvider),
);
});

final registrationServiceProvider = Provider<RegistrationService>((ref) {
return RegistrationService(
userRepository: ref.read(userRepositoryProvider),
subscriptionRepository: ref.read(subscriptionRepositoryProvider),
);
});

##

//src/providers/settings_provider.dart
// Provider for managing application settings.
import 'package:andalus_smart_pos/src/data/models/settings.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';
import "package:andalus_smart_pos/src/data/models/settings.dart";

final settingsProvider = AsyncNotifierProvider<SettingsNotifier, AppSettings>(
SettingsNotifier.new,
);

class SettingsNotifier extends AsyncNotifier<AppSettings> {
@override
Future<AppSettings> build() async {
try {
final repository = \_getRepository();
return await repository.getSettings();
} catch (e) {
print('Error building settings: $e');
// Return default settings as fallback
return \_getDefaultSettings();
}
}

SettingsRepository \_getRepository() {
return SettingsRepository(); // Your settings repository
}

AppSettings \_getDefaultSettings() {
return AppSettings(
shopName: 'Andalus Smart POS',
shopNameAm: '·ä†·äï·ã≥·àâ·àµ ·àõ·à≠·â≤·äï ·çñ·àµ',
address: 'Addis Ababa, Ethiopia',
phone: '+251 911 234 567',
tinNumber: 'TIN-123456789',
currency: 'ETB',
enableTax: false,
taxRate: 0.15,
enableDiscounts: true,
autoPrintReceipts: false,
defaultPaymentMethod: 'cash',
enableSync: true,
syncInterval: 5,
enableCreditSystem: true,
defaultCreditLimit: 1000.0,
defaultPaymentTerms: '30',
enableCustomerSelection: true,
lowStockNotifications: true,
lowStockThreshold: 10,
);
}

Future<void> updateSettings(AppSettings newSettings) async {
state = const AsyncValue.loading();
try {
final repository = \_getRepository();
await repository.saveSettings(newSettings);
state = AsyncValue.data(newSettings);
} catch (e, stackTrace) {
state = AsyncValue.error(e, stackTrace);
rethrow;
}
}

Future<void> resetToDefaults() async {
final defaultSettings = \_getDefaultSettings();
await updateSettings(defaultSettings);
}
}

// Simple Settings Repository for SharedPreferences
class SettingsRepository {
static const String \_settingsKey = 'app_settings';

Future<AppSettings> getSettings() async {
final prefs = await SharedPreferences.getInstance();
// In a real app, you'd parse JSON here
// For now, return default settings
return AppSettings(
shopName: 'Andalus Smart POS',
shopNameAm: '·ä†·äï·ã≥·àâ·àµ ·àõ·à≠·â≤·äï ·çñ·àµ',
address: 'Addis Ababa, Ethiopia',
phone: '+251 911 234 567',
tinNumber: 'TIN-123456789',
currency: 'ETB',
enableTax: false,
taxRate: 0.15,
enableDiscounts: true,
autoPrintReceipts: false,
defaultPaymentMethod: 'cash',
enableSync: true,
syncInterval: 5,
enableCreditSystem: true,
defaultCreditLimit: 1000.0,
defaultPaymentTerms: '30',
enableCustomerSelection: true,
lowStockNotifications: true,
lowStockThreshold: 10,
);
}

Future<void> saveSettings(AppSettings settings) async {
final prefs = await SharedPreferences.getInstance();
// In a real app, you'd convert to JSON here
await prefs.setString(\_settingsKey, 'settings_saved');
await Future.delayed(const Duration(milliseconds: 500)); // Simulate save
}
}

##

// providers/subscription_provider.dart
import 'package:andalus_smart_pos/src/data/models/subscription.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/data/repositories/subscription_repository.dart';

final subscriptionRepositoryProvider = Provider<SubscriptionRepository>((ref) {
return SubscriptionRepository();
});

final currentSubscriptionProvider = FutureProvider<Subscription?>((ref) async {
final repository = ref.read(subscriptionRepositoryProvider);
return await repository.getCurrentSubscription();
});

##

// mobile/lib/src/providers/theme_provider.dart
// Provider for managing application theme settings.
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';

final themeProvider = StateNotifierProvider<ThemeNotifier, ThemeMode>((ref) {
return ThemeNotifier();
});

class ThemeNotifier extends StateNotifier<ThemeMode> {
ThemeNotifier() : super(ThemeMode.light) {
\_loadTheme();
}

static const String \_themeKey = 'app_theme_mode';

Future<void> \_loadTheme() async {
try {
final prefs = await SharedPreferences.getInstance();
final themeIndex = prefs.getInt(\_themeKey) ?? 0;
state = ThemeMode.values[themeIndex];
} catch (e) {
print('Error loading theme: $e');
state = ThemeMode.light;
}
}

Future<void> setTheme(ThemeMode theme) async {
try {
state = theme;
final prefs = await SharedPreferences.getInstance();
await prefs.setInt(\_themeKey, theme.index);
} catch (e) {
print('Error saving theme: $e');
}
}

void toggleTheme() {
final newTheme =
state == ThemeMode.light ? ThemeMode.dark : ThemeMode.light;
setTheme(newTheme);
}
}

##

// src/service/auth_service.dart
// Service for handling authentication logic.
import 'package:crypto/crypto.dart';
import 'dart:convert';
import 'package:andalus_smart_pos/src/data/repositories/user_repository.dart';
import 'package:andalus_smart_pos/src/data/repositories/otp_repository.dart';
import 'package:andalus_smart_pos/src/data/repositories/subscription_repository.dart';
import 'package:andalus_smart_pos/src/data/models/user.dart';
import 'package:andalus_smart_pos/src/data/models/otp.dart';

class AuthService {
final UserRepository \_userRepository;
final OTPRepository \_otpRepository;
final SubscriptionRepository \_subscriptionRepository;

AuthService({
required UserRepository userRepository,
required OTPRepository otpRepository,
required SubscriptionRepository subscriptionRepository,
}) : \_userRepository = userRepository,
\_otpRepository = otpRepository,
\_subscriptionRepository = subscriptionRepository;

String \_hashPassword(String password) {
final bytes = utf8.encode(password);
final digest = sha256.convert(bytes);
return digest.toString();
}

Future<void> verifyOTPAndRegister(
String phone,
String code,
User user,
) async {
print('üîê OTP Registration for: $phone');

    try {
      // 1. Verify OTP
      final otp = await _otpRepository.getValidOTP(phone, code, 'registration');
      if (otp == null) {
        throw Exception('Invalid or expired OTP code. Please try again.');
      }

      // 2. Mark OTP as used
      await _otpRepository.markOTPAsUsed(otp.id);

      // 3. Check if user already exists
      final existingUser = await _userRepository.getUserByPhone(phone);
      if (existingUser != null) {
        throw Exception(
            'An account already exists with this phone number. Please login instead.');
      }

      // 4. Hash the password before saving
      final hashedPassword = _hashPassword(user.passwordHash ?? '');

      // 5. Create new user with verified status
      final newUser = user.copyWith(
        phone: phone,
        passwordHash: hashedPassword,
        isVerified: true,
        isActive: true,
      );
      await _userRepository.createUser(newUser);

      // 6. Update last login
      await _userRepository.updateLastLogin(newUser.id);

      print('‚úÖ Registration successful for: ${user.name}');
    } catch (e) {
      print('‚ùå OTP registration error: $e');
      rethrow;
    }

}

// Password-based login
Future<User> loginWithPassword(String phone, String password) async {
print('üîê Password login attempt for: $phone');

    try {
      // Get user by phone
      final user = await _userRepository.getUserByPhone(phone);
      if (user == null) {
        throw Exception(
            'No account found with this phone number. Please register first.');
      }

      if (!user.isActive) {
        throw Exception('Account is deactivated. Please contact support.');
      }

      // Verify password
      final hashedPassword = _hashPassword(password);
      if (user.passwordHash != hashedPassword) {
        throw Exception('Invalid password. Please try again.');
      }

      if (!user.isVerified) {
        throw Exception('Account not verified. Please complete verification.');
      }

      // Update last login
      await _userRepository.updateLastLogin(user.id);

      // Check subscription status
      final hasValidSubscription = await _subscriptionRepository
          .hasValidSubscription(user.businessId ?? '');
      if (!hasValidSubscription) {
        print('‚ö†Ô∏è No active subscription found for user: ${user.id}');
      }

      print('‚úÖ Password login successful for: ${user.name}');
      return user;
    } catch (e) {
      print('‚ùå Password login error: $e');
      rethrow;
    }

}

// Enhanced OTP-based login with better error handling
Future<User> loginWithOTP(String phone, String code) async {
print('üîê OTP login attempt for: $phone');

    // Validate inputs
    if (phone.isEmpty) {
      throw Exception('Phone number not set');
    }

    if (code.isEmpty || code.length != 6) {
      throw Exception('Please enter a valid 6-digit OTP code');
    }

    try {
      // Verify OTP
      final otp = await _otpRepository.getValidOTP(phone, code, 'login');
      if (otp == null) {
        throw Exception('Invalid or expired OTP code. Please try again.');
      }

      // Mark OTP as used
      await _otpRepository.markOTPAsUsed(otp.id);

      // Get user by phone
      final user = await _userRepository.getUserByPhone(phone);
      if (user == null) {
        throw Exception('User not found. Please complete registration.');
      }

      if (!user.isActive) {
        throw Exception('Account is deactivated. Please contact support.');
      }

      // Update last login
      await _userRepository.updateLastLogin(user.id);

      // Check subscription status
      final hasValidSubscription = await _subscriptionRepository
          .hasValidSubscription(user.businessId ?? '');
      if (!hasValidSubscription) {
        print('‚ö†Ô∏è No active subscription found for user: ${user.id}');
      }

      print('‚úÖ OTP login successful for: ${user.name}');
      return user;
    } catch (e) {
      print('‚ùå OTP login error: $e');
      rethrow;
    }

}

// Enhanced OTP sending with validation
Future<void> sendLoginOTP(String phone) async {
print('üì± Sending login OTP for: $phone');

    // Validate phone number
    if (phone.isEmpty || !RegExp(r'^\+251[0-9]{9}$').hasMatch(phone)) {
      throw Exception('Please enter a valid Ethiopian phone number (+251...)');
    }

    // Check if user exists
    final user = await _userRepository.getUserByPhone(phone);
    if (user == null) {
      throw Exception(
          'No account found with this phone number. Please register first.');
    }

    if (!user.isActive) {
      throw Exception('Account is deactivated. Please contact support.');
    }

    await _sendOTP(phone, 'login');

}

Future<void> sendRegistrationOTP(String phone) async {
print('üìù Sending registration OTP for: $phone');

    // Validate phone number
    if (phone.isEmpty || !RegExp(r'^\+251[0-9]{9}$').hasMatch(phone)) {
      throw Exception('Please enter a valid Ethiopian phone number (+251...)');
    }

    // Check if user already exists
    final existingUser = await _userRepository.getUserByPhone(phone);
    if (existingUser != null) {
      throw Exception(
          'An account already exists with this phone number. Please login instead.');
    }

    await _sendOTP(phone, 'registration');

}

// Generic OTP sending method for verification
Future<void> sendOTP(String phone) async {
print('üì± Sending OTP for: $phone');

    // Validate phone number
    if (phone.isEmpty || !RegExp(r'^\+251[0-9]{9}$').hasMatch(phone)) {
      throw Exception('Please enter a valid Ethiopian phone number (+251...)');
    }

    await _sendOTP(phone, 'verification');

}

// Enhanced OTP sending with better logging
Future<void> \_sendOTP(String phone, String type) async {
try {
// Generate OTP
final otp = OTP.create(phone: phone, type: type);

      // Store OTP
      await _otpRepository.createOTP(otp);

      // Simulate API call delay
      await Future.delayed(const Duration(seconds: 1));

      // Enhanced logging for demo purposes
      print('‚úÖ OTP sent successfully');
      print('üì± Phone: $phone');
      print('üîë OTP Code: ${otp.code}');
      print('üìù Type: $type');
      print('‚è∞ Expires: ${otp.expiresAt}');
      print('üéØ DEMO - Use this code: ${otp.code}');
    } catch (e) {
      print('‚ùå OTP send error: $e');
      throw Exception('Failed to send OTP. Please try again.');
    }

}

// Enhanced OTP verification for general use
Future<void> verifyOTP(String phone, String code,
{String type = 'verification'}) async {
print('üîê Verifying OTP for: $phone');

    if (phone.isEmpty) {
      throw Exception('Phone number not set');
    }

    if (code.isEmpty || code.length != 6) {
      throw Exception('Please enter a valid 6-digit OTP code');
    }

    try {
      final otp = await _otpRepository.getValidOTP(phone, code, type);
      if (otp == null) {
        throw Exception('Invalid or expired OTP code. Please try again.');
      }

      await _otpRepository.markOTPAsUsed(otp.id);
      print('‚úÖ OTP verified successfully for: $phone');
    } catch (e) {
      print('‚ùå OTP verification error: $e');
      rethrow;
    }

}

Future<void> logout() async {
// Clear any local authentication state
print('üö™ User logged out');
}

// Utility method to clean up expired OTPs
Future<void> cleanupExpiredOTPs() async {
await \_otpRepository.cleanExpiredOTPs();
}
}

##

// lib/src/services/receipt_service.dart
// Service for generating and printing sales receipt PDFs.
import 'dart:io';
import 'dart:typed_data';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:path_provider/path_provider.dart';
import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;
import 'package:printing/printing.dart';
import '../data/models/sale.dart';
import '../data/models/sale_item.dart';
import '../localization/app_localizations.dart';

class ReceiptService {
static const double \_receiptWidth = 80.0; // mm
static const double \_mmToPoint = 2.83465; // 1mm = 2.83465 points

Future<pw.Document> generateReceiptPDF({
required Sale sale,
required List<SaleItem> items,
required Map<String, dynamic> businessInfo,
required AppLocalizations localizations,
bool includeAmharic = true,
}) async {
final pdf = pw.Document();

    pdf.addPage(
      pw.Page(
        pageFormat: PdfPageFormat(
          _receiptWidth * _mmToPoint,
          double.infinity,
          marginAll: 4 * _mmToPoint,
        ),
        build: (pw.Context context) {
          return pw.Column(
            crossAxisAlignment: pw.CrossAxisAlignment.start,
            children: [
              // === HEADER ===
              _buildHeader(businessInfo, includeAmharic),

              pw.SizedBox(height: 8),
              pw.Divider(thickness: 1),
              pw.SizedBox(height: 8),

              // === SALE INFO ===
              _buildSaleInfo(sale, localizations),

              pw.SizedBox(height: 8),
              pw.Divider(thickness: 0.5),
              pw.SizedBox(height: 8),

              // === ITEMS TABLE ===
              _buildItemsTable(items, localizations),

              pw.SizedBox(height: 8),
              pw.Divider(thickness: 0.5),
              pw.SizedBox(height: 8),

              // === TOTALS ===
              _buildTotals(sale, localizations),

              pw.SizedBox(height: 8),
              pw.Divider(thickness: 1),
              pw.SizedBox(height: 8),

              // === PAYMENT INFO ===
              _buildPaymentInfo(sale, localizations),

              pw.SizedBox(height: 12),

              // === FOOTER ===
              _buildFooter(businessInfo, includeAmharic, localizations),
            ],
          );
        },
      ),
    );

    return pdf;

}

pw.Widget \_buildHeader(
Map<String, dynamic> businessInfo, bool includeAmharic) {
return pw.Column(
crossAxisAlignment: pw.CrossAxisAlignment.center,
children: [
pw.Text(
businessInfo['shopName'] ?? 'Andalus Smart POS',
style: pw.TextStyle(
fontSize: 14,
fontWeight: pw.FontWeight.bold,
),
textAlign: pw.TextAlign.center,
),
if (includeAmharic && businessInfo['shopNameAm'] != null)
pw.Text(
businessInfo['shopNameAm']!,
style: const pw.TextStyle(fontSize: 10),
textAlign: pw.TextAlign.center,
),
pw.SizedBox(height: 4),
if (businessInfo['address'] != null)
pw.Text(
businessInfo['address']!,
style: const pw.TextStyle(fontSize: 8),
textAlign: pw.TextAlign.center,
),
if (businessInfo['phone'] != null)
pw.Text(
'Tel: ${businessInfo['phone']!}',
style: const pw.TextStyle(fontSize: 8),
textAlign: pw.TextAlign.center,
),
if (businessInfo['tinNumber'] != null)
pw.Text(
'TIN: ${businessInfo['tinNumber']!}',
style: const pw.TextStyle(fontSize: 8),
textAlign: pw.TextAlign.center,
),
],
);
}

pw.Widget \_buildSaleInfo(Sale sale, AppLocalizations localizations) {
return pw.Column(
crossAxisAlignment: pw.CrossAxisAlignment.start,
children: [
pw.Row(
mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
children: [
pw.Text(
'${localizations.receipt}:',
style: pw.TextStyle(fontSize: 9, fontWeight: pw.FontWeight.bold),
),
pw.Text(
sale.saleId,
style: const pw.TextStyle(fontSize: 9),
),
],
),
pw.SizedBox(height: 4),
pw.Row(
mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
children: [
pw.Text(
'${localizations.time}:',
style: pw.TextStyle(fontSize: 9, fontWeight: pw.FontWeight.bold),
),
pw.Text(
sale.formattedDateTime,
style: const pw.TextStyle(fontSize: 9),
),
],
),
if (sale.customerName != null && sale.customerName!.isNotEmpty)
pw.Column(
children: [
pw.SizedBox(height: 4),
pw.Row(
mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
children: [
pw.Text(
'${localizations.translate("customer")}:',
style: pw.TextStyle(
fontSize: 9, fontWeight: pw.FontWeight.bold),
),
pw.Text(
sale.customerName!,
style: const pw.TextStyle(fontSize: 9),
),
],
),
],
),
if (sale.userName != null && sale.userName!.isNotEmpty)
pw.Column(
children: [
pw.SizedBox(height: 4),
pw.Row(
mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
children: [
pw.Text(
'${localizations.translate("cashier")}:',
style: pw.TextStyle(
fontSize: 9, fontWeight: pw.FontWeight.bold),
),
pw.Text(
sale.userName!,
style: const pw.TextStyle(fontSize: 9),
),
],
),
],
),
],
);
}

pw.Widget \_buildItemsTable(
List<SaleItem> items, AppLocalizations localizations) {
return pw.Table(
columnWidths: {
0: const pw.FlexColumnWidth(3),
1: const pw.FlexColumnWidth(1),
2: const pw.FlexColumnWidth(2),
3: const pw.FlexColumnWidth(2),
},
border: pw.TableBorder(
verticalInside: const pw.BorderSide(width: 0),
horizontalInside: const pw.BorderSide(width: 0),
),
children: [
// Header row
pw.TableRow(
children: [
pw.Text(
localizations.item,
style: pw.TextStyle(fontSize: 8, fontWeight: pw.FontWeight.bold),
),
pw.Text(
localizations.qty,
style: pw.TextStyle(fontSize: 8, fontWeight: pw.FontWeight.bold),
textAlign: pw.TextAlign.center,
),
pw.Text(
localizations.translate('price'),
style: pw.TextStyle(fontSize: 8, fontWeight: pw.FontWeight.bold),
textAlign: pw.TextAlign.right,
),
pw.Text(
localizations.total,
style: pw.TextStyle(fontSize: 8, fontWeight: pw.FontWeight.bold),
textAlign: pw.TextAlign.right,
),
],
),

        pw.TableRow(
          children: [
            pw.Divider(thickness: 0.5),
            pw.Divider(thickness: 0.5),
            pw.Divider(thickness: 0.5),
            pw.Divider(thickness: 0.5),
          ],
        ),

        // Item rows
        ...items
            .map((item) => pw.TableRow(
                  children: [
                    pw.Column(
                      crossAxisAlignment: pw.CrossAxisAlignment.start,
                      children: [
                        pw.Text(
                          _truncateText(item.productName, 18),
                          style: const pw.TextStyle(fontSize: 8),
                        ),
                        if (item.productNameAm != null &&
                            item.productNameAm!.isNotEmpty)
                          pw.Text(
                            _truncateText(item.productNameAm!, 18),
                            style: pw.TextStyle(
                                fontSize: 7, color: PdfColors.grey600),
                          ),
                      ],
                    ),
                    pw.Text(
                      item.quantity.toString(),
                      style: const pw.TextStyle(fontSize: 8),
                      textAlign: pw.TextAlign.center,
                    ),
                    pw.Text(
                      'ETB ${item.unitPrice.toStringAsFixed(2)}',
                      style: const pw.TextStyle(fontSize: 8),
                      textAlign: pw.TextAlign.right,
                    ),
                    pw.Text(
                      'ETB ${item.totalPrice.toStringAsFixed(2)}',
                      style: const pw.TextStyle(fontSize: 8),
                      textAlign: pw.TextAlign.right,
                    ),
                  ],
                ))
            .toList(),
      ],
    );

}

pw.Widget \_buildTotals(Sale sale, AppLocalizations localizations) {
return pw.Column(
children: [
// Use pw.Row instead of TableRow
_buildTotalRowWidget(
'${localizations.subtotal}:',
'ETB ${sale.subtotal.toStringAsFixed(2)}',
),
if (sale.taxAmount > 0)
_buildTotalRowWidget(
'${localizations.tax}:',
'ETB ${sale.taxAmount.toStringAsFixed(2)}',
),
if (sale.discountAmount > 0)
_buildTotalRowWidget(
'${localizations.discount}:',
'-ETB ${sale.discountAmount.toStringAsFixed(2)}',
),
pw.SizedBox(height: 4),
pw.Divider(thickness: 0.5),
pw.SizedBox(height: 4),
_buildTotalRowWidget(
'${localizations.total}:',
'ETB ${sale.finalAmount.toStringAsFixed(2)}',
isBold: true,
),
],
);
}

pw.Widget \_buildTotalRowWidget(String label, String value,
{bool isBold = false}) {
return pw.Row(
mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
children: [
pw.Text(
label,
style: pw.TextStyle(
fontSize: 9,
fontWeight: isBold ? pw.FontWeight.bold : pw.FontWeight.normal,
),
),
pw.Text(
value,
style: pw.TextStyle(
fontSize: 9,
fontWeight: isBold ? pw.FontWeight.bold : pw.FontWeight.normal,
),
),
],
);
}

pw.Widget \_buildPaymentInfo(Sale sale, AppLocalizations localizations) {
return pw.Column(
crossAxisAlignment: pw.CrossAxisAlignment.start,
children: [
pw.Row(
mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
children: [
pw.Text(
'${localizations.paymentMethod}:',
style: pw.TextStyle(fontSize: 9, fontWeight: pw.FontWeight.bold),
),
pw.Text(
_getPaymentMethodDisplay(sale.paymentMethod, localizations),
style: pw.TextStyle(fontSize: 9),
),
],
),
if (sale.paymentReference != null && sale.paymentReference!.isNotEmpty)
pw.Column(
children: [
pw.SizedBox(height: 4),
pw.Row(
mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
children: [
pw.Text(
'${localizations.telebirrReference}:',
style: pw.TextStyle(
fontSize: 9, fontWeight: pw.FontWeight.bold),
),
pw.Text(
sale.paymentReference!,
style: pw.TextStyle(fontSize: 9),
),
],
),
],
),
],
);
}

pw.Widget \_buildFooter(Map<String, dynamic> businessInfo, bool includeAmharic,
AppLocalizations localizations) {
return pw.Column(
crossAxisAlignment: pw.CrossAxisAlignment.center,
children: [
pw.Text(
localizations.thankYou,
style: pw.TextStyle(
fontSize: 10,
fontWeight: pw.FontWeight.bold,
),
textAlign: pw.TextAlign.center,
),
if (includeAmharic)
pw.Text(
'·ä•·äì·àò·à∞·åç·äì·àà·äï!',
style: const pw.TextStyle(fontSize: 9),
textAlign: pw.TextAlign.center,
),
pw.SizedBox(height: 8),
if (businessInfo['receiptFooter'] != null)
pw.Text(
businessInfo['receiptFooter']!,
style: const pw.TextStyle(fontSize: 7),
textAlign: pw.TextAlign.center,
),
pw.SizedBox(height: 4),
pw.Text(
'Powered by Andalus Smart POS',
style: pw.TextStyle(fontSize: 6, color: PdfColors.grey600),
textAlign: pw.TextAlign.center,
),
],
);
}

String \_truncateText(String text, int maxLength) {
if (text.length <= maxLength) return text;
return '${text.substring(0, maxLength - 3)}...';
}

String \_getPaymentMethodDisplay(
String method, AppLocalizations localizations) {
switch (method.toLowerCase()) {
case 'cash':
return localizations.cash;
case 'telebirr':
return localizations.telebirr;
case 'card':
return localizations.card;
case 'credit':
return localizations.credit;
case 'bank_transfer':
return localizations.bankTransfer;
default:
return method;
}
}

// === FILE MANAGEMENT ===
Future<File> saveReceiptToFile({
required Sale sale,
required pw.Document pdf,
String? customPath,
}) async {
final directory = await getApplicationDocumentsDirectory();
final receiptsDir = Directory('${directory.path}/receipts');

    if (!receiptsDir.existsSync()) {
      await receiptsDir.create(recursive: true);
    }

    final fileName =
        'receipt_${sale.saleId}_${DateTime.now().millisecondsSinceEpoch}.pdf';
    final filePath = customPath ?? '${receiptsDir.path}/$fileName';
    final file = File(filePath);

    final pdfBytes = await pdf.save();
    await file.writeAsBytes(pdfBytes);

    return file;

}

Future<List<File>> getSavedReceipts() async {
final directory = await getApplicationDocumentsDirectory();
final receiptsDir = Directory('${directory.path}/receipts');

    if (!receiptsDir.existsSync()) {
      return [];
    }

    final files = receiptsDir.listSync();
    return files
        .where((file) => file is File && file.path.endsWith('.pdf'))
        .map((file) => file as File)
        .toList();

}

Future<void> deleteOldReceipts({int daysToKeep = 30}) async {
final directory = await getApplicationDocumentsDirectory();
final receiptsDir = Directory('${directory.path}/receipts');

    if (!receiptsDir.existsSync()) {
      return;
    }

    final cutoffDate = DateTime.now().subtract(Duration(days: daysToKeep));
    final files = receiptsDir.listSync();

    for (final file in files) {
      if (file is File) {
        final stat = await file.stat();
        if (stat.modified.isBefore(cutoffDate)) {
          await file.delete();
        }
      }
    }

}

// === PRINTING ===
Future<void> printReceipt({
required Sale sale,
required List<SaleItem> items,
required Map<String, dynamic> businessInfo,
required AppLocalizations localizations,
}) async {
try {
final pdf = await generateReceiptPDF(
sale: sale,
items: items,
businessInfo: businessInfo,
localizations: localizations,
);

      await Printing.layoutPdf(
        onLayout: (PdfPageFormat format) async => pdf.save(),
      );

      // Save copy for records
      await saveReceiptToFile(sale: sale, pdf: pdf);
    } catch (e) {
      print('PDF printing error: $e');
      rethrow;
    }

}
}

// Provider
final receiptServiceProvider = Provider<ReceiptService>((ref) {
return ReceiptService();
});

##

// src/service/registration_service.dart
// Service for handling user and shop registration logic.
import 'package:andalus_smart_pos/src/data/models/registration.dart';
import 'package:andalus_smart_pos/src/data/repositories/subscription_repository.dart';
import 'package:andalus_smart_pos/src/data/repositories/user_repository.dart';
import 'package:crypto/crypto.dart';
import 'dart:convert';
import 'package:andalus_smart_pos/src/data/local/database.dart';
import 'package:andalus_smart_pos/src/data/models/user.dart';
import 'package:andalus_smart_pos/src/data/models/subscription.dart';
import 'package:andalus_smart_pos/src/data/models/shop_registration.dart';

class RegistrationService {
final UserRepository \_userRepository;
final SubscriptionRepository \_subscriptionRepository;

RegistrationService({
required UserRepository userRepository,
required SubscriptionRepository subscriptionRepository,
}) : \_userRepository = userRepository,
\_subscriptionRepository = subscriptionRepository;
// Convenience method to create a temporary registration using ShopRegistration directly.
Future<RegistrationResult> createTemporaryRegistrationFromShop({
required ShopRegistration shop,
required UserRegistration user,
required SubscriptionPlan plan,
required BillingCycle billingCycle,
required OwnerRegistration owner,
BusinessRegistration? business, // <--- Add '?' here
}) async {
final db = await AppDatabase.database;

    try {
      // Check if phone numbers already exist
      // ShopRegistration does not expose a `phone` getter, so read it from toMap().
      final shopPhone = shop.toMap()['phone']?.toString() ?? '';
      final shopPhoneExists = await checkShopPhoneExists(shopPhone);
      if (shopPhoneExists) {
        return RegistrationResult.failure(
            'Shop phone number already registered');
      }

      final userPhoneExists = await checkUserPhoneExists(user.phone);
      if (userPhoneExists) {
        return RegistrationResult.failure(
            'User phone number already registered');
      }

      String? tempShopId;
      String? tempOwnerId;

      await db.transaction((txn) async {
        // 1. Create temporary shop profile
        tempShopId = 'temp_shop_${DateTime.now().millisecondsSinceEpoch}';
        final now = DateTime.now().millisecondsSinceEpoch;

        await txn.insert('business_profile', {
          'business_id': tempShopId,
          ...shop.toMap(),
          'currency': 'ETB',
          'is_active': 0, // Not active until payment
          'created_at': now,
          'updated_at': now,
        });

        // 2. Create temporary owner account
        tempOwnerId = 'temp_user_${DateTime.now().millisecondsSinceEpoch}';

        // Handle email properly
        final userEmail =
            user.email?.trim().isEmpty == true ? '' : user.email?.trim() ?? '';

        final userModel = User(
          id: tempOwnerId!,
          name: user.name,
          phone: user.phone,
          email: userEmail,
          role: user.role,
          createdAt: DateTime.now(),
          isActive: false, // Not active until payment
          isVerified: false,
          businessId: tempShopId,
          passwordHash: _hashPassword(user.password),
        );

        await txn.insert('users', userModel.toMap());

        // 3. Create pending subscription
        final subscription = Subscription(
          id: 'pending_sub_${DateTime.now().millisecondsSinceEpoch}',
          businessId: tempShopId!,
          userId: tempOwnerId!,
          plan: plan,
          billingCycle: billingCycle,
          status: SubscriptionStatus.pending,
          startDate: DateTime.now(),
          endDate: DateTime.now().add(const Duration(days: 14)),
          amount: plan.getPrice(billingCycle),
          currency: 'ETB',
          isActive: false,
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        );

        await txn.insert('subscriptions', subscription.toMap());
      });

      return RegistrationResult.success(
        businessId: tempShopId,
        userId: tempOwnerId,
      );
    } catch (e) {
      print('Registration error: $e');
      return RegistrationResult.failure('Registration failed: ${e.toString()}');
    }

}

String \_hashPassword(String password) {
final bytes = utf8.encode(password);
final digest = sha256.convert(bytes);
return digest.toString();
}

Future<RegistrationResult> createTemporaryRegistration({
BusinessRegistration? business,
UserRegistration? user,
ShopRegistration? shop,
OwnerRegistration? owner,
required SubscriptionPlan plan,
required BillingCycle billingCycle,
}) async {
final db = await AppDatabase.database;

    try {
      String? phoneToCheck;

      // Determine which phone to check based on provided data
      if (shop != null) {
        final shopPhone = shop.phoneNumber;
        phoneToCheck = shopPhone;
      } else if (business != null) {
        phoneToCheck = business.phone;
      }

      if (phoneToCheck != null) {
        final shopPhoneExists = await checkShopPhoneExists(phoneToCheck);
        if (shopPhoneExists) {
          return RegistrationResult.failure('Phone number already registered');
        }
      }

      String? userPhoneToCheck;
      if (owner != null) {
        userPhoneToCheck = owner.phone;
      } else if (user != null) {
        userPhoneToCheck = user.phone;
      }

      if (userPhoneToCheck != null) {
        final userPhoneExists = await checkUserPhoneExists(userPhoneToCheck);
        if (userPhoneExists) {
          return RegistrationResult.failure(
              'User phone number already registered');
        }
      }

      String? tempShopId;
      String? tempOwnerId;

      await db.transaction((txn) async {
        // 1. Create temporary business profile
        tempShopId = 'temp_shop_${DateTime.now().millisecondsSinceEpoch}';
        final now = DateTime.now().millisecondsSinceEpoch;

        if (shop != null) {
          // Map ShopRegistration to business_profile table schema
          final shopMap = shop.toMap();
          await txn.insert('business_profile', {
            'business_id': tempShopId,
            'name': shopMap['shop_name'], // Map to 'name' column
            'name_am': shopMap[
                'shop_name'], // Use same name for Amharic or get from somewhere
            'business_type': shopMap['shop_category'], // Map to 'business_type'
            'phone': shopMap['phone_number'], // Map to 'phone'
            'email': '', // Optional field
            'address': shopMap['business_address'], // Map to 'address'
            'city': shopMap['city'],
            'region':
                shopMap['country'], // Map country to region or adjust as needed
            'tin_number':
                'TEMP_${DateTime.now().millisecondsSinceEpoch}', // Generate temp TIN
            'vat_number': null,
            'business_license': null,
            'owner_name': '', // Will be set from owner registration
            'owner_phone': '', // Will be set from owner registration
            'owner_email': null,
            'currency': 'ETB',
            'logo_path': shopMap['shop_logo'],
            'receipt_header': null,
            'receipt_footer': null,
            'is_active': 0,
            'created_at': now,
            'updated_at': now,
          });
        } else if (business != null) {
          // Use BusinessRegistration data (existing logic)
          await txn.insert('business_profile', {
            'business_id': tempShopId,
            ...business.toMap(),
            'currency': 'ETB',
            'is_active': 0,
            'created_at': now,
            'updated_at': now,
          });
        }

        // 2. Create temporary owner account
        tempOwnerId = 'temp_user_${DateTime.now().millisecondsSinceEpoch}';

        // In registration_service.dart - fix the user creation
        User userModel;
        if (owner != null) {
          // Handle email properly - use null if empty
          final userEmail =
              owner.email?.trim().isEmpty == true ? null : owner.email?.trim();

          userModel = User(
            id: tempOwnerId!,
            name: owner.fullName,
            phone: owner.phone,
            email: userEmail, // Can be null now
            role: UserRole.owner,
            createdAt: DateTime.now(),
            isActive: false,
            isVerified: false,
            businessId: tempShopId,
            passwordHash: _hashPassword(owner.password),
          );
        } else if (user != null) {
          // Use UserRegistration data - ensure email is unique
          final uniqueEmail = user.email?.isNotEmpty == true
              ? user.email
              : 'user_${DateTime.now().millisecondsSinceEpoch}@temp.com';

          userModel = User(
            id: tempOwnerId!,
            name: user.name,
            phone: user.phone,
            email: uniqueEmail!, // Ensure unique email
            role: user.role,
            createdAt: DateTime.now(),
            isActive: false,
            isVerified: false,
            businessId: tempShopId,
            passwordHash: _hashPassword(user.password),
          );
        } else {
          throw Exception('No user data provided');
        }

        await txn.insert('users', userModel.toMap());

        // 3. Update business profile with owner information
        if (owner != null && shop != null) {
          await txn.update(
            'business_profile',
            {
              'owner_name': owner.fullName,
              'owner_phone': owner.phone,
              'owner_email': owner.email,
              'updated_at': DateTime.now().millisecondsSinceEpoch,
            },
            where: 'business_id = ?',
            whereArgs: [tempShopId],
          );
        }

        // 4. Create pending subscription
        final subscription = Subscription(
          id: 'pending_sub_${DateTime.now().millisecondsSinceEpoch}',
          businessId: tempShopId!,
          userId: tempOwnerId!,
          plan: plan,
          billingCycle: billingCycle,
          status: SubscriptionStatus.pending,
          startDate: DateTime.now(),
          endDate: DateTime.now().add(const Duration(days: 14)),
          amount: plan.getPrice(billingCycle),
          currency: 'ETB',
          isActive: false,
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        );

        await txn.insert('subscriptions', subscription.toMap());
      });

      return RegistrationResult.success(
        businessId: tempShopId,
        userId: tempOwnerId,
      );
    } catch (e) {
      print('Registration error: $e');
      return RegistrationResult.failure('Registration failed: ${e.toString()}');
    }

}

Future<PaymentResult> activateAccountAfterPayment({
required String businessId,
required String userId,
required String paymentReference,
required String transactionId,
}) async {
final db = await AppDatabase.database;

    try {
      await db.transaction((txn) async {
        // 1. Activate business
        await txn.update(
          'business_profile',
          {
            'is_active': 1,
            'updated_at': DateTime.now().millisecondsSinceEpoch,
          },
          where: 'business_id = ?',
          whereArgs: [businessId],
        );

        // 2. Activate user
        await txn.update(
          'users',
          {
            'is_active': 1,
            'is_verified': 1,
            'updated_at': DateTime.now().millisecondsSinceEpoch,
          },
          where: 'user_id = ?',
          whereArgs: [userId],
        );

        // 3. Activate subscription and update payment info
        await txn.update(
          'subscriptions',
          {
            'is_active': 1,
            'status': 'active',
            'payment_reference': paymentReference,
            'updated_at': DateTime.now().millisecondsSinceEpoch,
          },
          where: 'business_id = ? AND user_id = ?',
          whereArgs: [businessId, userId],
        );
      });

      return PaymentResult.success(
        paymentReference: paymentReference,
        transactionId: transactionId,
      );
    } catch (e) {
      return PaymentResult.failure('Account activation failed: $e');
    }

}

Future<bool> checkShopPhoneExists(String phone) async {
final db = await AppDatabase.database;
final result = await db.query(
'business_profile',
where: 'phone = ?',
whereArgs: [phone],
);
return result.isNotEmpty;
}

Future<bool> checkUserPhoneExists(String phone) async {
final user = await \_userRepository.getUserByPhone(phone);
return user != null;
}
}

// Add these result classes at the bottom of the file
class RegistrationResult {
final bool success;
final String? error;
final String? businessId;
final String? userId;

const RegistrationResult({
required this.success,
this.error,
this.businessId,
this.userId,
});

factory RegistrationResult.success({String? businessId, String? userId}) {
return RegistrationResult(
success: true,
businessId: businessId,
userId: userId,
);
}

factory RegistrationResult.failure(String error) {
return RegistrationResult(success: false, error: error);
}
}

class PaymentResult {
final bool success;
final String? error;
final String? paymentReference;
final String? transactionId;

const PaymentResult({
required this.success,
this.error,
this.paymentReference,
this.transactionId,
});

factory PaymentResult.success({
required String paymentReference,
required String transactionId,
}) {
return PaymentResult(
success: true,
paymentReference: paymentReference,
transactionId: transactionId,
);
}

factory PaymentResult.failure(String error) {
return PaymentResult(success: false, error: error);
}
}

##

// lib/src/services/sync_service.dart
// Service for synchronizing local data with the remote server.
import 'dart:async';
import 'dart:convert';
import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:workmanager/workmanager.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../data/local/database.dart';
import '../data/models/sale.dart';
import '../data/models/product.dart';
import '../data/models/customer.dart';

@pragma('vm:entry-point')
void callbackDispatcher() {
Workmanager().executeTask((task, inputData) async {
try {
final service = SyncService();
await service.syncAllData();
return Future.value(true);
} catch (e) {
print('Background sync error: $e');
return Future.value(false);
}
});
}

class SyncService {
static const String \_lastSyncKey = 'last_sync_timestamp';
static const String \_syncStatusKey = 'sync_status';
static const Duration \_syncInterval = Duration(minutes: 15);
static const int \_maxRetries = 3;

Future<void> initialize() async {
await Workmanager().initialize(
callbackDispatcher,
isInDebugMode: false,
);

    // Register periodic sync
    await Workmanager().registerPeriodicTask(
      'pos_sync',
      'pos_sync_task',
      frequency: _syncInterval,
      constraints: Constraints(
        networkType: NetworkType.connected,
        requiresBatteryNotLow: false,
        requiresStorageNotLow: false,
      ),
      initialDelay: const Duration(seconds: 10),
    );

}

Future<SyncResult> syncAllData() async {
final connectivity = await Connectivity().checkConnectivity();
if (connectivity == ConnectivityResult.none) {
print('No internet connection for sync');
return SyncResult.noConnection();
}

    final prefs = await SharedPreferences.getInstance();
    final lastSync = prefs.getInt(_lastSyncKey) ?? 0;
    final now = DateTime.now().millisecondsSinceEpoch;

    // Skip if synced recently
    if (now - lastSync < _syncInterval.inMilliseconds ~/ 2) {
      return SyncResult.skipped();
    }

    try {
      await prefs.setString(_syncStatusKey, 'syncing');

      // Sync in order of importance
      final salesResult = await _syncSales();
      final productsResult = await _syncProducts();
      final customersResult = await _syncCustomers();

      await prefs.setInt(_lastSyncKey, now);
      await prefs.setString(_syncStatusKey, 'success');

      return SyncResult.success(
        syncedSales: salesResult.syncedCount,
        syncedProducts: productsResult.syncedCount,
        syncedCustomers: customersResult.syncedCount,
      );
    } catch (e, stackTrace) {
      await prefs.setString(_syncStatusKey, 'failed');

      // Log error
      print('Sync error: $e');
      print('Stack trace: $stackTrace');

      return SyncResult.failed(e.toString());
    }

}

Future<SyncBatchResult> \_syncSales() async {
final db = await AppDatabase.database;
final unsyncedSales = await db.query(
'sales',
where: 'is_synced = 0 AND sync_attempts < ?',
whereArgs: [_maxRetries],
);

    int syncedCount = 0;
    int failedCount = 0;

    for (final saleData in unsyncedSales) {
      try {
        final sale = Sale.fromMap(saleData);

        // Validate sale before syncing
        if (!sale.isValid() || !sale.isTotalValid) {
          await _markSaleAsInvalid(saleData['id'] as int);
          failedCount++;
          continue;
        }

        // Get sale items
        final items = await db.query(
          'sale_items',
          where: 'sale_id = ?',
          whereArgs: [saleData['sale_id']],
        );

        // Upload to server (simulate API call)
        // await _api.uploadSale(sale, items);
        await Future.delayed(const Duration(milliseconds: 100)); // Simulate API

        // Mark as synced
        await db.update(
          'sales',
          {
            'is_synced': 1,
            'synced_at': DateTime.now().millisecondsSinceEpoch,
            'updated_at': DateTime.now().millisecondsSinceEpoch,
          },
          where: 'id = ?',
          whereArgs: [saleData['id']],
        );

        // Mark items as synced
        for (final item in items) {
          await db.update(
            'sale_items',
            {'is_synced': 1},
            where: 'id = ?',
            whereArgs: [item['id']],
          );
        }

        syncedCount++;
      } catch (e) {
        failedCount++;

        // Increment sync attempts
        await db.update(
          'sales',
          {
            'sync_attempts': (saleData['sync_attempts'] as int? ?? 0) + 1,
            'updated_at': DateTime.now().millisecondsSinceEpoch,
          },
          where: 'id = ?',
          whereArgs: [saleData['id']],
        );

        // If max retries reached, move to failed queue
        if ((saleData['sync_attempts'] as int? ?? 0) + 1 >= _maxRetries) {
          await _moveToFailedQueue('sales', saleData);
        }
      }
    }

    return SyncBatchResult(
      type: 'sales',
      syncedCount: syncedCount,
      failedCount: failedCount,
    );

}

Future<SyncBatchResult> \_syncProducts() async {
final db = await AppDatabase.database;
final unsyncedProducts = await db.query(
'products',
where: 'is_synced = 0 AND sync_attempts < ?',
whereArgs: [_maxRetries],
);

    int syncedCount = 0;
    int failedCount = 0;

    for (final productData in unsyncedProducts) {
      try {
        final product = Product.fromMap(productData);

        // Validate product
        if (!product.verifyChecksum()) {
          await _markProductAsInvalid(productData['id'] as int);
          failedCount++;
          continue;
        }

        // Upload to server
        // await _api.uploadProduct(product);
        await Future.delayed(const Duration(milliseconds: 50));

        // Mark as synced
        await db.update(
          'products',
          {
            'is_synced': 1,
            'synced_at': DateTime.now().millisecondsSinceEpoch,
            'updated_at': DateTime.now().millisecondsSinceEpoch,
          },
          where: 'id = ?',
          whereArgs: [productData['id']],
        );

        syncedCount++;
      } catch (e) {
        failedCount++;

        await db.update(
          'products',
          {
            'sync_attempts': (productData['sync_attempts'] as int? ?? 0) + 1,
            'updated_at': DateTime.now().millisecondsSinceEpoch,
          },
          where: 'id = ?',
          whereArgs: [productData['id']],
        );
      }
    }

    return SyncBatchResult(
      type: 'products',
      syncedCount: syncedCount,
      failedCount: failedCount,
    );

}

Future<SyncBatchResult> \_syncCustomers() async {
final db = await AppDatabase.database;
final unsyncedCustomers = await db.query(
'customers',
where: 'is_synced = 0 AND sync_attempts < ?',
whereArgs: [_maxRetries],
);

    int syncedCount = 0;
    int failedCount = 0;

    for (final customerData in unsyncedCustomers) {
      try {
        // Upload to server
        // await _api.uploadCustomer(customerData);
        await Future.delayed(const Duration(milliseconds: 50));

        // Mark as synced
        await db.update(
          'customers',
          {
            'is_synced': 1,
            'synced_at': DateTime.now().millisecondsSinceEpoch,
            'updated_at': DateTime.now().millisecondsSinceEpoch,
          },
          where: 'id = ?',
          whereArgs: [customerData['id']],
        );

        syncedCount++;
      } catch (e) {
        failedCount++;

        await db.update(
          'customers',
          {
            'sync_attempts': (customerData['sync_attempts'] as int? ?? 0) + 1,
            'updated_at': DateTime.now().millisecondsSinceEpoch,
          },
          where: 'id = ?',
          whereArgs: [customerData['id']],
        );
      }
    }

    return SyncBatchResult(
      type: 'customers',
      syncedCount: syncedCount,
      failedCount: failedCount,
    );

}

Future<void> \_markSaleAsInvalid(int saleId) async {
final db = await AppDatabase.database;
await db.update(
'sales',
{
'is_synced': 2, // 2 = invalid
'updated_at': DateTime.now().millisecondsSinceEpoch,
},
where: 'id = ?',
whereArgs: [saleId],
);
}

Future<void> \_markProductAsInvalid(int productId) async {
final db = await AppDatabase.database;
await db.update(
'products',
{
'is_synced': 2, // 2 = invalid
'updated_at': DateTime.now().millisecondsSinceEpoch,
},
where: 'id = ?',
whereArgs: [productId],
);
}

Future<void> \_moveToFailedQueue(
String type, Map<String, dynamic> data) async {
final db = await AppDatabase.database;
await db.insert('failed_syncs', {
'type': type,
'data': jsonEncode(data),
'error': 'Max retries reached',
'created_at': DateTime.now().millisecondsSinceEpoch,
});
}

// === SYNC STATUS ===
Future<SyncStatus> getSyncStatus() async {
final prefs = await SharedPreferences.getInstance();
final status = prefs.getString(\_syncStatusKey) ?? 'idle';
final lastSync = prefs.getInt(\_lastSyncKey) ?? 0;

    return SyncStatus(
      status: status,
      lastSync:
          lastSync == 0 ? null : DateTime.fromMillisecondsSinceEpoch(lastSync),
    );

}

Future<void> forceSync() async {
await syncAllData();
}

Future<List<Map<String, dynamic>>> getFailedSyncs() async {
final db = await AppDatabase.database;
return await db.query('failed_syncs', orderBy: 'created_at DESC');
}

Future<void> retryFailedSync(int id) async {
final db = await AppDatabase.database;
final failed =
await db.query('failed_syncs', where: 'id = ?', whereArgs: [id]);

    if (failed.isNotEmpty) {
      final data = jsonDecode(failed.first['data'] as String);
      final type = failed.first['type'] as String;

      // Retry logic based on type
      // ...

      // Remove from failed queue
      await db.delete('failed_syncs', where: 'id = ?', whereArgs: [id]);
    }

}
}

// === DATA CLASSES ===
class SyncResult {
final bool success;
final String? error;
final int syncedSales;
final int syncedProducts;
final int syncedCustomers;
final bool hasConnection;
final bool wasSkipped;

const SyncResult({
required this.success,
this.error,
this.syncedSales = 0,
this.syncedProducts = 0,
this.syncedCustomers = 0,
this.hasConnection = true,
this.wasSkipped = false,
});

factory SyncResult.success({
int syncedSales = 0,
int syncedProducts = 0,
int syncedCustomers = 0,
}) {
return SyncResult(
success: true,
syncedSales: syncedSales,
syncedProducts: syncedProducts,
syncedCustomers: syncedCustomers,
);
}

factory SyncResult.failed(String error) {
return SyncResult(success: false, error: error);
}

factory SyncResult.noConnection() {
return SyncResult(success: false, hasConnection: false);
}

factory SyncResult.skipped() {
return SyncResult(success: true, wasSkipped: true);
}
}

class SyncBatchResult {
final String type;
final int syncedCount;
final int failedCount;

const SyncBatchResult({
required this.type,
required this.syncedCount,
required this.failedCount,
});
}

class SyncStatus {
final String status; // 'idle', 'syncing', 'success', 'failed'
final DateTime? lastSync;

const SyncStatus({
required this.status,
this.lastSync,
});

bool get isSyncing => status == 'syncing';
bool get hasSynced => lastSync != null;
}

// Provider
final syncServiceProvider = Provider<SyncService>((ref) {
return SyncService();
});

##

//src/ui/screens/account/account_management_screen.dart
// Screen for managing user account settings.
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
import 'package:andalus_smart_pos/src/providers/auth_provider.dart';
import 'package:andalus_smart_pos/src/providers/theme_provider.dart';
import 'package:andalus_smart_pos/src/providers/language_provider.dart';
import 'package:andalus_smart_pos/src/data/models/user.dart';
import 'package:andalus_smart_pos/src/ui/screens/auth/phone_login_screen.dart';

class AccountManagementScreen extends ConsumerStatefulWidget {
const AccountManagementScreen({super.key});

@override
ConsumerState<AccountManagementScreen> createState() =>
\_AccountManagementScreenState();
}

class \_AccountManagementScreenState
extends ConsumerState<AccountManagementScreen> {
final \_nameController = TextEditingController();
final \_phoneController = TextEditingController();
final \_emailController = TextEditingController();
final \_currentPasswordController = TextEditingController();
final \_newPasswordController = TextEditingController();
final \_confirmPasswordController = TextEditingController();

bool \_isEditing = false;
bool \_isChangingPassword = false;

@override
void initState() {
super.initState();
\_loadUserData();
}

void \_loadUserData() {
final authState = ref.read(authProvider);
final user = authState.user;

    if (user != null) {
      _nameController.text = user.name;
      _phoneController.text = user.phone;
      _emailController.text = user.email ?? '';
    }

}

@override
void dispose() {
\_nameController.dispose();
\_phoneController.dispose();
\_emailController.dispose();
\_currentPasswordController.dispose();
\_newPasswordController.dispose();
\_confirmPasswordController.dispose();
super.dispose();
}

void \_toggleEdit() {
setState(() {
\_isEditing = !\_isEditing;
if (!\_isEditing) {
\_loadUserData(); // Reset changes
}
});
}

void \_togglePasswordChange() {
setState(() {
\_isChangingPassword = !\_isChangingPassword;
if (!\_isChangingPassword) {
\_currentPasswordController.clear();
\_newPasswordController.clear();
\_confirmPasswordController.clear();
}
});
}

Future<void> \_updateProfile() async {
final authState = ref.read(authProvider);
final user = authState.user;

    if (user == null) return;

    // TODO: Implement profile update logic
    final updatedUser = user.copyWith(
      name: _nameController.text,
      phone: _phoneController.text,
      email: _emailController.text.isEmpty ? null : _emailController.text,
    );

    // Update user in provider/database
    // await ref.read(authProvider.notifier).updateProfile(updatedUser);

    setState(() => _isEditing = false);

    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content:
              Text(AppLocalizations.of(context).translate('settingsSaved')),
          backgroundColor: Colors.green,
        ),
      );
    }

}

Future<void> \_changePassword() async {
if (\_newPasswordController.text != \_confirmPasswordController.text) {
if (mounted) {
ScaffoldMessenger.of(context).showSnackBar(
const SnackBar(
content: Text('New passwords do not match'),
backgroundColor: Colors.red,
),
);
}
return;
}

    // TODO: Implement password change logic
    // await ref.read(authServiceProvider).changePassword(
    //   userId,
    //   _newPasswordController.text,
    // );

    _togglePasswordChange();

    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Password changed successfully'),
          backgroundColor: Colors.green,
        ),
      );
    }

}

void \_logout() {
showDialog(
context: context,
builder: (context) => AlertDialog(
title: Text(AppLocalizations.of(context).translate('confirm')),
content: Text(AppLocalizations.of(context)
.translate('Are you sure you want to logout?')),
actions: [
TextButton(
onPressed: () => Navigator.pop(context),
child: Text(AppLocalizations.of(context).translate('cancel')),
),
TextButton(
onPressed: () {
Navigator.pop(context);
_performLogout();
},
style: TextButton.styleFrom(foregroundColor: Colors.red),
child: Text(AppLocalizations.of(context).translate('confirm')),
),
],
),
);
}

void \_performLogout() {
ref.read(authProvider.notifier).logout();
Navigator.pushAndRemoveUntil(
context,
MaterialPageRoute(builder: (context) => const PhoneLoginScreen()),
(route) => false,
);
}

@override
Widget build(BuildContext context) {
final authState = ref.watch(authProvider);
final themeMode = ref.watch(themeProvider);
final locale = ref.watch(languageProvider);
final localizations = AppLocalizations.of(context);
final user = authState.user;

    return Scaffold(
      appBar: AppBar(
        title: Text(localizations.translate('Account Settings')),
        actions: [
          if (_isEditing) ...[
            IconButton(
              icon: const Icon(Icons.save),
              onPressed: _updateProfile,
              tooltip: 'Save Changes',
            ),
            IconButton(
              icon: const Icon(Icons.cancel),
              onPressed: _toggleEdit,
              tooltip: 'Cancel',
            ),
          ] else if (!_isChangingPassword) ...[
            IconButton(
              icon: const Icon(Icons.edit),
              onPressed: _toggleEdit,
              tooltip: 'Edit Profile',
            ),
          ],
        ],
      ),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          // User Profile Section
          Card(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      const CircleAvatar(
                        radius: 30,
                        backgroundColor: Colors.blue,
                        child:
                            Icon(Icons.person, color: Colors.white, size: 30),
                      ),
                      const SizedBox(width: 16),
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              user?.name ?? 'No Name',
                              style: const TextStyle(
                                fontSize: 18,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                            const SizedBox(height: 4),
                            Text(
                              user?.role.displayName ?? 'User',
                              style: TextStyle(
                                color: Colors.grey.shade600,
                              ),
                            ),
                            const SizedBox(height: 4),
                            Text(
                              user?.phone ?? 'No Phone',
                              style: TextStyle(
                                color: Colors.grey.shade600,
                              ),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 16),

                  // Profile Form
                  if (_isEditing) _buildProfileForm(),
                ],
              ),
            ),
          ),
          const SizedBox(height: 16),

          // Appearance & Language Section
          Card(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    localizations.appearanceLanguage,
                    style: const TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 16),

                  // Theme Mode
                  ListTile(
                    leading: const Icon(Icons.dark_mode),
                    title: Text(localizations.themeMode),
                    subtitle: Text(_getThemeModeText(themeMode, localizations)),
                    trailing: DropdownButton<ThemeMode>(
                      value: themeMode,
                      onChanged: (newMode) {
                        if (newMode != null) {
                          ref.read(themeProvider.notifier).setTheme(newMode);
                        }
                      },
                      items: ThemeMode.values.map((mode) {
                        return DropdownMenuItem(
                          value: mode,
                          child: Text(_getThemeModeText(mode, localizations)),
                        );
                      }).toList(),
                    ),
                  ),
                  const Divider(),

                  // Language
                  ListTile(
                    leading: const Icon(Icons.language),
                    title: Text(localizations.language),
                    subtitle: Text(_getLanguageText(locale, localizations)),
                    trailing: DropdownButton<Locale>(
                      value: locale,
                      onChanged: (newLocale) {
                        if (newLocale != null) {
                          ref
                              .read(languageProvider.notifier)
                              .setLanguage(newLocale.languageCode);
                        }
                      },
                      items: const [
                        DropdownMenuItem(
                          value: Locale('en'),
                          child: Text('English'),
                        ),
                        DropdownMenuItem(
                          value: Locale('am'),
                          child: Text('·ä†·àõ·à≠·äõ'),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ),
          ),
          const SizedBox(height: 16),

          // Security Section
          Card(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Security',
                    style: const TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 16),
                  if (_isChangingPassword) ...[
                    _buildPasswordChangeForm(),
                    const SizedBox(height: 16),
                  ],
                  SizedBox(
                    width: double.infinity,
                    child: OutlinedButton(
                      onPressed: _isChangingPassword
                          ? _changePassword
                          : _togglePasswordChange,
                      child: Text(_isChangingPassword
                          ? 'Change Password'
                          : 'Change Password'),
                    ),
                  ),
                ],
              ),
            ),
          ),
          const SizedBox(height: 16),

          // Logout Section
          Card(
            color: Colors.red.shade50,
            child: ListTile(
              leading: Icon(Icons.logout, color: Colors.red.shade600),
              title: Text(
                'Logout',
                style: TextStyle(
                  color: Colors.red.shade700,
                  fontWeight: FontWeight.bold,
                ),
              ),
              trailing: Icon(Icons.arrow_forward, color: Colors.red.shade600),
              onTap: _logout,
            ),
          ),
        ],
      ),
    );

}

Widget \_buildProfileForm() {
return Column(
children: [
TextFormField(
controller: _nameController,
decoration: const InputDecoration(
labelText: 'Full Name',
border: OutlineInputBorder(),
),
),
const SizedBox(height: 12),
TextFormField(
controller: _phoneController,
decoration: const InputDecoration(
labelText: 'Phone Number',
border: OutlineInputBorder(),
),
keyboardType: TextInputType.phone,
),
const SizedBox(height: 12),
TextFormField(
controller: _emailController,
decoration: const InputDecoration(
labelText: 'Email (Optional)',
border: OutlineInputBorder(),
),
keyboardType: TextInputType.emailAddress,
),
],
);
}

Widget \_buildPasswordChangeForm() {
return Column(
children: [
TextFormField(
controller: _currentPasswordController,
decoration: const InputDecoration(
labelText: 'Current Password',
border: OutlineInputBorder(),
),
obscureText: true,
),
const SizedBox(height: 12),
TextFormField(
controller: _newPasswordController,
decoration: const InputDecoration(
labelText: 'New Password',
border: OutlineInputBorder(),
),
obscureText: true,
),
const SizedBox(height: 12),
TextFormField(
controller: _confirmPasswordController,
decoration: const InputDecoration(
labelText: 'Confirm New Password',
border: OutlineInputBorder(),
),
obscureText: true,
),
],
);
}

String \_getThemeModeText(ThemeMode mode, AppLocalizations localizations) {
switch (mode) {
case ThemeMode.light:
return localizations.light;
case ThemeMode.dark:
return localizations.dark;
case ThemeMode.system:
return localizations.systemDefault;
}
}

String \_getLanguageText(Locale locale, AppLocalizations localizations) {
return locale.languageCode == 'en'
? localizations.english
: localizations.amharic;
}
}

##

// lib/src/ui/screens/auth/forgot_password_screen.dart
// Screen for handling the "Forgot Password" functionality.
import 'package:andalus_smart_pos/src/widgets/common/app_button.dart';
import 'package:andalus_smart_pos/src/widgets/common/app_text_field.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';

class ForgotPasswordScreen extends ConsumerStatefulWidget {
const ForgotPasswordScreen({super.key});

@override
ConsumerState<ForgotPasswordScreen> createState() =>
\_ForgotPasswordScreenState();
}

class \_ForgotPasswordScreenState extends ConsumerState<ForgotPasswordScreen> {
final \_phoneController = TextEditingController();
final \_otpController = TextEditingController();
final \_newPasswordController = TextEditingController();
final \_confirmPasswordController = TextEditingController();

final \_formKey = GlobalKey<FormState>();
final \_step2FormKey = GlobalKey<FormState>();

int \_currentStep = 0;
bool \_isLoading = false;
bool \_isResendingOTP = false;
String? \_errorMessage;

@override
void dispose() {
\_phoneController.dispose();
\_otpController.dispose();
\_newPasswordController.dispose();
\_confirmPasswordController.dispose();
super.dispose();
}

Future<void> \_sendOTP() async {
if (!\_formKey.currentState!.validate()) return;

    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      // Simulate API call
      await Future.delayed(const Duration(seconds: 2));

      // TODO: Implement actual OTP sending logic
      // await ref.read(authProvider.notifier).sendPasswordResetOTP(_phoneController.text.trim());

      setState(() {
        _currentStep = 1;
        _isLoading = false;
      });

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
              AppLocalizations.of(context).translate('otpSentSuccessfully')),
          backgroundColor: Colors.green,
        ),
      );
    } catch (e) {
      setState(() {
        _isLoading = false;
        _errorMessage = e.toString();
      });
    }

}

Future<void> \_resendOTP() async {
setState(() => \_isResendingOTP = true);

    try {
      // Simulate API call
      await Future.delayed(const Duration(seconds: 2));

      // TODO: Implement actual OTP resend logic

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
              AppLocalizations.of(context).translate('otpResentSuccessfully')),
          backgroundColor: Colors.green,
        ),
      );
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(e.toString()),
          backgroundColor: Colors.red,
        ),
      );
    } finally {
      setState(() => _isResendingOTP = false);
    }

}

Future<void> \_verifyOTPAndResetPassword() async {
if (!\_step2FormKey.currentState!.validate()) return;

    if (_newPasswordController.text != _confirmPasswordController.text) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
              AppLocalizations.of(context).translate('passwordsDoNotMatch')),
          backgroundColor: Colors.red,
        ),
      );
      return;
    }

    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      // Simulate API call
      await Future.delayed(const Duration(seconds: 2));

      // TODO: Implement actual password reset logic
      // await ref.read(authProvider.notifier).resetPassword(
      //   _phoneController.text.trim(),
      //   _otpController.text.trim(),
      //   _newPasswordController.text,
      // );

      setState(() {
        _currentStep = 2;
        _isLoading = false;
      });

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(AppLocalizations.of(context)
              .translate('passwordResetSuccessfully')),
          backgroundColor: Colors.green,
        ),
      );
    } catch (e) {
      setState(() {
        _isLoading = false;
        _errorMessage = e.toString();
      });
    }

}

void \_navigateToLogin() {
Navigator.of(context).pop();
}

String? \_validatePhone(String? value) {
if (value == null || value.trim().isEmpty) {
return AppLocalizations.of(context).translate('phoneRequired');
}
if (!RegExp(r'^\+251[0-9]{9}$').hasMatch(value.trim())) {
return AppLocalizations.of(context).translate('validEthiopianPhone');
}
return null;
}

String? \_validateOTP(String? value) {
if (value == null || value.trim().isEmpty) {
return AppLocalizations.of(context).translate('otpRequired');
}
if (value.trim().length != 6) {
return AppLocalizations.of(context).translate('otpMustBe6Digits');
}
return null;
}

String? \_validatePassword(String? value) {
if (value == null || value.isEmpty) {
return AppLocalizations.of(context).translate('passwordRequired');
}
if (value.length < 6) {
return AppLocalizations.of(context).translate('passwordMinLength');
}
return null;
}

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);
final loc = AppLocalizations.of(context);

    return Scaffold(
      appBar: AppBar(
        title: Text(loc.translate('forgotPassword')),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: _navigateToLogin,
        ),
      ),
      body: Padding(
        padding: const EdgeInsets.all(24),
        child: _buildStepContent(theme, loc),
      ),
    );

}

Widget \_buildStepContent(ThemeData theme, AppLocalizations loc) {
switch (\_currentStep) {
case 0:
return \_buildStep1(theme, loc);
case 1:
return \_buildStep2(theme, loc);
case 2:
return \_buildSuccessStep(theme, loc);
default:
return \_buildStep1(theme, loc);
}
}

Widget \_buildStep1(ThemeData theme, AppLocalizations loc) {
return Form(
key: \_formKey,
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
// Header
Icon(
Icons.lock_reset_rounded,
size: 80,
color: theme.colorScheme.primary,
),
const SizedBox(height: 24),
Text(
loc.translate('resetYourPassword'),
style: theme.textTheme.headlineSmall?.copyWith(
fontWeight: FontWeight.w700,
),
),
const SizedBox(height: 8),
Text(
loc.translate('enterPhoneToResetPassword'),
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.6),
),
),
const SizedBox(height: 32),

          // Phone Input
          AppTextField(
            controller: _phoneController,
            label: loc.translate('phoneNumber'),
            prefixText: '+251 ',
            prefixIcon: Icon(
              Icons.phone_rounded,
              color: theme.colorScheme.primary,
            ),
            keyboardType: TextInputType.phone,
            enabled: !_isLoading,
            validator: _validatePhone,
            textInputAction: TextInputAction.done,
          ),
          const SizedBox(height: 16),

          // Error Message
          if (_errorMessage != null) ...[
            Container(
              width: double.infinity,
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: theme.colorScheme.errorContainer,
                borderRadius: BorderRadius.circular(8),
              ),
              child: Row(
                children: [
                  Icon(
                    Icons.error_outline_rounded,
                    color: theme.colorScheme.onErrorContainer,
                    size: 16,
                  ),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      _errorMessage!,
                      style: theme.textTheme.bodySmall?.copyWith(
                        color: theme.colorScheme.onErrorContainer,
                      ),
                    ),
                  ),
                ],
              ),
            ),
            const SizedBox(height: 16),
          ],

          const Spacer(),

          // Send OTP Button
          AppButton.primary(
            onPressed: _isLoading ? null : _sendOTP,
            isLoading: _isLoading,
            child: Text(loc.translate('sendOTP')),
          ),
        ],
      ),
    );

}

Widget \_buildStep2(ThemeData theme, AppLocalizations loc) {
return Form(
key: \_step2FormKey,
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
// Header
Icon(
Icons.verified_user_rounded,
size: 80,
color: theme.colorScheme.primary,
),
const SizedBox(height: 24),
Text(
loc.translate('verifyAndReset'),
style: theme.textTheme.headlineSmall?.copyWith(
fontWeight: FontWeight.w700,
),
),
const SizedBox(height: 8),
Text(
loc.translate('enterOTPAndNewPassword'),
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.6),
),
),
const SizedBox(height: 32),

          // OTP Input
          AppTextField(
            controller: _otpController,
            label: loc.translate('enterOTPCode'),
            prefixIcon: Icon(
              Icons.sms_rounded,
              color: theme.colorScheme.primary,
            ),
            keyboardType: TextInputType.number,
            maxLength: 6,
            enabled: !_isLoading,
            validator: _validateOTP,
          ),
          const SizedBox(height: 16),

          // New Password
          AppTextField(
            controller: _newPasswordController,
            label: loc.translate('newPassword'),
            prefixIcon: Icon(
              Icons.lock_rounded,
              color: theme.colorScheme.primary,
            ),
            obscureText: true,
            enabled: !_isLoading,
            validator: _validatePassword,
          ),
          const SizedBox(height: 16),

          // Confirm Password
          AppTextField(
            controller: _confirmPasswordController,
            label: loc.translate('confirmNewPassword'),
            prefixIcon: Icon(
              Icons.lock_outline_rounded,
              color: theme.colorScheme.primary,
            ),
            obscureText: true,
            enabled: !_isLoading,
            validator: (value) {
              if (value != _newPasswordController.text) {
                return loc.translate('passwordsDoNotMatch');
              }
              return null;
            },
          ),
          const SizedBox(height: 16),

          // Resend OTP
          Center(
            child: TextButton(
              onPressed: _isResendingOTP ? null : _resendOTP,
              child: _isResendingOTP
                  ? Text(loc.translate('resendingOTP'))
                  : Text(loc.translate('resendOTP')),
            ),
          ),

          const Spacer(),

          // Reset Password Button
          AppButton.primary(
            onPressed: _isLoading ? null : _verifyOTPAndResetPassword,
            isLoading: _isLoading,
            child: Text(loc.translate('resetPassword')),
          ),
        ],
      ),
    );

}

Widget \_buildSuccessStep(ThemeData theme, AppLocalizations loc) {
return Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
Icon(
Icons.check_circle_rounded,
size: 100,
color: Colors.green,
),
const SizedBox(height: 32),
Text(
loc.translate('passwordResetSuccessfully'),
style: theme.textTheme.headlineSmall?.copyWith(
fontWeight: FontWeight.w700,
color: Colors.green,
),
textAlign: TextAlign.center,
),
const SizedBox(height: 16),
Text(
loc.translate('youCanNowLoginWithNewPassword'),
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.6),
),
textAlign: TextAlign.center,
),
const SizedBox(height: 40),
AppButton.primary(
onPressed: _navigateToLogin,
child: Text(loc.translate('backToLogin')),
),
],
);
}
}

##

// src/ui/screens/auth/otp_verification_screen.dart
// Screen for OTP verification during registration or login.
import 'dart:async';

import 'package:andalus_smart_pos/src/widgets/common/app_button.dart';
import 'package:andalus_smart_pos/src/widgets/common/app_text_field.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
import 'package:andalus_smart_pos/src/providers/auth_provider.dart';

class OTPVerificationScreen extends ConsumerStatefulWidget {
final String phone;
final VerificationType type;
final String? businessName;

const OTPVerificationScreen({
super.key,
required this.phone,
required this.type,
this.businessName,
});

@override
ConsumerState<OTPVerificationScreen> createState() =>
\_OTPVerificationScreenState();
}

class \_OTPVerificationScreenState extends ConsumerState<OTPVerificationScreen> {
final \_otpController = TextEditingController();
final \_formKey = GlobalKey<FormState>();
final \_focusNode = FocusNode();

bool \_isLoading = false;
bool \_isResending = false;
int \_resendCooldown = 0;
Timer? \_cooldownTimer;

@override
void initState() {
super.initState();
\_sendOTP();
\_focusNode.requestFocus();
}

@override
void dispose() {
\_otpController.dispose();
\_focusNode.dispose();
\_cooldownTimer?.cancel();
super.dispose();
}

Future<void> \_sendOTP() async {
if (widget.phone.isEmpty) {
\_showError('Phone number not set');
return;
}

    try {
      setState(() => _isResending = true);

      // Use the generic sendOTP method from your AuthService
      await ref.read(authProvider.notifier).sendOTP(widget.phone);

      // Start cooldown timer (60 seconds)
      _startCooldownTimer();

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              AppLocalizations.of(context).translate('otpSentSuccessfully'),
            ),
            backgroundColor: Colors.green,
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
    } catch (e) {
      _showError(e.toString());
    } finally {
      if (mounted) {
        setState(() => _isResending = false);
      }
    }

}

void \_startCooldownTimer() {
setState(() => \_resendCooldown = 60);

    _cooldownTimer?.cancel();
    _cooldownTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (_resendCooldown > 0) {
        setState(() => _resendCooldown--);
      } else {
        timer.cancel();
      }
    });

}

Future<void> \_verifyOTP() async {
if (!\_formKey.currentState!.validate()) return;
if (\_isLoading) return;

    setState(() => _isLoading = true);

    try {
      // Use the appropriate method based on verification type
      if (widget.type == VerificationType.registration) {
        // For registration, you'll need to handle this differently
        // This would typically be called from your registration flow
        _showError(
            'Registration OTP verification should be handled in registration flow');
      } else {
        // For login, use the existing loginWithOTP method
        await ref.read(authProvider.notifier).verifyOTPAndLogin(
              widget.phone,
              _otpController.text.trim(),
            );
      }

      // Success handling is done via auth state listener
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              widget.type == VerificationType.registration
                  ? AppLocalizations.of(context)
                      .translate('registrationSuccessful')
                  : AppLocalizations.of(context).translate('loginSuccessful'),
            ),
            backgroundColor: Colors.green,
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
    } catch (e) {
      _showError(e.toString());
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }

}

void \_showError(String message) {
if (mounted) {
ScaffoldMessenger.of(context).showSnackBar(
SnackBar(
content: Text(message),
backgroundColor: Colors.red,
behavior: SnackBarBehavior.floating,
duration: const Duration(seconds: 4),
),
);
}
}

String? \_validateOTP(String? value) {
if (value == null || value.trim().isEmpty) {
return AppLocalizations.of(context).translate('otpRequired');
}
if (value.trim().length != 6) {
return AppLocalizations.of(context).translate('otpMustBe6Digits');
}
if (!RegExp(r'^[0-9]{6}$').hasMatch(value.trim())) {
return AppLocalizations.of(context).translate('otpMustBeNumbers');
}
return null;
}

String \_formatPhone(String phone) {
if (phone.startsWith('+251')) {
return '+251 ${phone.substring(4, 6)} ${phone.substring(6, 9)} ${phone.substring(9)}';
}
return phone;
}

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);
final loc = AppLocalizations.of(context);

    return Scaffold(
      appBar: AppBar(
        title: Text(loc.translate('verifyPhone')),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: _isLoading ? null : () => Navigator.of(context).pop(),
        ),
      ),
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Form(
            key: _formKey,
            child: Column(
              children: [
                // Header Section
                _buildHeaderSection(theme, loc),
                const SizedBox(height: 32),

                // OTP Input Section
                _buildOTPInputSection(theme, loc),
                const SizedBox(height: 24),

                // Action Buttons
                _buildActionButtons(theme, loc),

                // Spacer to prevent overflow
                const Expanded(child: SizedBox()),

                // Demo Hint (Remove in production)
                _buildDemoHint(theme),
              ],
            ),
          ),
        ),
      ),
    );

}

Widget \_buildHeaderSection(ThemeData theme, AppLocalizations loc) {
return Column(
children: [
Icon(
Icons.verified_user_rounded,
size: 80,
color: theme.colorScheme.primary,
),
const SizedBox(height: 24),
Text(
loc.translate('verifyYourPhone'),
style: theme.textTheme.headlineSmall?.copyWith(
fontWeight: FontWeight.w700,
),
textAlign: TextAlign.center,
),
const SizedBox(height: 12),
Text(
loc.translate('otpSentToPhone',
params: {'phone': \_formatPhone(widget.phone)}),
style: theme.textTheme.bodyLarge?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.7),
),
textAlign: TextAlign.center,
),
if (widget.businessName != null) ...[
const SizedBox(height: 8),
Text(
loc.translate('forBusiness',
params: {'business': widget.businessName!}),
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.primary,
fontWeight: FontWeight.w600,
),
textAlign: TextAlign.center,
),
],
],
);
}

Widget _buildOTPInputSection(ThemeData theme, AppLocalizations loc) {
return Column(
children: [
AppTextField(
controller: \_otpController,
label: loc.translate('enterOTPCode'),
hintText: '123456',
keyboardType: TextInputType.number,
maxLength: 6,
validator: \_validateOTP,
focusNode: \_focusNode,
textInputAction: TextInputAction.done,
onSubmitted: (_) => _verifyOTP(),
onChanged: (value) {
if (value.length == 6) {
\_focusNode.unfocus();
// Auto-submit when 6 digits are entered
WidgetsBinding.instance.addPostFrameCallback((_) {
\_verifyOTP();
});
}
},
),
const SizedBox(height: 8),
Text(
loc.translate('enter6DigitCode'),
style: theme.textTheme.bodySmall?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.6),
),
),
],
);
}

Widget \_buildActionButtons(ThemeData theme, AppLocalizations loc) {
return Column(
children: [
AppButton.primary(
onPressed: \_isLoading ? null : \_verifyOTP,
isLoading: \_isLoading,
child: Text(
loc.translate('verifyAndContinue'),
style: const TextStyle(fontWeight: FontWeight.w600),
),
),
const SizedBox(height: 20),
Row(
mainAxisAlignment: MainAxisAlignment.center,
children: [
Text(
loc.translate('didNotReceiveCode'),
style: theme.textTheme.bodyMedium,
),
const SizedBox(width: 8),
if (_resendCooldown > 0)
Text(
'(${_resendCooldown}s)',
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.primary,
fontWeight: FontWeight.w600,
),
)
else
TextButton(
onPressed: (_isResending || _isLoading) ? null : _sendOTP,
child: _isResending
? SizedBox(
height: 16,
width: 16,
child: CircularProgressIndicator(
strokeWidth: 2,
color: theme.colorScheme.primary,
),
)
: Text(
loc.translate('resendOTP'),
style: TextStyle(
color: theme.colorScheme.primary,
fontWeight: FontWeight.w600,
),
),
),
],
),
],
);
}

Widget \_buildDemoHint(ThemeData theme) {
return Column(
children: [
const Divider(),
const SizedBox(height: 16),
Container(
padding: const EdgeInsets.all(16),
decoration: BoxDecoration(
color: theme.colorScheme.surfaceVariant,
borderRadius: BorderRadius.circular(12),
),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Row(
children: [
Icon(
Icons.info_outline_rounded,
size: 16,
color: theme.colorScheme.primary,
),
const SizedBox(width: 8),
Text(
'Demo Mode',
style: theme.textTheme.bodySmall?.copyWith(
fontWeight: FontWeight.w600,
color: theme.colorScheme.primary,
),
),
],
),
const SizedBox(height: 8),
Text(
'‚Ä¢ Use "123456" for instant verification\n‚Ä¢ OTPs expire after 10 minutes\n‚Ä¢ Remove this hint in production',
style: theme.textTheme.bodySmall?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.6),
),
),
],
),
),
],
);
}
}

enum VerificationType {
registration,
login,
}

##

// lib/src/ui/screens/auth/phone_login_screen.dart
// Screen for phone number and password login.
import 'package:andalus_smart_pos/src/widgets/common/app_button.dart';
import 'package:andalus_smart_pos/src/widgets/common/app_text_field.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
import 'package:andalus_smart_pos/src/providers/auth_provider.dart';
import 'package:andalus_smart_pos/src/ui/screens/onboarding/onboarding_screen.dart';
import 'package:andalus_smart_pos/src/ui/screens/main_navigation.dart';

class PhoneLoginScreen extends ConsumerStatefulWidget {
const PhoneLoginScreen({super.key});

@override
ConsumerState<PhoneLoginScreen> createState() => \_PhoneLoginScreenState();
}

class \_PhoneLoginScreenState extends ConsumerState<PhoneLoginScreen> {
final \_phoneController = TextEditingController();
final \_passwordController = TextEditingController();
final \_formKey = GlobalKey<FormState>();
final \_passwordFocusNode = FocusNode();

bool \_isLoggingIn = false;
String? \_loginError;

@override
void dispose() {
\_phoneController.dispose();
\_passwordController.dispose();
\_passwordFocusNode.dispose();
super.dispose();
}

Future<void> \_loginWithPassword() async {
if (!(\_formKey.currentState?.validate() ?? false)) return;

    if (_isLoggingIn) return;

    setState(() {
      _isLoggingIn = true;
      _loginError = null;
    });

    try {
      await ref.read(authProvider.notifier).loginWithPassword(
            _phoneController.text.trim(),
            _passwordController.text,
          );

      // Success handling is done in the auth state listener
    } catch (e) {
      setState(() {
        _isLoggingIn = false;
        _loginError = e.toString();
      });

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(e.toString()),
          backgroundColor: Theme.of(context).colorScheme.error,
          duration: const Duration(seconds: 3),
        ),
      );
    }

}

String? \_validatePhone(String? value) {
if (value == null || value.trim().isEmpty) {
return AppLocalizations.of(context).translate('phoneRequired');
}
if (!RegExp(r'^\+251[0-9]{9}$').hasMatch(value.trim())) {
return AppLocalizations.of(context).translate('validEthiopianPhone');
}
return null;
}

String? \_validatePassword(String? value) {
if (value == null || value.isEmpty) {
return AppLocalizations.of(context).translate('passwordRequired');
}
if (value.length < 6) {
return AppLocalizations.of(context).translate('passwordMinLength');
}
return null;
}

void \_navigateToOnboarding() {
Navigator.push(
context,
MaterialPageRoute(builder: (context) => const OnboardingScreen()),
);
}

@override
Widget build(BuildContext context) {
final authState = ref.watch(authProvider);
final theme = Theme.of(context);
final loc = AppLocalizations.of(context);

    // Handle successful login
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (authState.isAuthenticated) {
        Navigator.of(context).pushReplacement(
          MaterialPageRoute(builder: (context) => const MainNavigation()),
        );
      }
    });

    return Scaffold(
      backgroundColor: theme.colorScheme.primary,
      body: SafeArea(
        child: Center(
          child: SingleChildScrollView(
            padding: const EdgeInsets.all(24),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                // Logo and Welcome Section
                _buildWelcomeSection(theme, loc),
                const SizedBox(height: 40),

                // Login Card
                _buildLoginCard(theme, loc),
              ],
            ),
          ),
        ),
      ),
    );

}

Widget \_buildWelcomeSection(ThemeData theme, AppLocalizations loc) {
return Column(
children: [
// App Icon
Container(
width: 100,
height: 100,
decoration: BoxDecoration(
color: theme.colorScheme.onPrimary.withOpacity(0.1),
shape: BoxShape.circle,
border: Border.all(
color: theme.colorScheme.onPrimary.withOpacity(0.2),
width: 2,
),
),
child: Icon(
Icons.point_of_sale_rounded,
size: 50,
color: theme.colorScheme.onPrimary,
),
),
const SizedBox(height: 24),

        // App Name
        Text(
          'Andalus Smart POS',
          style: TextStyle(
            fontSize: 28,
            fontWeight: FontWeight.bold,
            color: theme.colorScheme.onPrimary,
            letterSpacing: -0.5,
          ),
        ),
        const SizedBox(height: 8),

        // Subtitle
        Text(
          loc.translate('loginToYourAccount'),
          style: TextStyle(
            fontSize: 16,
            color: theme.colorScheme.onPrimary.withOpacity(0.8),
          ),
          textAlign: TextAlign.center,
        ),
      ],
    );

}

Widget \_buildLoginCard(ThemeData theme, AppLocalizations loc) {
return Card(
elevation: 8,
shape: RoundedRectangleBorder(
borderRadius: BorderRadius.circular(20),
),
child: Padding(
padding: const EdgeInsets.all(32),
child: Form(
key: \_formKey,
child: Column(
children: [
// Header
Text(
loc.translate('welcomeBack'),
style: theme.textTheme.headlineSmall?.copyWith(
fontWeight: FontWeight.w700,
color: theme.colorScheme.onSurface,
),
),
const SizedBox(height: 8),
Text(
loc.translate('enterCredentialsToContinue'),
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.6),
),
textAlign: TextAlign.center,
),
const SizedBox(height: 32),

              // Phone Input
              AppTextField(
                controller: _phoneController,
                label: loc.translate('phoneNumber'),
                prefixText: '+251 ',
                prefixIcon: Icon(
                  Icons.phone_rounded,
                  color: theme.colorScheme.primary,
                ),
                keyboardType: TextInputType.phone,
                enabled: !_isLoggingIn,
                validator: _validatePhone,
                textInputAction: TextInputAction.next,
                onSubmitted: (_) {
                  // Move focus to password field when phone field is submitted
                  FocusScope.of(context).requestFocus(_passwordFocusNode);
                },
              ),
              const SizedBox(height: 20),

              // Password Input - FIXED: using onSubmitted instead of onFieldSubmitted
              AppTextField(
                controller: _passwordController,
                label: loc.translate('password'),
                prefixIcon: Icon(
                  Icons.lock_rounded,
                  color: theme.colorScheme.primary,
                ),
                obscureText: true,
                enabled: !_isLoggingIn,
                validator: _validatePassword,
                textInputAction: TextInputAction.done,
                focusNode: _passwordFocusNode,
                onSubmitted: (_) =>
                    _loginWithPassword(), // FIXED: Changed to onSubmitted
              ),
              const SizedBox(height: 8),

              // Forgot Password
              Align(
                alignment: Alignment.centerRight,
                child: TextButton(
                  onPressed: _isLoggingIn
                      ? null
                      : () {
                          // TODO: Implement forgot password
                          ScaffoldMessenger.of(context).showSnackBar(
                            SnackBar(
                              content: Text(loc.translate('featureComingSoon')),
                            ),
                          );
                        },
                  child: Text(
                    loc.translate('forgotPassword'),
                    style: TextStyle(
                      color: theme.colorScheme.primary,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ),
              ),
              const SizedBox(height: 24),

              // Error Message
              if (_loginError != null) ...[
                Container(
                  width: double.infinity,
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    color: theme.colorScheme.errorContainer,
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Row(
                    children: [
                      Icon(
                        Icons.error_outline_rounded,
                        color: theme.colorScheme.onErrorContainer,
                        size: 16,
                      ),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Text(
                          _loginError!,
                          style: theme.textTheme.bodySmall?.copyWith(
                            color: theme.colorScheme.onErrorContainer,
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
                const SizedBox(height: 16),
              ],

              // Login Button
              AppButton.primary(
                onPressed: _isLoggingIn ? null : _loginWithPassword,
                isLoading: _isLoggingIn,
                child: Text(
                  loc.translate('login'),
                  style: const TextStyle(
                    fontWeight: FontWeight.w600,
                    fontSize: 16,
                  ),
                ),
              ),
              const SizedBox(height: 24),

              // Divider
              Row(
                children: [
                  Expanded(
                    child: Divider(
                      color: theme.colorScheme.outline.withOpacity(0.3),
                    ),
                  ),
                  Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 16),
                    child: Text(
                      loc.translate('or'),
                      style: theme.textTheme.bodySmall?.copyWith(
                        color: theme.colorScheme.onSurface.withOpacity(0.5),
                      ),
                    ),
                  ),
                  Expanded(
                    child: Divider(
                      color: theme.colorScheme.outline.withOpacity(0.3),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 24),

              // Register Button
              AppButton.outlined(
                onPressed: _isLoggingIn ? null : _navigateToOnboarding,
                child: Text(
                  loc.translate('createNewBusiness'),
                  style: TextStyle(
                    fontWeight: FontWeight.w600,
                    color: theme.colorScheme.primary,
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );

}
}

##

// src/ui/screens/onboarding/onboarding_otp_verification_screen.dart
// Screen for OTP verification during the onboarding process.
import 'dart:async';

import 'package:andalus_smart_pos/src/widgets/common/app_button.dart';
import 'package:andalus_smart_pos/src/widgets/common/app_text_field.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
import 'package:andalus_smart_pos/src/providers/onboarding_provider.dart';

class OnboardingOTPVerificationScreen extends ConsumerStatefulWidget {
const OnboardingOTPVerificationScreen({super.key});

@override
ConsumerState<OnboardingOTPVerificationScreen> createState() =>
\_OnboardingOTPVerificationScreenState();
}

class \_OnboardingOTPVerificationScreenState
extends ConsumerState<OnboardingOTPVerificationScreen> {
final \_otpController = TextEditingController();
final \_formKey = GlobalKey<FormState>();
final \_focusNode = FocusNode();

bool \_isLoading = false;
bool \_isResending = false;
bool \_isVerifying = false; // Add this flag
int \_resendCooldown = 0;
Timer? \_cooldownTimer;
bool \_otpSent = false;
Timer? \_debounceTimer;

@override
void initState() {
super.initState();
WidgetsBinding.instance.addPostFrameCallback((\_) {
\_sendOTP();
});
\_focusNode.requestFocus();
}

@override
void dispose() {
\_otpController.dispose();
\_focusNode.dispose();
\_cooldownTimer?.cancel();
super.dispose();
}

String? get \_phone {
final state = ref.read(onboardingProvider);
return state.owner?.phone;
}

String? get \_businessName {
final state = ref.read(onboardingProvider);
return state.shop?.shopName;
}

Future<void> \_sendOTP() async {
final phone = \_phone;
if (phone == null) {
\_showError('Phone number not set. Please complete owner registration.');
return;
}

    try {
      setState(() => _isResending = true);

      await ref.read(onboardingProvider.notifier).sendRegistrationOTP(phone);

      _startCooldownTimer();
      setState(() => _otpSent = true);

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              AppLocalizations.of(context).translate('otpSentSuccessfully'),
            ),
            backgroundColor: Colors.green,
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
    } catch (e) {
      _showError(e.toString());
    } finally {
      if (mounted) {
        setState(() => _isResending = false);
      }
    }

}

void \_startCooldownTimer() {
setState(() => \_resendCooldown = 60);

    _cooldownTimer?.cancel();
    _cooldownTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (_resendCooldown > 0) {
        setState(() => _resendCooldown--);
      } else {
        timer.cancel();
      }
    });

}

Future<void> \_verifyOTP() async {
if (!\_formKey.currentState!.validate()) return;
if (\_isLoading || \_isVerifying) return; // Prevent multiple calls

    setState(() {
      _isLoading = true;
      _isVerifying = true;
    });

    try {
      final success =
          await ref.read(onboardingProvider.notifier).verifyRegistrationOTP(
                _otpController.text.trim(),
              );

      if (success && mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              AppLocalizations.of(context).translate('otpVerifiedSuccessfully'),
            ),
            backgroundColor: Colors.green,
            behavior: SnackBarBehavior.floating,
            duration: const Duration(seconds: 2),
          ),
        );

        // Wait a bit for the state to update and navigation to happen
        await Future.delayed(const Duration(milliseconds: 500));

        // Check if we're still on the same screen (navigation didn't happen)
        final currentState = ref.read(onboardingProvider);
        if (currentState.currentStep == 3 && mounted) {
          // Still on OTP screen - show manual continue option
          _showManualContinueOption();
        }
      }
    } catch (e) {
      _showError(e.toString());
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
          _isVerifying = false;
        });
      }
    }

}

void \_showManualContinueOption() {
showDialog(
context: context,
barrierDismissible: false,
builder: (context) => AlertDialog(
title: const Text('Verification Successful'),
content: const Text(
'OTP verified successfully! Please continue to payment.'),
actions: [
TextButton(
onPressed: () {
Navigator.pop(context);
// Manually trigger next step
ref.read(onboardingProvider.notifier).nextStep();
},
child: const Text('Continue to Payment'),
),
],
),
);
}

void \_showError(String message) {
if (mounted) {
ScaffoldMessenger.of(context).showSnackBar(
SnackBar(
content: Text(message),
backgroundColor: Colors.red,
behavior: SnackBarBehavior.floating,
duration: const Duration(seconds: 4),
),
);
}
}

String? \_validateOTP(String? value) {
if (value == null || value.trim().isEmpty) {
return AppLocalizations.of(context).translate('otpRequired');
}
if (value.trim().length != 6) {
return AppLocalizations.of(context).translate('otpMustBe6Digits');
}
if (!RegExp(r'^[0-9]{6}$').hasMatch(value.trim())) {
return AppLocalizations.of(context).translate('otpMustBeNumbers');
}
return null;
}

String \_formatPhone(String phone) {
if (phone.startsWith('+251')) {
return '+251 ${phone.substring(4, 6)} ${phone.substring(6, 9)} ${phone.substring(9)}';
}
return phone;
}

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);
final loc = AppLocalizations.of(context);

    final phone = _phone;
    final businessName = _businessName;

    if (phone == null) {
      return _buildErrorScreen('Please complete owner registration first.');
    }

    return Scaffold(
      appBar: AppBar(
        title: Text(loc.translate('verifyPhone')),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: _isLoading
              ? null
              : () => ref.read(onboardingProvider.notifier).previousStep(),
        ),
      ),
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Form(
            key: _formKey,
            child: Column(
              children: [
                // Header Section
                _buildHeaderSection(theme, loc, phone, businessName),
                const SizedBox(height: 32),

                // OTP Input Section
                _buildOTPInputSection(theme, loc),
                const SizedBox(height: 24),

                // Action Buttons
                _buildActionButtons(theme, loc),

                // Spacer to prevent overflow
                const Expanded(child: SizedBox()),

                // Demo Hint (Remove in production)
                if (_otpSent) _buildDemoHint(theme),
              ],
            ),
          ),
        ),
      ),
    );

}

Widget \_buildHeaderSection(ThemeData theme, AppLocalizations loc,
String phone, String? businessName) {
return Column(
children: [
Icon(
Icons.verified_user_rounded,
size: 80,
color: theme.colorScheme.primary,
),
const SizedBox(height: 24),
Text(
loc.translate('verifyYourPhone'),
style: theme.textTheme.headlineSmall?.copyWith(
fontWeight: FontWeight.w700,
),
textAlign: TextAlign.center,
),
const SizedBox(height: 12),
Text(
loc.translate('otpSentToPhone',
params: {'phone': \_formatPhone(phone)}),
style: theme.textTheme.bodyLarge?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.7),
),
textAlign: TextAlign.center,
),
if (businessName != null) ...[
const SizedBox(height: 8),
Text(
loc.translate('forBusiness', params: {'business': businessName}),
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.primary,
fontWeight: FontWeight.w600,
),
textAlign: TextAlign.center,
),
],
],
);
}

Widget _buildOTPInputSection(ThemeData theme, AppLocalizations loc) {
return Column(
children: [
AppTextField(
controller: \_otpController,
label: loc.translate('enterOTPCode'),
hintText: '123456',
keyboardType: TextInputType.number,
maxLength: 6,
validator: \_validateOTP,
focusNode: \_focusNode,
textInputAction: TextInputAction.done,
onSubmitted: (_) => _verifyOTP(),
onChanged: (value) {
if (value.length == 6 && !\_isLoading) {
\_focusNode.unfocus();
// Use a flag to prevent multiple calls
if (!\_isVerifying) {
\_isVerifying = true;
// Add a small delay to ensure the field is updated
Future.delayed(const Duration(milliseconds: 100), () {
if (mounted) {
\_verifyOTP().then((_) {
\_isVerifying = false;
});
}
});
}
}
},
),
const SizedBox(height: 8),
Text(
loc.translate('enter6DigitCode'),
style: theme.textTheme.bodySmall?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.6),
),
),
],
);
}

Widget \_buildActionButtons(ThemeData theme, AppLocalizations loc) {
return Column(
children: [
AppButton.primary(
onPressed: \_isLoading ? null : \_verifyOTP,
isLoading: \_isLoading,
child: Text(
loc.translate('verifyAndContinue'),
style: const TextStyle(fontWeight: FontWeight.w600),
),
),
const SizedBox(height: 20),
Row(
mainAxisAlignment: MainAxisAlignment.center,
children: [
Text(
loc.translate('didNotReceiveCode'),
style: theme.textTheme.bodyMedium,
),
const SizedBox(width: 8),
if (_resendCooldown > 0)
Text(
'(${_resendCooldown}s)',
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.primary,
fontWeight: FontWeight.w600,
),
)
else
TextButton(
onPressed: (_isResending || _isLoading) ? null : _sendOTP,
child: _isResending
? SizedBox(
height: 16,
width: 16,
child: CircularProgressIndicator(
strokeWidth: 2,
color: theme.colorScheme.primary,
),
)
: Text(
loc.translate('resendOTP'),
style: TextStyle(
color: theme.colorScheme.primary,
fontWeight: FontWeight.w600,
),
),
),
],
),
],
);
}

Widget \_buildDemoHint(ThemeData theme) {
return Column(
children: [
const Divider(),
const SizedBox(height: 16),
Container(
padding: const EdgeInsets.all(16),
decoration: BoxDecoration(
color: theme.colorScheme.surfaceVariant,
borderRadius: BorderRadius.circular(12),
),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Row(
children: [
Icon(
Icons.info_outline_rounded,
size: 16,
color: theme.colorScheme.primary,
),
const SizedBox(width: 8),
Text(
'Demo Mode',
style: theme.textTheme.bodySmall?.copyWith(
fontWeight: FontWeight.w600,
color: theme.colorScheme.primary,
),
),
],
),
const SizedBox(height: 8),
Text(
'‚Ä¢ Use "123456" for instant verification\n‚Ä¢ OTPs expire after 10 minutes\n‚Ä¢ Remove this hint in production',
style: theme.textTheme.bodySmall?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.6),
),
),
],
),
),
],
);
}

Widget \_buildErrorScreen(String message) {
return Center(
child: Padding(
padding: const EdgeInsets.all(24.0),
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
const Icon(
Icons.error_outline_rounded,
size: 64,
color: Colors.red,
),
const SizedBox(height: 24),
Text(
'Registration Error',
style: TextStyle(
fontSize: 20,
fontWeight: FontWeight.bold,
color: Colors.grey[800],
),
),
const SizedBox(height: 16),
Text(
message,
textAlign: TextAlign.center,
style: TextStyle(
fontSize: 16,
color: Colors.grey[600],
),
),
const SizedBox(height: 32),
ElevatedButton(
onPressed: () {
ref.read(onboardingProvider.notifier).previousStep();
},
child: const Text('Go Back to Owner Registration'),
),
],
),
),
);
}
}

##

// src/ui/screens/onboarding/onboarding_screen.dart
// Onboarding screen that manages the multi-step onboarding process.
import 'package:andalus_smart_pos/src/ui/screens/onboarding/onboarding_otp_verification_screen.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/providers/onboarding_provider.dart';
import 'package:andalus_smart_pos/src/ui/screens/onboarding/shop_registration_screen.dart';
import 'package:andalus_smart_pos/src/ui/screens/onboarding/owner_registration_screen.dart';
import 'package:andalus_smart_pos/src/ui/screens/onboarding/subscription_selection_screen.dart';
import 'package:andalus_smart_pos/src/ui/screens/onboarding/otp_verification_screen.dart';
import 'package:andalus_smart_pos/src/ui/screens/onboarding/payment_screen.dart';

class OnboardingScreen extends ConsumerWidget {
const OnboardingScreen({super.key});

@override
Widget build(BuildContext context, WidgetRef ref) {
final state = ref.watch(onboardingProvider);

    return Scaffold(
      backgroundColor: Theme.of(context).colorScheme.background,
      body: _buildStepContent(state.currentStep),
    );

}

// In onboarding_screen.dart - update the \_buildStepContent method
Widget \_buildStepContent(int currentStep) {
switch (currentStep) {
case 0:
return const ShopRegistrationScreen();
case 1:
return const OwnerRegistrationScreen();
case 2:
return const SubscriptionSelectionScreen();
case 3:
return const OnboardingOTPVerificationScreen(); // Use the new dedicated screen
case 4:
return const PaymentScreen();
default:
return const ShopRegistrationScreen();
}
}
}

##

// src/ui/screens/auth/otp_verification_screen.dart
// Screen for OTP verification during registration or login.
import 'dart:async';

import 'package:andalus_smart_pos/src/widgets/common/app_button.dart';
import 'package:andalus_smart_pos/src/widgets/common/app_text_field.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
import 'package:andalus_smart_pos/src/providers/auth_provider.dart';

class OTPVerificationScreen extends ConsumerStatefulWidget {
final String phone;
final VerificationType type;
final String? businessName;

const OTPVerificationScreen({
super.key,
required this.phone,
required this.type,
this.businessName,
});

@override
ConsumerState<OTPVerificationScreen> createState() =>
\_OTPVerificationScreenState();
}

class \_OTPVerificationScreenState extends ConsumerState<OTPVerificationScreen> {
final \_otpController = TextEditingController();
final \_formKey = GlobalKey<FormState>();
final \_focusNode = FocusNode();

bool \_isLoading = false;
bool \_isResending = false;
int \_resendCooldown = 0;
Timer? \_cooldownTimer;

@override
void initState() {
super.initState();
\_sendOTP();
\_focusNode.requestFocus();
}

@override
void dispose() {
\_otpController.dispose();
\_focusNode.dispose();
\_cooldownTimer?.cancel();
super.dispose();
}

Future<void> \_sendOTP() async {
if (widget.phone.isEmpty) {
\_showError('Phone number not set');
return;
}

    try {
      setState(() => _isResending = true);

      // Use the generic sendOTP method from your AuthService
      await ref.read(authProvider.notifier).sendOTP(widget.phone);

      // Start cooldown timer (60 seconds)
      _startCooldownTimer();

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              AppLocalizations.of(context).translate('otpSentSuccessfully'),
            ),
            backgroundColor: Colors.green,
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
    } catch (e) {
      _showError(e.toString());
    } finally {
      if (mounted) {
        setState(() => _isResending = false);
      }
    }

}

void \_startCooldownTimer() {
setState(() => \_resendCooldown = 60);

    _cooldownTimer?.cancel();
    _cooldownTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (_resendCooldown > 0) {
        setState(() => _resendCooldown--);
      } else {
        timer.cancel();
      }
    });

}

Future<void> \_verifyOTP() async {
if (!\_formKey.currentState!.validate()) return;
if (\_isLoading) return;

    setState(() => _isLoading = true);

    try {
      // Use the appropriate method based on verification type
      if (widget.type == VerificationType.registration) {
        // For registration, you'll need to handle this differently
        // This would typically be called from your registration flow
        _showError(
            'Registration OTP verification should be handled in registration flow');
      } else {
        // For login, use the existing loginWithOTP method
        await ref.read(authProvider.notifier).verifyOTPAndLogin(
              widget.phone,
              _otpController.text.trim(),
            );
      }

      // Success handling is done via auth state listener
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              widget.type == VerificationType.registration
                  ? AppLocalizations.of(context)
                      .translate('registrationSuccessful')
                  : AppLocalizations.of(context).translate('loginSuccessful'),
            ),
            backgroundColor: Colors.green,
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
    } catch (e) {
      _showError(e.toString());
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }

}

void \_showError(String message) {
if (mounted) {
ScaffoldMessenger.of(context).showSnackBar(
SnackBar(
content: Text(message),
backgroundColor: Colors.red,
behavior: SnackBarBehavior.floating,
duration: const Duration(seconds: 4),
),
);
}
}

String? \_validateOTP(String? value) {
if (value == null || value.trim().isEmpty) {
return AppLocalizations.of(context).translate('otpRequired');
}
if (value.trim().length != 6) {
return AppLocalizations.of(context).translate('otpMustBe6Digits');
}
if (!RegExp(r'^[0-9]{6}$').hasMatch(value.trim())) {
return AppLocalizations.of(context).translate('otpMustBeNumbers');
}
return null;
}

String \_formatPhone(String phone) {
if (phone.startsWith('+251')) {
return '+251 ${phone.substring(4, 6)} ${phone.substring(6, 9)} ${phone.substring(9)}';
}
return phone;
}

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);
final loc = AppLocalizations.of(context);

    return Scaffold(
      appBar: AppBar(
        title: Text(loc.translate('verifyPhone')),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: _isLoading ? null : () => Navigator.of(context).pop(),
        ),
      ),
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Form(
            key: _formKey,
            child: Column(
              children: [
                // Header Section
                _buildHeaderSection(theme, loc),
                const SizedBox(height: 32),

                // OTP Input Section
                _buildOTPInputSection(theme, loc),
                const SizedBox(height: 24),

                // Action Buttons
                _buildActionButtons(theme, loc),

                // Spacer to prevent overflow
                const Expanded(child: SizedBox()),

                // Demo Hint (Remove in production)
                _buildDemoHint(theme),
              ],
            ),
          ),
        ),
      ),
    );

}

Widget \_buildHeaderSection(ThemeData theme, AppLocalizations loc) {
return Column(
children: [
Icon(
Icons.verified_user_rounded,
size: 80,
color: theme.colorScheme.primary,
),
const SizedBox(height: 24),
Text(
loc.translate('verifyYourPhone'),
style: theme.textTheme.headlineSmall?.copyWith(
fontWeight: FontWeight.w700,
),
textAlign: TextAlign.center,
),
const SizedBox(height: 12),
Text(
loc.translate('otpSentToPhone',
params: {'phone': \_formatPhone(widget.phone)}),
style: theme.textTheme.bodyLarge?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.7),
),
textAlign: TextAlign.center,
),
if (widget.businessName != null) ...[
const SizedBox(height: 8),
Text(
loc.translate('forBusiness',
params: {'business': widget.businessName!}),
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.primary,
fontWeight: FontWeight.w600,
),
textAlign: TextAlign.center,
),
],
],
);
}

Widget _buildOTPInputSection(ThemeData theme, AppLocalizations loc) {
return Column(
children: [
AppTextField(
controller: \_otpController,
label: loc.translate('enterOTPCode'),
hintText: '123456',
keyboardType: TextInputType.number,
maxLength: 6,
validator: \_validateOTP,
focusNode: \_focusNode,
textInputAction: TextInputAction.done,
onSubmitted: (_) => _verifyOTP(),
onChanged: (value) {
if (value.length == 6) {
\_focusNode.unfocus();
// Auto-submit when 6 digits are entered
WidgetsBinding.instance.addPostFrameCallback((_) {
\_verifyOTP();
});
}
},
),
const SizedBox(height: 8),
Text(
loc.translate('enter6DigitCode'),
style: theme.textTheme.bodySmall?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.6),
),
),
],
);
}

Widget \_buildActionButtons(ThemeData theme, AppLocalizations loc) {
return Column(
children: [
AppButton.primary(
onPressed: \_isLoading ? null : \_verifyOTP,
isLoading: \_isLoading,
child: Text(
loc.translate('verifyAndContinue'),
style: const TextStyle(fontWeight: FontWeight.w600),
),
),
const SizedBox(height: 20),
Row(
mainAxisAlignment: MainAxisAlignment.center,
children: [
Text(
loc.translate('didNotReceiveCode'),
style: theme.textTheme.bodyMedium,
),
const SizedBox(width: 8),
if (_resendCooldown > 0)
Text(
'(${_resendCooldown}s)',
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.primary,
fontWeight: FontWeight.w600,
),
)
else
TextButton(
onPressed: (_isResending || _isLoading) ? null : _sendOTP,
child: _isResending
? SizedBox(
height: 16,
width: 16,
child: CircularProgressIndicator(
strokeWidth: 2,
color: theme.colorScheme.primary,
),
)
: Text(
loc.translate('resendOTP'),
style: TextStyle(
color: theme.colorScheme.primary,
fontWeight: FontWeight.w600,
),
),
),
],
),
],
);
}

Widget \_buildDemoHint(ThemeData theme) {
return Column(
children: [
const Divider(),
const SizedBox(height: 16),
Container(
padding: const EdgeInsets.all(16),
decoration: BoxDecoration(
color: theme.colorScheme.surfaceVariant,
borderRadius: BorderRadius.circular(12),
),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Row(
children: [
Icon(
Icons.info_outline_rounded,
size: 16,
color: theme.colorScheme.primary,
),
const SizedBox(width: 8),
Text(
'Demo Mode',
style: theme.textTheme.bodySmall?.copyWith(
fontWeight: FontWeight.w600,
color: theme.colorScheme.primary,
),
),
],
),
const SizedBox(height: 8),
Text(
'‚Ä¢ Use "123456" for instant verification\n‚Ä¢ OTPs expire after 10 minutes\n‚Ä¢ Remove this hint in production',
style: theme.textTheme.bodySmall?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.6),
),
),
],
),
),
],
);
}
}

enum VerificationType {
registration,
login,
}

##

// src/ui/screens/onboarding/owner_registration_screen.dart
// Screen for registering the owner during the onboarding process.
import 'package:andalus_smart_pos/src/widgets/common/app_button.dart';
import 'package:andalus_smart_pos/src/widgets/common/app_text_field.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
import 'package:andalus_smart_pos/src/providers/onboarding_provider.dart';
import 'package:andalus_smart_pos/src/data/models/shop_registration.dart';

class OwnerRegistrationScreen extends ConsumerStatefulWidget {
const OwnerRegistrationScreen({super.key});

@override
ConsumerState<OwnerRegistrationScreen> createState() =>
\_OwnerRegistrationScreenState();
}

class \_OwnerRegistrationScreenState
extends ConsumerState<OwnerRegistrationScreen> {
final \_fullNameController = TextEditingController();
final \_phoneController = TextEditingController();
final \_emailController = TextEditingController();
final \_passwordController = TextEditingController();
final \_confirmPasswordController = TextEditingController();

final \_formKey = GlobalKey<FormState>();
bool \_obscurePassword = true;
bool \_obscureConfirmPassword = true;

@override
void dispose() {
\_fullNameController.dispose();
\_phoneController.dispose();
\_emailController.dispose();
\_passwordController.dispose();
\_confirmPasswordController.dispose();
super.dispose();
}

bool \_validateForm() {
if (\_formKey.currentState?.validate() ?? false) {
if (\_passwordController.text != \_confirmPasswordController.text) {
ScaffoldMessenger.of(context).showSnackBar(
SnackBar(
content: Text(
AppLocalizations.of(context).translate('passwordsDoNotMatch')),
backgroundColor: Theme.of(context).colorScheme.error,
),
);
return false;
}

      final owner = OwnerRegistration(
        fullName: _fullNameController.text.trim(),
        phone: _phoneController.text.trim(),
        password: _passwordController.text,
        email: _emailController.text.trim().isEmpty
            ? null
            : _emailController.text.trim(),
      );

      ref.read(onboardingProvider.notifier).updateOwnerInfo(owner);
      return true;
    }
    return false;

}

void \_proceedToNextStep() {
if (\_validateForm()) {
ref.read(onboardingProvider.notifier).nextStep();
}
}

String? \_validateRequired(String? value, String fieldName) {
if (value == null || value.trim().isEmpty) {
return '$fieldName ${AppLocalizations.of(context).translate('isRequired')}';
}
return null;
}

String? \_validatePhone(String? value) {
if (value == null || value.trim().isEmpty) {
return AppLocalizations.of(context).translate('phoneRequired');
}
if (!RegExp(r'^\+251[0-9]{9}$').hasMatch(value.trim())) {
return AppLocalizations.of(context).translate('validEthiopianPhone');
}
return null;
}

String? \_validateEmail(String? value) {
if (value != null && value.trim().isNotEmpty) {
if (!RegExp(r'^[^@]+@[^@]+\.[^@]+').hasMatch(value.trim())) {
return AppLocalizations.of(context).translate('validEmail');
}
}
return null;
}

String? \_validatePassword(String? value) {
if (value == null || value.isEmpty) {
return AppLocalizations.of(context).translate('passwordRequired');
}
if (value.length < 6) {
return AppLocalizations.of(context).translate('passwordMinLength');
}
return null;
}

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);
final loc = AppLocalizations.of(context);

    return Scaffold(
      appBar: AppBar(
        title: Text(loc.translate('ownerAccount')),
        backgroundColor: Colors.transparent,
        elevation: 0,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => ref.read(onboardingProvider.notifier).previousStep(),
        ),
      ),
      body: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const SizedBox(height: 20),
              _buildProgressIndicator(1, loc),
              const SizedBox(height: 32),
              Text(
                loc.translate('createOwnerAccount'),
                style: theme.textTheme.headlineSmall?.copyWith(
                  fontWeight: FontWeight.w700,
                ),
              ),
              const SizedBox(height: 8),
              Text(
                loc.translate('setupOwnerDetails'),
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: theme.colorScheme.onSurface.withOpacity(0.6),
                ),
              ),
              const SizedBox(height: 32),
              Expanded(
                child: SingleChildScrollView(
                  child: Column(
                    children: [
                      AppTextField(
                        controller: _fullNameController,
                        label: loc.translate('fullName'),
                        validator: (value) =>
                            _validateRequired(value, loc.translate('fullName')),
                      ),
                      const SizedBox(height: 16),
                      AppTextField(
                        controller: _phoneController,
                        label: loc.translate('phoneNumber'),
                        prefixText: '+251 ',
                        keyboardType: TextInputType.phone,
                        validator: _validatePhone,
                      ),
                      const SizedBox(height: 16),
                      AppTextField(
                        controller: _emailController,
                        label:
                            '${loc.translate('email')} (${loc.translate('optional')})',
                        keyboardType: TextInputType.emailAddress,
                        validator: _validateEmail,
                      ),
                      const SizedBox(height: 16),
                      AppTextField(
                        controller: _passwordController,
                        label: loc.translate('password'),
                        obscureText: _obscurePassword,
                        suffixIcon: IconButton(
                          icon: Icon(
                            _obscurePassword
                                ? Icons.visibility
                                : Icons.visibility_off,
                          ),
                          onPressed: () {
                            setState(() {
                              _obscurePassword = !_obscurePassword;
                            });
                          },
                        ),
                        validator: _validatePassword,
                      ),
                      const SizedBox(height: 16),
                      AppTextField(
                        controller: _confirmPasswordController,
                        label: loc.translate('confirmPassword'),
                        obscureText: _obscureConfirmPassword,
                        suffixIcon: IconButton(
                          icon: Icon(
                            _obscureConfirmPassword
                                ? Icons.visibility
                                : Icons.visibility_off,
                          ),
                          onPressed: () {
                            setState(() {
                              _obscureConfirmPassword =
                                  !_obscureConfirmPassword;
                            });
                          },
                        ),
                        validator: (value) {
                          if (value != _passwordController.text) {
                            return loc.translate('passwordsDoNotMatch');
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 24),
                      // Password requirements
                      _buildPasswordRequirements(loc),
                      const SizedBox(height: 40),
                    ],
                  ),
                ),
              ),
              AppButton.primary(
                onPressed: _proceedToNextStep,
                child: Text(loc.translate('continue')),
              ),
            ],
          ),
        ),
      ),
    );

}

Widget \_buildPasswordRequirements(AppLocalizations loc) {
final password = \_passwordController.text;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          loc.translate('passwordRequirements'),
          style: Theme.of(context).textTheme.bodySmall?.copyWith(
                fontWeight: FontWeight.w600,
              ),
        ),
        const SizedBox(height: 8),
        _buildRequirementItem(
          loc.translate('min6Characters'),
          password.length >= 6,
        ),
        _buildRequirementItem(
          loc.translate('recommendSpecialChars'),
          password.length >= 8,
        ),
      ],
    );

}

Widget \_buildRequirementItem(String text, bool isMet) {
return Padding(
padding: const EdgeInsets.symmetric(vertical: 2),
child: Row(
children: [
Icon(
isMet ? Icons.check_circle : Icons.radio_button_unchecked,
size: 16,
color: isMet ? Colors.green : Theme.of(context).colorScheme.outline,
),
const SizedBox(width: 8),
Text(
text,
style: Theme.of(context).textTheme.bodySmall?.copyWith(
color: isMet
? Colors.green
: Theme.of(context).colorScheme.outline,
),
),
],
),
);
}

Widget \_buildProgressIndicator(int currentStep, AppLocalizations loc) {
// Same as previous screen
return Column(
children: [
Row(
mainAxisAlignment: MainAxisAlignment.spaceBetween,
children: [
_buildStep(1, 'üè™', loc.translate('shop'), currentStep >= 0),
_buildStep(2, 'üë§', loc.translate('owner'), currentStep >= 1),
_buildStep(3, 'üì¶', loc.translate('plan'), currentStep >= 2),
_buildStep(4, 'üîê', loc.translate('verify'), currentStep >= 3),
_buildStep(5, 'üí≥', loc.translate('payment'), currentStep >= 4),
],
),
const SizedBox(height: 8),
Text(
'${currentStep + 1}/5 ${loc.translate('steps')}',
style: Theme.of(context).textTheme.bodySmall?.copyWith(
color: Theme.of(context).colorScheme.onSurface.withOpacity(0.6),
),
),
],
);
}

Widget \_buildStep(int stepNumber, String emoji, String label, bool isActive) {
return Column(
children: [
Container(
width: 36,
height: 36,
decoration: BoxDecoration(
color: isActive
? Theme.of(context).colorScheme.primary
: Theme.of(context).colorScheme.surfaceVariant,
shape: BoxShape.circle,
),
child: Center(
child: Text(
emoji,
style: const TextStyle(fontSize: 16),
),
),
),
const SizedBox(height: 4),
Text(
label,
style: Theme.of(context).textTheme.labelSmall?.copyWith(
fontWeight: isActive ? FontWeight.w600 : FontWeight.normal,
color: isActive
? Theme.of(context).colorScheme.primary
: Theme.of(context).colorScheme.onSurface.withOpacity(0.5),
),
),
],
);
}
}

##

// src/ui/screens/onboarding/payment_screen.dart
// Screen for handling payment during the onboarding process.
import 'package:andalus_smart_pos/src/ui/screens/main_navigation.dart';
import 'package:andalus_smart_pos/src/widgets/common/app_button.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
import 'package:andalus_smart_pos/src/providers/onboarding_provider.dart';
import 'package:andalus_smart_pos/src/data/models/subscription.dart';
import 'package:andalus_smart_pos/src/ui/screens/dashboard_screen.dart';

class PaymentScreen extends ConsumerStatefulWidget {
const PaymentScreen({super.key});

@override
ConsumerState<PaymentScreen> createState() => \_PaymentScreenState();
}

class \_PaymentScreenState extends ConsumerState<PaymentScreen> {
String? \_selectedPaymentMethod;

final List<Map<String, dynamic>> \_paymentMethods = [
{
'id': 'telebirr',
'name': 'Telebirr',
'icon': Icons.phone_android_rounded,
'color': Colors.blue,
'description': 'Instant payment via Telebirr mobile money',
},
{
'id': 'cbe_birr',
'name': 'CBE Birr',
'icon': Icons.account_balance_rounded,
'color': Colors.green,
'description': 'Mobile banking with Commercial Bank of Ethiopia',
},
{
'id': 'chapa',
'name': 'Chapa',
'icon': Icons.payment_rounded,
'color': Colors.orange,
'description': 'Secure online payment gateway',
},
{
'id': 'bank_transfer',
'name': 'Bank Transfer',
'icon': Icons.account_balance_wallet_rounded,
'color': Colors.purple,
'description': 'Direct bank transfer to our account',
},
];

final ScrollController \_scrollController = ScrollController();

@override
void dispose() {
\_scrollController.dispose();
super.dispose();
}

Future<void> \_processPayment() async {
if (\_selectedPaymentMethod == null) {
ScaffoldMessenger.of(context).showSnackBar(
SnackBar(
content: const Text('Please select a payment method'),
backgroundColor: Theme.of(context).colorScheme.error,
behavior: SnackBarBehavior.floating,
),
);
return;
}

    final success = await ref.read(onboardingProvider.notifier).processPayment(
      _selectedPaymentMethod!,
      {
        'method': _selectedPaymentMethod,
        'timestamp': DateTime.now().millisecondsSinceEpoch,
      },
    );

    if (success && mounted) {
      _showSuccessDialog();
    }

}

void \_showSuccessDialog() {
showDialog(
context: context,
barrierDismissible: false,
builder: (context) => \_buildSuccessDialog(),
);
}

void \_navigateToMain() {
Navigator.pushAndRemoveUntil(
context,
MaterialPageRoute(builder: (context) => const MainNavigation()),
(route) => false,
);
}

@override
Widget build(BuildContext context) {
final state = ref.watch(onboardingProvider);
final theme = Theme.of(context);
final loc = AppLocalizations.of(context);

    return Scaffold(
      appBar: AppBar(
        title: Text(loc.translate('payment')),
        backgroundColor: Colors.transparent,
        elevation: 0,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => ref.read(onboardingProvider.notifier).previousStep(),
        ),
      ),
      body: Column(
        children: [
          // Fixed Header Section
          Container(
            padding: const EdgeInsets.all(24),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                _buildProgressIndicator(4, loc),
                const SizedBox(height: 32),
                Text(
                  loc.translate('completePayment'),
                  style: theme.textTheme.headlineSmall?.copyWith(
                    fontWeight: FontWeight.w700,
                  ),
                ),
                const SizedBox(height: 8),
                Text(
                  loc.translate('choosePaymentMethod'),
                  style: theme.textTheme.bodyMedium?.copyWith(
                    color: theme.colorScheme.onSurface.withOpacity(0.6),
                  ),
                ),
              ],
            ),
          ),

          // Scrollable Content Section
          Expanded(
            child: CustomScrollView(
              controller: _scrollController,
              slivers: [
                // Order Summary
                SliverToBoxAdapter(
                  child: Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 24),
                    child: _buildOrderSummary(state, theme, loc),
                  ),
                ),

                // Payment Methods Header
                SliverToBoxAdapter(
                  child: Padding(
                    padding: const EdgeInsets.fromLTRB(24, 32, 24, 16),
                    child: Row(
                      children: [
                        Text(
                          loc.translate('paymentMethods'),
                          style: theme.textTheme.titleMedium?.copyWith(
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                        const SizedBox(width: 8),
                        Container(
                          padding: const EdgeInsets.symmetric(
                              horizontal: 8, vertical: 4),
                          decoration: BoxDecoration(
                            color: theme.colorScheme.primary.withOpacity(0.1),
                            borderRadius: BorderRadius.circular(12),
                          ),
                          child: Text(
                            _paymentMethods.length.toString(),
                            style: theme.textTheme.bodySmall?.copyWith(
                              color: theme.colorScheme.primary,
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                ),

                // Payment Methods List
                SliverList(
                  delegate: SliverChildBuilderDelegate(
                    (context, index) {
                      final method = _paymentMethods[index];
                      return Padding(
                        padding: EdgeInsets.fromLTRB(
                          24,
                          0,
                          24,
                          index == _paymentMethods.length - 1 ? 24 : 12,
                        ),
                        child: _buildPaymentMethodCard(method, theme, loc),
                      );
                    },
                    childCount: _paymentMethods.length,
                  ),
                ),

                // Demo Notice
                SliverToBoxAdapter(
                  child: Padding(
                    padding: const EdgeInsets.fromLTRB(24, 8, 24, 24),
                    child: _buildDemoNotice(theme),
                  ),
                ),
              ],
            ),
          ),

          // Fixed Footer with Process Payment Button
          Container(
            padding: const EdgeInsets.all(24),
            decoration: BoxDecoration(
              color: theme.colorScheme.background,
              border: Border(
                top: BorderSide(
                  color: theme.colorScheme.outline.withOpacity(0.1),
                ),
              ),
            ),
            child: Column(
              children: [
                AppButton.primary(
                  onPressed: state.isLoading ? null : _processPayment,
                  isLoading: state.isLoading,
                  child: Text(
                    loc.translate('processPayment'),
                    style: const TextStyle(
                      fontWeight: FontWeight.w600,
                      fontSize: 16,
                    ),
                  ),
                ),
                const SizedBox(height: 8),
                Text(
                  'No payment required during 14-day free trial',
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: theme.colorScheme.onSurface.withOpacity(0.6),
                  ),
                  textAlign: TextAlign.center,
                ),
              ],
            ),
          ),
        ],
      ),
    );

}

Widget \_buildPaymentMethodCard(
Map<String, dynamic> method, ThemeData theme, AppLocalizations loc) {
final isSelected = \_selectedPaymentMethod == method['id'];

    return AnimatedContainer(
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeInOut,
      child: Card(
        elevation: isSelected ? 4 : 1,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
          side: BorderSide(
            color: isSelected
                ? theme.colorScheme.primary
                : theme.colorScheme.outline.withOpacity(0.1),
            width: isSelected ? 2 : 1,
          ),
        ),
        child: InkWell(
          onTap: () {
            setState(() {
              _selectedPaymentMethod = method['id'];
            });
          },
          borderRadius: BorderRadius.circular(16),
          child: Padding(
            padding: const EdgeInsets.all(20),
            child: Row(
              children: [
                // Icon
                Container(
                  width: 48,
                  height: 48,
                  decoration: BoxDecoration(
                    color: isSelected
                        ? method['color']
                        : method['color'].withOpacity(0.1),
                    shape: BoxShape.circle,
                  ),
                  child: Icon(
                    method['icon'],
                    color: isSelected ? Colors.white : method['color'],
                    size: 24,
                  ),
                ),
                const SizedBox(width: 16),

                // Content
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        method['name'],
                        style: theme.textTheme.titleMedium?.copyWith(
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                      const SizedBox(height: 4),
                      Text(
                        method['description'],
                        style: theme.textTheme.bodyMedium?.copyWith(
                          color: theme.colorScheme.onSurface.withOpacity(0.6),
                        ),
                      ),
                    ],
                  ),
                ),

                // Selection Indicator
                AnimatedContainer(
                  duration: const Duration(milliseconds: 300),
                  width: 24,
                  height: 24,
                  decoration: BoxDecoration(
                    shape: BoxShape.circle,
                    border: Border.all(
                      color: isSelected
                          ? theme.colorScheme.primary
                          : theme.colorScheme.outline.withOpacity(0.3),
                      width: 2,
                    ),
                    color: isSelected
                        ? theme.colorScheme.primary
                        : Colors.transparent,
                  ),
                  child: isSelected
                      ? Icon(
                          Icons.check_rounded,
                          size: 16,
                          color: Colors.white,
                        )
                      : null,
                ),
              ],
            ),
          ),
        ),
      ),
    );

}

Widget \_buildDemoNotice(ThemeData theme) {
return Container(
width: double.infinity,
padding: const EdgeInsets.all(16),
decoration: BoxDecoration(
color: theme.colorScheme.primary.withOpacity(0.05),
borderRadius: BorderRadius.circular(12),
border: Border.all(
color: theme.colorScheme.primary.withOpacity(0.1),
),
),
child: Row(
children: [
Icon(
Icons.info_outline_rounded,
size: 20,
color: theme.colorScheme.primary,
),
const SizedBox(width: 12),
Expanded(
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
'Demo Mode',
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.primary,
fontWeight: FontWeight.w600,
),
),
const SizedBox(height: 2),
Text(
'Select any payment method to continue. No actual payment will be processed during the 14-day free trial.',
style: theme.textTheme.bodySmall?.copyWith(
color: theme.colorScheme.primary.withOpacity(0.8),
),
),
],
),
),
],
),
);
}

Widget \_buildOrderSummary(
OnboardingState state, ThemeData theme, AppLocalizations loc) {
final plan = state.selectedPlan;
final billingCycle = state.billingCycle;

    if (plan == null || billingCycle == null) return const SizedBox();

    return Card(
      elevation: 2,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(20),
      ),
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Header
            Row(
              children: [
                Icon(
                  Icons.receipt_long_rounded,
                  color: theme.colorScheme.primary,
                  size: 20,
                ),
                const SizedBox(width: 8),
                Text(
                  loc.translate('orderSummary'),
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 20),

            // Plan Details
            _buildSummaryRow('Subscription Plan', plan.name, theme),
            _buildSummaryRow(
              'Billing Cycle',
              billingCycle == BillingCycle.monthly ? 'Monthly' : 'Yearly',
              theme,
            ),
            const SizedBox(height: 8),

            // Divider
            Divider(
              color: theme.colorScheme.outline.withOpacity(0.1),
              height: 1,
            ),
            const SizedBox(height: 16),

            // Total Amount
            _buildSummaryRow(
              'Total Amount',
              plan.getFormattedPrice(billingCycle),
              theme,
              isTotal: true,
            ),
            const SizedBox(height: 16),

            // Free Trial Notice
            Container(
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: Colors.green.withOpacity(0.08),
                borderRadius: BorderRadius.circular(12),
                border: Border.all(
                  color: Colors.green.withOpacity(0.2),
                ),
              ),
              child: Row(
                children: [
                  Icon(
                    Icons.celebration_rounded,
                    size: 20,
                    color: Colors.green,
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          '14-Day Free Trial',
                          style: theme.textTheme.bodyMedium?.copyWith(
                            color: Colors.green,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                        const SizedBox(height: 2),
                        Text(
                          'No payment required now. Your trial starts immediately after registration.',
                          style: theme.textTheme.bodySmall?.copyWith(
                            color: Colors.green.withOpacity(0.8),
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );

}

Widget \_buildSummaryRow(String label, String value, ThemeData theme,
{bool isTotal = false}) {
return Padding(
padding: const EdgeInsets.symmetric(vertical: 6),
child: Row(
mainAxisAlignment: MainAxisAlignment.spaceBetween,
children: [
Text(
label,
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.7),
),
),
Text(
value,
style: theme.textTheme.bodyMedium?.copyWith(
fontWeight: isTotal ? FontWeight.w700 : FontWeight.w500,
color: isTotal
? theme.colorScheme.primary
: theme.colorScheme.onSurface,
fontSize: isTotal ? 16 : 14,
),
),
],
),
);
}

Widget \_buildSuccessDialog() {
final theme = Theme.of(context);
final loc = AppLocalizations.of(context);

    return Dialog(
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(24),
      ),
      child: Container(
        padding: const EdgeInsets.all(32),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Success Icon
            Container(
              width: 80,
              height: 80,
              decoration: BoxDecoration(
                color: Colors.green.withOpacity(0.1),
                shape: BoxShape.circle,
              ),
              child: Icon(
                Icons.check_rounded,
                size: 40,
                color: Colors.green,
              ),
            ),
            const SizedBox(height: 24),

            // Title
            Text(
              'Welcome to Andalus POS! üéâ',
              style: theme.textTheme.headlineSmall?.copyWith(
                fontWeight: FontWeight.w700,
                // textAlign: TextAlign.center,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 12),

            // Description
            Text(
              'Your account has been successfully created and your 14-day free trial has started.',
              style: theme.textTheme.bodyLarge?.copyWith(
                color: theme.colorScheme.onSurface.withOpacity(0.7),
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),

            // Features List
            _buildFeatureItem('14-day full access to all features'),
            _buildFeatureItem('No credit card required'),
            _buildFeatureItem('Setup your products and start selling'),
            const SizedBox(height: 32),

            // Get Started Button
            AppButton.primary(
              onPressed: _navigateToMain,
              child: Text(
                'Get Started',
                style: const TextStyle(
                  fontWeight: FontWeight.w600,
                  fontSize: 16,
                ),
              ),
            ),
          ],
        ),
      ),
    );

}

Widget \_buildFeatureItem(String text) {
return Padding(
padding: const EdgeInsets.symmetric(vertical: 4),
child: Row(
children: [
Icon(
Icons.check_circle_rounded,
size: 16,
color: Colors.green,
),
const SizedBox(width: 8),
Expanded(
child: Text(
text,
style: Theme.of(context).textTheme.bodyMedium?.copyWith(
color: Theme.of(context)
.colorScheme
.onSurface
.withOpacity(0.7),
),
),
),
],
),
);
}

Widget \_buildProgressIndicator(int currentStep, AppLocalizations loc) {
return Column(
children: [
Row(
mainAxisAlignment: MainAxisAlignment.spaceBetween,
children: [
_buildStep(1, 'üè™', loc.translate('shop'), currentStep >= 0),
_buildStep(2, 'üë§', loc.translate('owner'), currentStep >= 1),
_buildStep(3, 'üì¶', loc.translate('plan'), currentStep >= 2),
_buildStep(4, 'üîê', loc.translate('verify'), currentStep >= 3),
_buildStep(5, 'üí≥', loc.translate('payment'), currentStep >= 4),
],
),
const SizedBox(height: 8),
Text(
'${currentStep + 1}/5 ${loc.translate('steps')}',
style: Theme.of(context).textTheme.bodySmall?.copyWith(
color: Theme.of(context).colorScheme.onSurface.withOpacity(0.6),
),
),
],
);
}

Widget \_buildStep(int stepNumber, String emoji, String label, bool isActive) {
final theme = Theme.of(context);

    return Column(
      children: [
        Container(
          width: 44,
          height: 44,
          decoration: BoxDecoration(
            color: isActive
                ? theme.colorScheme.primary
                : theme.colorScheme.surfaceVariant,
            shape: BoxShape.circle,
            boxShadow: isActive
                ? [
                    BoxShadow(
                      color: theme.colorScheme.primary.withOpacity(0.3),
                      blurRadius: 8,
                      offset: const Offset(0, 2),
                    ),
                  ]
                : null,
          ),
          child: Center(
            child: Text(
              emoji,
              style: const TextStyle(fontSize: 18),
            ),
          ),
        ),
        const SizedBox(height: 6),
        Text(
          label,
          style: theme.textTheme.labelSmall?.copyWith(
            fontWeight: isActive ? FontWeight.w700 : FontWeight.normal,
            color: isActive
                ? theme.colorScheme.primary
                : theme.colorScheme.onSurface.withOpacity(0.5),
          ),
        ),
      ],
    );

}
}

##

// src/ui/screens/onboarding/shop_registration_screen.dart
// Screen for registering the shop during the onboarding process.
import 'package:andalus_smart_pos/src/data/models/business.dart';
import 'package:andalus_smart_pos/src/widgets/common/app_button.dart';
import 'package:andalus_smart_pos/src/widgets/common/app_text_field.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
import 'package:andalus_smart_pos/src/providers/onboarding_provider.dart';
import 'package:andalus_smart_pos/src/data/models/shop_registration.dart';

class ShopRegistrationScreen extends ConsumerStatefulWidget {
const ShopRegistrationScreen({super.key});

@override
ConsumerState<ShopRegistrationScreen> createState() =>
\_ShopRegistrationScreenState();
}

class \_ShopRegistrationScreenState
extends ConsumerState<ShopRegistrationScreen> {
final \_shopNameController = TextEditingController();
final \_phoneController = TextEditingController();
final \_cityController = TextEditingController();
final \_countryController = TextEditingController();
final \_addressController = TextEditingController();

final \_formKey = GlobalKey<FormState>();
String? \_selectedCategory;

@override
void dispose() {
\_shopNameController.dispose();
\_phoneController.dispose();
\_cityController.dispose();
\_countryController.dispose();
\_addressController.dispose();
super.dispose();
}

bool \_validateForm() {
if (\_formKey.currentState?.validate() ?? false) {
final shop = ShopRegistration(
shopName: \_shopNameController.text.trim(),
shopCategory: \_selectedCategory ?? 'retail',
phoneNumber: \_phoneController.text.trim(),
city: \_cityController.text.trim(),
country: \_countryController.text.trim(),
businessAddress: \_addressController.text.trim(),
);

      ref.read(onboardingProvider.notifier).updateShopInfo(shop);
      return true;
    }
    return false;

}

void \_proceedToNextStep() {
if (\_validateForm()) {
ref.read(onboardingProvider.notifier).nextStep();
}
}

String? \_validateRequired(String? value, String fieldName) {
if (value == null || value.trim().isEmpty) {
return '$fieldName ${AppLocalizations.of(context).translate('isRequired')}';
}
return null;
}

String? \_validatePhone(String? value) {
if (value == null || value.trim().isEmpty) {
return AppLocalizations.of(context).translate('phoneRequired');
}
if (!RegExp(r'^\+251[0-9]{9}$').hasMatch(value.trim())) {
return AppLocalizations.of(context).translate('validEthiopianPhone');
}
return null;
}

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);
final loc = AppLocalizations.of(context);

    return Scaffold(
      appBar: AppBar(
        title: Text(loc.translate('shopRegistration')),
        backgroundColor: Colors.transparent,
        elevation: 0,
      ),
      body: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const SizedBox(height: 20),
              // Progress indicator
              _buildProgressIndicator(0, loc),
              const SizedBox(height: 32),
              Text(
                loc.translate('setupYourShop'),
                style: theme.textTheme.headlineSmall?.copyWith(
                  fontWeight: FontWeight.w700,
                ),
              ),
              const SizedBox(height: 8),
              Text(
                loc.translate('enterShopDetails'),
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: theme.colorScheme.onSurface.withOpacity(0.6),
                ),
              ),
              const SizedBox(height: 32),
              Expanded(
                child: SingleChildScrollView(
                  child: Column(
                    children: [
                      AppTextField(
                        controller: _shopNameController,
                        label: loc.translate('shopName'),
                        validator: (value) =>
                            _validateRequired(value, loc.translate('shopName')),
                      ),
                      const SizedBox(height: 16),
                      // Shop Category Dropdown
                      DropdownButtonFormField<String>(
                        value: _selectedCategory,
                        decoration: InputDecoration(
                          labelText: loc.translate('shopCategory'),
                          border: const OutlineInputBorder(),
                          contentPadding: const EdgeInsets.symmetric(
                              horizontal: 16, vertical: 12),
                        ),
                        items: BusinessType.allTypes.map((type) {
                          return DropdownMenuItem<String>(
                            value: type.id,
                            child: Text(loc.locale.languageCode == 'am'
                                ? type.nameAm
                                : type.name),
                          );
                        }).toList(),
                        onChanged: (value) {
                          setState(() {
                            _selectedCategory = value;
                          });
                        },
                        validator: (value) {
                          if (value == null) {
                            return loc.translate('shopCategoryRequired');
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 16),
                      AppTextField(
                        controller: _phoneController,
                        label: loc.translate('phoneNumber'),
                        prefixText: '+251 ',
                        keyboardType: TextInputType.phone,
                        validator: _validatePhone,
                      ),
                      const SizedBox(height: 16),
                      Row(
                        children: [
                          Expanded(
                            child: AppTextField(
                              controller: _cityController,
                              label: loc.translate('city'),
                              validator: (value) => _validateRequired(
                                  value, loc.translate('city')),
                            ),
                          ),
                          const SizedBox(width: 16),
                          Expanded(
                            child: AppTextField(
                              controller: _countryController,
                              label: loc.translate('country'),
                              readOnly: true,
                              enabled:
                                  false, // This makes it look disabled but without the initialValue conflict
                            ),
                          )
                        ],
                      ),
                      const SizedBox(height: 16),
                      AppTextField(
                        controller: _addressController,
                        label: loc.translate('businessAddress'),
                        maxLines: 2,
                        validator: (value) => _validateRequired(
                            value, loc.translate('businessAddress')),
                      ),
                      const SizedBox(height: 40),
                    ],
                  ),
                ),
              ),
              AppButton.primary(
                onPressed: _proceedToNextStep,
                child: Text(loc.translate('continue')),
              ),
            ],
          ),
        ),
      ),
    );

}

Widget \_buildProgressIndicator(int currentStep, AppLocalizations loc) {
return Column(
children: [
Row(
mainAxisAlignment: MainAxisAlignment.spaceBetween,
children: [
_buildStep(1, 'üè™', loc.translate('shop'), currentStep >= 0),
_buildStep(2, 'üë§', loc.translate('owner'), currentStep >= 1),
_buildStep(3, 'üì¶', loc.translate('plan'), currentStep >= 2),
_buildStep(4, 'üîê', loc.translate('verify'), currentStep >= 3),
_buildStep(5, 'üí≥', loc.translate('payment'), currentStep >= 4),
],
),
const SizedBox(height: 8),
Text(
'${currentStep + 1}/5 ${loc.translate('steps')}',
style: Theme.of(context).textTheme.bodySmall?.copyWith(
color: Theme.of(context).colorScheme.onSurface.withOpacity(0.6),
),
),
],
);
}

Widget \_buildStep(int stepNumber, String emoji, String label, bool isActive) {
return Column(
children: [
Container(
width: 36,
height: 36,
decoration: BoxDecoration(
color: isActive
? Theme.of(context).colorScheme.primary
: Theme.of(context).colorScheme.surfaceVariant,
shape: BoxShape.circle,
),
child: Center(
child: Text(
emoji,
style: const TextStyle(fontSize: 16),
),
),
),
const SizedBox(height: 4),
Text(
label,
style: Theme.of(context).textTheme.labelSmall?.copyWith(
fontWeight: isActive ? FontWeight.w600 : FontWeight.normal,
color: isActive
? Theme.of(context).colorScheme.primary
: Theme.of(context).colorScheme.onSurface.withOpacity(0.5),
),
),
],
);
}
}

##

// src/ui/screens/onboarding/subscription_selection_screen.dart
// Screen for selecting a subscription plan during the onboarding process.
import 'package:andalus_smart_pos/src/widgets/common/app_button.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
import 'package:andalus_smart_pos/src/providers/onboarding_provider.dart';
import 'package:andalus_smart_pos/src/data/models/subscription.dart';

class SubscriptionSelectionScreen extends ConsumerStatefulWidget {
const SubscriptionSelectionScreen({super.key});

@override
ConsumerState<SubscriptionSelectionScreen> createState() =>
\_SubscriptionSelectionScreenState();
}

class \_SubscriptionSelectionScreenState
extends ConsumerState<SubscriptionSelectionScreen> {
bool \_isYearlyBilling = false;
SubscriptionPlan? \_selectedPlan;

@override
void initState() {
super.initState();
// Set Professional as default selected plan
\_selectedPlan = SubscriptionPlan.professional;
}

void \_selectPlan(SubscriptionPlan plan) {
setState(() {
\_selectedPlan = plan;
});
}

void \_toggleBillingCycle() {
setState(() {
\_isYearlyBilling = !\_isYearlyBilling;
});
}

void \_proceedToNextStep() {
if (\_selectedPlan != null) {
ref.read(onboardingProvider.notifier).selectPlan(
\_selectedPlan!,
\_isYearlyBilling ? BillingCycle.yearly : BillingCycle.monthly,
);
ref.read(onboardingProvider.notifier).nextStep();
}
}

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);
final loc = AppLocalizations.of(context);

    return Scaffold(
      appBar: AppBar(
        title: Text(loc.translate('subscriptionPlan')),
        backgroundColor: Colors.transparent,
        elevation: 0,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => ref.read(onboardingProvider.notifier).previousStep(),
        ),
      ),
      body: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const SizedBox(height: 20),
            _buildProgressIndicator(2, loc),
            const SizedBox(height: 32),
            Text(
              loc.translate('chooseYourPlan'),
              style: theme.textTheme.headlineSmall?.copyWith(
                fontWeight: FontWeight.w700,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              loc.translate('startWithFreeTrial'),
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.onSurface.withOpacity(0.6),
              ),
            ),
            const SizedBox(height: 24),

            // Billing Cycle Toggle
            _buildBillingCycleToggle(theme, loc),
            const SizedBox(height: 32),

            // Subscription Plans
            Expanded(
              child: SingleChildScrollView(
                child: Column(
                  children: [
                    _buildPlanCard(SubscriptionPlan.basic, theme, loc),
                    const SizedBox(height: 16),
                    _buildPlanCard(SubscriptionPlan.professional, theme, loc),
                    const SizedBox(height: 16),
                    _buildPlanCard(SubscriptionPlan.premium, theme, loc),
                    const SizedBox(height: 40),
                  ],
                ),
              ),
            ),

            AppButton.primary(
              onPressed: _selectedPlan != null ? _proceedToNextStep : null,
              child: Text(loc.translate('continue')),
            ),
          ],
        ),
      ),
    );

}

Widget \_buildBillingCycleToggle(ThemeData theme, AppLocalizations loc) {
return Container(
padding: const EdgeInsets.all(4),
decoration: BoxDecoration(
color: theme.colorScheme.surfaceVariant,
borderRadius: BorderRadius.circular(12),
),
child: Row(
mainAxisAlignment: MainAxisAlignment.center,
children: [
Expanded(
child: GestureDetector(
onTap: () => setState(() => \_isYearlyBilling = false),
child: Container(
padding:
const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
decoration: BoxDecoration(
color: !\_isYearlyBilling
? theme.colorScheme.primary
: Colors.transparent,
borderRadius: BorderRadius.circular(8),
),
child: Center(
child: Text(
loc.translate('monthly'),
style: theme.textTheme.bodyMedium?.copyWith(
fontWeight: FontWeight.w600,
color: !\_isYearlyBilling
? theme.colorScheme.onPrimary
: theme.colorScheme.onSurfaceVariant,
),
),
),
),
),
),
Expanded(
child: GestureDetector(
onTap: () => setState(() => \_isYearlyBilling = true),
child: Container(
padding:
const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
decoration: BoxDecoration(
color: \_isYearlyBilling
? theme.colorScheme.primary
: Colors.transparent,
borderRadius: BorderRadius.circular(8),
),
child: Center(
child: Column(
children: [
Text(
loc.translate('yearly'),
style: theme.textTheme.bodyMedium?.copyWith(
fontWeight: FontWeight.w600,
color: _isYearlyBilling
? theme.colorScheme.onPrimary
: theme.colorScheme.onSurfaceVariant,
),
),
Text(
loc.translate('save20Percent'),
style: theme.textTheme.labelSmall?.copyWith(
color: _isYearlyBilling
? theme.colorScheme.onPrimary.withOpacity(0.8)
: theme.colorScheme.primary,
),
),
],
),
),
),
),
),
],
),
);
}

Widget \_buildPlanCard(
SubscriptionPlan plan, ThemeData theme, AppLocalizations loc) {
final isSelected = \_selectedPlan?.id == plan.id;
final isRecommended = plan.id == 'professional';

    return Card(
      margin: EdgeInsets.zero,
      elevation: isSelected ? 4 : 1,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
        side: BorderSide(
          color: isSelected
              ? theme.colorScheme.primary
              : theme.colorScheme.outline.withOpacity(0.1),
          width: isSelected ? 2 : 1,
        ),
      ),
      child: InkWell(
        onTap: () => _selectPlan(plan),
        borderRadius: BorderRadius.circular(16),
        child: Padding(
          padding: const EdgeInsets.all(20),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(
                    plan.name,
                    style: theme.textTheme.titleLarge?.copyWith(
                      fontWeight: FontWeight.w700,
                    ),
                  ),
                  if (isRecommended) ...[
                    Container(
                      padding: const EdgeInsets.symmetric(
                          horizontal: 12, vertical: 4),
                      decoration: BoxDecoration(
                        color: theme.colorScheme.primary.withOpacity(0.1),
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Text(
                        loc.translate('recommended'),
                        style: theme.textTheme.labelSmall?.copyWith(
                          color: theme.colorScheme.primary,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ),
                  ],
                ],
              ),
              const SizedBox(height: 8),

              // Description
              Text(
                plan.description,
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: theme.colorScheme.onSurface.withOpacity(0.6),
                ),
              ),
              const SizedBox(height: 16),

              // Price
              Text(
                _isYearlyBilling
                    ? plan.getFormattedPrice(BillingCycle.yearly)
                    : plan.getFormattedPrice(BillingCycle.monthly),
                style: theme.textTheme.headlineSmall?.copyWith(
                  fontWeight: FontWeight.w700,
                  color: theme.colorScheme.primary,
                ),
              ),
              if (_isYearlyBilling) ...[
                const SizedBox(height: 4),
                Text(
                  plan.savingsInfo,
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: theme.colorScheme.primary,
                  ),
                ),
              ],
              const SizedBox(height: 16),

              // Features
              ...plan.features.take(4).map((feature) => Padding(
                    padding: const EdgeInsets.symmetric(vertical: 4),
                    child: Row(
                      children: [
                        Icon(
                          Icons.check_circle_rounded,
                          size: 16,
                          color: theme.colorScheme.primary,
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Text(
                            feature,
                            style: theme.textTheme.bodyMedium,
                          ),
                        ),
                      ],
                    ),
                  )),

              // Selection indicator
              const SizedBox(height: 16),
              Container(
                width: double.infinity,
                padding: const EdgeInsets.symmetric(vertical: 12),
                decoration: BoxDecoration(
                  color: isSelected
                      ? theme.colorScheme.primary
                      : Colors.transparent,
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(
                    color: isSelected
                        ? theme.colorScheme.primary
                        : theme.colorScheme.outline,
                  ),
                ),
                child: Center(
                  child: Text(
                    isSelected
                        ? loc.translate('selected')
                        : loc.translate('selectPlan'),
                    style: theme.textTheme.bodyMedium?.copyWith(
                      fontWeight: FontWeight.w600,
                      color: isSelected
                          ? theme.colorScheme.onPrimary
                          : theme.colorScheme.primary,
                    ),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );

}

Widget \_buildProgressIndicator(int currentStep, AppLocalizations loc) {
return Column(
children: [
Row(
mainAxisAlignment: MainAxisAlignment.spaceBetween,
children: [
_buildStep(1, 'üè™', loc.translate('shop'), currentStep >= 0),
_buildStep(2, 'üë§', loc.translate('owner'), currentStep >= 1),
_buildStep(3, 'üì¶', loc.translate('plan'), currentStep >= 2),
_buildStep(4, 'üîê', loc.translate('verify'), currentStep >= 3),
_buildStep(5, 'üí≥', loc.translate('payment'), currentStep >= 4),
],
),
const SizedBox(height: 8),
Text(
'${currentStep + 1}/5 ${loc.translate('steps')}',
style: Theme.of(context).textTheme.bodySmall?.copyWith(
color: Theme.of(context).colorScheme.onSurface.withOpacity(0.6),
),
),
],
);
}

Widget \_buildStep(int stepNumber, String emoji, String label, bool isActive) {
return Column(
children: [
Container(
width: 36,
height: 36,
decoration: BoxDecoration(
color: isActive
? Theme.of(context).colorScheme.primary
: Theme.of(context).colorScheme.surfaceVariant,
shape: BoxShape.circle,
),
child: Center(
child: Text(
emoji,
style: const TextStyle(fontSize: 16),
),
),
),
const SizedBox(height: 4),
Text(
label,
style: Theme.of(context).textTheme.labelSmall?.copyWith(
fontWeight: isActive ? FontWeight.w600 : FontWeight.normal,
color: isActive
? Theme.of(context).colorScheme.primary
: Theme.of(context).colorScheme.onSurface.withOpacity(0.5),
),
),
],
);
}
}

##

// src/ui/screens/account_setting_screen.dart
// Account settings screen for viewing and updating user profile, preferences, and security settings.
import 'package:andalus_smart_pos/src/config/app_theme.dart';
import 'package:andalus_smart_pos/src/config/font_theme.dart';
import 'package:andalus_smart_pos/src/utils/date_utils.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
import 'package:andalus_smart_pos/src/providers/auth_provider.dart';
import 'package:andalus_smart_pos/src/providers/theme_provider.dart';
import 'package:andalus_smart_pos/src/providers/language_provider.dart';
// import 'package:andalus_smart_pos/src/config/theme/font_theme.dart';

import 'package:andalus_smart_pos/src/utils/calendar_utils.dart';
import 'package:andalus_smart_pos/src/data/models/user.dart';
import 'package:andalus_smart_pos/src/ui/screens/auth/phone_login_screen.dart';
import 'package:andalus_smart_pos/src/widgets/common/custom_card.dart';

class AccountSettingsScreen extends ConsumerStatefulWidget {
const AccountSettingsScreen({super.key});

@override
ConsumerState<AccountSettingsScreen> createState() =>
\_AccountSettingsScreenState();
}

class \_AccountSettingsScreenState extends ConsumerState<AccountSettingsScreen> {
final \_nameController = TextEditingController();
final \_phoneController = TextEditingController();
final \_emailController = TextEditingController();
final \_currentPasswordController = TextEditingController();
final \_newPasswordController = TextEditingController();
final \_confirmPasswordController = TextEditingController();

bool \_isEditing = false;
bool \_isChangingPassword = false;

@override
void initState() {
super.initState();
\_loadUserData();
}

void \_loadUserData() {
final authState = ref.read(authProvider);
final user = authState.user;

    if (user != null) {
      _nameController.text = user.name;
      _phoneController.text = user.phone;
      _emailController.text = user.email ?? '';
    }

}

@override
void dispose() {
\_nameController.dispose();
\_phoneController.dispose();
\_emailController.dispose();
\_currentPasswordController.dispose();
\_newPasswordController.dispose();
\_confirmPasswordController.dispose();
super.dispose();
}

void \_toggleEdit() {
setState(() {
\_isEditing = !\_isEditing;
if (!\_isEditing) {
\_loadUserData();
}
});
}

void \_togglePasswordChange() {
setState(() {
\_isChangingPassword = !\_isChangingPassword;
if (!\_isChangingPassword) {
\_currentPasswordController.clear();
\_newPasswordController.clear();
\_confirmPasswordController.clear();
}
});
}

Future<void> \_updateProfile() async {
final authState = ref.read(authProvider);
final user = authState.user;

    if (user == null) return;

    // TODO: Implement profile update logic
    final updatedUser = user.copyWith(
      name: _nameController.text,
      phone: _phoneController.text,
      email: _emailController.text.isEmpty ? null : _emailController.text,
    );

    setState(() => _isEditing = false);

    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content:
              Text(AppLocalizations.of(context).translate('settingsSaved')),
          backgroundColor: Colors.green,
        ),
      );
    }

}

Future<void> \_changePassword() async {
if (\_newPasswordController.text != \_confirmPasswordController.text) {
if (mounted) {
ScaffoldMessenger.of(context).showSnackBar(
const SnackBar(
content: Text('New passwords do not match'),
backgroundColor: Colors.red,
),
);
}
return;
}

    // TODO: Implement password change logic
    _togglePasswordChange();

    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Password changed successfully'),
          backgroundColor: Colors.green,
        ),
      );
    }

}

void \_logout() {
showDialog(
context: context,
builder: (context) => AlertDialog(
title: Text(AppLocalizations.of(context).translate('confirm')),
content: Text(AppLocalizations.of(context)
.translate('Are you sure you want to logout?')),
actions: [
TextButton(
onPressed: () => Navigator.pop(context),
child: Text(AppLocalizations.of(context).translate('cancel')),
),
TextButton(
onPressed: () {
Navigator.pop(context);
_performLogout();
},
style: TextButton.styleFrom(foregroundColor: Colors.red),
child: Text(AppLocalizations.of(context).translate('confirm')),
),
],
),
);
}

void \_performLogout() {
ref.read(authProvider.notifier).logout();
Navigator.pushAndRemoveUntil(
context,
MaterialPageRoute(builder: (context) => const PhoneLoginScreen()),
(route) => false,
);
}

@override
Widget build(BuildContext context) {
final authState = ref.watch(authProvider);
final themeMode = ref.watch(themeProvider);
final locale = ref.watch(languageProvider);
final fontTheme = ref.watch(fontThemeProvider);
final localizations = AppLocalizations.of(context);
final user = authState.user;

    return Scaffold(
      appBar: AppBar(
        title: Text(localizations.translate('Account Settings')),
        actions: [
          if (_isEditing) ...[
            IconButton(
              icon: const Icon(Icons.save),
              onPressed: _updateProfile,
              tooltip: 'Save Changes',
            ),
            IconButton(
              icon: const Icon(Icons.cancel),
              onPressed: _toggleEdit,
              tooltip: 'Cancel',
            ),
          ],
        ],
      ),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          // User Profile Section
          _buildProfileSection(user, localizations),
          const SizedBox(height: 16),

          // Calendar Settings
          _buildCalendarSection(localizations),
          const SizedBox(height: 16),

          // Language Settings
          _buildLanguageSection(locale, localizations),
          const SizedBox(height: 16),

          // Font Settings
          _buildFontSettingsSection(fontTheme, localizations),
          const SizedBox(height: 16),

          // Theme Settings
          _buildThemeSection(themeMode, localizations),
          const SizedBox(height: 16),

          // Security Section
          _buildSecuritySection(localizations),
          const SizedBox(height: 16),

          // Logout Section
          _buildLogoutSection(localizations),
        ],
      ),
    );

}

Widget \_buildProfileSection(User? user, AppLocalizations localizations) {
return CustomCard(
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Row(
children: [
const CircleAvatar(
radius: 30,
backgroundColor: Colors.blue,
child: Icon(Icons.person, color: Colors.white, size: 30),
),
const SizedBox(width: 16),
Expanded(
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
user?.name ?? 'No Name',
style: const TextStyle(
fontSize: 18,
fontWeight: FontWeight.bold,
),
),
const SizedBox(height: 4),
Text(
user?.role.displayName ?? 'User',
style: TextStyle(
color: Colors.grey.shade600,
),
),
const SizedBox(height: 4),
Text(
user?.phone ?? 'No Phone',
style: TextStyle(
color: Colors.grey.shade600,
),
),
],
),
),
if (!\_isEditing && !\_isChangingPassword)
IconButton(
icon: const Icon(Icons.edit),
onPressed: \_toggleEdit,
tooltip: 'Edit Profile',
),
],
),
const SizedBox(height: 16),
if (\_isEditing) \_buildProfileForm(),
],
),
),
);
}

Widget \_buildCalendarSection(AppLocalizations localizations) {
final currentCalendar = CalendarUtils.currentCalendar;

    return CustomCard(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                const Icon(Icons.calendar_today, color: Color(0xFF10B981)),
                const SizedBox(width: 12),
                Text(
                  'Calendar System',
                  style: Theme.of(context).textTheme.titleLarge?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                ),
              ],
            ),
            const SizedBox(height: 16),
            Text(
              'Choose your preferred calendar system for date displays throughout the app.',
              style: TextStyle(color: Colors.grey.shade600),
            ),
            const SizedBox(height: 16),
            Wrap(
              spacing: 12,
              runSpacing: 12,
              children: [
                _buildCalendarOption(
                  'Gregorian',
                  CalendarType.gregorian,
                  currentCalendar,
                  Icons.calendar_today,
                ),
                _buildCalendarOption(
                  'Ethiopian',
                  CalendarType.ethiopian,
                  currentCalendar,
                  Icons.language,
                ),
              ],
            ),
            const SizedBox(height: 8),
            Text(
              'Current date: ${AppDateUtils.formatFullDate(DateTime.now())}',
              style: const TextStyle(
                fontWeight: FontWeight.w500,
                color: Color(0xFF10B981),
              ),
            ),
          ],
        ),
      ),
    );

}

Widget \_buildCalendarOption(
String label,
CalendarType type,
CalendarType currentType,
IconData icon,
) {
final isSelected = currentType == type;

    return FilterChip(
      label: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 16),
          const SizedBox(width: 6),
          Text(label),
        ],
      ),
      selected: isSelected,
      onSelected: (selected) {
        CalendarUtils.setCalendarType(type);
        setState(() {});
      },
      backgroundColor: Colors.grey.shade100,
      selectedColor: const Color(0xFF10B981).withOpacity(0.2),
      checkmarkColor: const Color(0xFF10B981),
      labelStyle: TextStyle(
        color: isSelected ? const Color(0xFF10B981) : Colors.grey.shade700,
        fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
      ),
    );

}

Widget \_buildLanguageSection(Locale locale, AppLocalizations localizations) {
return CustomCard(
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Row(
children: [
const Icon(Icons.language, color: Color(0xFF10B981)),
const SizedBox(width: 12),
Text(
localizations.translate('language'),
style: Theme.of(context).textTheme.titleLarge?.copyWith(
fontWeight: FontWeight.bold,
),
),
],
),
const SizedBox(height: 16),
DropdownButtonFormField<Locale>(
value: locale,
decoration: InputDecoration(
labelText: 'App Language',
border: OutlineInputBorder(
borderRadius: BorderRadius.circular(12),
),
),
items: const [
DropdownMenuItem(
value: Locale('en'),
child: Text('English'),
),
DropdownMenuItem(
value: Locale('am'),
child: Text('·ä†·àõ·à≠·äõ'),
),
],
onChanged: (newLocale) {
if (newLocale != null) {
ref
.read(languageProvider.notifier)
.setLanguage(newLocale.languageCode);
}
},
),
],
),
),
);
}

Widget \_buildFontSettingsSection(
FontTheme fontTheme, AppLocalizations localizations) {
return CustomCard(
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Row(
children: [
const Icon(Icons.font_download, color: Color(0xFF10B981)),
const SizedBox(width: 12),
Text(
'Font Settings',
style: Theme.of(context).textTheme.titleLarge?.copyWith(
fontWeight: FontWeight.bold,
),
),
],
),
const SizedBox(height: 16),

            // English Font
            _buildFontSelector(
              'English Font',
              fontTheme.englishFont,
              AppFontFamily.values,
              (font) =>
                  ref.read(fontThemeProvider.notifier).updateEnglishFont(font),
            ),
            const SizedBox(height: 16),

            // Amharic Font
            _buildFontSelector(
              'Amharic Font',
              fontTheme.amharicFont,
              [AppFontFamily.notoSansEthiopic, AppFontFamily.AbyssinicaSIL],
              (font) =>
                  ref.read(fontThemeProvider.notifier).updateAmharicFont(font),
            ),
            const SizedBox(height: 16),

            // Font Size Scaling
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(
                      'Font Size Scale',
                      style: Theme.of(context).textTheme.titleMedium,
                    ),
                    Text(
                      '${(fontTheme.fontSizeScale * 100).toInt()}%',
                      style: const TextStyle(
                        fontWeight: FontWeight.bold,
                        color: Color(0xFF10B981),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 8),
                Slider(
                  value: fontTheme.fontSizeScale,
                  min: 0.8,
                  max: 1.5,
                  divisions: 7,
                  onChanged: (value) {
                    ref.read(fontThemeProvider.notifier).updateFontScale(value);
                  },
                  activeColor: const Color(0xFF10B981),
                ),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: const [
                    Text('Smaller', style: TextStyle(fontSize: 12)),
                    Text('Larger', style: TextStyle(fontSize: 12)),
                  ],
                ),
              ],
            ),
          ],
        ),
      ),
    );

}

Widget \_buildFontSelector(
String label,
AppFontFamily currentFont,
List<AppFontFamily> options,
Function(AppFontFamily) onChanged,
) {
return Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
label,
style: Theme.of(context).textTheme.titleMedium,
),
const SizedBox(height: 8),
Wrap(
spacing: 8,
runSpacing: 8,
children: options.map((font) {
final isSelected = currentFont == font;
return FilterChip(
label: Text(font.name),
selected: isSelected,
onSelected: (selected) => onChanged(font),
backgroundColor: Colors.grey.shade100,
selectedColor: const Color(0xFF10B981).withOpacity(0.2),
checkmarkColor: const Color(0xFF10B981),
labelStyle: TextStyle(
color:
isSelected ? const Color(0xFF10B981) : Colors.grey.shade700,
fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
),
);
}).toList(),
),
],
);
}

Widget \_buildThemeSection(
ThemeMode themeMode, AppLocalizations localizations) {
return CustomCard(
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Row(
children: [
const Icon(Icons.palette, color: Color(0xFF10B981)),
const SizedBox(width: 12),
Text(
localizations.translate('themeMode'),
style: Theme.of(context).textTheme.titleLarge?.copyWith(
fontWeight: FontWeight.bold,
),
),
],
),
const SizedBox(height: 16),
DropdownButtonFormField<ThemeMode>(
value: themeMode,
decoration: InputDecoration(
labelText: 'Theme Mode',
border: OutlineInputBorder(
borderRadius: BorderRadius.circular(12),
),
),
items: [
DropdownMenuItem(
value: ThemeMode.light,
child: Text(localizations.translate('light')),
),
DropdownMenuItem(
value: ThemeMode.dark,
child: Text(localizations.translate('dark')),
),
DropdownMenuItem(
value: ThemeMode.system,
child: Text(localizations.translate('systemDefault')),
),
],
onChanged: (newMode) {
if (newMode != null) {
ref.read(themeProvider.notifier).setTheme(newMode);
}
},
),
],
),
),
);
}

Widget \_buildSecuritySection(AppLocalizations localizations) {
return CustomCard(
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
'Security',
style: Theme.of(context).textTheme.titleLarge?.copyWith(
fontWeight: FontWeight.bold,
),
),
const SizedBox(height: 16),
if (\_isChangingPassword) ...[
_buildPasswordChangeForm(),
const SizedBox(height: 16),
],
SizedBox(
width: double.infinity,
child: OutlinedButton(
onPressed: \_isChangingPassword
? \_changePassword
: \_togglePasswordChange,
child: Text(\_isChangingPassword
? 'Change Password'
: 'Change Password'),
),
),
],
),
),
);
}

Widget \_buildLogoutSection(AppLocalizations localizations) {
return CustomCard(
backgroundColor: Colors.red.shade50,
child: ListTile(
leading: Icon(Icons.logout, color: Colors.red.shade600),
title: Text(
'Logout',
style: TextStyle(
color: Colors.red.shade700,
fontWeight: FontWeight.bold,
),
),
trailing: Icon(Icons.arrow_forward, color: Colors.red.shade600),
onTap: \_logout,
),
);
}

Widget \_buildProfileForm() {
return Column(
children: [
TextFormField(
controller: _nameController,
decoration: const InputDecoration(
labelText: 'Full Name',
border: OutlineInputBorder(),
),
),
const SizedBox(height: 12),
TextFormField(
controller: _phoneController,
decoration: const InputDecoration(
labelText: 'Phone Number',
border: OutlineInputBorder(),
),
keyboardType: TextInputType.phone,
),
const SizedBox(height: 12),
TextFormField(
controller: _emailController,
decoration: const InputDecoration(
labelText: 'Email (Optional)',
border: OutlineInputBorder(),
),
keyboardType: TextInputType.emailAddress,
),
],
);
}

Widget \_buildPasswordChangeForm() {
return Column(
children: [
TextFormField(
controller: _currentPasswordController,
decoration: const InputDecoration(
labelText: 'Current Password',
border: OutlineInputBorder(),
),
obscureText: true,
),
const SizedBox(height: 12),
TextFormField(
controller: _newPasswordController,
decoration: const InputDecoration(
labelText: 'New Password',
border: OutlineInputBorder(),
),
obscureText: true,
),
const SizedBox(height: 12),
TextFormField(
controller: _confirmPasswordController,
decoration: const InputDecoration(
labelText: 'Confirm New Password',
border: OutlineInputBorder(),
),
obscureText: true,
),
],
);
}
}

##

// src/ui/screens/business_registration_screen.dart
// Screen for registering a business during the onboarding process.
import 'package:andalus_smart_pos/src/data/models/category.dart';
import 'package:andalus_smart_pos/src/data/repositories/category_repository.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/data/models/business.dart';
import 'package:andalus_smart_pos/src/data/repositories/business_repository.dart';
import 'package:andalus_smart_pos/src/widgets/common/custom_card.dart';
import 'package:andalus_smart_pos/src/widgets/common/loading_shimmer.dart';

class BusinessRegistrationScreen extends ConsumerStatefulWidget {
const BusinessRegistrationScreen({super.key});

@override
ConsumerState<BusinessRegistrationScreen> createState() =>
\_BusinessRegistrationScreenState();
}

class \_BusinessRegistrationScreenState
extends ConsumerState<BusinessRegistrationScreen> {
final \_formKey = GlobalKey<FormState>();
final \_businessNameController = TextEditingController();
final \_businessNameAmController = TextEditingController();
final \_phoneController = TextEditingController();
final \_emailController = TextEditingController();
final \_addressController = TextEditingController();
final \_cityController = TextEditingController();
final \_regionController = TextEditingController();
final \_tinController = TextEditingController();
final \_vatController = TextEditingController();
final \_licenseController = TextEditingController();
final \_ownerNameController = TextEditingController();
final \_ownerPhoneController = TextEditingController();
final \_ownerEmailController = TextEditingController();

String \_selectedBusinessType = 'retail';
bool \_isLoading = false;

@override
void dispose() {
\_businessNameController.dispose();
\_businessNameAmController.dispose();
\_phoneController.dispose();
\_emailController.dispose();
\_addressController.dispose();
\_cityController.dispose();
\_regionController.dispose();
\_tinController.dispose();
\_vatController.dispose();
\_licenseController.dispose();
\_ownerNameController.dispose();
\_ownerPhoneController.dispose();
\_ownerEmailController.dispose();
super.dispose();
}

Future<void> \_registerBusiness() async {
if (!\_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);

    try {
      final businessRepo = ref.read(businessRepositoryProvider);
      final business = BusinessProfile(
        businessId: 'biz_${DateTime.now().millisecondsSinceEpoch}',
        name: _businessNameController.text.trim(),
        nameAm: _businessNameAmController.text.trim(),
        businessType: _selectedBusinessType,
        phone: _phoneController.text.trim(),
        email: _emailController.text.trim().isEmpty
            ? null
            : _emailController.text.trim(),
        address: _addressController.text.trim(),
        city: _cityController.text.trim().isEmpty
            ? null
            : _cityController.text.trim(),
        region: _regionController.text.trim().isEmpty
            ? null
            : _regionController.text.trim(),
        tinNumber: _tinController.text.trim(),
        vatNumber: _vatController.text.trim().isEmpty
            ? null
            : _vatController.text.trim(),
        businessLicense: _licenseController.text.trim().isEmpty
            ? null
            : _licenseController.text.trim(),
        ownerName: _ownerNameController.text.trim().isEmpty
            ? null
            : _ownerNameController.text.trim(),
        ownerPhone: _ownerPhoneController.text.trim().isEmpty
            ? null
            : _ownerPhoneController.text.trim(),
        ownerEmail: _ownerEmailController.text.trim().isEmpty
            ? null
            : _ownerEmailController.text.trim(),
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      await businessRepo.saveBusinessProfile(business);

      // Create default categories for the business type
      final categoryRepo = ref.read(categoryRepositoryProvider);
      final defaultCategories =
          DefaultCategories.forBusinessType(_selectedBusinessType);
      for (final category in defaultCategories) {
        await categoryRepo.createCategory(category);
      }

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Business registered successfully!'),
            backgroundColor: Colors.green,
          ),
        );
        Navigator.pushReplacementNamed(context, '/main');
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error registering business: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }

}

@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: const Text('Business Registration'),
backgroundColor: const Color(0xFF10B981),
foregroundColor: Colors.white,
),
body: \_isLoading
? \_buildLoadingState()
: SingleChildScrollView(
padding: const EdgeInsets.all(16),
child: Form(
key: \_formKey,
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
_buildBusinessTypeSection(),
const SizedBox(height: 24),
_buildBusinessInfoSection(),
const SizedBox(height: 24),
_buildOwnerInfoSection(),
const SizedBox(height: 32),
_buildSubmitButton(),
],
),
),
),
);
}

Widget \_buildLoadingState() {
return const Padding(
padding: EdgeInsets.all(16),
child: Column(
children: [
LoadingShimmer(height: 60, borderRadius: 12),
SizedBox(height: 16),
LoadingShimmer(height: 200, borderRadius: 12),
SizedBox(height: 16),
LoadingShimmer(height: 150, borderRadius: 12),
],
),
);
}

Widget \_buildBusinessTypeSection() {
return CustomCard(
margin: EdgeInsets.zero,
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
'Business Type',
style: Theme.of(context).textTheme.titleLarge?.copyWith(
fontWeight: FontWeight.bold,
),
),
const SizedBox(height: 16),
Wrap(
spacing: 8,
runSpacing: 8,
children: BusinessType.allTypes.map((type) {
final isSelected = \_selectedBusinessType == type.id;
return FilterChip(
label: Text(type.name),
selected: isSelected,
onSelected: (selected) {
setState(() => \_selectedBusinessType = type.id);
},
backgroundColor: Colors.grey.shade100,
selectedColor: const Color(0xFF10B981).withOpacity(0.2),
checkmarkColor: const Color(0xFF10B981),
labelStyle: TextStyle(
color: isSelected
? const Color(0xFF10B981)
: Colors.grey.shade700,
fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
),
);
}).toList(),
),
if (\_selectedBusinessType.isNotEmpty) ...[
const SizedBox(height: 12),
Text(
BusinessType.allTypes
.firstWhere((type) => type.id == _selectedBusinessType)
.description,
style: Theme.of(context).textTheme.bodySmall?.copyWith(
color: Colors.grey.shade600,
fontStyle: FontStyle.italic,
),
),
],
],
),
);
}

Widget \_buildBusinessInfoSection() {
return CustomCard(
margin: EdgeInsets.zero,
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
'Business Information',
style: Theme.of(context).textTheme.titleLarge?.copyWith(
fontWeight: FontWeight.bold,
),
),
const SizedBox(height: 16),
\_buildTextField(
controller: \_businessNameController,
label: 'Business Name (English) _',
hintText: 'Enter business name in English',
validator: (value) {
if (value == null || value.trim().isEmpty) {
return 'Business name is required';
}
return null;
},
),
const SizedBox(height: 12),
\_buildTextField(
controller: \_businessNameAmController,
label: 'Business Name (Amharic) _',
hintText: '·ã®·äï·åç·ãµ ·àµ·àù ·â†·ä†·àõ·à≠·äõ',
validator: (value) {
if (value == null || value.trim().isEmpty) {
return 'Business name in Amharic is required';
}
return null;
},
),
const SizedBox(height: 12),
\_buildTextField(
controller: \_phoneController,
label: 'Business Phone _',
hintText: '+251 XXX XXX XXX',
keyboardType: TextInputType.phone,
validator: (value) {
if (value == null || value.trim().isEmpty) {
return 'Phone number is required';
}
if (!RegExp(r'^(\+251|251|0)\d{9}$').hasMatch(value.trim())) {
return 'Please enter a valid Ethiopian phone number';
}
return null;
},
),
const SizedBox(height: 12),
\_buildTextField(
controller: \_emailController,
label: 'Business Email',
hintText: 'business@example.com',
keyboardType: TextInputType.emailAddress,
),
const SizedBox(height: 12),
\_buildTextField(
controller: \_addressController,
label: 'Address _',
hintText: 'Full business address',
maxLines: 2,
validator: (value) {
if (value == null || value.trim().isEmpty) {
return 'Address is required';
}
return null;
},
),
const SizedBox(height: 12),
Row(
children: [
Expanded(
child: _buildTextField(
controller: _cityController,
label: 'City',
hintText: 'City',
),
),
const SizedBox(width: 12),
Expanded(
child: _buildTextField(
controller: _regionController,
label: 'Region',
hintText: 'Region/State',
),
),
],
),
const SizedBox(height: 12),
\_buildTextField(
controller: \_tinController,
label: 'TIN Number \*',
hintText: 'Tax Identification Number',
validator: (value) {
if (value == null || value.trim().isEmpty) {
return 'TIN number is required';
}
return null;
},
),
const SizedBox(height: 12),
Row(
children: [
Expanded(
child: _buildTextField(
controller: _vatController,
label: 'VAT Number',
hintText: 'VAT Registration Number',
),
),
const SizedBox(width: 12),
Expanded(
child: _buildTextField(
controller: _licenseController,
label: 'Business License',
hintText: 'License Number',
),
),
],
),
],
),
);
}

Widget \_buildOwnerInfoSection() {
return CustomCard(
margin: EdgeInsets.zero,
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
'Owner Information (Optional)',
style: Theme.of(context).textTheme.titleLarge?.copyWith(
fontWeight: FontWeight.bold,
),
),
const SizedBox(height: 8),
Text(
'Provide owner details for business records',
style: Theme.of(context).textTheme.bodySmall?.copyWith(
color: Colors.grey.shade600,
),
),
const SizedBox(height: 16),
_buildTextField(
controller: _ownerNameController,
label: 'Owner Name',
hintText: 'Full name of business owner',
),
const SizedBox(height: 12),
_buildTextField(
controller: _ownerPhoneController,
label: 'Owner Phone',
hintText: 'Owner phone number',
keyboardType: TextInputType.phone,
),
const SizedBox(height: 12),
_buildTextField(
controller: _ownerEmailController,
label: 'Owner Email',
hintText: 'Owner email address',
keyboardType: TextInputType.emailAddress,
),
],
),
);
}

Widget \_buildTextField({
required TextEditingController controller,
required String label,
required String hintText,
TextInputType keyboardType = TextInputType.text,
int maxLines = 1,
String? Function(String?)? validator,
}) {
return TextFormField(
controller: controller,
decoration: InputDecoration(
labelText: label,
hintText: hintText,
border: const OutlineInputBorder(),
contentPadding:
const EdgeInsets.symmetric(horizontal: 12, vertical: 16),
),
keyboardType: keyboardType,
maxLines: maxLines,
validator: validator,
);
}

Widget \_buildSubmitButton() {
return SizedBox(
width: double.infinity,
child: ElevatedButton(
onPressed: \_isLoading ? null : \_registerBusiness,
style: ElevatedButton.styleFrom(
backgroundColor: const Color(0xFF10B981),
foregroundColor: Colors.white,
padding: const EdgeInsets.symmetric(vertical: 16),
shape: RoundedRectangleBorder(
borderRadius: BorderRadius.circular(12),
),
),
child: \_isLoading
? const SizedBox(
height: 20,
width: 20,
child: CircularProgressIndicator(
strokeWidth: 2,
valueColor: AlwaysStoppedAnimation(Colors.white),
),
)
: const Text(
'Register Business',
style: TextStyle(
fontSize: 16,
fontWeight: FontWeight.bold,
),
),
),
);
}
}

##

// src/ui/screens/category_management_screen.dart
// Screen for managing product categories including viewing, searching, adding, editing, and toggling active
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/data/models/category.dart';
import 'package:andalus_smart_pos/src/data/repositories/category_repository.dart';
import 'package:andalus_smart_pos/src/widgets/common/custom_card.dart';
import 'package:andalus_smart_pos/src/widgets/common/loading_shimmer.dart';

class CategoryManagementScreen extends ConsumerStatefulWidget {
const CategoryManagementScreen({super.key});

@override
ConsumerState<CategoryManagementScreen> createState() =>
\_CategoryManagementScreenState();
}

class \_CategoryManagementScreenState
extends ConsumerState<CategoryManagementScreen> {
final \_searchController = TextEditingController();
List<ProductCategory> \_categories = [];
List<ProductCategory> \_filteredCategories = [];
bool \_isLoading = true;
String \_searchQuery = '';

@override
void initState() {
super.initState();
\_loadCategories();
\_searchController.addListener(\_onSearchChanged);
}

@override
void dispose() {
\_searchController.dispose();
super.dispose();
}

Future<void> \_loadCategories() async {
setState(() => \_isLoading = true);
try {
final categoryRepo = ref.read(categoryRepositoryProvider);
final categories = await categoryRepo.getAllCategories();
setState(() {
\_categories = categories;
\_filteredCategories = categories;
});
} catch (e) {
if (mounted) {
ScaffoldMessenger.of(context).showSnackBar(
SnackBar(
content: Text('Error loading categories: $e'),
backgroundColor: Colors.red,
),
);
}
} finally {
setState(() => \_isLoading = false);
}
}

void \_onSearchChanged() {
setState(() {
\_searchQuery = \_searchController.text.toLowerCase();
\_filteredCategories = \_categories.where((category) {
return category.name.toLowerCase().contains(\_searchQuery) ||
category.nameAm.toLowerCase().contains(\_searchQuery) ||
(category.description?.toLowerCase().contains(\_searchQuery) ??
false);
}).toList();
});
}

void \_showAddCategoryDialog({ProductCategory? existingCategory}) {
final isEdit = existingCategory != null;
final nameController =
TextEditingController(text: existingCategory?.name ?? '');
final nameAmController =
TextEditingController(text: existingCategory?.nameAm ?? '');
final descriptionController =
TextEditingController(text: existingCategory?.description ?? '');
final colorController =
TextEditingController(text: existingCategory?.color ?? '#4CAF50');
final iconController =
TextEditingController(text: existingCategory?.icon ?? 'category');

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(isEdit ? 'Edit Category' : 'Add New Category'),
        content: SingleChildScrollView(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              _buildDialogTextField(
                controller: nameController,
                label: 'Category Name (English) *',
                hintText: 'e.g., Beverages',
              ),
              const SizedBox(height: 12),
              _buildDialogTextField(
                controller: nameAmController,
                label: 'Category Name (Amharic) *',
                hintText: 'e.g., ·àò·å†·å¶·âΩ',
              ),
              const SizedBox(height: 12),
              _buildDialogTextField(
                controller: descriptionController,
                label: 'Description',
                hintText: 'Category description',
                maxLines: 2,
              ),
              const SizedBox(height: 12),
              Row(
                children: [
                  Expanded(
                    child: _buildDialogTextField(
                      controller: colorController,
                      label: 'Color',
                      hintText: '#4CAF50',
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: _buildDialogTextField(
                      controller: iconController,
                      label: 'Icon',
                      hintText: 'local_cafe',
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () async {
              if (nameController.text.trim().isEmpty ||
                  nameAmController.text.trim().isEmpty) {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('Category name is required')),
                );
                return;
              }

              try {
                final categoryRepo = ref.read(categoryRepositoryProvider);
                final category = ProductCategory(
                  id: existingCategory?.id,
                  categoryId: existingCategory?.categoryId ??
                      'cat_${DateTime.now().millisecondsSinceEpoch}',
                  name: nameController.text.trim(),
                  nameAm: nameAmController.text.trim(),
                  description: descriptionController.text.trim().isEmpty
                      ? null
                      : descriptionController.text.trim(),
                  color: colorController.text.trim().isEmpty
                      ? null
                      : colorController.text.trim(),
                  icon: iconController.text.trim().isEmpty
                      ? null
                      : iconController.text.trim(),
                  sortOrder: existingCategory?.sortOrder ?? _categories.length,
                  isActive: existingCategory?.isActive ?? true,
                  createdAt: existingCategory?.createdAt ?? DateTime.now(),
                  updatedAt: DateTime.now(),
                );

                if (isEdit) {
                  await categoryRepo.updateCategory(category);
                } else {
                  await categoryRepo.createCategory(category);
                }

                if (mounted) {
                  Navigator.pop(context);
                  _loadCategories();
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(
                      content: Text(
                          'Category ${isEdit ? 'updated' : 'created'} successfully!'),
                      backgroundColor: Colors.green,
                    ),
                  );
                }
              } catch (e) {
                if (mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(
                      content: Text('Error saving category: $e'),
                      backgroundColor: Colors.red,
                    ),
                  );
                }
              }
            },
            child: Text(isEdit ? 'Update' : 'Create'),
          ),
        ],
      ),
    );

}

Widget \_buildDialogTextField({
required TextEditingController controller,
required String label,
required String hintText,
int maxLines = 1,
}) {
return TextFormField(
controller: controller,
decoration: InputDecoration(
labelText: label,
hintText: hintText,
border: const OutlineInputBorder(),
),
maxLines: maxLines,
);
}

Future<void> \_toggleCategoryStatus(ProductCategory category) async {
try {
final categoryRepo = ref.read(categoryRepositoryProvider);
await categoryRepo
.updateCategory(category.copyWith(isActive: !category.isActive));
\_loadCategories();
} catch (e) {
if (mounted) {
ScaffoldMessenger.of(context).showSnackBar(
SnackBar(
content: Text('Error updating category: $e'),
backgroundColor: Colors.red,
),
);
}
}
}

@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: const Text('Product Categories'),
backgroundColor: const Color(0xFF10B981),
foregroundColor: Colors.white,
actions: [
IconButton(
icon: const Icon(Icons.add),
onPressed: () => _showAddCategoryDialog(),
tooltip: 'Add Category',
),
],
),
body: Column(
children: [
// Search Bar
Padding(
padding: const EdgeInsets.all(16),
child: TextField(
controller: _searchController,
decoration: InputDecoration(
hintText: 'Search categories...',
prefixIcon: const Icon(Icons.search),
border: OutlineInputBorder(
borderRadius: BorderRadius.circular(12),
),
),
),
),
// Categories List
Expanded(
child: _isLoading
? _buildLoadingState()
: _filteredCategories.isEmpty
? _buildEmptyState()
: _buildCategoriesList(),
),
],
),
);
}

Widget \_buildLoadingState() {
return ListView.builder(
padding: const EdgeInsets.all(16),
itemCount: 6,
itemBuilder: (context, index) => const Padding(
padding: EdgeInsets.only(bottom: 12),
child: ListItemShimmer(hasLeading: true, hasTrailing: true),
),
);
}

Widget \_buildEmptyState() {
return Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
Icon(Icons.category_outlined, size: 64, color: Colors.grey.shade400),
const SizedBox(height: 16),
Text(
_searchQuery.isEmpty ? 'No categories yet' : 'No categories found',
style: const TextStyle(
fontSize: 18,
fontWeight: FontWeight.bold,
color: Colors.grey,
),
),
const SizedBox(height: 8),
Text(
_searchQuery.isEmpty
? 'Add your first product category to get started'
: 'Try adjusting your search terms',
style: TextStyle(color: Colors.grey.shade600),
textAlign: TextAlign.center,
),
const SizedBox(height: 24),
if (_searchQuery.isEmpty)
ElevatedButton(
onPressed: () => _showAddCategoryDialog(),
style: ElevatedButton.styleFrom(
backgroundColor: const Color(0xFF10B981),
foregroundColor: Colors.white,
),
child: const Text('Add First Category'),
),
],
),
);
}

Widget \_buildCategoriesList() {
return ListView.builder(
padding: const EdgeInsets.all(16),
itemCount: \_filteredCategories.length,
itemBuilder: (context, index) {
final category = \_filteredCategories[index];
return \_buildCategoryCard(category);
},
);
}

Widget \_buildCategoryCard(ProductCategory category) {
return CustomCard(
margin: const EdgeInsets.only(bottom: 12),
onTap: () => \_showAddCategoryDialog(existingCategory: category),
child: Row(
children: [
// Category Icon/Color
Container(
width: 48,
height: 48,
decoration: BoxDecoration(
color: \_parseColor(category.color ?? '#4CAF50').withOpacity(0.2),
borderRadius: BorderRadius.circular(12),
),
child: Icon(
\_getIcon(category.icon ?? 'category'),
color: \_parseColor(category.color ?? '#4CAF50'),
size: 24,
),
),
const SizedBox(width: 16),
// Category Info
Expanded(
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
category.name,
style: const TextStyle(
fontWeight: FontWeight.bold,
fontSize: 16,
),
),
const SizedBox(height: 4),
Text(
category.nameAm,
style: TextStyle(
color: Colors.grey.shade600,
fontSize: 14,
),
),
if (category.description != null) ...[
const SizedBox(height: 4),
Text(
category.description!,
style: TextStyle(
color: Colors.grey.shade500,
fontSize: 12,
),
maxLines: 1,
overflow: TextOverflow.ellipsis,
),
],
],
),
),
// Status and Actions
Row(
mainAxisSize: MainAxisSize.min,
children: [
// Active/Inactive Badge
Container(
padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
decoration: BoxDecoration(
color: category.isActive
? Colors.green.shade50
: Colors.grey.shade100,
borderRadius: BorderRadius.circular(6),
border: Border.all(
color: category.isActive
? Colors.green.shade200
: Colors.grey.shade300,
),
),
child: Text(
category.isActive ? 'Active' : 'Inactive',
style: TextStyle(
color: category.isActive
? Colors.green.shade700
: Colors.grey.shade600,
fontSize: 12,
fontWeight: FontWeight.w500,
),
),
),
const SizedBox(width: 12),
// Toggle Button
IconButton(
icon: Icon(
category.isActive ? Icons.toggle_on : Icons.toggle_off,
color:
category.isActive ? const Color(0xFF10B981) : Colors.grey,
size: 30,
),
onPressed: () => _toggleCategoryStatus(category),
),
],
),
],
),
);
}

Color \_parseColor(String colorString) {
try {
return Color(int.parse(colorString.replaceAll('#', '0xFF')));
} catch (e) {
return const Color(0xFF4CAF50);
}
}

IconData \_getIcon(String iconName) {
switch (iconName) {
case 'local_grocery_store':
return Icons.local_grocery_store;
case 'restaurant':
return Icons.restaurant;
case 'local_cafe':
return Icons.local_cafe;
case 'medical_services':
return Icons.medical_services;
case 'local_pharmacy':
return Icons.local_pharmacy;
case 'spa':
return Icons.spa;
case 'home':
return Icons.home;
case 'cake':
return Icons.cake;
default:
return Icons.category;
}
}
}

##

// src/ui/screens/customer_detail_screen.dart
// Screen for viewing and managing detailed information about a specific customer, including credit sales and payments.
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/data/models/customer.dart';
import 'package:andalus_smart_pos/src/data/models/credit_transaction.dart';
import 'package:andalus_smart_pos/src/data/repositories/customer_repository.dart';

class CustomerDetailScreen extends ConsumerStatefulWidget {
final Customer customer;

const CustomerDetailScreen({super.key, required this.customer});

@override
ConsumerState<CustomerDetailScreen> createState() =>
\_CustomerDetailScreenState();
}

class \_CustomerDetailScreenState extends ConsumerState<CustomerDetailScreen> {
List<CreditTransaction> \_transactions = [];
bool \_isLoading = true;
Customer? \_currentCustomer;

@override
void initState() {
super.initState();
\_currentCustomer = widget.customer;
\_loadData();
}

Future<void> \_loadData() async {
await \_loadCustomer();
await \_loadTransactions();
}

Future<void> \_loadCustomer() async {
try {
final repository = ref.read(customerRepositoryProvider);
final customer = await repository.getCustomerById(widget.customer.id!);
if (customer != null && mounted) {
setState(() {
\_currentCustomer = customer;
});
}
} catch (e) {
print('Error loading customer: $e');
}
}

Future<void> \_loadTransactions() async {
try {
final repository = ref.read(customerRepositoryProvider);
final transactions =
await repository.getCustomerTransactions(widget.customer.id!);

      if (mounted) {
        setState(() {
          _transactions = transactions;
          _isLoading = false;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error loading transactions: $e'),
          backgroundColor: Colors.red,
        ),
      );
    }

}

void \_showAddCreditSaleDialog() {
showDialog(
context: context,
builder: (context) => AddCreditSaleDialog(
customer: \_currentCustomer!,
onSaleCompleted: \_loadData,
),
);
}

void \_showRecordPaymentDialog() {
showDialog(
context: context,
builder: (context) => RecordPaymentDialog(
customer: \_currentCustomer!,
onPaymentRecorded: \_loadData,
),
);
}

void \_showEditCreditLimitDialog() {
showDialog(
context: context,
builder: (context) => EditCreditLimitDialog(
customer: \_currentCustomer!,
onCreditLimitUpdated: \_loadData,
),
);
}

@override
Widget build(BuildContext context) {
if (\_currentCustomer == null) {
return const Scaffold(
body: Center(
child: CircularProgressIndicator(),
),
);
}

    final customer = _currentCustomer!;
    final screenSize = MediaQuery.of(context).size;
    final isSmallScreen = screenSize.width < 600;

    return Scaffold(
      appBar: AppBar(
        title: Text(customer.name),
        backgroundColor: const Color(0xFF10B981),
        foregroundColor: Colors.white,
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: _loadData,
            tooltip: 'Refresh',
          ),
        ],
      ),
      body: SingleChildScrollView(
        padding: EdgeInsets.all(isSmallScreen ? 16 : 24),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Customer Info Card
            _buildCustomerInfoCard(customer, isSmallScreen),
            const SizedBox(height: 24),

            // Credit Control Actions
            _buildCreditActionsCard(customer, isSmallScreen),
            const SizedBox(height: 24),

            // Transaction History
            _buildTransactionHistory(),
          ],
        ),
      ),
    );

}

// In customer_detail_screen.dart, update the customer info card
Widget \_buildCustomerInfoCard(Customer customer, bool isSmallScreen) {
return Card(
elevation: 2,
child: Padding(
padding: const EdgeInsets.all(20),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
// Header with business name if available
Row(
children: [
Container(
width: 50,
height: 50,
decoration: BoxDecoration(
color: const Color(0xFF10B981).withOpacity(0.1),
borderRadius: BorderRadius.circular(25),
),
child: const Icon(
Icons.person,
color: Color(0xFF10B981),
size: 24,
),
),
const SizedBox(width: 16),
Expanded(
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
customer.name,
style: const TextStyle(
fontSize: 20,
fontWeight: FontWeight.bold,
),
),
if (customer.businessName != null) ...[
const SizedBox(height: 4),
Text(
customer.businessName!,
style: const TextStyle(
color: Colors.grey,
fontStyle: FontStyle.italic,
),
),
],
if (customer.phone != null) ...[
const SizedBox(height: 4),
Text(
customer.phone!,
style: const TextStyle(
color: Colors.grey,
),
),
],
],
),
),
// Status Badge
Container(
padding:
const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
decoration: BoxDecoration(
color: customer.isOverdue
? Colors.red.withOpacity(0.1)
: customer.currentBalance > 0
? Colors.orange.withOpacity(0.1)
: Colors.green.withOpacity(0.1),
borderRadius: BorderRadius.circular(20),
border: Border.all(
color: customer.isOverdue
? Colors.red
: customer.currentBalance > 0
? Colors.orange
: Colors.green,
),
),
child: Text(
customer.isOverdue
? 'OVERDUE'
: customer.currentBalance > 0
? 'PENDING'
: 'PAID',
style: TextStyle(
fontSize: 12,
fontWeight: FontWeight.bold,
color: customer.isOverdue
? Colors.red
: customer.currentBalance > 0
? Colors.orange
: Colors.green,
),
),
),
],
),
const SizedBox(height: 20),

            // Additional customer info
            if (customer.tinNumber != null ||
                customer.whatsappNumber != null ||
                customer.email != null) ...[
              _buildAdditionalInfo(customer),
              const SizedBox(height: 16),
            ],

            // Rest of the existing credit information grid...
            // ... [keep the existing credit info grid code]
          ],
        ),
      ),
    );

}

Widget \_buildAdditionalInfo(Customer customer) {
return Container(
padding: const EdgeInsets.all(16),
decoration: BoxDecoration(
color: Colors.grey.shade50,
borderRadius: BorderRadius.circular(12),
border: Border.all(color: Colors.grey.shade200),
),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
const Text(
'Additional Information',
style: TextStyle(
fontWeight: FontWeight.w600,
fontSize: 14,
),
),
const SizedBox(height: 8),
if (customer.tinNumber != null)
_buildInfoRow('TIN/VAT:', customer.tinNumber!),
if (customer.whatsappNumber != null)
_buildInfoRow('WhatsApp:', customer.whatsappNumber!),
if (customer.email != null) _buildInfoRow('Email:', customer.email!),
if (customer.notes != null) _buildInfoRow('Notes:', customer.notes!),
],
),
);
}

Widget \_buildInfoRow(String label, String value) {
return Padding(
padding: const EdgeInsets.symmetric(vertical: 4),
child: Row(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
SizedBox(
width: 80,
child: Text(
label,
style: const TextStyle(
fontWeight: FontWeight.w500,
color: Colors.grey,
fontSize: 12,
),
),
),
Expanded(
child: Text(
value,
style: const TextStyle(
fontSize: 12,
),
),
),
],
),
);
}

Widget \_buildInfoItem(
String title, String value, IconData icon, Color color) {
return Container(
decoration: BoxDecoration(
color: Colors.white,
borderRadius: BorderRadius.circular(12),
border: Border.all(color: Colors.grey.shade200),
),
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
mainAxisAlignment: MainAxisAlignment.spaceBetween,
children: [
Row(
children: [
Container(
padding: const EdgeInsets.all(4),
decoration: BoxDecoration(
color: color.withOpacity(0.1),
borderRadius: BorderRadius.circular(6),
),
child: Icon(icon, color: color, size: 16),
),
const SizedBox(width: 8),
Expanded(
child: Text(
title,
style: const TextStyle(
fontSize: 12,
color: Colors.grey,
fontWeight: FontWeight.w500,
),
),
),
],
),
const SizedBox(height: 8),
Text(
value,
style: TextStyle(
fontSize: 16,
fontWeight: FontWeight.bold,
color: color,
),
),
],
),
),
);
}

Widget \_buildCreditActionsCard(Customer customer, bool isSmallScreen) {
return Card(
elevation: 2,
child: Padding(
padding: const EdgeInsets.all(20),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
const Text(
'Credit Actions',
style: TextStyle(
fontSize: 18,
fontWeight: FontWeight.bold,
),
),
const SizedBox(height: 16),
Wrap(
spacing: 12,
runSpacing: 12,
children: [
ElevatedButton.icon(
onPressed: customer.canMakeCreditSale
? _showAddCreditSaleDialog
: null,
style: ElevatedButton.styleFrom(
backgroundColor: const Color(0xFF10B981),
foregroundColor: Colors.white,
padding: const EdgeInsets.symmetric(
horizontal: 20, vertical: 12),
),
icon: const Icon(Icons.add_shopping_cart, size: 18),
label: const Text('Add Credit Sale'),
),
ElevatedButton.icon(
onPressed: customer.currentBalance > 0
? _showRecordPaymentDialog
: null,
style: ElevatedButton.styleFrom(
backgroundColor: const Color(0xFF059669),
foregroundColor: Colors.white,
padding: const EdgeInsets.symmetric(
horizontal: 20, vertical: 12),
),
icon: const Icon(Icons.payment, size: 18),
label: const Text('Record Payment'),
),
OutlinedButton.icon(
onPressed: _showEditCreditLimitDialog,
style: OutlinedButton.styleFrom(
foregroundColor: const Color(0xFF10B981),
side: const BorderSide(color: Color(0xFF10B981)),
padding: const EdgeInsets.symmetric(
horizontal: 20, vertical: 12),
),
icon: const Icon(Icons.credit_card, size: 18),
label: const Text('Edit Credit Limit'),
),
],
),
],
),
),
);
}

Widget \_buildTransactionHistory() {
return Card(
elevation: 2,
child: Padding(
padding: const EdgeInsets.all(20),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
const Text(
'Transaction History',
style: TextStyle(
fontSize: 18,
fontWeight: FontWeight.bold,
),
),
const SizedBox(height: 16),
\_isLoading
? const Center(
child: Padding(
padding: EdgeInsets.all(32),
child:
CircularProgressIndicator(color: Color(0xFF10B981)),
),
)
: \_transactions.isEmpty
? const Padding(
padding: EdgeInsets.all(32),
child: Column(
children: [
Icon(Icons.receipt_long,
size: 64, color: Colors.grey),
SizedBox(height: 16),
Text(
'No transactions yet',
style: TextStyle(
color: Colors.grey,
fontSize: 16,
),
),
],
),
)
: ListView.separated(
shrinkWrap: true,
physics: const NeverScrollableScrollPhysics(),
itemCount: \_transactions.length,
separatorBuilder: (context, index) =>
const Divider(height: 1),
itemBuilder: (context, index) {
final transaction = \_transactions[index];
return \_buildTransactionItem(transaction);
},
),
],
),
),
);
}

Widget \_buildTransactionItem(CreditTransaction transaction) {
return ListTile(
leading: Container(
width: 40,
height: 40,
decoration: BoxDecoration(
color: transaction.amountColor.withOpacity(0.1),
borderRadius: BorderRadius.circular(20),
),
child: Icon(transaction.icon, color: transaction.amountColor, size: 20),
),
title: Text(transaction.description),
subtitle: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
if (transaction.reference != null)
Text('Reference: ${transaction.reference}'),
if (transaction.notes != null) Text(transaction.notes!),
Text(
'${_formatDateTime(transaction.createdAt)} ‚Ä¢ Balance: ETB ${transaction.balanceAfter.toStringAsFixed(2)}',
style: const TextStyle(fontSize: 12, color: Colors.grey),
),
],
),
trailing: Text(
transaction.formattedAmount,
style: TextStyle(
fontWeight: FontWeight.bold,
color: transaction.amountColor,
fontSize: 16,
),
),
);
}

String \_formatDate(DateTime date) {
return '${date.day}/${date.month}/${date.year}';
}

String \_formatDateTime(DateTime date) {
return '${_formatDate(date)} ${date.hour.toString().padLeft(2, '0')}:${date.minute.toString().padLeft(2, '0')}';
}

int \_daysOverdue(DateTime dueDate) {
return DateTime.now().difference(dueDate).inDays;
}
}

// Add these dialog classes to your customer_detail_screen.dart file

// Add Credit Sale Dialog
class AddCreditSaleDialog extends ConsumerStatefulWidget {
final Customer customer;
final VoidCallback onSaleCompleted;

const AddCreditSaleDialog({
super.key,
required this.customer,
required this.onSaleCompleted,
});

@override
ConsumerState<AddCreditSaleDialog> createState() =>
\_AddCreditSaleDialogState();
}

class \_AddCreditSaleDialogState extends ConsumerState<AddCreditSaleDialog> {
final \_formKey = GlobalKey<FormState>();
final \_amountController = TextEditingController();
final \_referenceController = TextEditingController();
final \_notesController = TextEditingController();
final \_dueDaysController = TextEditingController(text: '30');

bool \_isSubmitting = false;

@override
void dispose() {
\_amountController.dispose();
\_referenceController.dispose();
\_notesController.dispose();
\_dueDaysController.dispose();
super.dispose();
}

Future<void> \_addCreditSale() async {
if (!\_formKey.currentState!.validate()) return;

    final amount = double.tryParse(_amountController.text) ?? 0;
    final dueDays = int.tryParse(_dueDaysController.text) ?? 30;

    if (amount <= 0) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Sale amount must be greater than zero'),
          backgroundColor: Colors.orange,
        ),
      );
      return;
    }

    setState(() {
      _isSubmitting = true;
    });

    try {
      final repository = ref.read(customerRepositoryProvider);
      final result = await repository.createCreditSale(
        customerId: widget.customer.id!,
        amount: amount,
        saleReference: _referenceController.text.isNotEmpty
            ? _referenceController.text
            : 'SALE-${DateTime.now().millisecondsSinceEpoch}',
        dueDays: dueDays,
        notes: _notesController.text.isNotEmpty ? _notesController.text : null,
      );

      if (result.success) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
                'Credit sale of ETB ${amount.toStringAsFixed(2)} added successfully!'),
            backgroundColor: const Color(0xFF10B981),
          ),
        );
        Navigator.pop(context);
        widget.onSaleCompleted();
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(result.error!),
            backgroundColor: Colors.red,
          ),
        );
      }
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error adding credit sale: $e'),
          backgroundColor: Colors.red,
        ),
      );
    } finally {
      if (mounted) {
        setState(() {
          _isSubmitting = false;
        });
      }
    }

}

@override
Widget build(BuildContext context) {
return Dialog(
insetPadding: const EdgeInsets.all(20),
shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
child: SingleChildScrollView(
padding: const EdgeInsets.all(24),
child: Form(
key: \_formKey,
child: Column(
mainAxisSize: MainAxisSize.min,
crossAxisAlignment: CrossAxisAlignment.start,
children: [
// Header
Row(
children: [
Container(
padding: const EdgeInsets.all(8),
decoration: BoxDecoration(
color: const Color(0xFF10B981).withOpacity(0.1),
borderRadius: BorderRadius.circular(8),
),
child: const Icon(Icons.add_shopping_cart,
color: Color(0xFF10B981), size: 24),
),
const SizedBox(width: 12),
const Expanded(
child: Text(
'Add Credit Sale',
style: TextStyle(
fontSize: 18,
fontWeight: FontWeight.bold,
),
),
),
IconButton(
icon: const Icon(Icons.close),
onPressed: () => Navigator.pop(context),
),
],
),
const SizedBox(height: 8),
Text(
'Customer: ${widget.customer.name}',
style: const TextStyle(color: Colors.grey),
),
const SizedBox(height: 4),
Text(
'Available Credit: ETB ${widget.customer.availableCredit.toStringAsFixed(2)}',
style: TextStyle(
color: widget.customer.availableCredit > 0
? Colors.green
: Colors.red,
fontWeight: FontWeight.w500,
),
),
const SizedBox(height: 24),

              // Form Fields
              TextFormField(
                controller: _amountController,
                decoration: const InputDecoration(
                  labelText: 'Sale Amount (ETB) *',
                  border: OutlineInputBorder(),
                  prefixText: 'ETB ',
                ),
                keyboardType: TextInputType.number,
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Please enter sale amount';
                  }
                  final amount = double.tryParse(value);
                  if (amount == null || amount <= 0) {
                    return 'Please enter a valid amount';
                  }
                  if (amount > widget.customer.availableCredit) {
                    return 'Amount exceeds available credit';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _referenceController,
                decoration: const InputDecoration(
                  labelText: 'Sale Reference',
                  border: OutlineInputBorder(),
                  hintText: 'Optional reference number',
                ),
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _dueDaysController,
                decoration: const InputDecoration(
                  labelText: 'Due Days',
                  border: OutlineInputBorder(),
                  hintText: '30',
                  suffixText: 'days',
                ),
                keyboardType: TextInputType.number,
                validator: (value) {
                  if (value != null && value.isNotEmpty) {
                    final days = int.tryParse(value);
                    if (days == null || days <= 0) {
                      return 'Please enter valid number of days';
                    }
                  }
                  return null;
                },
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _notesController,
                decoration: const InputDecoration(
                  labelText: 'Notes',
                  border: OutlineInputBorder(),
                  hintText: 'Optional notes about this sale',
                ),
                maxLines: 2,
              ),
              const SizedBox(height: 32),

              // Actions
              Row(
                children: [
                  Expanded(
                    child: OutlinedButton(
                      onPressed:
                          _isSubmitting ? null : () => Navigator.pop(context),
                      child: const Text('Cancel'),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: ElevatedButton(
                      onPressed: _isSubmitting ? null : _addCreditSale,
                      style: ElevatedButton.styleFrom(
                        backgroundColor: const Color(0xFF10B981),
                        foregroundColor: Colors.white,
                      ),
                      child: _isSubmitting
                          ? const SizedBox(
                              width: 20,
                              height: 20,
                              child: CircularProgressIndicator(
                                strokeWidth: 2,
                                color: Colors.white,
                              ),
                            )
                          : const Text('Add Sale'),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );

}
}

// Record Payment Dialog
class RecordPaymentDialog extends ConsumerStatefulWidget {
final Customer customer;
final VoidCallback onPaymentRecorded;

const RecordPaymentDialog({
super.key,
required this.customer,
required this.onPaymentRecorded,
});

@override
ConsumerState<RecordPaymentDialog> createState() =>
\_RecordPaymentDialogState();
}

class \_RecordPaymentDialogState extends ConsumerState<RecordPaymentDialog> {
final \_formKey = GlobalKey<FormState>();
final \_amountController = TextEditingController();
final \_referenceController = TextEditingController();
final \_notesController = TextEditingController();

bool \_isSubmitting = false;

@override
void initState() {
super.initState();
\_amountController.text = widget.customer.currentBalance.toStringAsFixed(2);
}

@override
void dispose() {
\_amountController.dispose();
\_referenceController.dispose();
\_notesController.dispose();
super.dispose();
}

Future<void> \_recordPayment() async {
if (!\_formKey.currentState!.validate()) return;

    final amount = double.tryParse(_amountController.text) ?? 0;

    if (amount <= 0) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Please enter a valid payment amount'),
          backgroundColor: Colors.orange,
        ),
      );
      return;
    }

    if (amount > widget.customer.currentBalance) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Payment amount cannot exceed outstanding balance'),
          backgroundColor: Colors.orange,
        ),
      );
      return;
    }

    setState(() {
      _isSubmitting = true;
    });

    try {
      final repository = ref.read(customerRepositoryProvider);
      final result = await repository.recordPayment(
        customerId: widget.customer.id!,
        amount: amount,
        paymentReference: _referenceController.text.isNotEmpty
            ? _referenceController.text
            : 'PAY-${DateTime.now().millisecondsSinceEpoch}',
        notes: _notesController.text.isNotEmpty ? _notesController.text : null,
      );

      if (result.success) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
                'Payment of ETB ${amount.toStringAsFixed(2)} recorded successfully!'),
            backgroundColor: const Color(0xFF10B981),
          ),
        );
        Navigator.pop(context);
        widget.onPaymentRecorded();
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(result.error!),
            backgroundColor: Colors.red,
          ),
        );
      }
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error recording payment: $e'),
          backgroundColor: Colors.red,
        ),
      );
    } finally {
      if (mounted) {
        setState(() {
          _isSubmitting = false;
        });
      }
    }

}

@override
Widget build(BuildContext context) {
return Dialog(
insetPadding: const EdgeInsets.all(20),
shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
child: SingleChildScrollView(
padding: const EdgeInsets.all(24),
child: Form(
key: \_formKey,
child: Column(
mainAxisSize: MainAxisSize.min,
crossAxisAlignment: CrossAxisAlignment.start,
children: [
// Header
Row(
children: [
Container(
padding: const EdgeInsets.all(8),
decoration: BoxDecoration(
color: const Color(0xFF10B981).withOpacity(0.1),
borderRadius: BorderRadius.circular(8),
),
child: const Icon(Icons.payment,
color: Color(0xFF10B981), size: 24),
),
const SizedBox(width: 12),
const Expanded(
child: Text(
'Record Payment',
style: TextStyle(
fontSize: 18,
fontWeight: FontWeight.bold,
),
),
),
IconButton(
icon: const Icon(Icons.close),
onPressed: () => Navigator.pop(context),
),
],
),
const SizedBox(height: 8),
Text(
'Customer: ${widget.customer.name}',
style: const TextStyle(color: Colors.grey),
),
const SizedBox(height: 4),
Text(
'Current Balance: ETB ${widget.customer.currentBalance.toStringAsFixed(2)}',
style: TextStyle(
color: widget.customer.currentBalance > 0
? Colors.orange
: Colors.green,
fontWeight: FontWeight.w500,
),
),
const SizedBox(height: 24),

              // Form Fields
              TextFormField(
                controller: _amountController,
                decoration: const InputDecoration(
                  labelText: 'Payment Amount (ETB) *',
                  border: OutlineInputBorder(),
                  prefixText: 'ETB ',
                ),
                keyboardType: TextInputType.number,
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Please enter payment amount';
                  }
                  final amount = double.tryParse(value);
                  if (amount == null || amount <= 0) {
                    return 'Please enter a valid amount';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _referenceController,
                decoration: const InputDecoration(
                  labelText: 'Payment Reference',
                  border: OutlineInputBorder(),
                  hintText: 'Optional reference number',
                ),
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _notesController,
                decoration: const InputDecoration(
                  labelText: 'Notes',
                  border: OutlineInputBorder(),
                  hintText: 'Optional notes about this payment',
                ),
                maxLines: 2,
              ),
              const SizedBox(height: 32),

              // Actions
              Row(
                children: [
                  Expanded(
                    child: OutlinedButton(
                      onPressed:
                          _isSubmitting ? null : () => Navigator.pop(context),
                      child: const Text('Cancel'),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: ElevatedButton(
                      onPressed: _isSubmitting ? null : _recordPayment,
                      style: ElevatedButton.styleFrom(
                        backgroundColor: const Color(0xFF10B981),
                        foregroundColor: Colors.white,
                      ),
                      child: _isSubmitting
                          ? const SizedBox(
                              width: 20,
                              height: 20,
                              child: CircularProgressIndicator(
                                strokeWidth: 2,
                                color: Colors.white,
                              ),
                            )
                          : const Text('Record Payment'),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );

}
}

// Edit Credit Limit Dialog
class EditCreditLimitDialog extends ConsumerStatefulWidget {
final Customer customer;
final VoidCallback onCreditLimitUpdated;

const EditCreditLimitDialog({
super.key,
required this.customer,
required this.onCreditLimitUpdated,
});

@override
ConsumerState<EditCreditLimitDialog> createState() =>
\_EditCreditLimitDialogState();
}

class \_EditCreditLimitDialogState extends ConsumerState<EditCreditLimitDialog> {
final \_formKey = GlobalKey<FormState>();
final \_creditLimitController = TextEditingController();

bool \_isSubmitting = false;

@override
void initState() {
super.initState();
\_creditLimitController.text =
widget.customer.creditLimit.toStringAsFixed(2);
}

@override
void dispose() {
\_creditLimitController.dispose();
super.dispose();
}

Future<void> \_updateCreditLimit() async {
if (!\_formKey.currentState!.validate()) return;

    final newLimit = double.tryParse(_creditLimitController.text) ?? 0;

    if (newLimit < 0) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Credit limit cannot be negative'),
          backgroundColor: Colors.orange,
        ),
      );
      return;
    }

    setState(() {
      _isSubmitting = true;
    });

    try {
      final repository = ref.read(customerRepositoryProvider);
      final result = await repository.updateCreditLimit(
        customerId: widget.customer.id!,
        newCreditLimit: newLimit,
      );

      if (result.success) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
                'Credit limit updated to ETB ${newLimit.toStringAsFixed(2)}'),
            backgroundColor: const Color(0xFF10B981),
          ),
        );
        Navigator.pop(context);
        widget.onCreditLimitUpdated();
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(result.error!),
            backgroundColor: Colors.red,
          ),
        );
      }
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error updating credit limit: $e'),
          backgroundColor: Colors.red,
        ),
      );
    } finally {
      if (mounted) {
        setState(() {
          _isSubmitting = false;
        });
      }
    }

}

@override
Widget build(BuildContext context) {
return Dialog(
insetPadding: const EdgeInsets.all(20),
shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
child: SingleChildScrollView(
padding: const EdgeInsets.all(24),
child: Form(
key: \_formKey,
child: Column(
mainAxisSize: MainAxisSize.min,
crossAxisAlignment: CrossAxisAlignment.start,
children: [
// Header
Row(
children: [
Container(
padding: const EdgeInsets.all(8),
decoration: BoxDecoration(
color: const Color(0xFF10B981).withOpacity(0.1),
borderRadius: BorderRadius.circular(8),
),
child: const Icon(Icons.credit_card,
color: Color(0xFF10B981), size: 24),
),
const SizedBox(width: 12),
const Expanded(
child: Text(
'Edit Credit Limit',
style: TextStyle(
fontSize: 18,
fontWeight: FontWeight.bold,
),
),
),
IconButton(
icon: const Icon(Icons.close),
onPressed: () => Navigator.pop(context),
),
],
),
const SizedBox(height: 8),
Text(
'Customer: ${widget.customer.name}',
style: const TextStyle(color: Colors.grey),
),
const SizedBox(height: 4),
Text(
'Current Balance: ETB ${widget.customer.currentBalance.toStringAsFixed(2)}',
style: const TextStyle(
color: Colors.orange,
fontWeight: FontWeight.w500,
),
),
const SizedBox(height: 24),

              // Form Field
              TextFormField(
                controller: _creditLimitController,
                decoration: const InputDecoration(
                  labelText: 'New Credit Limit (ETB) *',
                  border: OutlineInputBorder(),
                  prefixText: 'ETB ',
                ),
                keyboardType: TextInputType.number,
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Please enter credit limit';
                  }
                  final limit = double.tryParse(value);
                  if (limit == null) {
                    return 'Please enter a valid amount';
                  }
                  if (limit < widget.customer.currentBalance) {
                    return 'Credit limit cannot be less than current balance';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 32),

              // Actions
              Row(
                children: [
                  Expanded(
                    child: OutlinedButton(
                      onPressed:
                          _isSubmitting ? null : () => Navigator.pop(context),
                      child: const Text('Cancel'),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: ElevatedButton(
                      onPressed: _isSubmitting ? null : _updateCreditLimit,
                      style: ElevatedButton.styleFrom(
                        backgroundColor: const Color(0xFF10B981),
                        foregroundColor: Colors.white,
                      ),
                      child: _isSubmitting
                          ? const SizedBox(
                              width: 20,
                              height: 20,
                              child: CircularProgressIndicator(
                                strokeWidth: 2,
                                color: Colors.white,
                              ),
                            )
                          : const Text('Update Limit'),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );

}
}

##

// src/ui/screens/customer_detail_screen.dart
//
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/data/models/customer.dart';
import 'package:andalus_smart_pos/src/data/models/credit_transaction.dart';
import 'package:andalus_smart_pos/src/data/repositories/customer_repository.dart';
import 'package:andalus_smart_pos/src/data/local/database.dart';
// import 'package:andalus_smart_pos/src/ui/screens/customer_detail_screen.dart';

class CustomerManagementScreen extends ConsumerStatefulWidget {
const CustomerManagementScreen({super.key});

@override
ConsumerState<CustomerManagementScreen> createState() =>
\_CustomerManagementScreenState();
}

class \_CustomerManagementScreenState
extends ConsumerState<CustomerManagementScreen> {
final TextEditingController \_searchController = TextEditingController();
final ScrollController \_scrollController = ScrollController();

List<Customer> \_filteredCustomers = [];
List<Customer> \_allCustomers = [];
bool \_isLoading = true;
String \_filter = 'all';
String \_searchQuery = '';

@override
void initState() {
super.initState();
\_initializeData();
\_searchController.addListener(\_onSearchChanged);
}

@override
void dispose() {
\_searchController.dispose();
\_scrollController.dispose();
super.dispose();
}

Future<void> \_initializeData() async {
// Attempt to access the customers via the repository to ensure DB is initialized,
// and reset the database if accessing customers fails.
try {
final repository = ref.read(customerRepositoryProvider);
final customers = await repository.getAllCustomers();
print('Loaded ${customers.length} customers from database');
} catch (e) {
print('Database access error: $e');
try {
print('Resetting database...');
await AppDatabase.resetDatabase();
} catch (resetError) {
print('Failed to reset database: $resetError');
}
}

    await _loadCustomers();

}

Future<void> \_loadCustomers() async {
if (mounted) {
setState(() {
\_isLoading = true;
});
}

    try {
      final repository = ref.read(customerRepositoryProvider);
      List<Customer> customers;

      switch (_filter) {
        case 'with_balance':
          customers = await repository.getCustomersWithBalance();
          break;
        case 'overdue':
          customers = await repository.getOverdueCustomers();
          break;
        case 'all':
        default:
          customers = await repository.getAllCustomers();
      }

      if (mounted) {
        setState(() {
          _allCustomers = customers;
          _filteredCustomers = _applySearchFilter(customers, _searchQuery);
          _isLoading = false;
        });
      }
    } catch (e, stackTrace) {
      print('Error loading customers: $e');
      print('Stack trace: $stackTrace');

      if (mounted) {
        setState(() {
          _isLoading = false;
        });

        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error loading customers: $e'),
            backgroundColor: Colors.red,
            duration: const Duration(seconds: 5),
            action: SnackBarAction(
              label: 'Retry',
              onPressed: _loadCustomers,
            ),
          ),
        );
      }
    }

}

List<Customer> \_applySearchFilter(List<Customer> customers, String query) {
if (query.isEmpty) return customers;

    return customers.where((customer) {
      return customer.name.toLowerCase().contains(query.toLowerCase()) ||
          (customer.phone?.toLowerCase().contains(query.toLowerCase()) ??
              false) ||
          (customer.email?.toLowerCase().contains(query.toLowerCase()) ??
              false);
    }).toList();

}

void \_onSearchChanged() {
final query = \_searchController.text;
setState(() {
\_searchQuery = query;
\_filteredCustomers = \_applySearchFilter(\_allCustomers, query);
});
}

void \_changeFilter(String newFilter) {
setState(() {
\_filter = newFilter;
});
\_loadCustomers();
}

void _showAddCustomerDialog() {
showDialog(
context: context,
builder: (context) => AddCustomerDialog(
onCustomerAdded: \_loadCustomers,
),
).then((_) {
// This ensures the screen resizes properly after dialog closes
if (mounted) {
setState(() {});
}
});
}

void \_showCustomerDetails(Customer customer) {
Navigator.push(
context,
MaterialPageRoute(
builder: (context) => CustomerDetailScreen(customer: customer),
),
);
}

void \_showRecordPaymentDialog(Customer customer) {
showDialog(
context: context,
builder: (context) => RecordPaymentDialog(
customer: customer,
onPaymentRecorded: \_loadCustomers,
),
);
}

// Statistics
int get \_totalCustomers => \_allCustomers.length;
int get \_customersWithBalance =>
\_allCustomers.where((c) => c.currentBalance != 0).length;
int get \_overdueCustomers => \_allCustomers.where((c) => c.isOverdue).length;
double get \_totalOutstanding =>
\_allCustomers.fold(0, (sum, c) => sum + c.currentBalance);

@override
Widget build(BuildContext context) {
final screenSize = MediaQuery.of(context).size;
final isSmallScreen = screenSize.width < 600;
final isVerySmallScreen = screenSize.width < 400;

    return Scaffold(
      backgroundColor: const Color(0xFFF8FAFC),
      appBar: AppBar(
        title: const Text(
          'Customer Management',
          style: TextStyle(
            fontWeight: FontWeight.w600,
            fontSize: 18,
          ),
        ),
        backgroundColor: Colors.white,
        foregroundColor: const Color(0xFF1E293B),
        elevation: 1,
        shadowColor: Colors.black12,
        actions: [
          IconButton(
            icon: const Icon(Icons.add, size: 22),
            onPressed: _showAddCustomerDialog,
            tooltip: 'Add Customer',
          ),
          IconButton(
            icon: const Icon(Icons.refresh, size: 22),
            onPressed: _loadCustomers,
            tooltip: 'Refresh',
          ),
          const SizedBox(width: 8),
        ],
      ),
      body: Column(
        children: [
          // Header Section with Search
          _buildHeaderSection(isSmallScreen, isVerySmallScreen),

          // Statistics Cards
          if (_allCustomers.isNotEmpty)
            _buildStatisticsSection(isSmallScreen, isVerySmallScreen),

          // Content
          Expanded(
            child: _isLoading
                ? _buildLoadingState()
                : _filteredCustomers.isEmpty
                    ? _buildEmptyState(isSmallScreen)
                    : _buildCustomersList(isSmallScreen),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _showAddCustomerDialog,
        backgroundColor: const Color(0xFF10B981),
        foregroundColor: Colors.white,
        elevation: 4,
        child: const Icon(Icons.person_add_alt_1, size: 24),
      ),
    );

}

Widget \_buildHeaderSection(bool isSmallScreen, bool isVerySmallScreen) {
return Container(
padding: EdgeInsets.fromLTRB(
isVerySmallScreen ? 16 : 20,
16,
isVerySmallScreen ? 16 : 20,
12,
),
decoration: BoxDecoration(
color: Colors.white,
boxShadow: [
BoxShadow(
color: Colors.black.withOpacity(0.05),
blurRadius: 8,
offset: const Offset(0, 2),
),
],
),
child: Column(
children: [
// Search Bar
Container(
decoration: BoxDecoration(
borderRadius: BorderRadius.circular(12),
boxShadow: [
BoxShadow(
color: const Color(0xFF10B981).withOpacity(0.1),
blurRadius: 8,
offset: const Offset(0, 2),
),
],
),
child: TextField(
controller: \_searchController,
decoration: InputDecoration(
hintText: 'Search customers by name, phone, or email...',
prefixIcon: const Icon(Icons.search, color: Color(0xFF64748B)),
filled: true,
fillColor: Colors.white,
border: OutlineInputBorder(
borderRadius: BorderRadius.circular(12),
borderSide: BorderSide.none,
),
enabledBorder: OutlineInputBorder(
borderRadius: BorderRadius.circular(12),
borderSide: BorderSide.none,
),
focusedBorder: OutlineInputBorder(
borderRadius: BorderRadius.circular(12),
borderSide: const BorderSide(
color: Color(0xFF10B981),
width: 2,
),
),
contentPadding: const EdgeInsets.symmetric(
horizontal: 16,
vertical: 16,
),
),
),
),
const SizedBox(height: 16),

          // Filter Chips
          SizedBox(
            height: isVerySmallScreen ? 36 : 40,
            child: ListView(
              scrollDirection: Axis.horizontal,
              children: [
                _buildFilterChip('All Customers', 'all', isVerySmallScreen),
                SizedBox(width: isVerySmallScreen ? 8 : 12),
                _buildFilterChip(
                    'With Balance', 'with_balance', isVerySmallScreen),
                SizedBox(width: isVerySmallScreen ? 8 : 12),
                _buildFilterChip('Overdue', 'overdue', isVerySmallScreen),
              ],
            ),
          ),
        ],
      ),
    );

}

Widget \_buildFilterChip(String label, String value, bool isVerySmallScreen) {
final isSelected = \_filter == value;

    return FilterChip(
      label: Text(
        label,
        style: TextStyle(
          fontSize: isVerySmallScreen ? 12 : 13,
          fontWeight: FontWeight.w500,
          color: isSelected ? Colors.white : const Color(0xFF475569),
        ),
      ),
      selected: isSelected,
      onSelected: (selected) => _changeFilter(value),
      backgroundColor: Colors.white,
      selectedColor: const Color(0xFF10B981),
      side: BorderSide(
        color: isSelected ? const Color(0xFF10B981) : const Color(0xFFE2E8F0),
        width: 1,
      ),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(20),
      ),
      checkmarkColor: Colors.white,
      padding: EdgeInsets.symmetric(
        horizontal: isVerySmallScreen ? 12 : 16,
        vertical: isVerySmallScreen ? 4 : 6,
      ),
    );

}

Widget \_buildStatisticsSection(bool isSmallScreen, bool isVerySmallScreen) {
final stats = [
_StatItem('Total Customers', _totalCustomers.toString(), Icons.people_alt,
const Color(0xFF10B981)),
_StatItem('With Balance', _customersWithBalance.toString(),
Icons.account_balance_wallet, const Color(0xFFF59E0B)),
_StatItem('Overdue', _overdueCustomers.toString(), Icons.warning_amber,
const Color(0xFFEF4444)),
_StatItem('Outstanding', 'ETB ${_totalOutstanding.toStringAsFixed(0)}',
Icons.attach_money, const Color(0xFF8B5CF6)),
];

    return Container(
      padding: EdgeInsets.symmetric(
        horizontal: isVerySmallScreen ? 16 : 20,
        vertical: 16,
      ),
      child: GridView.builder(
        shrinkWrap: true,
        physics: const NeverScrollableScrollPhysics(),
        gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: isVerySmallScreen ? 2 : (isSmallScreen ? 2 : 4),
          crossAxisSpacing: isVerySmallScreen ? 12 : 16,
          mainAxisSpacing: isVerySmallScreen ? 12 : 16,
          childAspectRatio: isVerySmallScreen ? 1.2 : 1.4,
        ),
        itemCount: stats.length,
        itemBuilder: (context, index) {
          return _buildStatCard(stats[index], isVerySmallScreen);
        },
      ),
    );

}

Widget \_buildStatCard(\_StatItem stat, bool isVerySmallScreen) {
return Container(
decoration: BoxDecoration(
color: Colors.white,
borderRadius: BorderRadius.circular(12),
boxShadow: [
BoxShadow(
color: Colors.black.withOpacity(0.05),
blurRadius: 8,
offset: const Offset(0, 2),
),
],
),
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
mainAxisAlignment: MainAxisAlignment.spaceBetween,
children: [
Container(
padding: const EdgeInsets.all(8),
decoration: BoxDecoration(
color: stat.color.withOpacity(0.1),
borderRadius: BorderRadius.circular(8),
),
child: Icon(stat.icon, color: stat.color, size: 20),
),
Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
stat.value,
style: TextStyle(
fontSize: isVerySmallScreen ? 16 : 18,
fontWeight: FontWeight.bold,
color: const Color(0xFF1E293B),
),
),
const SizedBox(height: 4),
Text(
stat.label,
style: TextStyle(
fontSize: isVerySmallScreen ? 11 : 12,
color: const Color(0xFF64748B),
fontWeight: FontWeight.w500,
),
),
],
),
],
),
),
);
}

Widget \_buildLoadingState() {
return const Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
SizedBox(
width: 40,
height: 40,
child: CircularProgressIndicator(
strokeWidth: 3,
color: Color(0xFF10B981),
),
),
SizedBox(height: 16),
Text(
'Loading customers...',
style: TextStyle(
color: Color(0xFF64748B),
fontSize: 14,
),
),
],
),
);
}

Widget \_buildEmptyState(bool isSmallScreen) {
return Center(
child: Padding(
padding: EdgeInsets.all(isSmallScreen ? 32 : 48),
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
Container(
width: isSmallScreen ? 120 : 150,
height: isSmallScreen ? 120 : 150,
decoration: BoxDecoration(
color: const Color(0xFFF1F5F9),
borderRadius: BorderRadius.circular(75),
),
child: Icon(
Icons.people_outline,
size: isSmallScreen ? 50 : 60,
color: const Color(0xFF94A3B8),
),
),
const SizedBox(height: 24),
Text(
_getEmptyStateTitle(),
style: const TextStyle(
fontSize: 20,
fontWeight: FontWeight.bold,
color: Color(0xFF1E293B),
),
textAlign: TextAlign.center,
),
const SizedBox(height: 8),
Text(
_getEmptyStateMessage(),
style: const TextStyle(
fontSize: 14,
color: Color(0xFF64748B),
height: 1.5,
),
textAlign: TextAlign.center,
),
const SizedBox(height: 32),
ElevatedButton(
onPressed: _showAddCustomerDialog,
style: ElevatedButton.styleFrom(
backgroundColor: const Color(0xFF10B981),
foregroundColor: Colors.white,
padding:
const EdgeInsets.symmetric(horizontal: 32, vertical: 16),
shape: RoundedRectangleBorder(
borderRadius: BorderRadius.circular(12),
),
elevation: 2,
),
child: const Text(
'Add First Customer',
style: TextStyle(
fontWeight: FontWeight.w600,
fontSize: 14,
),
),
),
],
),
),
);
}

String \_getEmptyStateTitle() {
switch (\_filter) {
case 'with_balance':
return 'No Customers with Balance';
case 'overdue':
return 'No Overdue Customers';
default:
return 'No Customers Yet';
}
}

String \_getEmptyStateMessage() {
switch (\_filter) {
case 'with_balance':
return 'All customers are paid up! Great job managing credit.';
case 'overdue':
return 'No customers have exceeded their credit limits. Excellent credit control!';
default:
return 'Start building your customer database to track sales, credit, and customer relationships.';
}
}

Widget \_buildCustomersList(bool isSmallScreen) {
return RefreshIndicator(
onRefresh: \_loadCustomers,
color: const Color(0xFF10B981),
backgroundColor: Colors.white,
child: ListView.builder(
controller: \_scrollController,
padding: EdgeInsets.fromLTRB(
isSmallScreen ? 16 : 20,
8,
isSmallScreen ? 16 : 20,
20,
),
itemCount: \_filteredCustomers.length,
itemBuilder: (context, index) {
final customer = \_filteredCustomers[index];
return \_buildCustomerCard(customer, isSmallScreen);
},
),
);
}

Widget \_buildCustomerCard(Customer customer, bool isSmallScreen) {
return Card(
elevation: 1,
margin: const EdgeInsets.only(bottom: 12),
shape: RoundedRectangleBorder(
borderRadius: BorderRadius.circular(12),
),
child: InkWell(
onTap: () => \_showCustomerDetails(customer),
borderRadius: BorderRadius.circular(12),
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
// Header Row
Row(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
// Customer Avatar
Container(
width: 44,
height: 44,
decoration: BoxDecoration(
color: const Color(0xFF10B981).withOpacity(0.1),
borderRadius: BorderRadius.circular(10),
),
child: Icon(
Icons.person,
color: const Color(0xFF10B981),
size: 20,
),
),
const SizedBox(width: 12),

                  // Customer Info
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Row(
                          children: [
                            Expanded(
                              child: Text(
                                customer.name,
                                style: const TextStyle(
                                  fontSize: 16,
                                  fontWeight: FontWeight.w600,
                                  color: Color(0xFF1E293B),
                                ),
                                maxLines: 1,
                                overflow: TextOverflow.ellipsis,
                              ),
                            ),
                            // Status Badges
                            if (customer.isOverdue)
                              _buildStatusBadge('OVERDUE', Colors.red),
                            if (customer.currentBalance > 0 &&
                                !customer.isOverdue)
                              _buildStatusBadge('BALANCE', Colors.blue),
                          ],
                        ),
                        const SizedBox(height: 4),

                        // Contact Info
                        if (customer.phone != null) ...[
                          Row(
                            children: [
                              Icon(Icons.phone,
                                  size: 14, color: const Color(0xFF64748B)),
                              const SizedBox(width: 4),
                              Text(
                                customer.phone!,
                                style: const TextStyle(
                                  fontSize: 13,
                                  color: Color(0xFF64748B),
                                ),
                              ),
                            ],
                          ),
                          const SizedBox(height: 2),
                        ],

                        if (customer.email != null) ...[
                          Row(
                            children: [
                              Icon(Icons.email,
                                  size: 14, color: const Color(0xFF64748B)),
                              const SizedBox(width: 4),
                              Expanded(
                                child: Text(
                                  customer.email!,
                                  style: const TextStyle(
                                    fontSize: 13,
                                    color: Color(0xFF64748B),
                                  ),
                                  maxLines: 1,
                                  overflow: TextOverflow.ellipsis,
                                ),
                              ),
                            ],
                          ),
                        ],
                      ],
                    ),
                  ),
                ],
              ),

              const SizedBox(height: 12),

              // Balance and Actions
              Row(
                children: [
                  // Balance Info
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          customer.balanceStatus,
                          style: TextStyle(
                            fontSize: 14,
                            fontWeight: FontWeight.w600,
                            color: customer.currentBalance > 0
                                ? (customer.isOverdue
                                    ? Colors.red
                                    : const Color(0xFF2563EB))
                                : const Color(0xFF10B981),
                          ),
                        ),
                        if (customer.hasCredit)
                          Text(
                            'Credit Limit: ETB ${customer.creditLimit.toStringAsFixed(2)}',
                            style: const TextStyle(
                              fontSize: 12,
                              color: Color(0xFF64748B),
                            ),
                          ),
                      ],
                    ),
                  ),

                  // Action Buttons
                  if (customer.currentBalance > 0)
                    ElevatedButton(
                      onPressed: () => _showRecordPaymentDialog(customer),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: const Color(0xFF10B981),
                        foregroundColor: Colors.white,
                        padding: const EdgeInsets.symmetric(
                            horizontal: 16, vertical: 8),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(8),
                        ),
                        elevation: 0,
                      ),
                      child: const Text(
                        'Receive Payment',
                        style: TextStyle(
                          fontSize: 12,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ),
                ],
              ),
            ],
          ),
        ),
      ),
    );

}

Widget \_buildStatusBadge(String text, Color color) {
return Container(
padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
margin: const EdgeInsets.only(left: 8),
decoration: BoxDecoration(
color: color.withOpacity(0.1),
borderRadius: BorderRadius.circular(6),
border: Border.all(color: color.withOpacity(0.3)),
),
child: Text(
text,
style: TextStyle(
fontSize: 10,
fontWeight: FontWeight.bold,
color: color,
),
),
);
}
}

// Stat Item Helper Class
class \_StatItem {
final String label;
final String value;
final IconData icon;
final Color color;

\_StatItem(this.label, this.value, this.icon, this.color);
}

// Enhanced Add Customer Dialog
// Enhanced AddCustomerDialog in customer_management_screen.dart
class AddCustomerDialog extends ConsumerStatefulWidget {
final VoidCallback onCustomerAdded;

const AddCustomerDialog({super.key, required this.onCustomerAdded});

@override
ConsumerState<AddCustomerDialog> createState() => \_AddCustomerDialogState();
}

class \_AddCustomerDialogState extends ConsumerState<AddCustomerDialog> {
final \_formKey = GlobalKey<FormState>();
final \_nameController = TextEditingController();
final \_businessNameController = TextEditingController();
final \_phoneController = TextEditingController();
final \_whatsappController = TextEditingController();
final \_emailController = TextEditingController();
final \_tinController = TextEditingController();
final \_addressController = TextEditingController();
final \_creditLimitController = TextEditingController(text: '0.00');
final \_notesController = TextEditingController();

bool \_isSubmitting = false;
bool \_allowCredit = false;
String \_paymentTerms = '30'; // Default to 30 days
DateTime? \_customDueDate;

@override
void dispose() {
\_nameController.dispose();
\_businessNameController.dispose();
\_phoneController.dispose();
\_whatsappController.dispose();
\_emailController.dispose();
\_tinController.dispose();
\_addressController.dispose();
\_creditLimitController.dispose();
\_notesController.dispose();
super.dispose();
}

// Validation methods
String? \_validateRequired(String? value, String fieldName) {
if (value == null || value.trim().isEmpty) {
return '$fieldName is required';
}
return null;
}

String? \_validatePhone(String? value) {
if (value == null || value.trim().isEmpty) {
return 'Phone number is required';
}

    // Ethiopian phone format validation (starts with +251 or 09)
    final phoneRegex = RegExp(r'^(\+251|0)(9|7)\d{8}$');
    final digitsOnly = value.replaceAll(RegExp(r'[\s\-]'), '');

    if (!phoneRegex.hasMatch(digitsOnly)) {
      return 'Please enter a valid Ethiopian phone number';
    }
    return null;

}

String? _validateEmail(String? value) {
if (value != null && value.trim().isNotEmpty) {
final emailRegex =
RegExp(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$');
if (!emailRegex.hasMatch(value)) {
return 'Please enter a valid email address';
}
}
return null;
}

String? \_validateCreditLimit(String? value) {
if (\_allowCredit) {
if (value == null || value.trim().isEmpty) {
return 'Credit limit is required when credit is allowed';
}
final amount = double.tryParse(value);
if (amount == null || amount < 0) {
return 'Please enter a valid credit limit';
}
}
return null;
}

String? \_validateTIN(String? value) {
if (value != null && value.trim().isNotEmpty) {
// Basic TIN validation (Ethiopian TIN is typically 10 digits)
final tinRegex = RegExp(r'^\d{10}$');
final digitsOnly = value.replaceAll(RegExp(r'[^\d]'), '');

      if (digitsOnly.length != 10) {
        return 'TIN should be 10 digits';
      }
    }
    return null;

}

Future<void> \_addCustomer() async {
if (!\_formKey.currentState!.validate()) return;

    setState(() {
      _isSubmitting = true;
    });

    try {
      final repository = ref.read(customerRepositoryProvider);

      // Calculate due date based on payment terms
      DateTime? dueDate;
      if (_paymentTerms == 'custom' && _customDueDate != null) {
        dueDate = _customDueDate;
      } else if (_paymentTerms != 'none' && _paymentTerms != 'custom') {
        final days = int.tryParse(_paymentTerms) ?? 30;
        dueDate = DateTime.now().add(Duration(days: days));
      }

      final customer = Customer(
        localId: 'cust_${DateTime.now().millisecondsSinceEpoch}',
        name: _nameController.text.trim(),
        businessName: _businessNameController.text.trim().isNotEmpty
            ? _businessNameController.text.trim()
            : null,
        phone: _phoneController.text.trim(),
        whatsappNumber: _whatsappController.text.trim().isNotEmpty
            ? _whatsappController.text.trim()
            : null,
        email: _emailController.text.trim().isNotEmpty
            ? _emailController.text.trim()
            : null,
        address: _addressController.text.trim().isNotEmpty
            ? _addressController.text.trim()
            : null,
        tinNumber: _tinController.text.trim().isNotEmpty
            ? _tinController.text.trim()
            : null,
        creditLimit: _allowCredit
            ? (double.tryParse(_creditLimitController.text) ?? 0)
            : 0,
        currentBalance: 0, // Always start with zero balance
        dueDate: dueDate,
        allowCredit: _allowCredit,
        paymentTerms: _allowCredit ? _paymentTerms : null,
        notes: _notesController.text.trim().isNotEmpty
            ? _notesController.text.trim()
            : null,
        isActive: true,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      await repository.createCustomer(customer);

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: const Text('Customer added successfully!'),
            backgroundColor: const Color(0xFF10B981),
            behavior: SnackBarBehavior.floating,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(8),
            ),
          ),
        );

        Navigator.pop(context);
        widget.onCustomerAdded();
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error adding customer: $e'),
            backgroundColor: Colors.red,
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isSubmitting = false;
        });
      }
    }

}

Future<void> \_selectCustomDueDate() async {
final DateTime? picked = await showDatePicker(
context: context,
initialDate: DateTime.now().add(const Duration(days: 30)),
firstDate: DateTime.now(),
lastDate: DateTime(2100),
builder: (context, child) {
return Theme(
data: Theme.of(context).copyWith(
colorScheme: const ColorScheme.light(
primary: Color(0xFF10B981),
onPrimary: Colors.white,
surface: Colors.white,
onSurface: Colors.black,
),
),
child: child!,
);
},
);

    if (picked != null && mounted) {
      setState(() {
        _customDueDate = picked;
        _paymentTerms = 'custom';
      });
    }

}

@override
Widget build(BuildContext context) {
final screenSize = MediaQuery.of(context).size;
final isSmallScreen = screenSize.width < 600;

    return Dialog(
      insetPadding: EdgeInsets.all(isSmallScreen ? 8 : 20),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
      ),
      child: Container(
        constraints: BoxConstraints(
          maxHeight: screenSize.height * 0.9,
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Header that stays fixed
            Container(
              padding: EdgeInsets.all(isSmallScreen ? 16 : 20),
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius: const BorderRadius.only(
                  topLeft: Radius.circular(16),
                  topRight: Radius.circular(16),
                ),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.1),
                    blurRadius: 4,
                    offset: const Offset(0, 2),
                  ),
                ],
              ),
              child: Row(
                children: [
                  Container(
                    padding: const EdgeInsets.all(8),
                    decoration: BoxDecoration(
                      color: const Color(0xFF10B981).withOpacity(0.1),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: const Icon(
                      Icons.person_add_alt_1,
                      color: Color(0xFF10B981),
                      size: 24,
                    ),
                  ),
                  const SizedBox(width: 12),
                  const Expanded(
                    child: Text(
                      'Add New Customer',
                      style: TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                        color: Color(0xFF1E293B),
                      ),
                    ),
                  ),
                  IconButton(
                    icon: const Icon(Icons.close, size: 20),
                    onPressed: () => Navigator.pop(context),
                    color: const Color(0xFF64748B),
                  ),
                ],
              ),
            ),

            // Scrollable content area
            Expanded(
              child: SingleChildScrollView(
                padding: EdgeInsets.all(isSmallScreen ? 16 : 20),
                child: Form(
                  key: _formKey,
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const Text(
                        'Enter customer details for your POS system',
                        style: TextStyle(
                          color: Color(0xFF64748B),
                          fontSize: 14,
                        ),
                      ),
                      const SizedBox(height: 20),

                      // Your form fields here (same as before)
                      // Personal Information Section
                      _buildSectionHeader('Personal Information'),
                      _buildFormField(
                        label: 'Full Name *',
                        controller: _nameController,
                        validator: (value) =>
                            _validateRequired(value, 'Full name'),
                        icon: Icons.person_outline,
                        textCapitalization: TextCapitalization.words,
                      ),
                      const SizedBox(height: 12), // Reduced spacing

                      _buildFormField(
                        label: 'Business/Company Name',
                        controller: _businessNameController,
                        icon: Icons.business_outlined,
                        textCapitalization: TextCapitalization.words,
                      ),
                      const SizedBox(height: 16),

                      // Contact Information Section
                      _buildSectionHeader('Contact Information'),
                      _buildFormField(
                        label: 'Phone Number *',
                        controller: _phoneController,
                        validator: _validatePhone,
                        icon: Icons.phone_outlined,
                        keyboardType: TextInputType.phone,
                      ),
                      const SizedBox(height: 12),

                      _buildFormField(
                        label: 'WhatsApp Number',
                        controller: _whatsappController,
                        validator: (value) {
                          if (value != null && value.isNotEmpty) {
                            return _validatePhone(value);
                          }
                          return null;
                        },
                        icon: Icons.chat,
                        keyboardType: TextInputType.phone,
                      ),
                      const SizedBox(height: 12),

                      _buildFormField(
                        label: 'Email Address',
                        controller: _emailController,
                        validator: _validateEmail,
                        icon: Icons.email_outlined,
                        keyboardType: TextInputType.emailAddress,
                      ),
                      const SizedBox(height: 16),

                      // Business Information Section
                      _buildSectionHeader('Business Information'),
                      _buildFormField(
                        label: 'TIN/VAT Number',
                        controller: _tinController,
                        validator: _validateTIN,
                        icon: Icons.assignment_outlined,
                        keyboardType: TextInputType.number,
                      ),
                      const SizedBox(height: 12),

                      _buildFormField(
                        label: 'Address',
                        controller: _addressController,
                        icon: Icons.location_on_outlined,
                        maxLines: 2,
                        textCapitalization: TextCapitalization.sentences,
                      ),
                      const SizedBox(height: 16),

                      // Credit Control Section
                      _buildSectionHeader('Credit Control'),
                      _buildCreditControlSection(),
                      const SizedBox(height: 16),

                      // Additional Information Section
                      _buildSectionHeader('Additional Information'),
                      _buildFormField(
                        label: 'Notes',
                        controller: _notesController,
                        icon: Icons.notes_outlined,
                        maxLines: 3,
                        textCapitalization: TextCapitalization.sentences,
                      ),
                      const SizedBox(height: 24),

                      // Actions
                      _buildActionButtons(),
                    ],
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );

}

Widget \_buildCreditControlSection() {
return Container(
decoration: BoxDecoration(
color: Colors.grey.shade50,
borderRadius: BorderRadius.circular(12),
border: Border.all(color: Colors.grey.shade200),
),
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
// Allow Credit Switch
Row(
children: [
Container(
padding: const EdgeInsets.all(6),
decoration: BoxDecoration(
color: const Color(0xFF10B981).withOpacity(0.1),
borderRadius: BorderRadius.circular(6),
),
child: const Icon(
Icons.credit_card_outlined,
color: Color(0xFF10B981),
size: 20,
),
),
const SizedBox(width: 12),
const Expanded(
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
'Allow Credit',
style: TextStyle(
fontWeight: FontWeight.w500,
color: Color(0xFF1E293B),
),
),
SizedBox(height: 2),
Text(
'Enable credit facility for this customer',
style: TextStyle(
fontSize: 12,
color: Color(0xFF64748B),
),
),
],
),
),
Switch(
value: \_allowCredit,
onChanged: (value) {
setState(() {
\_allowCredit = value;
if (!value) {
\_paymentTerms = 'none';
\_customDueDate = null;
}
});
},
activeColor: const Color(0xFF10B981),
),
],
),

            // Credit Limit (only show if credit is allowed)
            if (_allowCredit) ...[
              const SizedBox(height: 16),
              _buildFormField(
                label: 'Credit Limit (ETB) *',
                controller: _creditLimitController,
                validator: _validateCreditLimit,
                icon: Icons.attach_money_outlined,
                keyboardType: TextInputType.number,
              ),
              const SizedBox(height: 16),

              // Payment Terms
              Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Container(
                        padding: const EdgeInsets.all(6),
                        decoration: BoxDecoration(
                          color: const Color(0xFF10B981).withOpacity(0.1),
                          borderRadius: BorderRadius.circular(6),
                        ),
                        child: const Icon(
                          Icons.calendar_today_outlined,
                          color: Color(0xFF10B981),
                          size: 20,
                        ),
                      ),
                      const SizedBox(width: 12),
                      const Expanded(
                        child: Text(
                          'Payment Terms',
                          style: TextStyle(
                            fontWeight: FontWeight.w500,
                            color: Color(0xFF1E293B),
                          ),
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 12),
                  DropdownButtonFormField<String>(
                    value: _paymentTerms,
                    decoration: const InputDecoration(
                      labelText: 'Select Payment Terms',
                      border: OutlineInputBorder(),
                      contentPadding: EdgeInsets.symmetric(
                        horizontal: 12,
                        vertical: 16,
                      ),
                    ),
                    items: const [
                      DropdownMenuItem(
                        value: 'none',
                        child: Text('No Credit Terms'),
                      ),
                      DropdownMenuItem(
                        value: '7',
                        child: Text('7 Days'),
                      ),
                      DropdownMenuItem(
                        value: '15',
                        child: Text('15 Days'),
                      ),
                      DropdownMenuItem(
                        value: '30',
                        child: Text('30 Days'),
                      ),
                      DropdownMenuItem(
                        value: 'custom',
                        child: Text('Custom Date'),
                      ),
                    ],
                    onChanged: (value) {
                      setState(() {
                        _paymentTerms = value ?? '30';
                        if (value != 'custom') {
                          _customDueDate = null;
                        }
                      });
                    },
                  ),
                  if (_paymentTerms == 'custom') ...[
                    const SizedBox(height: 12),
                    OutlinedButton.icon(
                      onPressed: _selectCustomDueDate,
                      icon: const Icon(Icons.calendar_today, size: 16),
                      label: Text(
                        _customDueDate != null
                            ? 'Due Date: ${_formatDate(_customDueDate!)}'
                            : 'Select Custom Due Date',
                      ),
                      style: OutlinedButton.styleFrom(
                        foregroundColor: const Color(0xFF10B981),
                        side: const BorderSide(color: Color(0xFF10B981)),
                        minimumSize: const Size(double.infinity, 48),
                      ),
                    ),
                  ],
                ],
              ),
            ],
          ],
        ),
      ),
    );

}

Widget \_buildActionButtons() {
return Row(
children: [
Expanded(
child: OutlinedButton(
onPressed: _isSubmitting ? null : () => Navigator.pop(context),
style: OutlinedButton.styleFrom(
foregroundColor: const Color(0xFF64748B),
side: const BorderSide(color: Color(0xFFE2E8F0)),
padding: const EdgeInsets.symmetric(vertical: 16),
shape: RoundedRectangleBorder(
borderRadius: BorderRadius.circular(12),
),
),
child: const Text(
'Cancel',
style: TextStyle(
fontWeight: FontWeight.w600,
),
),
),
),
const SizedBox(width: 12),
Expanded(
child: ElevatedButton(
onPressed: _isSubmitting ? null : _addCustomer,
style: ElevatedButton.styleFrom(
backgroundColor: const Color(0xFF10B981),
foregroundColor: Colors.white,
padding: const EdgeInsets.symmetric(vertical: 16),
shape: RoundedRectangleBorder(
borderRadius: BorderRadius.circular(12),
),
elevation: 0,
),
child: _isSubmitting
? const SizedBox(
width: 20,
height: 20,
child: CircularProgressIndicator(
strokeWidth: 2,
color: Colors.white,
),
)
: const Text(
'Add Customer',
style: TextStyle(
fontWeight: FontWeight.w600,
),
),
),
),
],
);
}

Widget \_buildSectionHeader(String title) {
return Padding(
padding: const EdgeInsets.only(bottom: 16, top: 8),
child: Text(
title,
style: const TextStyle(
fontSize: 16,
fontWeight: FontWeight.w600,
color: Color(0xFF1E293B),
),
),
);
}

Widget \_buildFormField({
required String label,
required TextEditingController controller,
String? Function(String?)? validator,
required IconData icon,
TextInputType? keyboardType,
int maxLines = 1,
TextCapitalization textCapitalization = TextCapitalization.none,
}) {
return TextFormField(
controller: controller,
keyboardType: keyboardType,
maxLines: maxLines,
validator: validator,
textCapitalization: textCapitalization,
decoration: InputDecoration(
labelText: label,
prefixIcon: Icon(icon, color: const Color(0xFF64748B)),
filled: true,
fillColor: const Color(0xFFF8FAFC),
border: OutlineInputBorder(
borderRadius: BorderRadius.circular(12),
borderSide: BorderSide.none,
),
enabledBorder: OutlineInputBorder(
borderRadius: BorderRadius.circular(12),
borderSide: const BorderSide(color: Color(0xFFE2E8F0)),
),
focusedBorder: OutlineInputBorder(
borderRadius: BorderRadius.circular(12),
borderSide: const BorderSide(
color: Color(0xFF10B981),
width: 2,
),
),
errorBorder: OutlineInputBorder(
borderRadius: BorderRadius.circular(12),
borderSide: const BorderSide(color: Colors.red),
),
focusedErrorBorder: OutlineInputBorder(
borderRadius: BorderRadius.circular(12),
borderSide: const BorderSide(
color: Colors.red,
width: 2,
),
),
contentPadding: EdgeInsets.symmetric(
horizontal: 16,
vertical: maxLines > 1 ? 16 : 18,
),
alignLabelWithHint: maxLines > 1,
),
);
}

String \_formatDate(DateTime date) {
return '${date.day}/${date.month}/${date.year}';
}
}
// Keep the existing RecordPaymentDialog and CustomerDetailScreen as they are
// but ensure they also use ref.read(customerRepositoryProvider)

class RecordPaymentDialog extends ConsumerStatefulWidget {
final Customer customer;
final VoidCallback onPaymentRecorded;

const RecordPaymentDialog({
super.key,
required this.customer,
required this.onPaymentRecorded,
});

@override
ConsumerState<RecordPaymentDialog> createState() =>
\_RecordPaymentDialogState();
}

class \_RecordPaymentDialogState extends ConsumerState<RecordPaymentDialog> {
final \_formKey = GlobalKey<FormState>();
final \_amountController = TextEditingController();
final \_notesController = TextEditingController();
bool \_isSubmitting = false;

@override
void initState() {
super.initState();
\_amountController.text = widget.customer.currentBalance.toStringAsFixed(2);
}

@override
void dispose() {
\_amountController.dispose();
\_notesController.dispose();
super.dispose();
}

void \_recordPayment() async {
if (\_formKey.currentState!.validate()) {
final amount = double.tryParse(\_amountController.text) ?? 0;

      if (amount <= 0) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Please enter a valid payment amount'),
            backgroundColor: Colors.orange,
          ),
        );
        return;
      }

      if (amount > widget.customer.currentBalance) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Payment amount cannot exceed outstanding balance'),
            backgroundColor: Colors.orange,
          ),
        );
        return;
      }

      setState(() {
        _isSubmitting = true;
      });

      try {
        final repository = ref.read(customerRepositoryProvider);
        final transaction = CreditTransaction(
          localId: 'payment_${DateTime.now().millisecondsSinceEpoch}',
          customerId: widget.customer.id!,
          customerName: widget.customer.name,
          type: 'payment',
          amount: amount,
          balanceBefore: widget.customer.currentBalance,
          balanceAfter: widget.customer.currentBalance - amount,
          notes:
              _notesController.text.isNotEmpty ? _notesController.text : null,
          createdAt: DateTime.now(),
        );

        await repository.addCreditTransaction(transaction);

        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content:
                Text('Payment of ETB ${amount.toStringAsFixed(2)} recorded!'),
            backgroundColor: const Color(0xFF10B981),
          ),
        );

        Navigator.pop(context);
        widget.onPaymentRecorded();
      } catch (e) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error recording payment: $e'),
            backgroundColor: Colors.red,
          ),
        );
      } finally {
        if (mounted) {
          setState(() {
            _isSubmitting = false;
          });
        }
      }
    }

}

@override
Widget build(BuildContext context) {
final isSmallScreen = MediaQuery.of(context).size.width < 600;

    return Dialog(
      insetPadding: EdgeInsets.all(isSmallScreen ? 16 : 24),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
      ),
      child: SingleChildScrollView(
        padding: EdgeInsets.all(isSmallScreen ? 20 : 24),
        child: Form(
          key: _formKey,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Container(
                    padding: const EdgeInsets.all(8),
                    decoration: BoxDecoration(
                      color: const Color(0xFF10B981).withOpacity(0.1),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: const Icon(Icons.payment,
                        color: Color(0xFF10B981), size: 24),
                  ),
                  const SizedBox(width: 12),
                  const Expanded(
                    child: Text(
                      'Record Payment',
                      style: TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                        color: Color(0xFF1E293B),
                      ),
                    ),
                  ),
                  IconButton(
                    icon: const Icon(Icons.close, size: 20),
                    onPressed: () => Navigator.pop(context),
                    color: const Color(0xFF64748B),
                  ),
                ],
              ),
              const SizedBox(height: 16),
              Text(
                'Customer: ${widget.customer.name}',
                style: const TextStyle(
                  fontWeight: FontWeight.w600,
                  fontSize: 16,
                ),
              ),
              const SizedBox(height: 8),
              Text(
                'Outstanding Balance: ETB ${widget.customer.currentBalance.toStringAsFixed(2)}',
                style: TextStyle(
                  color: widget.customer.isOverdue ? Colors.red : Colors.blue,
                  fontWeight: FontWeight.w600,
                ),
              ),
              const SizedBox(height: 24),
              TextFormField(
                controller: _amountController,
                decoration: const InputDecoration(
                  labelText: 'Payment Amount (ETB) *',
                  border: OutlineInputBorder(),
                  filled: true,
                ),
                keyboardType: TextInputType.number,
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Please enter payment amount';
                  }
                  if (double.tryParse(value) == null) {
                    return 'Please enter a valid amount';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _notesController,
                decoration: const InputDecoration(
                  labelText: 'Notes (Optional)',
                  border: OutlineInputBorder(),
                  filled: true,
                ),
                maxLines: 2,
              ),
              const SizedBox(height: 32),
              Row(
                children: [
                  Expanded(
                    child: OutlinedButton(
                      onPressed:
                          _isSubmitting ? null : () => Navigator.pop(context),
                      child: const Text('Cancel'),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: ElevatedButton(
                      onPressed: _isSubmitting ? null : _recordPayment,
                      style: ElevatedButton.styleFrom(
                        backgroundColor: const Color(0xFF10B981),
                        foregroundColor: Colors.white,
                      ),
                      child: _isSubmitting
                          ? const SizedBox(
                              width: 20,
                              height: 20,
                              child: CircularProgressIndicator(
                                strokeWidth: 2,
                                color: Colors.white,
                              ),
                            )
                          : const Text('Record Payment'),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );

}
}

// Add this to your customer_management_screen.dart or create separate files

// Add Credit Sale Dialog
class AddCreditSaleDialog extends ConsumerStatefulWidget {
final Customer customer;
final VoidCallback onSaleCompleted;

const AddCreditSaleDialog({
super.key,
required this.customer,
required this.onSaleCompleted,
});

@override
ConsumerState<AddCreditSaleDialog> createState() =>
\_AddCreditSaleDialogState();
}

class \_AddCreditSaleDialogState extends ConsumerState<AddCreditSaleDialog> {
final \_formKey = GlobalKey<FormState>();
final \_amountController = TextEditingController();
final \_referenceController = TextEditingController();
final \_notesController = TextEditingController();
final \_dueDaysController = TextEditingController(text: '30');

bool \_isSubmitting = false;

@override
void dispose() {
\_amountController.dispose();
\_referenceController.dispose();
\_notesController.dispose();
\_dueDaysController.dispose();
super.dispose();
}

Future<void> \_addCreditSale() async {
if (!\_formKey.currentState!.validate()) return;

    final amount = double.tryParse(_amountController.text) ?? 0;
    final dueDays = int.tryParse(_dueDaysController.text) ?? 30;

    if (amount <= 0) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Sale amount must be greater than zero'),
          backgroundColor: Colors.orange,
        ),
      );
      return;
    }

    setState(() {
      _isSubmitting = true;
    });

    try {
      final repository = ref.read(customerRepositoryProvider);
      final result = await repository.createCreditSale(
        customerId: widget.customer.id!,
        amount: amount,
        saleReference: _referenceController.text.isNotEmpty
            ? _referenceController.text
            : 'SALE-${DateTime.now().millisecondsSinceEpoch}',
        dueDays: dueDays,
        notes: _notesController.text.isNotEmpty ? _notesController.text : null,
      );

      if (result.success) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
                'Credit sale of ETB ${amount.toStringAsFixed(2)} added successfully!'),
            backgroundColor: const Color(0xFF10B981),
          ),
        );
        Navigator.pop(context);
        widget.onSaleCompleted();
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(result.error!),
            backgroundColor: Colors.red,
          ),
        );
      }
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error adding credit sale: $e'),
          backgroundColor: Colors.red,
        ),
      );
    } finally {
      if (mounted) {
        setState(() {
          _isSubmitting = false;
        });
      }
    }

}

@override
Widget build(BuildContext context) {
return Dialog(
insetPadding: const EdgeInsets.all(20),
shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
child: SingleChildScrollView(
padding: const EdgeInsets.all(24),
child: Form(
key: \_formKey,
child: Column(
mainAxisSize: MainAxisSize.min,
crossAxisAlignment: CrossAxisAlignment.start,
children: [
// Header
Row(
children: [
Container(
padding: const EdgeInsets.all(8),
decoration: BoxDecoration(
color: const Color(0xFF10B981).withOpacity(0.1),
borderRadius: BorderRadius.circular(8),
),
child: const Icon(Icons.add_shopping_cart,
color: Color(0xFF10B981), size: 24),
),
const SizedBox(width: 12),
const Expanded(
child: Text(
'Add Credit Sale',
style: TextStyle(
fontSize: 18,
fontWeight: FontWeight.bold,
),
),
),
IconButton(
icon: const Icon(Icons.close),
onPressed: () => Navigator.pop(context),
),
],
),
const SizedBox(height: 8),
Text(
'Customer: ${widget.customer.name}',
style: const TextStyle(color: Colors.grey),
),
const SizedBox(height: 4),
Text(
'Available Credit: ETB ${widget.customer.availableCredit.toStringAsFixed(2)}',
style: TextStyle(
color: widget.customer.availableCredit > 0
? Colors.green
: Colors.red,
fontWeight: FontWeight.w500,
),
),
const SizedBox(height: 24),

              // Form Fields
              TextFormField(
                controller: _amountController,
                decoration: const InputDecoration(
                  labelText: 'Sale Amount (ETB) *',
                  border: OutlineInputBorder(),
                  prefixText: 'ETB ',
                ),
                keyboardType: TextInputType.number,
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Please enter sale amount';
                  }
                  final amount = double.tryParse(value);
                  if (amount == null || amount <= 0) {
                    return 'Please enter a valid amount';
                  }
                  if (amount > widget.customer.availableCredit) {
                    return 'Amount exceeds available credit';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _referenceController,
                decoration: const InputDecoration(
                  labelText: 'Sale Reference',
                  border: OutlineInputBorder(),
                  hintText: 'Optional reference number',
                ),
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _dueDaysController,
                decoration: const InputDecoration(
                  labelText: 'Due Days',
                  border: OutlineInputBorder(),
                  hintText: '30',
                  suffixText: 'days',
                ),
                keyboardType: TextInputType.number,
                validator: (value) {
                  if (value != null && value.isNotEmpty) {
                    final days = int.tryParse(value);
                    if (days == null || days <= 0) {
                      return 'Please enter valid number of days';
                    }
                  }
                  return null;
                },
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _notesController,
                decoration: const InputDecoration(
                  labelText: 'Notes',
                  border: OutlineInputBorder(),
                  hintText: 'Optional notes about this sale',
                ),
                maxLines: 2,
              ),
              const SizedBox(height: 32),

              // Actions
              Row(
                children: [
                  Expanded(
                    child: OutlinedButton(
                      onPressed:
                          _isSubmitting ? null : () => Navigator.pop(context),
                      child: const Text('Cancel'),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: ElevatedButton(
                      onPressed: _isSubmitting ? null : _addCreditSale,
                      style: ElevatedButton.styleFrom(
                        backgroundColor: const Color(0xFF10B981),
                        foregroundColor: Colors.white,
                      ),
                      child: _isSubmitting
                          ? const SizedBox(
                              width: 20,
                              height: 20,
                              child: CircularProgressIndicator(
                                strokeWidth: 2,
                                color: Colors.white,
                              ),
                            )
                          : const Text('Add Sale'),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );

}
}

// Edit Credit Limit Dialog
class EditCreditLimitDialog extends ConsumerStatefulWidget {
final Customer customer;
final VoidCallback onCreditLimitUpdated;

const EditCreditLimitDialog({
super.key,
required this.customer,
required this.onCreditLimitUpdated,
});

@override
ConsumerState<EditCreditLimitDialog> createState() =>
\_EditCreditLimitDialogState();
}

class \_EditCreditLimitDialogState extends ConsumerState<EditCreditLimitDialog> {
final \_formKey = GlobalKey<FormState>();
final \_creditLimitController = TextEditingController();

bool \_isSubmitting = false;

@override
void initState() {
super.initState();
\_creditLimitController.text =
widget.customer.creditLimit.toStringAsFixed(2);
}

@override
void dispose() {
\_creditLimitController.dispose();
super.dispose();
}

Future<void> \_updateCreditLimit() async {
if (!\_formKey.currentState!.validate()) return;

    final newLimit = double.tryParse(_creditLimitController.text) ?? 0;

    if (newLimit < 0) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Credit limit cannot be negative'),
          backgroundColor: Colors.orange,
        ),
      );
      return;
    }

    setState(() {
      _isSubmitting = true;
    });

    try {
      final repository = ref.read(customerRepositoryProvider);
      final result = await repository.updateCreditLimit(
        customerId: widget.customer.id!,
        newCreditLimit: newLimit,
      );

      if (result.success) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
                'Credit limit updated to ETB ${newLimit.toStringAsFixed(2)}'),
            backgroundColor: const Color(0xFF10B981),
          ),
        );
        Navigator.pop(context);
        widget.onCreditLimitUpdated();
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(result.error!),
            backgroundColor: Colors.red,
          ),
        );
      }
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error updating credit limit: $e'),
          backgroundColor: Colors.red,
        ),
      );
    } finally {
      if (mounted) {
        setState(() {
          _isSubmitting = false;
        });
      }
    }

}

@override
Widget build(BuildContext context) {
return Dialog(
insetPadding: const EdgeInsets.all(20),
shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
child: SingleChildScrollView(
padding: const EdgeInsets.all(24),
child: Form(
key: \_formKey,
child: Column(
mainAxisSize: MainAxisSize.min,
crossAxisAlignment: CrossAxisAlignment.start,
children: [
// Header
Row(
children: [
Container(
padding: const EdgeInsets.all(8),
decoration: BoxDecoration(
color: const Color(0xFF10B981).withOpacity(0.1),
borderRadius: BorderRadius.circular(8),
),
child: const Icon(Icons.credit_card,
color: Color(0xFF10B981), size: 24),
),
const SizedBox(width: 12),
const Expanded(
child: Text(
'Edit Credit Limit',
style: TextStyle(
fontSize: 18,
fontWeight: FontWeight.bold,
),
),
),
IconButton(
icon: const Icon(Icons.close),
onPressed: () => Navigator.pop(context),
),
],
),
const SizedBox(height: 8),
Text(
'Customer: ${widget.customer.name}',
style: const TextStyle(color: Colors.grey),
),
const SizedBox(height: 4),
Text(
'Current Balance: ETB ${widget.customer.currentBalance.toStringAsFixed(2)}',
style: const TextStyle(
color: Colors.orange,
fontWeight: FontWeight.w500,
),
),
const SizedBox(height: 24),

              // Form Field
              TextFormField(
                controller: _creditLimitController,
                decoration: const InputDecoration(
                  labelText: 'New Credit Limit (ETB) *',
                  border: OutlineInputBorder(),
                  prefixText: 'ETB ',
                ),
                keyboardType: TextInputType.number,
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Please enter credit limit';
                  }
                  final limit = double.tryParse(value);
                  if (limit == null) {
                    return 'Please enter a valid amount';
                  }
                  if (limit < widget.customer.currentBalance) {
                    return 'Credit limit cannot be less than current balance';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 32),

              // Actions
              Row(
                children: [
                  Expanded(
                    child: OutlinedButton(
                      onPressed:
                          _isSubmitting ? null : () => Navigator.pop(context),
                      child: const Text('Cancel'),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: ElevatedButton(
                      onPressed: _isSubmitting ? null : _updateCreditLimit,
                      style: ElevatedButton.styleFrom(
                        backgroundColor: const Color(0xFF10B981),
                        foregroundColor: Colors.white,
                      ),
                      child: _isSubmitting
                          ? const SizedBox(
                              width: 20,
                              height: 20,
                              child: CircularProgressIndicator(
                                strokeWidth: 2,
                                color: Colors.white,
                              ),
                            )
                          : const Text('Update Limit'),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );

}
}

// CustomerDetailScreen remains the same but ensure it uses ref.read
class CustomerDetailScreen extends ConsumerStatefulWidget {
final Customer customer;

const CustomerDetailScreen({super.key, required this.customer});

@override
ConsumerState<CustomerDetailScreen> createState() =>
\_CustomerDetailScreenState();
}

class \_CustomerDetailScreenState extends ConsumerState<CustomerDetailScreen> {
List<CreditTransaction> \_transactions = [];
bool \_isLoading = true;

@override
void initState() {
super.initState();
\_loadTransactions();
}

Future<void> \_loadTransactions() async {
try {
final repository = ref.read(customerRepositoryProvider);
final transactions =
await repository.getCustomerTransactions(widget.customer.id!);

      setState(() {
        _transactions = transactions;
        _isLoading = false;
      });
    } catch (e) {
      setState(() {
        _isLoading = false;
      });
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error loading transactions: $e'),
          backgroundColor: Colors.red,
        ),
      );
    }

}

@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: Text(widget.customer.name),
backgroundColor: const Color(0xFF10B981),
foregroundColor: Colors.white,
),
body: SingleChildScrollView(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Card(
elevation: 2,
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
widget.customer.name,
style: const TextStyle(
fontSize: 20,
fontWeight: FontWeight.bold,
),
),
if (widget.customer.phone != null) ...[
const SizedBox(height: 8),
Text('Phone: ${widget.customer.phone}'),
],
if (widget.customer.email != null) ...[
const SizedBox(height: 4),
Text('Email: ${widget.customer.email}'),
],
if (widget.customer.address != null) ...[
const SizedBox(height: 4),
Text('Address: ${widget.customer.address}'),
],
const SizedBox(height: 16),
Row(
mainAxisAlignment: MainAxisAlignment.spaceBetween,
children: [
Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
const Text('Current Balance:'),
Text(
widget.customer.formattedBalance,
style: TextStyle(
fontSize: 18,
fontWeight: FontWeight.bold,
color: widget.customer.currentBalance > 0
? (widget.customer.isOverdue
? Colors.red
: Colors.blue)
: Colors.green,
),
),
],
),
if (widget.customer.hasCredit)
Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
const Text('Credit Limit:'),
Text(
'ETB ${widget.customer.creditLimit.toStringAsFixed(2)}',
style: const TextStyle(
fontSize: 16,
fontWeight: FontWeight.w600,
),
),
],
),
],
),
],
),
),
),
const SizedBox(height: 24),
const Text(
'Transaction History',
style: TextStyle(
fontSize: 18,
fontWeight: FontWeight.bold,
),
),
const SizedBox(height: 16),
\_isLoading
? const Center(
child: CircularProgressIndicator(color: Color(0xFF10B981)))
: \_transactions.isEmpty
? const Center(
child: Text(
'No transactions yet',
style: TextStyle(color: Colors.grey),
),
)
: Column(
children: \_transactions
.map((transaction) =>
\_buildTransactionCard(transaction))
.toList(),
),
],
),
),
);
}

Widget \_buildTransactionCard(CreditTransaction transaction) {
return Card(
margin: const EdgeInsets.only(bottom: 8),
child: Padding(
padding: const EdgeInsets.all(12),
child: Row(
mainAxisAlignment: MainAxisAlignment.spaceBetween,
children: [
Expanded(
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
transaction.description,
style: const TextStyle(
fontWeight: FontWeight.w500,
),
),
if (transaction.notes != null) ...[
const SizedBox(height: 4),
Text(
transaction.notes!,
style: const TextStyle(
fontSize: 12,
color: Colors.grey,
),
),
],
const SizedBox(height: 4),
Text(
'${transaction.createdAt.day}/${transaction.createdAt.month}/${transaction.createdAt.year} ${transaction.createdAt.hour}:${transaction.createdAt.minute.toString().padLeft(2, '0')}',
style: const TextStyle(
fontSize: 12,
color: Colors.grey,
),
),
],
),
),
Column(
crossAxisAlignment: CrossAxisAlignment.end,
children: [
Text(
transaction.formattedAmount,
style: TextStyle(
fontWeight: FontWeight.bold,
color: transaction.amountColor,
),
),
Text(
'Balance: ETB ${transaction.balanceAfter.toStringAsFixed(2)}',
style: const TextStyle(
fontSize: 12,
color: Colors.grey,
),
),
],
),
],
),
),
);
}
}

##

//lib/src/ui/screens/dashboard_screen.dart
// Dashboard screen displaying key metrics, charts, and recent activity.
// i need professionnal modern content rich dashboard screen code secure responsive and optimized for performance code here as per best practices and expert guidelines.
import 'package:andalus_smart_pos/src/data/models/customer.dart';
import 'package:andalus_smart_pos/src/providers/language_provider.dart';
import 'package:andalus_smart_pos/src/ui/screens/customer_management_screen.dart';
import 'package:andalus_smart_pos/src/ui/screens/product_management_screen.dart';
import 'package:andalus_smart_pos/src/utils/calendar_utils.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/data/repositories/sale_repository.dart';
import 'package:andalus_smart_pos/src/data/repositories/customer_repository.dart';
import 'package:andalus_smart_pos/src/data/repositories/product_repository.dart';
import 'package:andalus_smart_pos/src/data/models/sale.dart';
import 'package:andalus_smart_pos/src/data/models/product.dart';
import 'package:andalus_smart_pos/src/utils/date_utils.dart';
import 'package:andalus_smart_pos/src/utils/formatters.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
// import 'package:andalus_smart_pos/src/widgets/dashboard/stat_card.dart';
import 'package:andalus_smart_pos/src/widgets/dashboard/metric_card.dart';
import 'package:andalus_smart_pos/src/widgets/dashboard/recent_sales_list.dart';
import 'package:andalus_smart_pos/src/widgets/dashboard/stock_alert_widget.dart';
import 'package:andalus_smart_pos/src/widgets/dashboard/quick_actions_widget.dart';
// import 'package:andalus_smart_pos/src/widgets/dashboard/sales_charts.dart';
import 'package:andalus_smart_pos/src/widgets/common/loading_shimmer.dart';
// import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
import 'package:intl/intl.dart';
import 'package:andalus_smart_pos/src/widgets/dashboard/dashboard_cards.dart';
import 'package:andalus_smart_pos/src/widgets/dashboard/sales_analytics.dart';

class DashboardScreen extends ConsumerStatefulWidget {
const DashboardScreen({super.key});

@override
ConsumerState<DashboardScreen> createState() => \_DashboardScreenState();
}

class \_DashboardScreenState extends ConsumerState<DashboardScreen> {
late Future<DashboardData> \_dashboardData;
bool \_isRefreshing = false;

@override
void initState() {
super.initState();
\_dashboardData = \_loadDashboardData();
}

Future<DashboardData> \_loadDashboardData() async {
try {
final saleRepository = ref.read(saleRepositoryProvider);
final customerRepository = ref.read(customerRepositoryProvider);
final productRepository = ref.read(productRepositoryProvider);

      // Load all data
      final salesSummary = await saleRepository.getSalesSummary();
      final creditSummary = await customerRepository.getCreditSummary();
      final todaysSales = await saleRepository.getTodaysSales();
      final lowStockProducts = await productRepository.getLowStockProducts();
      final totalProducts = await productRepository.getAllProducts();

      // Get customers for total count
      List<Customer> allCustomers = [];
      try {
        allCustomers = await customerRepository.getAllCustomers();
      } catch (e) {
        print('Error loading customers: $e');
        allCustomers = [];
      }

      // Calculate metrics
      final totalRevenue = salesSummary.totalSales;
      final averageOrderValue = salesSummary.totalOrders > 0
          ? (totalRevenue / salesSummary.totalOrders).toDouble()
          : 0.0;

      final dailyGrowth = salesSummary.weeklySales > 0
          ? ((salesSummary.todaysSales / salesSummary.weeklySales * 100) - 100)
              .toDouble()
          : 0.0;

      return DashboardData(
        salesSummary: salesSummary,
        creditSummary: creditSummary,
        todaysSales: todaysSales,
        lowStockProducts: lowStockProducts,
        totalProducts: totalProducts,
        allCustomers: allCustomers,
        totalRevenue: totalRevenue,
        averageOrderValue: averageOrderValue,
        dailyGrowth: dailyGrowth,
        timestamp: DateTime.now(),
      );
    } catch (e) {
      print('Error loading dashboard data: $e');
      // Return fallback data without using createSample methods
      return _createFallbackDashboardData();
    }

}

// Add this fallback method
DashboardData \_createFallbackDashboardData() {
return DashboardData(
salesSummary: SalesSummary(
todaysSales: 1250.0,
todaysOrders: 8,
totalSales: 12500.0,
totalOrders: 45,
weeklySales: 3250.0,
weeklyOrders: 22,
),
creditSummary: {
'totalOutstanding': 2500.0,
'overdueAmount': 750.0,
'customersWithBalance': 3,
'overdueCustomers': 1,
'totalCustomers': 15,
},
todaysSales: [],
lowStockProducts: [],
totalProducts: [],
allCustomers: [],
totalRevenue: 12500.0,
averageOrderValue: 277.78,
dailyGrowth: 15.2,
timestamp: DateTime.now(),
);
}

Future<void> \_refreshData() async {
setState(() => \_isRefreshing = true);
await Future.delayed(const Duration(milliseconds: 800));
setState(() {
\_dashboardData = \_loadDashboardData();
\_isRefreshing = false;
});
}

// Add navigation methods:
void \_navigateToSalesDetails(BuildContext context) {
// Navigate to sales details screen
showDialog(
context: context,
builder: (context) => \_buildSalesDetailsDialog(context),
);
}

void \_navigateToProducts(BuildContext context) {
Navigator.push(
context,
MaterialPageRoute(builder: (context) => const ProductManagementScreen()),
);
}

void \_navigateToCustomers(BuildContext context) {
Navigator.push(
context,
MaterialPageRoute(builder: (context) => const CustomerManagementScreen()),
);
}

void \_navigateToRevenueAnalytics(BuildContext context) {
// Navigate to detailed revenue analytics
showDialog(
context: context,
builder: (context) => \_buildRevenueAnalyticsDialog(context),
);
}

// Helper methods

// Helper methods for dashboard
int \_getTotalItems(List<Product> products) {
if (products.isEmpty) return 0;
return products.fold(0, (sum, product) => sum + (product.stockQuantity));
}

int \_getTotalCategories(List<Product> products) {
if (products.isEmpty) return 0;
final categoryIds =
// ignore: unnecessary_null_comparison
products.map((p) => p.categoryId).where((id) => id != null).toSet();
return categoryIds.length;
}

int \_getTotalCustomers(DashboardData data) {
// Try to get from credit summary first, then fallback to actual list
final fromSummary = data.creditSummary['totalCustomers'] as int?;
if (fromSummary != null) return fromSummary;
return data.allCustomers.length;
}

int \_getCustomersWithBalance(DashboardData data) {
return data.creditSummary['customersWithBalance'] as int? ?? 0;
}

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);

    return Scaffold(
      backgroundColor: Theme.of(context).colorScheme.background,
      appBar: _buildAppBar(localizations),
      body: FutureBuilder<DashboardData>(
        future: _dashboardData,
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return DashboardShimmer(localizations: localizations);
          }

          if (snapshot.hasError) {
            return DashboardErrorWidget(
              error: snapshot.error.toString(),
              onRetry: _refreshData,
              localizations: localizations,
            );
          }

          final data = snapshot.data!;

          return RefreshIndicator.adaptive(
            onRefresh: _refreshData,
            color: Theme.of(context).colorScheme.primary,
            child: CustomScrollView(
              slivers: [
                SliverToBoxAdapter(
                  child: _buildLiveDateTimeWidget(context),
                ),
                // Header Stats Section
                _buildStatsSection(data, localizations),

                // Charts Section
                _buildChartsSection(data, localizations),

                // Content Section
                _buildContentSection(data, localizations),
              ],
            ),
          );
        },
      ),
    );

}

AppBar \_buildAppBar(AppLocalizations localizations) {
return AppBar(
title: Text(
localizations.dashboard,
style: TextStyle(
fontWeight: FontWeight.w700,
fontSize: 24,
color: Theme.of(context).colorScheme.onBackground,
),
),
backgroundColor: Colors.transparent,
foregroundColor: Theme.of(context).colorScheme.onBackground,
elevation: 0,
actions: [
IconButton(
icon: Icon(
_isRefreshing ? Icons.refresh : Icons.refresh_rounded,
color: _isRefreshing
? Theme.of(context).colorScheme.outline
: Theme.of(context).colorScheme.primary,
),
onPressed: _isRefreshing ? null : _refreshData,
tooltip: localizations.translate('refresh'),
),
],
);
}

SliverToBoxAdapter \_buildStatsSection(
DashboardData data, AppLocalizations localizations) {
return SliverToBoxAdapter(
child: Padding(
padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
child: LayoutBuilder(
builder: (context, constraints) {
final isTablet = constraints.maxWidth > 600;
final crossAxisCount = isTablet ? 4 : 2;

            // Use fixed height instead of aspect ratio for better control
            return GridView.count(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              crossAxisCount: crossAxisCount,
              crossAxisSpacing: 12,
              mainAxisSpacing: 12,
              childAspectRatio: 1.0, // Square cards
              padding: EdgeInsets.zero,
              children: [
                SizedBox(
                  height: 130, // Fixed height matching card height
                  child: SalesCard(
                    todaySales: data.salesSummary.todaysSales,
                    itemsSold: data.salesSummary.todaysOrders,
                    onTap: () => _navigateToSalesDetails(context),
                  ),
                ),
                SizedBox(
                  height: 130,
                  child: ProductsCard(
                    totalProducts: data.totalProducts.length,
                    totalItems: _getTotalItems(data.totalProducts),
                    totalCategories: _getTotalCategories(data.totalProducts),
                    onTap: () => _navigateToProducts(context),
                  ),
                ),
                SizedBox(
                  height: 130,
                  child: CustomersCard(
                    totalCustomers: _getTotalCustomers(data),
                    customersWithBalance: _getCustomersWithBalance(data),
                    onTap: () => _navigateToCustomers(context),
                  ),
                ),
                SizedBox(
                  height: 130,
                  child: RevenueCard(
                    totalRevenue: data.totalRevenue,
                    outstandingCredit:
                        data.creditSummary['totalOutstanding'] as double? ??
                            0.0,
                    onTap: () => _navigateToRevenueAnalytics(context),
                  ),
                ),
              ],
            );
          },
        ),
      ),
    );

}

SliverToBoxAdapter \_buildChartsSection(
DashboardData data, AppLocalizations localizations) {
return SliverToBoxAdapter(
child: Padding(
padding: const EdgeInsets.symmetric(
horizontal: 16, vertical: 12), // Reduced padding
child: SalesAnalyticsWidget(
salesData: data.salesSummary,
localizations: localizations,
),
),
);
}

Widget \_buildContentSection(
DashboardData data, AppLocalizations localizations) {
return SliverToBoxAdapter(
child: Padding(
padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 8),
child: Column(
children: [
_buildInsightsSection(data, localizations), // Add this line
const SizedBox(height: 20),
_buildPerformanceOverview(data, localizations),
const SizedBox(height: 20),
RecentSalesList(
sales: data.todaysSales,
localizations: localizations,
),
const SizedBox(height: 20),
StockAlertWidget(
products: data.lowStockProducts,
localizations: localizations,
),
const SizedBox(height: 20),
QuickActionsWidget(localizations: localizations),
],
),
),
);
}

Widget \_buildSalesDetailsDialog(BuildContext context) {
return AlertDialog(
title: const Text('Today\'s Sales Details'),
content: SizedBox(
width: double.maxFinite,
child: ListView(
shrinkWrap: true,
children: [
// Add sales details content here
const ListTile(
leading: Icon(Icons.shopping_cart, color: Color(0xFF10B981)),
title: Text('Total Sales'),
subtitle: Text('ETB 12,500.00'),
),
// Add more sales details...
],
),
),
actions: [
TextButton(
onPressed: () => Navigator.pop(context),
child: const Text('Close'),
),
],
);
}

// Revenue Analytics Dialog
Widget \_buildRevenueAnalyticsDialog(BuildContext context) {
return Dialog(
child: Container(
padding: const EdgeInsets.all(20),
width: MediaQuery.of(context).size.width _ 0.9,
height: MediaQuery.of(context).size.height _ 0.8,
child: Column(
children: [
const Text(
'Revenue Analytics',
style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
),
const SizedBox(height: 20),
Expanded(
child: SalesAnalyticsWidget(
salesData: SalesSummary(
todaysSales: 12500,
todaysOrders: 45,
totalSales: 125000,
totalOrders: 450,
weeklySales: 32500,
weeklyOrders: 120,
),
localizations: AppLocalizations.of(context),
),
),
],
),
),
);
}

Widget \_buildLiveDateTimeWidget(BuildContext context) {
return Consumer(
builder: (context, ref, child) {
final calendarType = ref.watch(calendarProvider);
final locale = ref.watch(languageProvider);
final currentTime = DateTime.now();

        return Container(
          margin: const EdgeInsets.symmetric(horizontal: 20, vertical: 8),
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            gradient: LinearGradient(
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
              colors: [
                Theme.of(context).colorScheme.primary.withOpacity(0.1),
                Theme.of(context).colorScheme.primary.withOpacity(0.05),
              ],
            ),
            borderRadius: BorderRadius.circular(16),
            border: Border.all(
              color: Theme.of(context).colorScheme.primary.withOpacity(0.2),
            ),
          ),
          child: Row(
            children: [
              Icon(
                Icons.calendar_today_rounded,
                color: Theme.of(context).colorScheme.primary,
                size: 24,
              ),
              const SizedBox(width: 12),
              // In your dashboard_screen.dart, update this section:
              // In your dashboard_screen.dart, update this section:
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      calendarType == CalendarType.ethiopian
                          ? '·ã®·ä¢·âµ·ãÆ·åµ·ã´ ·âÄ·äï ·âÜ·å†·à´'
                          : 'Ethiopian Calendar',
                      style: Theme.of(context).textTheme.labelSmall?.copyWith(
                            color: Theme.of(context).colorScheme.primary,
                            fontWeight: FontWeight.w600,
                          ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      AppDateUtils.getCurrentFullDate(
                          context, ref), // Add ref parameter
                      style: Theme.of(context).textTheme.titleMedium?.copyWith(
                            fontWeight: FontWeight.w700,
                            color: Theme.of(context).colorScheme.onBackground,
                          ),
                    ),
                    const SizedBox(height: 2),
                    Text(
                      DateFormat('HH:mm:ss').format(currentTime),
                      style: Theme.of(context).textTheme.bodySmall?.copyWith(
                            color: Theme.of(context).colorScheme.outline,
                            fontFamily: 'RobotoMono',
                          ),
                    ),
                  ],
                ),
              ),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                decoration: BoxDecoration(
                  color: Theme.of(context).colorScheme.primary.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Text(
                  calendarType == CalendarType.ethiopian ? 'ETH' : 'GREG',
                  style: Theme.of(context).textTheme.labelSmall?.copyWith(
                        color: Theme.of(context).colorScheme.primary,
                        fontWeight: FontWeight.w700,
                      ),
                ),
              ),
            ],
          ),
        );
      },
    );

}

Widget \_buildDesktopLayout(
DashboardData data, AppLocalizations localizations) {
return Row(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
// Main Content - 70%
Expanded(
flex: 7,
child: Column(
children: [
_buildPerformanceOverview(data, localizations),
const SizedBox(height: 20),
RecentSalesList(
sales: data.todaysSales,
localizations: localizations,
),
],
),
),
const SizedBox(width: 20),
// Sidebar - 30%
Expanded(
flex: 3,
child: Column(
children: [
StockAlertWidget(
products: data.lowStockProducts,
localizations: localizations,
),
const SizedBox(height: 20),
QuickActionsWidget(localizations: localizations),
],
),
),
],
);
}

Widget \_buildMobileLayout(
DashboardData data, AppLocalizations localizations) {
return Column(
children: [
_buildPerformanceOverview(data, localizations),
const SizedBox(height: 20),
RecentSalesList(
sales: data.todaysSales,
localizations: localizations,
),
const SizedBox(height: 20),
StockAlertWidget(
products: data.lowStockProducts,
localizations: localizations,
),
const SizedBox(height: 20),
QuickActionsWidget(localizations: localizations),
],
);
}

Widget \_buildPerformanceOverview(
DashboardData data, AppLocalizations localizations) {
return Card(
elevation: 0,
shape: RoundedRectangleBorder(
borderRadius: BorderRadius.circular(20),
side: BorderSide(
color: Theme.of(context).colorScheme.outline.withOpacity(0.1),
),
),
child: Padding(
padding: const EdgeInsets.all(24),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Row(
children: [
Container(
padding: const EdgeInsets.all(8),
decoration: BoxDecoration(
color:
Theme.of(context).colorScheme.primary.withOpacity(0.1),
borderRadius: BorderRadius.circular(12),
),
child: Icon(
Icons.analytics_rounded,
color: Theme.of(context).colorScheme.primary,
size: 24,
),
),
const SizedBox(width: 12),
Text(
localizations.translate('performanceOverview'),
style: Theme.of(context).textTheme.titleLarge?.copyWith(
fontWeight: FontWeight.w700,
),
),
],
),
const SizedBox(height: 24),
LayoutBuilder(
builder: (context, constraints) {
final isWide = constraints.maxWidth > 400;
return GridView.count(
shrinkWrap: true,
physics: const NeverScrollableScrollPhysics(),
crossAxisCount: isWide ? 2 : 1,
crossAxisSpacing: 16,
mainAxisSpacing: 16,
childAspectRatio: isWide ? 3.5 : 2.5,
children: [
MetricCard(
label: localizations.averageOrderValue,
value:
AppFormatters.formatCurrency(data.averageOrderValue),
icon: Icons.shopping_cart_rounded,
localizations: localizations,
),
MetricCard(
label: localizations.totalOrders,
value: data.salesSummary.totalOrders.toString(),
icon: Icons.receipt_long_rounded,
localizations: localizations,
),
MetricCard(
label: localizations.translate('customersWithBalance'),
value: (data.creditSummary['customersWithBalance'] ?? 0)
.toString(),
icon: Icons.people_alt_rounded,
localizations: localizations,
),
MetricCard(
label: localizations.translate('overdueAmount'),
value: AppFormatters.formatCurrency(
data.creditSummary['overdueAmount'] ?? 0),
icon: Icons.warning_amber_rounded,
isWarning: (data.creditSummary['overdueAmount'] ?? 0) > 0,
localizations: localizations,
),
],
);
},
),
],
),
),
);
}

Widget \_buildInsightsSection(
DashboardData data, AppLocalizations localizations) {
return PerformanceInsightsWidget(
data: data,
localizations: localizations,
);
}
}

// Dashboard Data Model
// In your dashboard_screen.dart - update DashboardData
class DashboardData {
final SalesSummary salesSummary;
final Map<String, dynamic> creditSummary;
final List<Sale> todaysSales;
final List<Product> lowStockProducts;
final List<Product> totalProducts;
final List<Customer> allCustomers;
final double totalRevenue;
final double averageOrderValue;
final double dailyGrowth;
final DateTime timestamp;

DashboardData({
required this.salesSummary,
required this.creditSummary,
required this.todaysSales,
required this.lowStockProducts,
required this.totalProducts,
required this.allCustomers,
required this.totalRevenue,
required this.averageOrderValue,
required this.dailyGrowth,
required this.timestamp,
});
}

class DashboardErrorWidget extends StatelessWidget {
final String error;
final VoidCallback onRetry;
final AppLocalizations localizations;

const DashboardErrorWidget({
super.key,
required this.error,
required this.onRetry,
required this.localizations,
});

@override
Widget build(BuildContext context) {
return Center(
child: Padding(
padding: const EdgeInsets.all(32),
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
Icon(
Icons.error_outline_rounded,
size: 64,
color: Theme.of(context).colorScheme.outline,
),
const SizedBox(height: 16),
Text(
localizations.translate('errorLoadingData'),
style: Theme.of(context).textTheme.titleLarge?.copyWith(
fontWeight: FontWeight.w700,
),
),
const SizedBox(height: 12),
Padding(
padding: const EdgeInsets.symmetric(horizontal: 20),
child: Text(
error.contains('DatabaseException')
? localizations.translate('databaseNeedsUpdate')
: error.length > 100
? '${error.substring(0, 100)}...'
: error,
style: Theme.of(context).textTheme.bodyMedium?.copyWith(
color: Theme.of(context).colorScheme.outline,
),
textAlign: TextAlign.center,
maxLines: 3,
),
),
const SizedBox(height: 24),
FilledButton.icon(
onPressed: onRetry,
icon: const Icon(Icons.refresh_rounded),
label: Text(localizations.translate('tryAgain')),
),
],
),
),
);
}
}

class DashboardShimmer extends StatelessWidget {
final AppLocalizations localizations;

const DashboardShimmer({
super.key,
required this.localizations,
});

@override
Widget build(BuildContext context) {
return CustomScrollView(
slivers: [
SliverToBoxAdapter(
child: Padding(
padding: const EdgeInsets.all(20),
child: GridView.count(
shrinkWrap: true,
physics: const NeverScrollableScrollPhysics(),
crossAxisCount: 2,
crossAxisSpacing: 16,
mainAxisSpacing: 16,
childAspectRatio: 1.4,
children: List.generate(
4,
(index) => const LoadingShimmer(
height: 100,
borderRadius: 16,
)),
),
),
),
const SliverToBoxAdapter(
child: Padding(
padding: EdgeInsets.symmetric(horizontal: 20),
child: LoadingShimmer(height: 200, borderRadius: 20),
),
),
SliverToBoxAdapter(
child: Padding(
padding: const EdgeInsets.all(20),
child: Column(
children: [
const LoadingShimmer(height: 180, borderRadius: 20),
const SizedBox(height: 20),
Row(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
const Expanded(
flex: 2,
child: LoadingShimmer(height: 300, borderRadius: 20),
),
const SizedBox(width: 20),
const Expanded(
flex: 1,
child: Column(
children: [
LoadingShimmer(height: 140, borderRadius: 20),
SizedBox(height: 20),
LoadingShimmer(height: 120, borderRadius: 20),
],
),
),
],
),
],
),
),
),
],
);
}
}
// Add these new widgets to your dashboard_screen.dart

class PerformanceInsightsWidget extends StatelessWidget {
final DashboardData data;
final AppLocalizations localizations;

const PerformanceInsightsWidget({
super.key,
required this.data,
required this.localizations,
});

@override
Widget build(BuildContext context) {
final insights = \_generateInsights(data);

    return Card(
      elevation: 0,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(20),
        side: BorderSide(
          color: Theme.of(context).colorScheme.outline.withOpacity(0.1),
        ),
      ),
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color:
                        Theme.of(context).colorScheme.primary.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Icon(
                    Icons.insights_rounded,
                    color: Theme.of(context).colorScheme.primary,
                    size: 24,
                  ),
                ),
                const SizedBox(width: 12),
                Text(
                  'Performance Insights',
                  style: Theme.of(context).textTheme.titleLarge?.copyWith(
                        fontWeight: FontWeight.w700,
                      ),
                ),
              ],
            ),
            const SizedBox(height: 20),
            ...insights.map((insight) => _buildInsightItem(context, insight)),
          ],
        ),
      ),
    );

}

List<DashboardInsight> \_generateInsights(DashboardData data) {
final insights = <DashboardInsight>[];

    // Sales performance insights
    if (data.salesSummary.todaysSales >
        data.salesSummary.weeklySales / 7 * 1.2) {
      insights.add(DashboardInsight(
        type: InsightType.positive,
        title: 'Strong Sales Today',
        message: 'Today\'s sales are 20% above daily average',
        icon: Icons.trending_up_rounded,
      ));
    }

    if (data.lowStockProducts.isNotEmpty) {
      insights.add(DashboardInsight(
        type: InsightType.warning,
        title: 'Low Stock Alert',
        message: '${data.lowStockProducts.length} products need restocking',
        icon: Icons.inventory_2_rounded,
      ));
    }

    // Credit risk insights
    final overdueAmount = data.creditSummary['overdueAmount'] as double? ?? 0.0;
    if (overdueAmount > 1000) {
      insights.add(DashboardInsight(
        type: InsightType.negative,
        title: 'High Overdue Amount',
        message: 'ETB ${overdueAmount.toStringAsFixed(0)} in overdue payments',
        icon: Icons.warning_amber_rounded,
      ));
    }

    // Customer growth insights
    final newCustomers = _getNewCustomersCount(data);
    if (newCustomers > 5) {
      insights.add(DashboardInsight(
        type: InsightType.positive,
        title: 'Customer Growth',
        message: '$newCustomers new customers this week',
        icon: Icons.people_alt_rounded,
      ));
    }

    return insights;

}

int \_getNewCustomersCount(DashboardData data) {
// Calculate new customers from the last 7 days
final weekAgo = DateTime.now().subtract(const Duration(days: 7));
return data.allCustomers
.where((customer) => customer.createdAt.isAfter(weekAgo))
.length;
}

Widget \_buildInsightItem(BuildContext context, DashboardInsight insight) {
Color backgroundColor;
Color textColor;

    switch (insight.type) {
      case InsightType.positive:
        backgroundColor = Colors.green.shade50;
        textColor = Colors.green.shade800;
        break;
      case InsightType.warning:
        backgroundColor = Colors.orange.shade50;
        textColor = Colors.orange.shade800;
        break;
      case InsightType.negative:
        backgroundColor = Colors.red.shade50;
        textColor = Colors.red.shade800;
        break;
    }

    return Container(
      margin: const EdgeInsets.only(bottom: 12),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: backgroundColor,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: textColor.withOpacity(0.2)),
      ),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.all(8),
            decoration: BoxDecoration(
              color: textColor.withOpacity(0.1),
              borderRadius: BorderRadius.circular(8),
            ),
            child: Icon(insight.icon, color: textColor, size: 20),
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  insight.title,
                  style: TextStyle(
                    fontWeight: FontWeight.w600,
                    color: textColor,
                    fontSize: 14,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  insight.message,
                  style: TextStyle(
                    color: textColor.withOpacity(0.8),
                    fontSize: 12,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );

}
}

class DashboardInsight {
final InsightType type;
final String title;
final String message;
final IconData icon;

const DashboardInsight({
required this.type,
required this.title,
required this.message,
required this.icon,
});
}

enum InsightType {
positive,
warning,
negative,
}

##

//lib/src/ui/screens/main_navigation.dart
// Main navigation screen with bottom navigation bar for primary app sections.
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
import 'dashboard_screen.dart';
import 'pos_screen.dart';
import 'sales_history_screen.dart';
import 'customer_management_screen.dart';
import 'product_management_screen.dart';
import 'category_management_screen.dart';
import 'package:andalus_smart_pos/src/ui/screens/account_settings_screen.dart';

class MainNavigation extends ConsumerStatefulWidget {
const MainNavigation({super.key});

@override
ConsumerState<MainNavigation> createState() => \_MainNavigationState();
}

class \_MainNavigationState extends ConsumerState<MainNavigation> {
int \_selectedIndex = 0;

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);

    final List<Widget> screens = [
      const DashboardScreen(),
      const PosScreen(),
      const SalesHistoryScreen(),
      const CustomerManagementScreen(),
      const ProductManagementScreen(),
      const CategoryManagementScreen(),
      const AccountSettingsScreen(), // Use the combined screen
    ];

    final List<BottomNavigationBarItem> navItems = [
      BottomNavigationBarItem(
        icon: const Icon(Icons.dashboard_outlined),
        activeIcon: const Icon(Icons.dashboard),
        label: localizations.dashboard,
      ),
      BottomNavigationBarItem(
        icon: const Icon(Icons.point_of_sale_outlined),
        activeIcon: const Icon(Icons.point_of_sale),
        label: localizations.pointOfSale,
      ),
      BottomNavigationBarItem(
        icon: const Icon(Icons.receipt_long_outlined),
        activeIcon: const Icon(Icons.receipt_long),
        label: localizations.salesHistory,
      ),
      BottomNavigationBarItem(
        icon: const Icon(Icons.people_outline),
        activeIcon: const Icon(Icons.people),
        label: localizations.customers,
      ),
      BottomNavigationBarItem(
        icon: const Icon(Icons.inventory_2_outlined),
        activeIcon: const Icon(Icons.inventory_2),
        label: localizations.products,
      ),
      BottomNavigationBarItem(
        icon: const Icon(Icons.category_outlined),
        activeIcon: const Icon(Icons.category),
        label: localizations.categories,
      ),
      BottomNavigationBarItem(
        icon: const Icon(Icons.settings_outlined),
        activeIcon: const Icon(Icons.settings),
        label: localizations.settings, // Now this shows both account & settings
      ),
    ];

    return Scaffold(
      body: screens[_selectedIndex],
      bottomNavigationBar: Container(
        decoration: BoxDecoration(
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.1),
              blurRadius: 8,
              offset: const Offset(0, -2),
            ),
          ],
        ),
        child: BottomNavigationBar(
          currentIndex: _selectedIndex,
          onTap: (index) => setState(() => _selectedIndex = index),
          type: BottomNavigationBarType.fixed,
          backgroundColor: Colors.white,
          selectedItemColor: const Color(0xFF10B981),
          unselectedItemColor: Colors.grey.shade600,
          selectedLabelStyle: const TextStyle(fontWeight: FontWeight.w500),
          unselectedLabelStyle: const TextStyle(fontWeight: FontWeight.w400),
          items: navItems,
        ),
      ),
    );

}
}

##

// lib/src/ui/screens/pos_screen.dart
// Point of Sale (POS) screen for managing product sales, cart, and printing receipts.
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/data/models/customer.dart';
import 'package:andalus_smart_pos/src/data/models/product.dart';
import 'package:andalus_smart_pos/src/data/models/sale.dart';
import 'package:andalus_smart_pos/src/data/models/sale_item.dart';
import 'package:andalus_smart_pos/src/data/models/cart_item.dart';
import 'package:andalus_smart_pos/src/data/repositories/customer_repository.dart';
import 'package:andalus_smart_pos/src/data/repositories/product_repository.dart';
import 'package:andalus_smart_pos/src/data/repositories/sale_repository.dart';
import 'package:andalus_smart_pos/src/providers/cart_provider.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
import 'package:andalus_smart_pos/src/utils/formatters.dart';
import 'package:andalus_smart_pos/src/utils/print_service.dart';
import 'package:andalus_smart_pos/src/ui/screens/printer_connection_screen.dart';
import 'package:andalus_smart_pos/src/widgets/common/custom_card.dart';
import 'package:andalus_smart_pos/src/widgets/common/loading_shimmer.dart';

class PosScreen extends ConsumerStatefulWidget {
const PosScreen({super.key});

@override
ConsumerState<PosScreen> createState() => \_PosScreenState();
}

class \_PosScreenState extends ConsumerState<PosScreen> {
final TextEditingController \_searchController = TextEditingController();
final TextEditingController \_barcodeController = TextEditingController();
final FocusNode \_barcodeFocusNode = FocusNode();

List<Product> \_filteredProducts = [];
List<Product> \_allProducts = [];
bool \_isLoading = true;
String \_selectedCategory = 'all';
bool \_isPrinting = false;

@override
void initState() {
super.initState();
\_loadProducts();
\_searchController.addListener(\_onSearchChanged);
}

@override
void dispose() {
\_searchController.dispose();
\_barcodeController.dispose();
\_barcodeFocusNode.dispose();
super.dispose();
}

Future<void> \_loadProducts() async {
setState(() => \_isLoading = true);
try {
final repository = ref.read(productRepositoryProvider);
final products = await repository.getAllProducts();
setState(() {
\_allProducts = products;
\_filteredProducts = products;
\_isLoading = false;
});
} catch (e) {
setState(() => \_isLoading = false);
if (mounted) {
\_showErrorSnackBar('Error loading products: $e');
}
}
}

void \_onSearchChanged() {
final query = \_searchController.text.toLowerCase();
setState(() {
\_filteredProducts = \_allProducts.where((product) {
final matchesSearch = product.name.toLowerCase().contains(query) ||
product.nameAm.toLowerCase().contains(query) ||
product.barcode.toLowerCase().contains(query);
final matchesCategory = \_selectedCategory == 'all' ||
product.categoryId == \_selectedCategory;
return matchesSearch && matchesCategory;
}).toList();
});
}

void \_addToCart(Product product) {
if (product.stockQuantity <= 0) {
\_showWarningSnackBar('${product.name} is out of stock');
return;
}

    ref.read(cartProvider.notifier).addProduct(
          productId: product.id!,
          productName: product.name,
          unitPrice: product.price,
        );

    _showSuccessSnackBar('Added ${product.name} to cart');

}

void \_scanBarcode() {
if (\_barcodeController.text.isNotEmpty) {
final barcode = \_barcodeController.text.trim();
final product = \_allProducts.firstWhere(
(p) => p.barcode == barcode,
orElse: () => Product(
id: -1,
productId: '',
name: '',
nameAm: '',
price: 0,
stockQuantity: 0,
barcode: '',
categoryId: '',
createdAt: DateTime.now(),
updatedAt: DateTime.now(),
),
);

      if (product.id != -1) {
        _addToCart(product);
        _barcodeController.clear();
        _barcodeFocusNode.requestFocus();
      } else {
        _showWarningSnackBar('Product not found');
      }
    }

}

// Snackbar helpers
void \_showSuccessSnackBar(String message) {
ScaffoldMessenger.of(context).showSnackBar(
SnackBar(
content: Row(
children: [
const Icon(Icons.check_circle, color: Colors.white, size: 20),
const SizedBox(width: 8),
Expanded(child: Text(message)),
],
),
backgroundColor: Theme.of(context).colorScheme.primary,
behavior: SnackBarBehavior.floating,
shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
duration: const Duration(seconds: 2),
),
);
}

void \_showErrorSnackBar(String message) {
ScaffoldMessenger.of(context).showSnackBar(
SnackBar(
content: Text(message),
backgroundColor: Theme.of(context).colorScheme.error,
),
);
}

void \_showWarningSnackBar(String message) {
ScaffoldMessenger.of(context).showSnackBar(
SnackBar(
content: Text(message),
backgroundColor: Colors.orange,
),
);
}

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);
final cart = ref.watch(cartProvider);
final cartNotifier = ref.read(cartProvider.notifier);

    return Scaffold(
      backgroundColor: theme.colorScheme.background,
      body: Column(
        children: [
          // FIXED: Proper Header with Search
          _buildHeaderSection(localizations, theme),

          // Main Content Area
          Expanded(
            child: Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Products Section
                Expanded(
                  flex: 3,
                  child: _buildProductsSection(localizations, theme),
                ),

                // Cart Panel
                _buildCartPanel(cart, cartNotifier, localizations, theme),
              ],
            ),
          ),
        ],
      ),
    );

}

// FIXED: Header with proper search box
Widget \_buildHeaderSection(AppLocalizations localizations, ThemeData theme) {
return Container(
decoration: BoxDecoration(
color: theme.colorScheme.primary,
boxShadow: [
BoxShadow(
color: theme.colorScheme.shadow.withOpacity(0.1),
blurRadius: 8,
offset: const Offset(0, 2),
),
],
),
child: SafeArea(
bottom: false,
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
children: [
// Title and Printer Status Row
Row(
children: [
// Title
Expanded(
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
localizations.pointOfSale,
style: theme.textTheme.titleLarge?.copyWith(
color: theme.colorScheme.onPrimary,
fontWeight: FontWeight.bold,
),
),
const SizedBox(height: 2),
Text(
localizations.searchProducts,
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.onPrimary.withOpacity(0.8),
),
),
],
),
),

                  // Printer Status
                  _buildPrinterStatus(theme, localizations),

                  const SizedBox(width: 12),

                  // Cart Badge
                  _buildCartBadge(localizations, theme),
                ],
              ),

              const SizedBox(height: 16),

              // FIXED: Search Box - Now properly visible
              _buildSearchBox(localizations, theme),
            ],
          ),
        ),
      ),
    );

}

// FIXED: Search Box Widget
Widget _buildSearchBox(AppLocalizations localizations, ThemeData theme) {
return Row(
children: [
// Search Field
Expanded(
child: Container(
decoration: BoxDecoration(
color: theme.colorScheme.onPrimary.withOpacity(0.1),
borderRadius: BorderRadius.circular(12),
),
child: TextField(
controller: \_searchController,
decoration: InputDecoration(
hintText: localizations.searchProducts,
hintStyle: TextStyle(
color: theme.colorScheme.onPrimary.withOpacity(0.7),
),
prefixIcon: Icon(
Icons.search,
color: theme.colorScheme.onPrimary.withOpacity(0.7),
),
border: InputBorder.none,
contentPadding: const EdgeInsets.symmetric(horizontal: 16),
),
style: TextStyle(
color: theme.colorScheme.onPrimary,
),
onChanged: (_) => \_onSearchChanged(),
),
),
),

        const SizedBox(width: 12),

        // Print Button - Now visible in header
        Tooltip(
          message: PrintService.isConnected
              ? 'Print Test Receipt'
              : 'Connect Printer First',
          child: Container(
            decoration: BoxDecoration(
              color: theme.colorScheme.onPrimary.withOpacity(0.2),
              borderRadius: BorderRadius.circular(12),
            ),
            child: IconButton(
              icon: Icon(
                Icons.print,
                color: PrintService.isConnected
                    ? theme.colorScheme.onPrimary
                    : theme.colorScheme.onPrimary.withOpacity(0.5),
              ),
              onPressed: PrintService.isConnected
                  ? _testPrint
                  : _navigateToPrinterConnection,
            ),
          ),
        ),
      ],
    );

}

Widget \_buildPrinterStatus(ThemeData theme, AppLocalizations localizations) {
return Tooltip(
message: PrintService.isConnected
? '${localizations.translate("connectedTo")} ${PrintService.connectedDeviceName}'
: localizations.translate("noPrinterConnected"),
child: Container(
padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
decoration: BoxDecoration(
color: theme.colorScheme.onPrimary.withOpacity(0.2),
borderRadius: BorderRadius.circular(20),
),
child: Row(
mainAxisSize: MainAxisSize.min,
children: [
Icon(
PrintService.isConnected ? Icons.print : Icons.print_disabled,
size: 16,
color: PrintService.isConnected
? theme.colorScheme.onPrimary
: Colors.amber[300],
),
const SizedBox(width: 6),
Text(
PrintService.isConnected ? 'Connected' : 'No Printer',
style: theme.textTheme.bodySmall?.copyWith(
color: theme.colorScheme.onPrimary,
fontWeight: FontWeight.w500,
),
),
],
),
),
);
}

Widget \_buildCartBadge(AppLocalizations localizations, ThemeData theme) {
final cart = ref.watch(cartProvider);
return Badge(
label: Text(
ref.read(cartProvider.notifier).totalItems.toString(),
style: TextStyle(
fontSize: 10,
color: theme.colorScheme.primary,
fontWeight: FontWeight.bold,
),
),
isLabelVisible: cart.isNotEmpty,
backgroundColor: theme.colorScheme.onPrimary,
child: IconButton(
icon: Icon(Icons.shopping_cart, color: theme.colorScheme.onPrimary),
onPressed: () {},
tooltip: localizations.shoppingCart,
),
);
}

Widget \_buildProductsSection(
AppLocalizations localizations, ThemeData theme) {
return Column(
children: [
// Barcode Scanner Section
\_buildBarcodeSection(localizations, theme),

        // Products Grid
        Expanded(
          child: _isLoading
              ? _buildProductsShimmer()
              : _filteredProducts.isEmpty
                  ? _buildEmptyProducts(localizations, theme)
                  : _buildProductsGrid(localizations, theme),
        ),
      ],
    );

}

Widget _buildBarcodeSection(AppLocalizations localizations, ThemeData theme) {
return CustomCard(
margin: const EdgeInsets.all(16),
padding: const EdgeInsets.all(16),
child: Row(
children: [
// Barcode Input
Expanded(
child: TextField(
controller: \_barcodeController,
focusNode: \_barcodeFocusNode,
decoration: InputDecoration(
labelText: localizations.translate('scanBarcode'),
border: OutlineInputBorder(
borderRadius: BorderRadius.circular(12),
),
contentPadding: const EdgeInsets.symmetric(horizontal: 16),
),
onSubmitted: (_) => \_scanBarcode(),
),
),
const SizedBox(width: 12),
// Scan Button
SizedBox(
height: 56,
child: ElevatedButton.icon(
onPressed: \_scanBarcode,
icon: const Icon(Icons.qr_code_scanner, size: 20),
label: Text(localizations.translate('scan')),
style: ElevatedButton.styleFrom(
backgroundColor: theme.colorScheme.primary,
foregroundColor: theme.colorScheme.onPrimary,
shape: RoundedRectangleBorder(
borderRadius: BorderRadius.circular(12),
),
),
),
),
],
),
);
}

Widget \_buildProductsShimmer() {
return GridView.builder(
padding: const EdgeInsets.all(16),
gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
crossAxisCount: 3,
crossAxisSpacing: 12,
mainAxisSpacing: 12,
childAspectRatio: 0.85,
),
itemCount: 9,
itemBuilder: (context, index) => const LoadingShimmer(
height: 120,
borderRadius: 12,
),
);
}

Widget \_buildProductsGrid(AppLocalizations localizations, ThemeData theme) {
return Column(
children: [
// Category Filter
SizedBox(
height: 60,
child: \_buildCategoryFilter(theme),
),

        // Products Grid
        Expanded(
          child: GridView.builder(
            padding: const EdgeInsets.all(16),
            gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: 3,
              crossAxisSpacing: 12,
              mainAxisSpacing: 12,
              childAspectRatio: 0.85,
            ),
            itemCount: _filteredProducts.length,
            itemBuilder: (context, index) {
              final product = _filteredProducts[index];
              return _ProductCard(
                product: product,
                onTap: () => _addToCart(product),
              );
            },
          ),
        ),
      ],
    );

}

Widget \_buildCategoryFilter(ThemeData theme) {
return ListView.separated(
padding: const EdgeInsets.symmetric(horizontal: 16),
scrollDirection: Axis.horizontal,
itemCount: \_getCategories().length,
separatorBuilder: (context, index) => const SizedBox(width: 8),
itemBuilder: (context, index) {
final category = \_getCategories()[index];
final isSelected = \_selectedCategory == category;
return FilterChip(
label: Text(category == 'all' ? 'All Categories' : category),
selected: isSelected,
onSelected: (selected) {
setState(() => \_selectedCategory = category);
\_onSearchChanged();
},
backgroundColor: theme.colorScheme.surface,
selectedColor: theme.colorScheme.primary.withOpacity(0.1),
checkmarkColor: theme.colorScheme.primary,
labelStyle: TextStyle(
color: isSelected
? theme.colorScheme.primary
: theme.colorScheme.onSurface,
),
side: BorderSide(
color: isSelected
? theme.colorScheme.primary
: theme.colorScheme.outline.withOpacity(0.3),
),
);
},
);
}

Widget \_buildCartPanel(List<CartItem> cart, CartNotifier cartNotifier,
AppLocalizations localizations, ThemeData theme) {
return Container(
width: 400,
margin: const EdgeInsets.all(16),
child: CustomCard(
margin: EdgeInsets.zero,
padding: EdgeInsets.zero,
child: Column(
children: [
// Cart Header
Container(
padding: const EdgeInsets.all(20),
decoration: BoxDecoration(
color: theme.colorScheme.primary,
borderRadius: const BorderRadius.only(
topLeft: Radius.circular(16),
topRight: Radius.circular(16),
),
),
child: Row(
children: [
Icon(Icons.shopping_cart, color: theme.colorScheme.onPrimary),
const SizedBox(width: 12),
Text(
localizations.translate('orderSummary'),
style: TextStyle(
color: theme.colorScheme.onPrimary,
fontSize: 18,
fontWeight: FontWeight.bold,
),
),
const Spacer(),
if (cart.isNotEmpty)
TextButton(
onPressed: () => cartNotifier.clearCart(),
style: TextButton.styleFrom(
foregroundColor: theme.colorScheme.onPrimary,
),
child: Text(localizations.clearAll),
),
Badge(
label: Text(cartNotifier.totalItems.toString()),
backgroundColor: theme.colorScheme.onPrimary,
textColor: theme.colorScheme.primary,
),
],
),
),

            // Cart Items
            Expanded(
              child: cart.isEmpty
                  ? _EmptyCart(localizations: localizations)
                  : ListView.builder(
                      padding: const EdgeInsets.all(16),
                      itemCount: cart.length,
                      itemBuilder: (context, index) {
                        final item = cart[index];
                        return _CartItem(
                          item: item,
                          onQuantityChanged: (newQuantity) {
                            if (newQuantity > 0) {
                              cartNotifier.updateQuantity(
                                  item.productId, newQuantity);
                            } else {
                              cartNotifier.removeProduct(item.productId);
                            }
                          },
                          onRemove: () {
                            cartNotifier.removeProduct(item.productId);
                          },
                        );
                      },
                    ),
            ),

            // Cart Footer with Print Button
            Container(
              padding: const EdgeInsets.all(20),
              decoration: BoxDecoration(
                border: Border(
                  top: BorderSide(
                      color: theme.colorScheme.outline.withOpacity(0.2)),
                ),
              ),
              child: Column(
                children: [
                  // Totals
                  _buildTotalRow(localizations.translate('subtotal'),
                      cartNotifier.subtotalAmount, theme),
                  const SizedBox(height: 8),
                  _buildTotalRow(localizations.translate('total'),
                      cartNotifier.totalAmount, theme,
                      isTotal: true),

                  const SizedBox(height: 16),

                  // FIXED: Action Buttons with Print Option
                  _buildActionButtons(cartNotifier, localizations, theme),
                ],
              ),
            ),
          ],
        ),
      ),
    );

}

Widget \_buildTotalRow(String label, double amount, ThemeData theme,
{bool isTotal = false}) {
return Row(
mainAxisAlignment: MainAxisAlignment.spaceBetween,
children: [
Text(
label,
style: TextStyle(
fontSize: isTotal ? 16 : 14,
fontWeight: isTotal ? FontWeight.bold : FontWeight.normal,
color: isTotal
? theme.colorScheme.onSurface
: theme.colorScheme.onSurface.withOpacity(0.7),
),
),
Text(
AppFormatters.formatCurrency(amount),
style: TextStyle(
fontSize: isTotal ? 18 : 14,
fontWeight: FontWeight.bold,
color: isTotal
? theme.colorScheme.primary
: theme.colorScheme.onSurface,
),
),
],
);
}

// FIXED: Action Buttons with Print Option
Widget \_buildActionButtons(CartNotifier cartNotifier,
AppLocalizations localizations, ThemeData theme) {
final cart = ref.watch(cartProvider);

    return Column(
      children: [
        // Complete Sale Button
        SizedBox(
          width: double.infinity,
          height: 56,
          child: ElevatedButton(
            onPressed: _completeSale,
            style: ElevatedButton.styleFrom(
              backgroundColor: theme.colorScheme.primary,
              foregroundColor: theme.colorScheme.onPrimary,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(12),
              ),
              elevation: 2,
            ),
            child: _isPrinting
                ? SizedBox(
                    height: 20,
                    width: 20,
                    child: CircularProgressIndicator(
                      strokeWidth: 2,
                      valueColor: AlwaysStoppedAnimation<Color>(
                          theme.colorScheme.onPrimary),
                    ),
                  )
                : Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      const Icon(Icons.payment, size: 20),
                      const SizedBox(width: 8),
                      Text(
                        localizations.completeSale,
                        style: const TextStyle(
                          fontSize: 16,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ],
                  ),
          ),
        ),

        if (cart.isNotEmpty) ...[
          const SizedBox(height: 8),

          // Print and Clear Buttons Row
          Row(
            children: [
              // Print Button
              Expanded(
                child: OutlinedButton.icon(
                  onPressed: _isPrinting ? null : _testPrint,
                  icon: Icon(
                    Icons.print,
                    size: 18,
                    color: theme.colorScheme.primary,
                  ),
                  label: Text(
                    localizations.translate('testPrint'),
                    style: TextStyle(color: theme.colorScheme.primary),
                  ),
                  style: OutlinedButton.styleFrom(
                    side: BorderSide(color: theme.colorScheme.primary),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                  ),
                ),
              ),
              const SizedBox(width: 8),

              // Clear Cart Button
              Expanded(
                child: OutlinedButton.icon(
                  onPressed: () => cartNotifier.clearCart(),
                  icon: Icon(
                    Icons.clear_all,
                    size: 18,
                    color: theme.colorScheme.error,
                  ),
                  label: Text(
                    localizations.clearAll,
                    style: TextStyle(color: theme.colorScheme.error),
                  ),
                  style: OutlinedButton.styleFrom(
                    side: BorderSide(color: theme.colorScheme.error),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                  ),
                ),
              ),
            ],
          ),
        ],
      ],
    );

}

Widget \_buildEmptyProducts(AppLocalizations localizations, ThemeData theme) {
return Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
Icon(Icons.search_off, size: 64, color: theme.colorScheme.outline),
const SizedBox(height: 16),
Text(
localizations.noProductsFound,
style: theme.textTheme.titleMedium?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.6),
),
),
const SizedBox(height: 8),
Text(
localizations.translate('tryAdjustingSearch'),
style: TextStyle(color: theme.colorScheme.outline),
textAlign: TextAlign.center,
),
],
),
);
}

List<String> \_getCategories() {
final categories = \_allProducts.map((p) => p.categoryId).toSet().toList();
return ['all', ...categories];
}

// Payment and Printing Methods
Future<void> \_completeSale() async {
final cart = ref.read(cartProvider);
if (cart.isEmpty) {
\_showWarningSnackBar('Please add products to cart first');
return;
}

    // Check stock availability
    for (final item in cart) {
      final product = _allProducts.firstWhere(
        (p) => p.id == item.productId,
        orElse: () => Product(
          id: -1,
          productId: '',
          name: '',
          nameAm: '',
          price: 0,
          stockQuantity: 0,
          barcode: '',
          categoryId: '',
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        ),
      );

      if (product.id != -1 && product.stockQuantity < item.quantity) {
        _showErrorSnackBar(
            'Insufficient stock for ${product.name}. Available: ${product.stockQuantity}');
        return;
      }
    }

    final total = ref.read(cartProvider.notifier).totalAmount;
    await _showPaymentMethodDialog(total, cart);

}

Future<void> \_showPaymentMethodDialog(
double total, List<CartItem> cart) async {
final result = await showDialog<Map<String, dynamic>>(
context: context,
builder: (context) => PaymentMethodDialog(total: total),
);

    if (result != null && mounted) {
      final paymentMethod = result['method'] as String;
      final customer = result['customer'] as Customer?;
      await _processSale(total, cart, paymentMethod, customer);
    }

}

Future<void> \_processSale(double total, List<CartItem> cart,
String paymentMethod, Customer? customer) async {
setState(() => \_isPrinting = true);

    try {
      final saleRepository = ref.read(saleRepositoryProvider);
      final customerRepository = ref.read(customerRepositoryProvider);

      // Create sale object
      final sale = Sale(
        localId: 'sale_${DateTime.now().millisecondsSinceEpoch}',
        totalAmount: total,
        finalAmount: total,
        paymentMethod: paymentMethod,
        paymentStatus: 'completed',
        userId: 1,
        shopId: 1,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
        saleId: 'SALE${DateTime.now().millisecondsSinceEpoch}',
      );

      // Convert cart items to sale items
      final saleItems = cart
          .map((cartItem) => SaleItem(
                saleId: "0",
                productId: cartItem.productId as String,
                productName: cartItem.productName,
                quantity: cartItem.quantity,
                unitPrice: cartItem.unitPrice,
                totalPrice: cartItem.totalPrice,
                createdAt: DateTime.now(),
              ))
          .toList();

      // Handle credit sale
      if (paymentMethod == 'credit' && customer != null) {
        final creditResult = await customerRepository.createCreditSale(
          customerId: customer.id!,
          amount: total,
          saleReference: sale.saleId,
          notes: 'POS Sale - ${cart.length} items',
        );

        if (!creditResult.success) {
          _showErrorSnackBar('Credit sale failed: ${creditResult.error}');
          return;
        }
      }

      // Save sale to database
      final saleId = await saleRepository.createSale(sale, saleItems);

      // Update product stock
      final productRepo = ref.read(productRepositoryProvider);
      for (final item in cart) {
        final product = _allProducts.firstWhere((p) => p.id == item.productId);
        if (product.trackInventory) {
          await productRepo.updateStockQuantity(
              item.productId, product.stockQuantity - item.quantity);
        }
      }

      // Print receipt
      final printSuccess = await _printReceipt(
        saleId: saleId,
        cart: cart,
        total: total,
        paymentMethod: paymentMethod,
        customer: customer,
      );

      // Clear cart
      ref.read(cartProvider.notifier).clearCart();

      // Show success message
      if (mounted) {
        _showSuccessSnackBar(
          'Sale #$saleId completed successfully!${printSuccess ? '' : ' (Receipt not printed)'}',
        );
      }

      // Reload products
      _loadProducts();
    } catch (e) {
      if (mounted) {
        _showErrorSnackBar('Error processing sale: $e');
      }
    } finally {
      setState(() => _isPrinting = false);
    }

}

Future<bool> \_printReceipt({
required int saleId,
required List<CartItem> cart,
required double total,
required String paymentMethod,
required Customer? customer,
}) async {
try {
final printItems = cart
.map((item) => {
'name': item.productName,
'quantity': item.quantity,
'price': item.unitPrice,
'total': item.totalPrice,
})
.toList();

      final subtotal = ref.read(cartProvider.notifier).subtotalAmount;

// In your pos*screen.dart, update the printReceipt call:
final success = await PrintService.printReceipt(
context: context,
shopName: 'Andalus Smart POS',
shopNameAm: '·ä†·äï·ã≥·àâ·àµ ·àµ·àõ·à≠·âµ ·çñ·àµ',
address: 'Addis Ababa, Ethiopia',
phone: '+251911223344',
tinNumber: '1234567890',
receiptNumber: 'REC-$saleId',
        dateTime: DateTime.now(),
        items: printItems,
        subtotal: subtotal,
        tax: 0.0,
        discount: 0.0,
        total: total,
        paymentMethod: paymentMethod,
        telebirrRef: paymentMethod == 'telebirr'
            ? 'TEL${DateTime.now().millisecondsSinceEpoch}'
: null,
sale: Sale(
saleId: 'REC-$saleId',
localId: 'local*${DateTime.now().millisecondsSinceEpoch}',
totalAmount: total,
finalAmount: total,
paymentMethod: paymentMethod,
userId: 1,
shopId: 1,
createdAt: DateTime.now(),
), // Add sale parameter
businessInfo: {
'shopName': 'Andalus Smart POS',
'shopNameAm': '·ä†·äï·ã≥·àâ·àµ ·àµ·àõ·à≠·âµ ·çñ·àµ',
'address': 'Addis Ababa, Ethiopia',
'phone': '+251911223344',
'tinNumber': '1234567890',
}, // Add businessInfo parameter
);
return success;
} catch (e) {
print('Printing error: $e');
return false;
}
}

void \_testPrint() async {
final cart = ref.read(cartProvider);
if (cart.isEmpty) {
\_showWarningSnackBar('Please add products to cart first');
return;
}

    setState(() => _isPrinting = true);
    final success = await _printReceipt(
      saleId: 999,
      cart: cart,
      total: ref.read(cartProvider.notifier).totalAmount,
      paymentMethod: 'cash',
      customer: null,
    );

    setState(() => _isPrinting = false);

    if (!success && mounted) {
      _showPrinterConnectionDialog();
    }

}

void \_showPrinterConnectionDialog() {
showDialog(
context: context,
builder: (context) => AlertDialog(
title: const Text('Printer Not Connected'),
content: const Text('Please connect a printer to print receipts.'),
actions: [
TextButton(
onPressed: () => Navigator.pop(context),
child: const Text('Cancel'),
),
TextButton(
onPressed: () {
Navigator.pop(context);
_navigateToPrinterConnection();
},
child: const Text('Connect Printer'),
),
],
),
);
}

void \_navigateToPrinterConnection() {
Navigator.push(
context,
MaterialPageRoute(builder: (context) => const PrinterConnectionScreen()),
);
}
}

// Keep the existing \_ProductCard, \_CartItem, \_EmptyCart, and PaymentMethodDialog classes...
// [The rest of the widget classes remain the same as in the previous implementation]
// Modern Product Card
class \_ProductCard extends StatelessWidget {
final Product product;
final VoidCallback onTap;

const \_ProductCard({
required this.product,
required this.onTap,
});

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);

    return CustomCard(
      margin: EdgeInsets.zero,
      onTap: onTap,
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Stock Status Badge
          if (product.isLowStock || product.isOutOfStock)
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
              decoration: BoxDecoration(
                color: product.isOutOfStock
                    ? theme.colorScheme.errorContainer
                    : Colors.orange.shade50,
                borderRadius: BorderRadius.circular(6),
                border: Border.all(
                  color: product.isOutOfStock
                      ? theme.colorScheme.error
                      : Colors.orange.shade200,
                ),
              ),
              child: Text(
                product.isOutOfStock ? 'OUT OF STOCK' : 'LOW STOCK',
                style: TextStyle(
                  fontSize: 10,
                  fontWeight: FontWeight.bold,
                  color: product.isOutOfStock
                      ? theme.colorScheme.error
                      : Colors.orange.shade700,
                ),
              ),
            )
          else
            const SizedBox(height: 20),

          const Spacer(),

          // Product Name
          Text(
            product.name,
            style: theme.textTheme.bodyLarge?.copyWith(
              fontWeight: FontWeight.w600,
              height: 1.2,
            ),
            maxLines: 2,
            overflow: TextOverflow.ellipsis,
          ),

          const SizedBox(height: 8),

          // Price
          Text(
            AppFormatters.formatCurrency(product.price),
            style: theme.textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.bold,
              color: theme.colorScheme.primary,
            ),
          ),

          const SizedBox(height: 4),

          // Stock and Barcode
          Text(
            'Stock: ${product.stockQuantity}',
            style: theme.textTheme.bodySmall?.copyWith(
              color: product.isLowStock
                  ? Colors.orange.shade700
                  : theme.colorScheme.onSurface.withOpacity(0.6),
              fontWeight:
                  product.isLowStock ? FontWeight.w600 : FontWeight.normal,
            ),
          ),
          if (product.barcode.isNotEmpty) ...[
            const SizedBox(height: 2),
            Text(
              'Barcode: ${product.barcode}',
              style: theme.textTheme.bodySmall?.copyWith(
                color: theme.colorScheme.onSurface.withOpacity(0.5),
              ),
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
            ),
          ],
        ],
      ),
    );

}
}

// Modern Cart Item
class \_CartItem extends StatelessWidget {
final CartItem item;
final Function(int) onQuantityChanged;
final VoidCallback onRemove;

const \_CartItem({
required this.item,
required this.onQuantityChanged,
required this.onRemove,
});

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);

    return Container(
      margin: const EdgeInsets.only(bottom: 12),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.colorScheme.surfaceVariant.withOpacity(0.3),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: theme.colorScheme.outline.withOpacity(0.2)),
      ),
      child: Row(
        children: [
          // Product Info
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  item.productName,
                  style: theme.textTheme.bodyLarge?.copyWith(
                    fontWeight: FontWeight.w600,
                  ),
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                ),
                const SizedBox(height: 4),
                Text(
                  AppFormatters.formatCurrency(item.unitPrice),
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: theme.colorScheme.onSurface.withOpacity(0.6),
                  ),
                ),
              ],
            ),
          ),

          const SizedBox(width: 12),

          // Quantity Controls
          Container(
            decoration: BoxDecoration(
              color: theme.colorScheme.surface,
              borderRadius: BorderRadius.circular(8),
              border:
                  Border.all(color: theme.colorScheme.outline.withOpacity(0.3)),
            ),
            child: Row(
              children: [
                IconButton(
                  icon: Icon(Icons.remove,
                      size: 18, color: theme.colorScheme.primary),
                  onPressed: () => onQuantityChanged(item.quantity - 1),
                  padding: const EdgeInsets.all(4),
                  constraints: const BoxConstraints(
                    minWidth: 32,
                    minHeight: 32,
                  ),
                ),
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 12),
                  child: Text(
                    item.quantity.toString(),
                    style: theme.textTheme.bodyLarge?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
                IconButton(
                  icon: Icon(Icons.add,
                      size: 18, color: theme.colorScheme.primary),
                  onPressed: () => onQuantityChanged(item.quantity + 1),
                  padding: const EdgeInsets.all(4),
                  constraints: const BoxConstraints(
                    minWidth: 32,
                    minHeight: 32,
                  ),
                ),
              ],
            ),
          ),

          const SizedBox(width: 12),

          // Total and Remove
          Column(
            crossAxisAlignment: CrossAxisAlignment.end,
            children: [
              Text(
                AppFormatters.formatCurrency(item.totalPrice),
                style: theme.textTheme.bodyLarge?.copyWith(
                  fontWeight: FontWeight.bold,
                  color: theme.colorScheme.primary,
                ),
              ),
              const SizedBox(height: 8),
              IconButton(
                icon: Icon(
                  Icons.delete_outline,
                  size: 18,
                  color: theme.colorScheme.onSurface.withOpacity(0.5),
                ),
                onPressed: onRemove,
                padding: EdgeInsets.zero,
                constraints: const BoxConstraints(
                  minWidth: 24,
                  minHeight: 24,
                ),
              ),
            ],
          ),
        ],
      ),
    );

}
}

// Empty Cart State
class \_EmptyCart extends StatelessWidget {
final AppLocalizations localizations;

const \_EmptyCart({required this.localizations});

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);

    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.shopping_cart_outlined,
            size: 64,
            color: theme.colorScheme.outline,
          ),
          const SizedBox(height: 16),
          Text(
            localizations.yourCartEmpty,
            style: theme.textTheme.titleMedium?.copyWith(
              color: theme.colorScheme.onSurface.withOpacity(0.6),
            ),
          ),
          const SizedBox(height: 8),
          Text(
            localizations.addProductsGetStarted,
            style: theme.textTheme.bodyMedium?.copyWith(
              color: theme.colorScheme.outline,
            ),
          ),
        ],
      ),
    );

}
}

// Payment Method Dialog
class PaymentMethodDialog extends ConsumerStatefulWidget {
final double total;

const PaymentMethodDialog({super.key, required this.total});

@override
ConsumerState<PaymentMethodDialog> createState() =>
\_PaymentMethodDialogState();
}

class \_PaymentMethodDialogState extends ConsumerState<PaymentMethodDialog> {
String \_selectedMethod = 'cash';
Customer? \_selectedCustomer;

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);
final localizations = AppLocalizations.of(context);

    return Dialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              localizations.selectPaymentMethod,
              style: theme.textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              '${localizations.totalAmount}: ${AppFormatters.formatCurrency(widget.total)}',
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.w600,
                color: theme.colorScheme.primary,
              ),
            ),
            const SizedBox(height: 24),

            // Payment Methods
            _buildPaymentMethodOption(
                'cash', localizations.cash, Icons.money, theme),
            _buildPaymentMethodOption(
                'telebirr', localizations.telebirr, Icons.qr_code, theme),
            _buildPaymentMethodOption(
                'card', localizations.card, Icons.credit_card, theme),
            _buildPaymentMethodOption(
                'credit', localizations.credit, Icons.credit_score, theme),

            // Customer Selection for Credit
            if (_selectedMethod == 'credit') ...[
              const SizedBox(height: 16),
              _buildCustomerSelector(localizations, theme),
            ],

            const SizedBox(height: 24),
            Row(
              children: [
                Expanded(
                  child: OutlinedButton(
                    onPressed: () => Navigator.pop(context),
                    child: Text(localizations.cancel),
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: ElevatedButton(
                    onPressed: _canProceed
                        ? () => Navigator.pop(context, {
                              'method': _selectedMethod,
                              'customer': _selectedCustomer,
                            })
                        : null,
                    style: ElevatedButton.styleFrom(
                      backgroundColor: theme.colorScheme.primary,
                      foregroundColor: theme.colorScheme.onPrimary,
                    ),
                    child: Text(localizations.confirm),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );

}

Widget \_buildPaymentMethodOption(
String value, String label, IconData icon, ThemeData theme) {
return RadioListTile<String>(
value: value,
groupValue: \_selectedMethod,
onChanged: (newValue) => setState(() => \_selectedMethod = newValue!),
title: Row(
children: [
Icon(icon, size: 20, color: theme.colorScheme.primary),
const SizedBox(width: 8),
Text(
label,
style: theme.textTheme.bodyLarge
?.copyWith(fontWeight: FontWeight.w500),
),
],
),
);
}

Widget \_buildCustomerSelector(
AppLocalizations localizations, ThemeData theme) {
return FutureBuilder<List<Customer>>(
future: ref
.read(customerRepositoryProvider)
.getAllCustomers(activeOnly: true),
builder: (context, snapshot) {
if (snapshot.connectionState == ConnectionState.waiting) {
return const Center(child: CircularProgressIndicator());
}

        if (snapshot.hasError || snapshot.data == null) {
          return Text(
            'Error loading customers',
            style: TextStyle(color: theme.colorScheme.error),
          );
        }

        final customers = snapshot.data!.where((c) => c.allowCredit).toList();

        if (customers.isEmpty) {
          return Text(
            'No credit customers found',
            style: TextStyle(color: Colors.orange.shade700),
          );
        }

        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              '${localizations.selectCustomer} *',
              style: theme.textTheme.bodyLarge
                  ?.copyWith(fontWeight: FontWeight.w500),
            ),
            const SizedBox(height: 8),
            DropdownButtonFormField<Customer>(
              value: _selectedCustomer,
              decoration: InputDecoration(
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(12),
                ),
                contentPadding: const EdgeInsets.symmetric(horizontal: 12),
              ),
              items: customers.map((customer) {
                return DropdownMenuItem(
                  value: customer,
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(customer.name),
                      Text(
                        '${localizations.creditAvailable}: ${AppFormatters.formatCurrency(customer.availableCredit)}',
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: theme.colorScheme.onSurface.withOpacity(0.6),
                        ),
                      ),
                    ],
                  ),
                );
              }).toList(),
              onChanged: (customer) =>
                  setState(() => _selectedCustomer = customer),
              validator: (value) {
                if (_selectedMethod == 'credit' && value == null) {
                  return 'Please select a customer';
                }
                return null;
              },
            ),
          ],
        );
      },
    );

}

bool get \_canProceed {
if (\_selectedMethod == 'credit') {
return \_selectedCustomer != null &&
\_selectedCustomer!.availableCredit >= widget.total;
}
return true;
}
}

##

// lib/src/ui/screens/printer_connection_screen.dart
// Screen for connecting to and managing Bluetooth printers.
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_blue_plus/flutter_blue_plus.dart';
import '../../utils/print_service.dart';
import '../../localization/app_localizations.dart';

class PrinterConnectionScreen extends ConsumerStatefulWidget {
const PrinterConnectionScreen({super.key});

@override
ConsumerState<PrinterConnectionScreen> createState() =>
\_PrinterConnectionScreenState();
}

class \_PrinterConnectionScreenState
extends ConsumerState<PrinterConnectionScreen> {
bool \_isScanning = false;

@override
void initState() {
super.initState();
\_startScan();
}

void \_startScan() {
setState(() {
\_isScanning = true;
});
PrintService.startScan();
}

void \_stopScan() {
setState(() {
\_isScanning = false;
});
PrintService.stopScan();
}

Future<void> \_connectToPrinter(BluetoothDevice device) async {
final success = await PrintService.connectToPrinter(device);
if (success && mounted) {
ScaffoldMessenger.of(context).showSnackBar(
SnackBar(
content: Text('Connected to ${device.localName}'),
backgroundColor: Colors.green,
),
);
} else if (mounted) {
ScaffoldMessenger.of(context).showSnackBar(
SnackBar(
content: Text('Failed to connect to ${device.localName}'),
backgroundColor: Colors.red,
),
);
}
}

Future<void> \_disconnectPrinter() async {
await PrintService.disconnect();
if (mounted) {
setState(() {});
}
}

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);

    return Scaffold(
      appBar: AppBar(
        title: Text(localizations.translate('printerSettings')),
        actions: [
          if (_isScanning)
            IconButton(
              icon: const Icon(Icons.stop),
              onPressed: _stopScan,
              tooltip: 'Stop Scan',
            )
          else
            IconButton(
              icon: const Icon(Icons.refresh),
              onPressed: _startScan,
              tooltip: 'Scan for Printers',
            ),
        ],
      ),
      body: Column(
        children: [
          // Connection Status
          ListTile(
            leading: Icon(
              PrintService.isConnected ? Icons.print : Icons.print_disabled,
              color: PrintService.isConnected ? Colors.green : Colors.red,
            ),
            title: Text(PrintService.isConnected
                ? 'Connected to ${PrintService.connectedDeviceName}'
                : 'No printer connected'),
            trailing: PrintService.isConnected
                ? IconButton(
                    icon: const Icon(Icons.link_off),
                    onPressed: _disconnectPrinter,
                    tooltip: 'Disconnect',
                  )
                : null,
          ),
          const Divider(),

          // Available Printers
          Expanded(
            child: StreamBuilder<List<BluetoothDevice>>(
              stream: PrintService.scanForPrinters(),
              builder: (context, snapshot) {
                if (!snapshot.hasData || snapshot.data!.isEmpty) {
                  return Center(
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Icon(Icons.search, size: 64, color: Colors.grey[400]),
                        const SizedBox(height: 16),
                        Text(
                          _isScanning
                              ? 'Searching for printers...'
                              : 'No printers found',
                          style: Theme.of(context).textTheme.bodyLarge,
                        ),
                      ],
                    ),
                  );
                }

                final printers = snapshot.data!;
                return ListView.builder(
                  itemCount: printers.length,
                  itemBuilder: (context, index) {
                    final device = printers[index];
                    return ListTile(
                      leading: const Icon(Icons.print),
                      title: Text(device.localName.isEmpty
                          ? 'Unknown Device'
                          : device.localName),
                      subtitle: Text(device.remoteId.toString()),
                      trailing: IconButton(
                        icon: const Icon(Icons.link),
                        onPressed: () => _connectToPrinter(device),
                        tooltip: 'Connect',
                      ),
                    );
                  },
                );
              },
            ),
          ),
        ],
      ),
    );

}

@override
void dispose() {
PrintService.stopScan();
super.dispose();
}
}

##

// lib/src/ui/screens/product_management_screen.dart
// Screen for managing products including viewing, searching, adding, editing, and filtering.
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/data/models/product.dart';
import 'package:andalus_smart_pos/src/data/repositories/product_repository.dart';
import 'package:andalus_smart_pos/src/data/repositories/category_repository.dart';
import 'package:andalus_smart_pos/src/data/models/category.dart';
import 'package:andalus_smart_pos/src/widgets/common/custom_card.dart';
import 'package:andalus_smart_pos/src/widgets/common/loading_shimmer.dart';
import 'package:andalus_smart_pos/src/utils/formatters.dart';

class ProductManagementScreen extends ConsumerStatefulWidget {
const ProductManagementScreen({super.key});

@override
ConsumerState<ProductManagementScreen> createState() =>
\_ProductManagementScreenState();
}

class \_ProductManagementScreenState
extends ConsumerState<ProductManagementScreen> {
final TextEditingController \_searchController = TextEditingController();
List<Product> \_filteredProducts = [];
List<Product> \_allProducts = [];
List<ProductCategory> \_categories = [];
bool \_isLoading = true;
String \_filter = 'all'; // 'all', 'active', 'low_stock', 'out_of_stock'
String \_categoryFilter = 'all';

@override
void initState() {
super.initState();
\_loadData();
\_searchController.addListener(\_onSearchChanged);
}

@override
void dispose() {
\_searchController.dispose();
super.dispose();
}

Future<void> \_loadData() async {
setState(() => \_isLoading = true);
try {
final productRepo = ref.read(productRepositoryProvider);
final categoryRepo = ref.read(categoryRepositoryProvider);

      // Load both products and categories concurrently
      final results = await Future.wait([
        productRepo.getAllProducts(),
        categoryRepo.getAllCategories(),
      ], eagerError: true); // eagerError: true will throw on first error

      // Type casting with null safety
      final products = results[0] as List<Product>? ?? [];
      final categories = results[1] as List<ProductCategory>? ?? [];

      // Ensure we have at least one category for the filter
      if (categories.isNotEmpty && _categoryFilter == 'all') {
        _categoryFilter = categories.first.categoryId;
      }

      setState(() {
        _allProducts = products;
        _categories = categories;
        _filteredProducts = _applyFilters(products, _filter, _categoryFilter);
        _isLoading = false;
      });
    } catch (e) {
      setState(() {
        _isLoading = false;
        _allProducts = [];
        _categories = [];
        _filteredProducts = [];
      });

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error loading data: $e'),
            backgroundColor: Colors.red,
            action: SnackBarAction(
              label: 'Retry',
              onPressed: _loadData,
            ),
          ),
        );
      }
    }

}

List<Product> _applyFilters(
List<Product> products, String statusFilter, String categoryFilter) {
return products.where((product) {
// Status filter
final statusMatch = switch (statusFilter) {
'active' => product.isActive,
'inactive' => !product.isActive,
'low_stock' => product.isLowStock,
'out_of_stock' => product.isOutOfStock,
_ => true,
};

      // Category filter
      final categoryMatch =
          categoryFilter == 'all' || product.categoryId == categoryFilter;

      return statusMatch && categoryMatch;
    }).toList();

}

void \_onSearchChanged() {
final query = \_searchController.text.toLowerCase();

    setState(() {
      if (query.isEmpty) {
        _filteredProducts =
            _applyFilters(_allProducts, _filter, _categoryFilter);
      } else {
        final searched = _allProducts.where((product) {
          return product.name.toLowerCase().contains(query) ||
              product.nameAm.toLowerCase().contains(query) ||
              product.barcode.toLowerCase().contains(query) ||
              product.sku?.toLowerCase().contains(query) == true;
        }).toList();
        _filteredProducts = _applyFilters(searched, _filter, _categoryFilter);
      }
    });

}

void \_changeStatusFilter(String newFilter) {
setState(() => \_filter = newFilter);
\_filteredProducts = \_applyFilters(\_allProducts, newFilter, \_categoryFilter);
}

void \_changeCategoryFilter(String newCategory) {
setState(() => \_categoryFilter = newCategory);
\_filteredProducts = \_applyFilters(\_allProducts, \_filter, newCategory);
}

void \_showAddProductDialog() {
showDialog(
context: context,
builder: (context) => AddProductDialog(
categories: \_categories,
onProductAdded: \_loadData,
),
);
}

void \_showEditProductDialog(Product product) {
showDialog(
context: context,
builder: (context) => EditProductDialog(
product: product,
categories: \_categories,
onProductUpdated: \_loadData,
),
);
}

Future<void> \_toggleProductStatus(Product product) async {
try {
final repository = ref.read(productRepositoryProvider);
await repository.updateProduct(
product.copyWith(isActive: !product.isActive),
);

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              '${product.name} ${product.isActive ? 'deactivated' : 'activated'} successfully',
            ),
            backgroundColor: const Color(0xFF10B981),
          ),
        );
      }
      _loadData();
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error updating product: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }

}

Future<void> \_updateStock(Product product, int newStock) async {
try {
final repository = ref.read(productRepositoryProvider);
await repository.updateStockQuantity(product.id!, newStock);

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Stock updated successfully'),
            backgroundColor: Color(0xFF10B981),
          ),
        );
      }
      _loadData();
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error updating stock: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }

}

// Statistics
int get \_totalProducts => \_allProducts.length;
int get \_activeProducts => \_allProducts.where((p) => p.isActive).length;
int get \_lowStockProducts => \_allProducts.where((p) => p.isLowStock).length;
int get \_outOfStockProducts =>
\_allProducts.where((p) => p.isOutOfStock).length;
double get \_totalInventoryValue => \_allProducts.fold(
0, (sum, product) => sum + (product.price \* product.stockQuantity));

@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: const Text('Product Management'),
backgroundColor: const Color(0xFF10B981),
foregroundColor: Colors.white,
actions: [
IconButton(
icon: const Icon(Icons.add),
onPressed: _showAddProductDialog,
tooltip: 'Add Product',
),
IconButton(
icon: const Icon(Icons.refresh),
onPressed: _loadData,
tooltip: 'Refresh',
),
],
),
body: Column(
children: [
// Search and Filters
\_buildSearchSection(),

          // Statistics
          if (_allProducts.isNotEmpty) _buildStatisticsSection(),

          // Products List
          Expanded(
            child: _isLoading
                ? _buildLoadingState()
                : _filteredProducts.isEmpty
                    ? _buildEmptyState()
                    : _buildProductsList(),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _showAddProductDialog,
        backgroundColor: const Color(0xFF10B981),
        foregroundColor: Colors.white,
        child: const Icon(Icons.add),
      ),
    );

}

Widget \_buildSearchSection() {
return CustomCard(
margin: const EdgeInsets.all(16),
padding: const EdgeInsets.all(16),
child: Column(
children: [
// Search Bar
TextField(
controller: \_searchController,
decoration: InputDecoration(
labelText: 'Search products...',
prefixIcon: const Icon(Icons.search),
border: OutlineInputBorder(
borderRadius: BorderRadius.circular(12),
),
contentPadding: const EdgeInsets.symmetric(horizontal: 16),
),
),
const SizedBox(height: 12),

          // Filters Row
          Row(
            children: [
              // Status Filter
              Expanded(
                child: DropdownButtonFormField<String>(
                  value: _filter,
                  decoration: const InputDecoration(
                    labelText: 'Status',
                    border: OutlineInputBorder(),
                    contentPadding: EdgeInsets.symmetric(horizontal: 12),
                  ),
                  items: const [
                    DropdownMenuItem(value: 'all', child: Text('All Products')),
                    DropdownMenuItem(
                        value: 'active', child: Text('Active Only')),
                    DropdownMenuItem(
                        value: 'inactive', child: Text('Inactive')),
                    DropdownMenuItem(
                        value: 'low_stock', child: Text('Low Stock')),
                    DropdownMenuItem(
                        value: 'out_of_stock', child: Text('Out of Stock')),
                  ],
                  onChanged: (value) => _changeStatusFilter(value!),
                ),
              ),
              const SizedBox(width: 12),

              // Category Filter
              Expanded(
                child: DropdownButtonFormField<String>(
                  value: _categoryFilter,
                  decoration: const InputDecoration(
                    labelText: 'Category',
                    border: OutlineInputBorder(),
                    contentPadding: EdgeInsets.symmetric(horizontal: 12),
                  ),
                  items: [
                    const DropdownMenuItem(
                        value: 'all', child: Text('All Categories')),
                    ..._categories.map((category) {
                      return DropdownMenuItem(
                        value: category.categoryId,
                        child: Text(category.name),
                      );
                    }),
                  ],
                  onChanged: (value) => _changeCategoryFilter(value!),
                ),
              ),
            ],
          ),
        ],
      ),
    );

}

Widget \_buildStatisticsSection() {
return CustomCard(
margin: const EdgeInsets.fromLTRB(16, 0, 16, 16),
padding: const EdgeInsets.all(20),
child: Column(
children: [
// Main Stats
Row(
mainAxisAlignment: MainAxisAlignment.spaceAround,
children: [
_buildStatItem('Total', _totalProducts.toString(),
Icons.inventory_2, const Color(0xFF10B981)),
_buildStatItem('Active', _activeProducts.toString(),
Icons.check_circle, Colors.green),
_buildStatItem('Low Stock', _lowStockProducts.toString(),
Icons.warning, Colors.orange),
_buildStatItem('Out of Stock', _outOfStockProducts.toString(),
Icons.error, Colors.red),
],
),
const SizedBox(height: 12),

          // Inventory Value
          Container(
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: const Color(0xFF10B981).withOpacity(0.1),
              borderRadius: BorderRadius.circular(8),
            ),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Icon(Icons.attach_money,
                    color: Color(0xFF10B981), size: 16),
                const SizedBox(width: 8),
                Text(
                  'Total Inventory Value: ${AppFormatters.formatCurrency(_totalInventoryValue)}',
                  style: const TextStyle(
                    fontWeight: FontWeight.bold,
                    color: Color(0xFF10B981),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );

}

Widget \_buildStatItem(
String title, String value, IconData icon, Color color) {
return Column(
children: [
Container(
padding: const EdgeInsets.all(8),
decoration: BoxDecoration(
color: color.withOpacity(0.1),
borderRadius: BorderRadius.circular(8),
),
child: Icon(icon, color: color, size: 20),
),
const SizedBox(height: 8),
Text(
value,
style: TextStyle(
fontSize: 16,
fontWeight: FontWeight.bold,
color: color,
),
),
Text(
title,
style: const TextStyle(
fontSize: 10,
color: Colors.grey,
),
),
],
);
}

Widget \_buildLoadingState() {
return ListView.builder(
padding: const EdgeInsets.all(16),
itemCount: 6,
itemBuilder: (context, index) => const Padding(
padding: EdgeInsets.only(bottom: 12),
child: LoadingShimmer(height: 120, borderRadius: 12),
),
);
}

Widget \_buildEmptyState() {
return Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
Icon(Icons.inventory_2, size: 64, color: Colors.grey.shade400),
const SizedBox(height: 16),
Text(
'No products found',
style: Theme.of(context).textTheme.titleMedium?.copyWith(
color: Colors.grey.shade600,
),
),
const SizedBox(height: 8),
Text(
_getEmptyStateMessage(),
style: TextStyle(color: Colors.grey.shade500),
textAlign: TextAlign.center,
),
const SizedBox(height: 24),
ElevatedButton.icon(
onPressed: _showAddProductDialog,
icon: const Icon(Icons.add),
label: const Text('Add First Product'),
style: ElevatedButton.styleFrom(
backgroundColor: const Color(0xFF10B981),
foregroundColor: Colors.white,
),
),
],
),
);
}

String \_getEmptyStateMessage() {
if (\_searchController.text.isNotEmpty) {
return 'No products match your search criteria.\nTry adjusting your search terms.';
}

    switch (_filter) {
      case 'active':
        return 'No active products found.';
      case 'inactive':
        return 'No inactive products found.';
      case 'low_stock':
        return 'No low stock products.\nGreat job managing inventory!';
      case 'out_of_stock':
        return 'No out of stock products.';
      default:
        return 'No products in inventory.\nAdd your first product to get started!';
    }

}

Widget \_buildProductsList() {
return ListView.builder(
padding: const EdgeInsets.all(16),
itemCount: \_filteredProducts.length,
itemBuilder: (context, index) {
final product = \_filteredProducts[index];
return \_buildProductCard(product);
},
);
}

Widget \_buildProductCard(Product product) {
final category = \_categories.firstWhere(
(c) => c.categoryId == product.categoryId,
orElse: () => ProductCategory(
categoryId: '',
name: 'Unknown',
nameAm: 'Unknown',
createdAt: DateTime.now(),
updatedAt: DateTime.now(),
),
);

    return CustomCard(
      margin: const EdgeInsets.only(bottom: 12),
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Product Info
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        Expanded(
                          child: Text(
                            product.name,
                            style: const TextStyle(
                              fontWeight: FontWeight.bold,
                              fontSize: 16,
                            ),
                            maxLines: 2,
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                        // Status Badges
                        Row(
                          children: [
                            if (!product.isActive)
                              _buildStatusBadge('INACTIVE', Colors.grey),
                            if (product.isOutOfStock)
                              _buildStatusBadge('OUT OF STOCK', Colors.red),
                            if (product.isLowStock)
                              _buildStatusBadge('LOW STOCK', Colors.orange),
                          ],
                        ),
                      ],
                    ),
                    const SizedBox(height: 4),
                    Text(
                      category.name,
                      style: TextStyle(
                        color: Colors.grey.shade600,
                        fontSize: 14,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),

          // Details
          Row(
            children: [
              // Product Details
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      AppFormatters.formatCurrency(product.price),
                      style: const TextStyle(
                        fontWeight: FontWeight.bold,
                        fontSize: 16,
                        color: Color(0xFF10B981),
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      'Stock: ${product.stockQuantity}',
                      style: TextStyle(
                        color:
                            product.isLowStock ? Colors.orange : Colors.green,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                    if (product.barcode.isNotEmpty) ...[
                      const SizedBox(height: 2),
                      Text(
                        'Barcode: ${product.barcode}',
                        style: TextStyle(
                          fontSize: 12,
                          color: Colors.grey.shade600,
                        ),
                      ),
                    ],
                    if (product.sku != null) ...[
                      const SizedBox(height: 2),
                      Text(
                        'SKU: ${product.sku}',
                        style: TextStyle(
                          fontSize: 12,
                          color: Colors.grey.shade600,
                        ),
                      ),
                    ],
                  ],
                ),
              ),

              // Action Buttons
              Column(
                children: [
                  // Stock Update Button
                  OutlinedButton(
                    onPressed: () => _showStockUpdateDialog(product),
                    style: OutlinedButton.styleFrom(
                      foregroundColor: const Color(0xFF10B981),
                      side: const BorderSide(color: Color(0xFF10B981)),
                      padding: const EdgeInsets.symmetric(horizontal: 12),
                    ),
                    child: const Text('Update Stock'),
                  ),
                  const SizedBox(height: 8),

                  // Edit and Toggle Buttons
                  Row(
                    children: [
                      IconButton(
                        icon: const Icon(Icons.edit, size: 18),
                        onPressed: () => _showEditProductDialog(product),
                        tooltip: 'Edit Product',
                      ),
                      IconButton(
                        icon: Icon(
                          product.isActive ? Icons.toggle_on : Icons.toggle_off,
                          size: 18,
                          color: product.isActive
                              ? const Color(0xFF10B981)
                              : Colors.grey,
                        ),
                        onPressed: () => _toggleProductStatus(product),
                        tooltip: product.isActive ? 'Deactivate' : 'Activate',
                      ),
                    ],
                  ),
                ],
              ),
            ],
          ),
        ],
      ),
    );

}

Widget \_buildStatusBadge(String text, Color color) {
return Container(
margin: const EdgeInsets.only(left: 4),
padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
decoration: BoxDecoration(
color: color.withOpacity(0.1),
borderRadius: BorderRadius.circular(4),
border: Border.all(color: color.withOpacity(0.3)),
),
child: Text(
text,
style: TextStyle(
fontSize: 8,
color: color,
fontWeight: FontWeight.bold,
),
),
);
}

void \_showStockUpdateDialog(Product product) {
final stockController =
TextEditingController(text: product.stockQuantity.toString());

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Update Stock'),
        content: TextField(
          controller: stockController,
          decoration: const InputDecoration(
            labelText: 'New Stock Quantity',
            border: OutlineInputBorder(),
          ),
          keyboardType: TextInputType.number,
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () {
              final newStock = int.tryParse(stockController.text);
              if (newStock != null && newStock >= 0) {
                Navigator.pop(context);
                _updateStock(product, newStock);
              } else {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(
                    content: Text('Please enter a valid stock quantity'),
                    backgroundColor: Colors.orange,
                  ),
                );
              }
            },
            style: ElevatedButton.styleFrom(
              backgroundColor: const Color(0xFF10B981),
            ),
            child: const Text('Update'),
          ),
        ],
      ),
    );

}
}

// Add Product Dialog
class AddProductDialog extends ConsumerStatefulWidget {
final List<ProductCategory> categories;
final VoidCallback onProductAdded;

const AddProductDialog({
super.key,
required this.categories,
required this.onProductAdded,
});

@override
ConsumerState<AddProductDialog> createState() => \_AddProductDialogState();
}

class \_AddProductDialogState extends ConsumerState<AddProductDialog> {
final \_formKey = GlobalKey<FormState>();
final \_nameController = TextEditingController();
final \_nameAmController = TextEditingController();
final \_priceController = TextEditingController();
final \_costPriceController = TextEditingController();
final \_stockController = TextEditingController(text: '0');
final \_minStockController = TextEditingController(text: '10');
final \_barcodeController = TextEditingController();
final \_skuController = TextEditingController();
final \_descriptionController = TextEditingController();
final \_unitController = TextEditingController();
final \_brandController = TextEditingController();
final \_supplierController = TextEditingController();

String \_selectedCategory = '';
bool \_trackInventory = true;

@override
void initState() {
super.initState();
if (widget.categories.isNotEmpty) {
\_selectedCategory = widget.categories.first.categoryId;
}
}

@override
void dispose() {
\_nameController.dispose();
\_nameAmController.dispose();
\_priceController.dispose();
\_costPriceController.dispose();
\_stockController.dispose();
\_minStockController.dispose();
\_barcodeController.dispose();
\_skuController.dispose();
\_descriptionController.dispose();
\_unitController.dispose();
\_brandController.dispose();
\_supplierController.dispose();
super.dispose();
}

Future<void> \_addProduct() async {
if (!\_formKey.currentState!.validate()) return;

    try {
      final repository = ref.read(productRepositoryProvider);

      final product = Product(
        productId: 'prod_${DateTime.now().millisecondsSinceEpoch}',
        name: _nameController.text.trim(),
        nameAm: _nameAmController.text.trim(),
        description: _descriptionController.text.trim().isEmpty
            ? null
            : _descriptionController.text.trim(),
        price: double.parse(_priceController.text),
        costPrice: _costPriceController.text.isEmpty
            ? null
            : double.parse(_costPriceController.text),
        stockQuantity: int.parse(_stockController.text),
        minStockLevel: _minStockController.text.isEmpty
            ? null
            : int.parse(_minStockController.text),
        barcode: _barcodeController.text.trim(),
        sku: _skuController.text.trim().isEmpty
            ? null
            : _skuController.text.trim(),
        categoryId: _selectedCategory,
        unit: _unitController.text.trim().isEmpty
            ? null
            : _unitController.text.trim(),
        brand: _brandController.text.trim().isEmpty
            ? null
            : _brandController.text.trim(),
        supplier: _supplierController.text.trim().isEmpty
            ? null
            : _supplierController.text.trim(),
        trackInventory: _trackInventory,
        isActive: true,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      await repository.createProduct(product);

      if (mounted) {
        Navigator.pop(context);
        widget.onProductAdded();
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Product added successfully!'),
            backgroundColor: Color(0xFF10B981),
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error adding product: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }

}

@override
Widget build(BuildContext context) {
return Dialog(
shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
child: SingleChildScrollView(
padding: const EdgeInsets.all(24),
child: Form(
key: \_formKey,
child: Column(
mainAxisSize: MainAxisSize.min,
crossAxisAlignment: CrossAxisAlignment.start,
children: [
const Row(
children: [
Icon(Icons.add, color: Color(0xFF10B981)),
SizedBox(width: 8),
Text(
'Add New Product',
style: TextStyle(
fontSize: 18,
fontWeight: FontWeight.bold,
),
),
],
),
const SizedBox(height: 20),

              // Basic Information
              const Text(
                'Basic Information',
                style: TextStyle(fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 8),
              _buildTextField(_nameController, 'Product Name (English) *',
                  validator: _validateRequired),
              const SizedBox(height: 12),
              _buildTextField(_nameAmController, 'Product Name (Amharic) *',
                  validator: _validateRequired),
              const SizedBox(height: 12),
              _buildTextField(_descriptionController, 'Description',
                  maxLines: 2),

              const SizedBox(height: 20),
              const Text(
                'Pricing & Inventory',
                style: TextStyle(fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 8),
              Row(
                children: [
                  Expanded(
                      child: _buildTextField(_priceController, 'Price (ETB) *',
                          keyboardType: TextInputType.number,
                          validator: _validatePrice)),
                  const SizedBox(width: 12),
                  Expanded(
                      child: _buildTextField(
                          _costPriceController, 'Cost Price (ETB)',
                          keyboardType: TextInputType.number)),
                ],
              ),
              const SizedBox(height: 12),
              Row(
                children: [
                  Expanded(
                      child: _buildTextField(
                          _stockController, 'Stock Quantity *',
                          keyboardType: TextInputType.number,
                          validator: _validateStock)),
                  const SizedBox(width: 12),
                  Expanded(
                      child: _buildTextField(
                          _minStockController, 'Min Stock Level',
                          keyboardType: TextInputType.number)),
                ],
              ),

              const SizedBox(height: 12),
              SwitchListTile(
                title: const Text('Track Inventory'),
                value: _trackInventory,
                onChanged: (value) => setState(() => _trackInventory = value),
              ),

              const SizedBox(height: 20),
              const Text(
                'Categorization',
                style: TextStyle(fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 8),
              DropdownButtonFormField<String>(
                value: _selectedCategory,
                decoration: const InputDecoration(
                  labelText: 'Category *',
                  border: OutlineInputBorder(),
                ),
                items: widget.categories.map((category) {
                  return DropdownMenuItem(
                    value: category.categoryId,
                    child: Text(category.name),
                  );
                }).toList(),
                onChanged: (value) =>
                    setState(() => _selectedCategory = value!),
                validator: (value) =>
                    value == null ? 'Please select a category' : null,
              ),

              const SizedBox(height: 20),
              const Text(
                'Additional Information',
                style: TextStyle(fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 8),
              Row(
                children: [
                  Expanded(
                      child: _buildTextField(_barcodeController, 'Barcode')),
                  const SizedBox(width: 12),
                  Expanded(child: _buildTextField(_skuController, 'SKU')),
                ],
              ),
              const SizedBox(height: 12),
              Row(
                children: [
                  Expanded(
                      child: _buildTextField(
                          _unitController, 'Unit (e.g., pcs, kg)')),
                  const SizedBox(width: 12),
                  Expanded(child: _buildTextField(_brandController, 'Brand')),
                ],
              ),
              const SizedBox(height: 12),
              _buildTextField(_supplierController, 'Supplier'),

              const SizedBox(height: 24),
              Row(
                children: [
                  Expanded(
                    child: OutlinedButton(
                      onPressed: () => Navigator.pop(context),
                      child: const Text('Cancel'),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: ElevatedButton(
                      onPressed: _addProduct,
                      style: ElevatedButton.styleFrom(
                        backgroundColor: const Color(0xFF10B981),
                        foregroundColor: Colors.white,
                      ),
                      child: const Text('Add Product'),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );

}

Widget \_buildTextField(
TextEditingController controller,
String label, {
TextInputType keyboardType = TextInputType.text,
int maxLines = 1,
String? Function(String?)? validator,
}) {
return TextFormField(
controller: controller,
decoration: InputDecoration(
labelText: label,
border: const OutlineInputBorder(),
),
keyboardType: keyboardType,
maxLines: maxLines,
validator: validator,
);
}

String? \_validateRequired(String? value) {
if (value == null || value.trim().isEmpty) {
return 'This field is required';
}
return null;
}

String? \_validatePrice(String? value) {
if (value == null || value.trim().isEmpty) {
return 'Price is required';
}
final price = double.tryParse(value);
if (price == null || price < 0) {
return 'Please enter a valid price';
}
return null;
}

String? \_validateStock(String? value) {
if (value == null || value.trim().isEmpty) {
return 'Stock quantity is required';
}
final stock = int.tryParse(value);
if (stock == null || stock < 0) {
return 'Please enter a valid stock quantity';
}
return null;
}
}

// Edit Product Dialog (similar structure but for editing)
class EditProductDialog extends ConsumerStatefulWidget {
final Product product;
final List<ProductCategory> categories;
final VoidCallback onProductUpdated;

const EditProductDialog({
super.key,
required this.product,
required this.categories,
required this.onProductUpdated,
});

@override
ConsumerState<EditProductDialog> createState() => \_EditProductDialogState();
}

class \_EditProductDialogState extends ConsumerState<EditProductDialog> {
// Similar structure to AddProductDialog but pre-filled with product data
// Implementation follows same pattern as AddProductDialog
@override
Widget build(BuildContext context) {
return AlertDialog(
title: const Text('Edit Product'),
content: const Text('Edit product form goes here...'),
actions: [
TextButton(
onPressed: () => Navigator.pop(context),
child: const Text('Cancel'),
),
ElevatedButton(
onPressed: () {
// Save changes logic
},
child: const Text('Save Changes'),
),
],
);
}
}

##

// lib/src/ui/screens/reports_screen.dart
// Screen for viewing detailed reports and analytics on sales, products, customers, and financials.
import 'package:andalus_smart_pos/src/data/models/subscription.dart';
import 'package:andalus_smart_pos/src/utils/reports_data_calculator.dart';
import 'package:andalus_smart_pos/src/widgets/reports/advanced_product_analytics.dart';
import 'package:andalus_smart_pos/src/widgets/reports/advanced_sales_charts.dart';
import 'package:andalus_smart_pos/src/widgets/reports/customer_analytics_section.dart';
import 'package:andalus_smart_pos/src/widgets/reports/customers_overview_card.dart';
import 'package:andalus_smart_pos/src/widgets/reports/financial_ratios_section.dart';
import 'package:andalus_smart_pos/src/widgets/reports/inventory_analysis_section.dart';
import 'package:andalus_smart_pos/src/widgets/reports/outstanding_balance_chart.dart';
import 'package:andalus_smart_pos/src/widgets/reports/products_overview_card.dart';
import 'package:andalus_smart_pos/src/widgets/reports/revenue_by_day_chart.dart';
import 'package:andalus_smart_pos/src/widgets/reports/top_customers_chart.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import '../../controllers/reports_controller.dart';
import '../../localization/app_localizations.dart';
import '../../widgets/common/date_range_picker.dart';
import '../../widgets/common/custom_card.dart';
import '../../widgets/reports/sales_overview_card.dart';
import '../../widgets/reports/sales_trend_chart.dart';
import '../../widgets/reports/payment_method_chart.dart';
import '../../widgets/reports/top_products_chart.dart';
import '../../widgets/reports/customer_report_section.dart';
import '../../widgets/reports/financial_report_section.dart';
import '../../widgets/reports/subscription_info_card.dart';
import 'package:andalus_smart_pos/src/widgets/reports/top_products_chart.dart';

class ReportsScreen extends ConsumerStatefulWidget {
const ReportsScreen({super.key});

@override
ConsumerState<ReportsScreen> createState() => \_ReportsScreenState();
}

class \_ReportsScreenState extends ConsumerState<ReportsScreen>
with SingleTickerProviderStateMixin {
late TabController \_tabController;

@override
void initState() {
super.initState();
\_tabController = TabController(length: 4, vsync: this);
}

@override
void dispose() {
\_tabController.dispose();
super.dispose();
}

@override
Widget build(BuildContext context) {
final state = ref.watch(reportsControllerProvider);
final controller = ref.read(reportsControllerProvider.notifier);
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);

    return Scaffold(
      appBar: AppBar(
        title: Text(localizations.reports),
        backgroundColor: theme.colorScheme.primary,
        foregroundColor: theme.colorScheme.onPrimary,
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: controller.refresh,
            tooltip: localizations.refresh,
          ),
          _buildReportTypeMenu(localizations, controller, state),
        ],
        bottom: state.currentPlan.id != 'basic'
            ? _buildTabBar(localizations, state)
            : null,
      ),
      body: state.isLoading
          ? _buildLoadingState()
          : state.error != null
              ? _buildErrorState(state.error!, controller)
              : _buildContent(state, localizations, theme),
    );

}

Widget \_buildReportTypeMenu(AppLocalizations localizations,
ReportsController controller, ReportsState state) {
return PopupMenuButton<ReportType>(
onSelected: (type) {
controller.setReportType(type);
\_tabController.animateTo(\_getTabIndex(type));
},
itemBuilder: (context) => [
PopupMenuItem(
value: ReportType.sales,
child: Text(localizations.salesAnalytics),
),
PopupMenuItem(
value: ReportType.products,
enabled: state.currentPlan.id != 'basic',
child: Text(localizations.productsReport),
),
PopupMenuItem(
value: ReportType.customers,
enabled: state.currentPlan.id != 'basic',
child: Text(localizations.customersReport),
),
PopupMenuItem(
value: ReportType.financial,
enabled: state.currentPlan.id == 'enterprise',
child: Text(localizations.financialReport),
),
],
);
}

TabBar \_buildTabBar(AppLocalizations localizations, ReportsState state) {
return TabBar(
controller: \_tabController,
tabs: [
Tab(text: localizations.salesAnalytics),
Tab(text: localizations.productsReport),
Tab(text: localizations.customersReport),
if (state.currentPlan.id == 'enterprise')
Tab(text: localizations.financialReport),
],
);
}

Widget \_buildLoadingState() {
return Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
CircularProgressIndicator(),
SizedBox(height: 16),
Text('Loading reports...'),
],
),
);
}

Widget \_buildErrorState(String error, ReportsController controller) {
return Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
Icon(Icons.error_outline, size: 64, color: Colors.red),
SizedBox(height: 16),
Text('Error loading reports', style: TextStyle(fontSize: 18)),
SizedBox(height: 8),
Text(error, textAlign: TextAlign.center),
SizedBox(height: 16),
ElevatedButton(
onPressed: controller.refresh,
child: Text('Try Again'),
),
],
),
);
}

Widget \_buildContent(
ReportsState state, AppLocalizations localizations, ThemeData theme) {
return Column(
children: [
_buildFiltersSection(localizations, theme, state, ref),
SubscriptionInfoCard(plan: state.currentPlan),
Expanded(
child: state.currentPlan.id != 'basic'
? _buildTabbedView(state, localizations, theme)
: _buildBasicView(state, localizations, theme),
),
],
);
}

Widget \_buildFiltersSection(AppLocalizations localizations, ThemeData theme,
ReportsState state, WidgetRef ref) {
final controller = ref.read(reportsControllerProvider.notifier);

    return CustomCard(
      margin: const EdgeInsets.all(16),
      padding: const EdgeInsets.all(16),
      child: Column(
        children: [
          ProfessionalDateRangePicker(
            initialDateRange: state.dateRange,
            onDateRangeSelected: controller.setDateRange,
            title: localizations.selectDateRange,
          ),
        ],
      ),
    );

}

Widget \_buildTabbedView(
ReportsState state, AppLocalizations localizations, ThemeData theme) {
return TabBarView(
controller: \_tabController,
children: [
SalesReportSection(
salesData: state.salesData!, plan: state.currentPlan),
ProductsReportSection(
productsData: state.productsData!, plan: state.currentPlan),
CustomersReportSection(
customersData: state.customersData!, plan: state.currentPlan),
if (state.currentPlan.id == 'enterprise')
FinancialReportSection(financialData: state.financialData!),
],
);
}

Widget \_buildBasicView(
ReportsState state, AppLocalizations localizations, ThemeData theme) {
return SalesReportSection(
salesData: state.salesData!, plan: state.currentPlan);
}

int \_getTabIndex(ReportType type) {
switch (type) {
case ReportType.sales:
return 0;
case ReportType.products:
return 1;
case ReportType.customers:
return 2;
case ReportType.financial:
return 3;
}
}
}

// Modular report sections
class SalesReportSection extends StatelessWidget {
final SalesReportData salesData;
final SubscriptionPlan plan;

const SalesReportSection({
super.key,
required this.salesData,
required this.plan,
});

@override
Widget build(BuildContext context) {
return ListView(
padding: const EdgeInsets.all(16),
children: [
SalesOverviewCard(salesData: salesData),
const SizedBox(height: 16),
SalesTrendChart(dailySales: salesData.dailySalesTrend),
const SizedBox(height: 16),
PaymentMethodChart(paymentMethods: salesData.salesByPaymentMethod),
if (plan.id != 'basic') ...[
const SizedBox(height: 16),
RevenueByDayChart(revenueByDay: salesData.revenueByDay),
],
if (plan.id == 'enterprise') ...[
const SizedBox(height: 16),
AdvancedSalesCharts(salesData: salesData),
],
],
);
}
}

class ProductsReportSection extends StatelessWidget {
final ProductsReportData productsData;
final SubscriptionPlan plan;

const ProductsReportSection({
super.key,
required this.productsData,
required this.plan,
});

@override
Widget build(BuildContext context) {
return ListView(
padding: const EdgeInsets.all(16),
children: [
ProductsOverviewCard(productsData: productsData),
const SizedBox(height: 16),
TopProductsChart(products: productsData.topSellingProducts),
if (plan.id != 'basic') ...[
const SizedBox(height: 16),
InventoryAnalysisSection(productsData: productsData),
],
if (plan.id == 'enterprise') ...[
const SizedBox(height: 16),
AdvancedProductAnalytics(productsData: productsData),
],
],
);
}
}

class CustomersReportSection extends StatelessWidget {
final CustomersReportData customersData;
final SubscriptionPlan plan;

const CustomersReportSection({
super.key,
required this.customersData,
required this.plan,
});

@override
Widget build(BuildContext context) {
return ListView(
padding: const EdgeInsets.all(16),
children: [
CustomersOverviewCard(customersData: customersData),
const SizedBox(height: 16),
TopCustomersChart(customers: customersData.topCustomers),
const SizedBox(height: 16),
OutstandingBalanceChart(customersData: customersData),
if (plan.id == 'enterprise') ...[
const SizedBox(height: 16),
CustomerAnalyticsSection(customersData: customersData),
],
],
);
}
}

class FinancialReportSection extends StatelessWidget {
final FinancialReportData financialData;

const FinancialReportSection({super.key, required this.financialData});

@override
Widget build(BuildContext context) {
return ListView(
padding: const EdgeInsets.all(16),
children: [
FinancialKPICards(financialData: financialData),
const SizedBox(height: 16),
ProfitMarginTrendChart(financialData: financialData),
const SizedBox(height: 16),
CashFlowAnalysisChart(financialData: financialData),
const SizedBox(height: 16),
FinancialRatiosSection(financialData: financialData),
],
);
}
}

enum ReportType { sales, products, customers, financial }

##

// lib/src/ui/screens/sales_history_screen.dart
// Screen for viewing and managing sales history, including filtering, analytics, and detailed sale information.
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/data/repositories/sale_repository.dart';
import 'package:andalus_smart_pos/src/data/models/sale.dart';
import 'package:andalus_smart_pos/src/widgets/common/custom_card.dart';
import 'package:andalus_smart_pos/src/widgets/common/loading_shimmer.dart';
import 'package:andalus_smart_pos/src/utils/date_utils.dart';
import 'package:andalus_smart_pos/src/utils/formatters.dart';

class SalesHistoryScreen extends ConsumerStatefulWidget {
const SalesHistoryScreen({super.key});

@override
ConsumerState<SalesHistoryScreen> createState() => \_SalesHistoryScreenState();
}

class \_SalesHistoryScreenState extends ConsumerState<SalesHistoryScreen> {
List<Sale> \_sales = [];
bool \_isLoading = true;
String \_filter = 'today'; // 'today', 'week', 'month', 'all', 'custom'
DateTimeRange? \_selectedDateRange;
SaleWithItems? \_selectedSale;

@override
void initState() {
super.initState();
\_loadSales();
}

Future<void> \_loadSales() async {
setState(() => \_isLoading = true);

    try {
      final saleRepository = ref.read(saleRepositoryProvider);
      List<Sale> sales;

      final now = DateTime.now();
      switch (_filter) {
        case 'today':
          sales = await saleRepository.getTodaysSales();
          break;
        case 'week':
          final weekAgo = now.subtract(const Duration(days: 7));
          final allSales = await saleRepository.getAllSales();
          sales = allSales
              .where((sale) => sale.createdAt.isAfter(weekAgo))
              .toList();
          break;
        case 'month':
          final monthAgo = DateTime(now.year, now.month - 1, now.day);
          final allSales = await saleRepository.getAllSales();
          sales = allSales
              .where((sale) => sale.createdAt.isAfter(monthAgo))
              .toList();
          break;
        case 'custom':
          if (_selectedDateRange != null) {
            final allSales = await saleRepository.getAllSales();
            sales = allSales
                .where((sale) =>
                    sale.createdAt.isAfter(_selectedDateRange!.start) &&
                    sale.createdAt.isBefore(_selectedDateRange!.end))
                .toList();
          } else {
            sales = await saleRepository.getAllSales();
          }
          break;
        default:
          sales = await saleRepository.getAllSales();
      }

      // Sort by date (newest first)
      sales.sort((a, b) => b.createdAt.compareTo(a.createdAt));

      setState(() {
        _sales = sales;
        _isLoading = false;
      });
    } catch (e) {
      setState(() => _isLoading = false);
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error loading sales: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }

}

Future<void> \_loadSaleDetails(int saleId) async {
try {
final saleRepository = ref.read(saleRepositoryProvider);
final saleWithItems = await saleRepository.getSaleById(saleId);

      setState(() => _selectedSale = saleWithItems);
      _showSaleDetailsDialog();
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error loading sale details: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }

}

void \_showSaleDetailsDialog() {
if (\_selectedSale == null) return;

    showDialog(
      context: context,
      builder: (context) => Dialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
        elevation: 4,
        child: _buildSaleDetailsContent(),
      ),
    );

}

Widget \_buildSaleDetailsContent() {
final sale = \_selectedSale!.sale;
final items = \_selectedSale!.items;
final theme = Theme.of(context);
final colorScheme = theme.colorScheme;

    return SingleChildScrollView(
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Header
            Row(
              children: [
                Icon(Icons.receipt_long, color: colorScheme.primary, size: 28),
                const SizedBox(width: 12),
                Text(
                  'Sale #${sale.id}',
                  style: theme.textTheme.titleLarge?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const Spacer(),
                IconButton(
                  icon: const Icon(Icons.close),
                  onPressed: () => Navigator.pop(context),
                ),
              ],
            ),
            const SizedBox(height: 24),

            // Sale Information
            Card(
              elevation: 0,
              color: colorScheme.surfaceVariant.withOpacity(0.3),
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(16)),
              margin: const EdgeInsets.only(bottom: 16),
              child: Padding(
                padding: const EdgeInsets.all(16),
                child: Column(
                  children: [
                    _buildDetailRow('Date',
                        '${AppDateUtils.formatDate(sale.createdAt)} ${AppDateUtils.formatTime(sale.createdAt)}'),
                    _buildDetailRow('Payment Method',
                        _formatPaymentMethod(sale.paymentMethod)),
                    _buildDetailRow(
                        'Status', _formatStatus(sale.paymentStatus)),
                    if (sale.taxAmount > 0)
                      _buildDetailRow('Tax Amount',
                          AppFormatters.formatCurrency(sale.taxAmount)),
                    if (sale.discountAmount > 0)
                      _buildDetailRow('Discount',
                          AppFormatters.formatCurrency(sale.discountAmount)),
                  ],
                ),
              ),
            ),
            const SizedBox(height: 16),

            // Items Header
            Text(
              'Items',
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 12),

            // Items List
            Card(
              elevation: 0,
              color: colorScheme.surfaceVariant.withOpacity(0.3),
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(16)),
              margin: const EdgeInsets.only(bottom: 16),
              child: Padding(
                padding: const EdgeInsets.all(16),
                child: Column(
                  children: [
                    ...items.map((item) => Padding(
                          padding: const EdgeInsets.symmetric(vertical: 8),
                          child: Row(
                            children: [
                              Expanded(
                                flex: 3,
                                child: Text(
                                  item.productName,
                                  style: theme.textTheme.bodyLarge?.copyWith(
                                    fontWeight: FontWeight.w600,
                                  ),
                                ),
                              ),
                              Expanded(
                                child: Text(
                                  'x${item.quantity}',
                                  style: theme.textTheme.bodyMedium?.copyWith(
                                    color: colorScheme.onSurfaceVariant,
                                  ),
                                  textAlign: TextAlign.center,
                                ),
                              ),
                              Expanded(
                                child: Text(
                                  AppFormatters.formatCurrency(item.unitPrice),
                                  style: theme.textTheme.bodyMedium?.copyWith(
                                    color: colorScheme.onSurfaceVariant,
                                  ),
                                  textAlign: TextAlign.right,
                                ),
                              ),
                              Expanded(
                                child: Text(
                                  AppFormatters.formatCurrency(item.totalPrice),
                                  style: theme.textTheme.bodyLarge?.copyWith(
                                    fontWeight: FontWeight.bold,
                                    color: colorScheme.primary,
                                  ),
                                  textAlign: TextAlign.right,
                                ),
                              ),
                            ],
                          ),
                        )),
                  ],
                ),
              ),
            ),
            const SizedBox(height: 16),

            // Total
            Container(
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: colorScheme.primary.withOpacity(0.1),
                borderRadius: BorderRadius.circular(16),
                border: Border.all(color: colorScheme.primary.withOpacity(0.2)),
              ),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(
                    'TOTAL AMOUNT:',
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  Text(
                    AppFormatters.formatCurrency(sale.finalAmount),
                    style: theme.textTheme.titleLarge?.copyWith(
                      fontWeight: FontWeight.bold,
                      color: colorScheme.primary,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );

}

Widget \_buildDetailRow(String label, String value) {
final theme = Theme.of(context);
final colorScheme = theme.colorScheme;

    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(
            label,
            style: theme.textTheme.bodyMedium?.copyWith(
              color: colorScheme.onSurfaceVariant,
              fontWeight: FontWeight.w500,
            ),
          ),
          Text(
            value,
            style: theme.textTheme.bodyMedium?.copyWith(
              fontWeight: FontWeight.w600,
            ),
          ),
        ],
      ),
    );

}

String \_formatPaymentMethod(String method) {
switch (method) {
case 'cash':
return 'Cash';
case 'telebirr':
return 'Telebirr';
case 'card':
return 'Card';
case 'credit':
return 'Credit';
default:
return method.toUpperCase();
}
}

String \_formatStatus(String status) {
switch (status) {
case 'completed':
return 'Completed';
case 'pending':
return 'Pending';
case 'refunded':
return 'Refunded';
default:
return status.capitalize();
}
}

void \_changeFilter(String newFilter) {
setState(() => \_filter = newFilter);
\_loadSales();
}

Future<void> \_selectDateRange() async {
final DateTimeRange? picked = await showDateRangePicker(
context: context,
firstDate: DateTime(2020),
lastDate: DateTime.now().add(const Duration(days: 365)),
initialEntryMode: DatePickerEntryMode.calendarOnly,
helpText: 'Select Date Range',
confirmText: 'Apply',
cancelText: 'Cancel',
);

    if (picked != null) {
      setState(() {
        _selectedDateRange = picked;
        _filter = 'custom';
      });
      _loadSales();
    }

}

// Analytics calculations
double get \_totalSalesAmount =>
\_sales.fold(0, (sum, sale) => sum + sale.finalAmount);
int get \_totalOrders => \_sales.length;
double get \_averageOrderValue =>
\_totalOrders > 0 ? \_totalSalesAmount / \_totalOrders : 0;

Map<String, double> get \_paymentMethodBreakdown {
final breakdown = <String, double>{};
for (final sale in \_sales) {
breakdown.update(
sale.paymentMethod,
(value) => value + sale.finalAmount,
ifAbsent: () => sale.finalAmount,
);
}
return breakdown;
}

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);
final colorScheme = theme.colorScheme;

    return Scaffold(
      appBar: AppBar(
        title: const Text('Sales History'),
        backgroundColor: colorScheme.primary,
        foregroundColor: colorScheme.onPrimary,
        elevation: 0,
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: _loadSales,
            tooltip: 'Refresh',
          ),
        ],
      ),
      body: Column(
        children: [
          // Filter Section
          _buildFilterSection(),

          // Analytics Summary
          if (_sales.isNotEmpty && !_isLoading) _buildAnalyticsSummary(),

          // Sales List
          Expanded(
            child: _isLoading
                ? _buildLoadingState()
                : _sales.isEmpty
                    ? _buildEmptyState()
                    : _buildSalesList(),
          ),
        ],
      ),
    );

}

Widget \_buildFilterSection() {
final theme = Theme.of(context);
final colorScheme = theme.colorScheme;

    return Card(
      elevation: 2,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      margin: const EdgeInsets.all(16),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            // Quick Filters
            SingleChildScrollView(
              scrollDirection: Axis.horizontal,
              child: Row(
                children: [
                  _buildFilterChip('Today', 'today'),
                  const SizedBox(width: 8),
                  _buildFilterChip('This Week', 'week'),
                  const SizedBox(width: 8),
                  _buildFilterChip('This Month', 'month'),
                  const SizedBox(width: 8),
                  _buildFilterChip('All Time', 'all'),
                  const SizedBox(width: 8),
                  _buildDateRangeChip(),
                ],
              ),
            ),

            // Selected Date Range
            if (_filter == 'custom' && _selectedDateRange != null) ...[
              const SizedBox(height: 12),
              Text(
                '${AppDateUtils.formatDate(_selectedDateRange!.start)} - ${AppDateUtils.formatDate(_selectedDateRange!.end)}',
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: colorScheme.onSurfaceVariant,
                  fontWeight: FontWeight.w500,
                ),
              ),
            ],
          ],
        ),
      ),
    );

}

Widget \_buildFilterChip(String label, String value) {
final isSelected = \_filter == value;
final theme = Theme.of(context);
final colorScheme = theme.colorScheme;

    return FilterChip(
      label: Text(label),
      selected: isSelected,
      onSelected: (selected) => _changeFilter(value),
      backgroundColor: colorScheme.surface,
      selectedColor: colorScheme.primary,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
      side: BorderSide(
        color: colorScheme.primary.withOpacity(isSelected ? 0 : 0.2),
      ),
      labelStyle: TextStyle(
        color: isSelected ? colorScheme.onPrimary : colorScheme.primary,
        fontWeight: FontWeight.w600,
      ),
      elevation: isSelected ? 2 : 0,
      pressElevation: 4,
    );

}

Widget \_buildDateRangeChip() {
final isSelected = \_filter == 'custom';
final theme = Theme.of(context);
final colorScheme = theme.colorScheme;

    return FilterChip(
      label: const Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(Icons.calendar_today, size: 16),
          SizedBox(width: 4),
          Text('Custom Range'),
        ],
      ),
      selected: isSelected,
      onSelected: (_) => _selectDateRange(),
      backgroundColor: colorScheme.surface,
      selectedColor: colorScheme.primary,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
      side: BorderSide(
        color: colorScheme.primary.withOpacity(isSelected ? 0 : 0.2),
      ),
      labelStyle: TextStyle(
        color: isSelected ? colorScheme.onPrimary : colorScheme.primary,
        fontWeight: FontWeight.w600,
      ),
      elevation: isSelected ? 2 : 0,
      pressElevation: 4,
    );

}

Widget \_buildAnalyticsSummary() {
final theme = Theme.of(context);
final colorScheme = theme.colorScheme;

    return Card(
      elevation: 2,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      margin: const EdgeInsets.fromLTRB(16, 0, 16, 16),
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          children: [
            // Main Stats
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceAround,
              children: [
                _buildAnalyticsItem(
                  'Total Sales',
                  AppFormatters.formatCurrency(_totalSalesAmount),
                  Icons.attach_money,
                ),
                _buildAnalyticsItem(
                  'Total Orders',
                  _totalOrders.toString(),
                  Icons.receipt_long,
                ),
                _buildAnalyticsItem(
                  'Avg. Order',
                  AppFormatters.formatCurrency(_averageOrderValue),
                  Icons.trending_up,
                ),
              ],
            ),
            const SizedBox(height: 24),

            // Payment Methods Breakdown
            if (_paymentMethodBreakdown.isNotEmpty) ...[
              Divider(color: colorScheme.outline.withOpacity(0.5)),
              const SizedBox(height: 12),
              Text(
                'Payment Methods',
                style: theme.textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 12),
              Wrap(
                spacing: 12,
                runSpacing: 8,
                children: _paymentMethodBreakdown.entries.map((entry) {
                  final percentage = (entry.value / _totalSalesAmount * 100);
                  return Chip(
                    label: Text(
                      '${_formatPaymentMethod(entry.key)}: ${percentage.toStringAsFixed(1)}%',
                    ),
                    backgroundColor: colorScheme.primary.withOpacity(0.1),
                    labelStyle: TextStyle(
                      color: colorScheme.primary,
                      fontWeight: FontWeight.w600,
                    ),
                    shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(20)),
                    elevation: 1,
                  );
                }).toList(),
              ),
            ],
          ],
        ),
      ),
    );

}

Widget \_buildAnalyticsItem(String title, String value, IconData icon) {
final theme = Theme.of(context);
final colorScheme = theme.colorScheme;

    return Column(
      children: [
        Container(
          padding: const EdgeInsets.all(12),
          decoration: BoxDecoration(
            color: colorScheme.primary.withOpacity(0.1),
            borderRadius: BorderRadius.circular(12),
          ),
          child: Icon(icon, color: colorScheme.primary, size: 28),
        ),
        const SizedBox(height: 8),
        Text(
          value,
          style: theme.textTheme.titleMedium?.copyWith(
            fontWeight: FontWeight.bold,
            color: colorScheme.onSurface,
          ),
        ),
        const SizedBox(height: 4),
        Text(
          title,
          style: theme.textTheme.bodySmall?.copyWith(
            color: colorScheme.onSurfaceVariant,
          ),
        ),
      ],
    );

}

Widget \_buildLoadingState() {
return ListView.builder(
padding: const EdgeInsets.all(16),
itemCount: 6,
itemBuilder: (context, index) => const Padding(
padding: EdgeInsets.only(bottom: 12),
child: LoadingShimmer(height: 120, borderRadius: 16),
),
);
}

Widget \_buildEmptyState() {
final theme = Theme.of(context);
final colorScheme = theme.colorScheme;

    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.receipt_long,
              size: 80, color: colorScheme.onSurfaceVariant),
          const SizedBox(height: 16),
          Text(
            'No sales found',
            style: theme.textTheme.titleLarge?.copyWith(
              color: colorScheme.onSurfaceVariant,
            ),
          ),
          const SizedBox(height: 8),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 32),
            child: Text(
              _getEmptyStateMessage(),
              style: theme.textTheme.bodyMedium?.copyWith(
                color: colorScheme.onSurfaceVariant,
              ),
              textAlign: TextAlign.center,
            ),
          ),
          const SizedBox(height: 24),
          ElevatedButton.icon(
            onPressed: () => Navigator.pop(context),
            icon: const Icon(Icons.point_of_sale),
            label: const Text('Start Selling'),
            style: ElevatedButton.styleFrom(
              backgroundColor: colorScheme.primary,
              foregroundColor: colorScheme.onPrimary,
              elevation: 2,
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(20)),
              padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
            ),
          ),
        ],
      ),
    );

}

String \_getEmptyStateMessage() {
switch (\_filter) {
case 'today':
return 'No sales made today yet.\nComplete your first sale to see it here!';
case 'week':
return 'No sales in the last 7 days.';
case 'month':
return 'No sales this month.';
case 'custom':
return 'No sales found in the selected date range.';
default:
return 'No sales recorded yet.\nComplete your first sale to see it here!';
}
}

Widget \_buildSalesList() {
return RefreshIndicator(
onRefresh: \_loadSales,
child: ListView.builder(
padding: const EdgeInsets.all(16),
itemCount: \_sales.length,
itemBuilder: (context, index) {
final sale = \_sales[index];
return \_buildSaleCard(sale);
},
),
);
}

Widget \_buildSaleCard(Sale sale) {
final theme = Theme.of(context);
final colorScheme = theme.colorScheme;

    return Card(
      elevation: 2,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      margin: const EdgeInsets.only(bottom: 12),
      child: InkWell(
        onTap: () => _loadSaleDetails(sale.id!),
        borderRadius: BorderRadius.circular(16),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Expanded(
                    child: Text(
                      'Sale #${sale.id}',
                      style: theme.textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                  Chip(
                    label: Text(
                      _formatPaymentMethod(sale.paymentMethod),
                      style: const TextStyle(
                        color: Colors.white,
                        fontSize: 12,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    backgroundColor: _getPaymentMethodColor(sale.paymentMethod),
                    shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(20)),
                  ),
                ],
              ),
              const SizedBox(height: 12),

              // Details
              Row(
                children: [
                  // Date and Time
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Row(
                          children: [
                            Icon(Icons.calendar_today,
                                size: 16, color: colorScheme.onSurfaceVariant),
                            const SizedBox(width: 6),
                            Text(
                              AppDateUtils.formatDate(sale.createdAt),
                              style: theme.textTheme.bodyMedium?.copyWith(
                                  color: colorScheme.onSurfaceVariant),
                            ),
                          ],
                        ),
                        const SizedBox(height: 4),
                        Row(
                          children: [
                            Icon(Icons.access_time,
                                size: 16, color: colorScheme.onSurfaceVariant),
                            const SizedBox(width: 6),
                            Text(
                              AppDateUtils.formatTime(sale.createdAt),
                              style: theme.textTheme.bodyMedium?.copyWith(
                                  color: colorScheme.onSurfaceVariant),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ),

                  // Amount
                  Column(
                    crossAxisAlignment: CrossAxisAlignment.end,
                    children: [
                      Text(
                        AppFormatters.formatCurrency(sale.finalAmount),
                        style: theme.textTheme.titleLarge?.copyWith(
                          fontWeight: FontWeight.bold,
                          color: colorScheme.primary,
                        ),
                      ),
                      const SizedBox(height: 4),
                      Text(
                        'Tap for details',
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: colorScheme.onSurfaceVariant,
                          fontStyle: FontStyle.italic,
                        ),
                      ),
                    ],
                  ),
                ],
              ),

              // Sync Status
              if (!sale.isSynced) ...[
                const SizedBox(height: 12),
                Row(
                  children: [
                    Icon(Icons.sync, size: 16, color: Colors.orange.shade600),
                    const SizedBox(width: 6),
                    Text(
                      'Pending sync',
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: Colors.orange.shade600,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ],
                ),
              ],
            ],
          ),
        ),
      ),
    );

}

Color \_getPaymentMethodColor(String method) {
switch (method) {
case 'cash':
return const Color(0xFF10B981);
case 'telebirr':
return const Color(0xFF3B82F6);
case 'card':
return const Color(0xFF8B5CF6);
case 'credit':
return const Color(0xFFF59E0B);
default:
return const Color(0xFF6B7280);
}
}
}

extension StringExtension on String {
String capitalize() {
return "${this[0].toUpperCase()}${substring(1)}";
}
}

##

// lib/src/ui/screens/splash_screen.dart
// Splash screen with animated logo and initial setup flow for language and theme selection.
// After setup, navigates to authentication or main app screen.
// Implements smooth animations and responsive design.

import 'package:andalus_smart_pos/src/providers/language_provider.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/providers/auth_provider.dart';
import 'package:andalus_smart_pos/src/providers/theme_provider.dart';
import 'package:andalus_smart_pos/src/ui/screens/auth/phone_login_screen.dart';
import 'package:andalus_smart_pos/src/ui/screens/main_navigation.dart';

class SplashScreen extends ConsumerStatefulWidget {
const SplashScreen({super.key});

@override
ConsumerState<SplashScreen> createState() => \_SplashScreenState();
}

class \_SplashScreenState extends ConsumerState<SplashScreen>
with SingleTickerProviderStateMixin {
late AnimationController \_animationController;
late Animation<double> \_fadeAnimation;
late Animation<double> \_scaleAnimation;

int \_currentStep = 0;
bool \_showSettings = false;

final List<Map<String, dynamic>> \_languages = [
{
'code': 'en',
'name': 'English',
'nativeName': 'English',
'flag': 'üá∫üá∏',
'description': 'English'
},
{
'code': 'am',
'name': 'Amharic',
'nativeName': '·ä†·àõ·à≠·äõ',
'flag': 'üá™üáπ',
'description': 'Amharic'
},
];

final List<Map<String, dynamic>> \_themes = [
{
'mode': ThemeMode.light,
'name': 'Light',
'description': 'Bright theme',
'icon': Icons.light_mode_outlined,
'selectedIcon': Icons.light_mode,
},
{
'mode': ThemeMode.dark,
'name': 'Dark',
'description': 'Dark theme',
'icon': Icons.dark_mode_outlined,
'selectedIcon': Icons.dark_mode,
},
{
'mode': ThemeMode.system,
'name': 'System',
'description': 'Follow device',
'icon': Icons.settings_outlined,
'selectedIcon': Icons.settings,
},
];

@override
void initState() {
super.initState();
\_initializeAnimations();
\_initializeApp();
}

void \_initializeAnimations() {
\_animationController = AnimationController(
vsync: this,
duration: const Duration(milliseconds: 1200),
);

    _fadeAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(
        parent: _animationController,
        curve: const Interval(0.0, 0.6, curve: Curves.easeInOut),
      ),
    );

    _scaleAnimation = Tween<double>(begin: 0.8, end: 1.0).animate(
      CurvedAnimation(
        parent: _animationController,
        curve: const Interval(0.3, 1.0, curve: Curves.elasticOut),
      ),
    );

    _animationController.forward();

}

Future<void> \_initializeApp() async {
// Initial loading delay
await Future.delayed(const Duration(milliseconds: 1800));

    if (mounted) {
      setState(() {
        _showSettings = true;
        _currentStep = 1;
      });
    }

}

void \_selectLanguage(String languageCode) {
ref.read(languageProvider.notifier).setLanguage(languageCode);
\_nextStep();
}

void \_selectTheme(ThemeMode themeMode) {
ref.read(themeProvider.notifier).setTheme(themeMode);
\_nextStep();
}

void \_nextStep() {
if (\_currentStep < 3) {
setState(() => \_currentStep++);
} else {
\_proceedToApp();
}
}

void \_previousStep() {
if (\_currentStep > 1) {
setState(() => \_currentStep--);
}
}

void \_skipToApp() {
\_proceedToApp();
}

void \_proceedToApp() {
final authState = ref.read(authProvider);
Navigator.of(context).pushReplacement(
MaterialPageRoute(
builder: (context) => authState.isAuthenticated
? const MainNavigation()
// : const PhoneLoginScreen(),
: const MainNavigation(),
),
);
}

@override
void dispose() {
\_animationController.dispose();
super.dispose();
}

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);
final locale = ref.watch(languageProvider);
final isEnglish = locale.languageCode == 'en';

    return Scaffold(
      backgroundColor: theme.colorScheme.primary,
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            children: [
              // Progress Indicator
              if (_showSettings && _currentStep > 0 && _currentStep < 3)
                _buildProgressIndicator(),

              // Main Content
              Expanded(
                child: AnimatedSwitcher(
                  duration: const Duration(milliseconds: 400),
                  child: _showSettings
                      ? _buildSettingsFlow(isEnglish)
                      : _buildWelcomeScreen(),
                ),
              ),

              // Navigation Buttons
              if (_showSettings && _currentStep > 0 && _currentStep < 3)
                _buildNavigationButtons(isEnglish),
            ],
          ),
        ),
      ),
    );

}

Widget \_buildWelcomeScreen() {
return FadeTransition(
opacity: \_fadeAnimation,
child: ScaleTransition(
scale: \_scaleAnimation,
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
// App Logo with gradient
Container(
width: 140,
height: 140,
decoration: BoxDecoration(
gradient: LinearGradient(
begin: Alignment.topLeft,
end: Alignment.bottomRight,
colors: [
Colors.white.withOpacity(0.9),
Colors.white.withOpacity(0.7),
],
),
borderRadius: BorderRadius.circular(28),
boxShadow: [
BoxShadow(
color: Colors.black.withOpacity(0.15),
blurRadius: 20,
offset: const Offset(0, 10),
),
],
),
child: Icon(
Icons.point_of_sale_rounded,
size: 70,
color: Theme.of(context).colorScheme.primary,
),
),
const SizedBox(height: 32),

            // App Name
            Text(
              'Andalus POS',
              style: TextStyle(
                color: Colors.white,
                fontSize: 32,
                fontWeight: FontWeight.w800,
                letterSpacing: -0.5,
              ),
            ),
            const SizedBox(height: 12),

            // Subtitle
            Text(
              'Smart Point of Sale for Ethiopian Businesses',
              style: TextStyle(
                color: Colors.white.withOpacity(0.8),
                fontSize: 16,
                fontWeight: FontWeight.w400,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 40),

            // Loading Indicator
            SizedBox(
              width: 32,
              height: 32,
              child: CircularProgressIndicator(
                strokeWidth: 2.5,
                valueColor: AlwaysStoppedAnimation<Color>(
                    Colors.white.withOpacity(0.8)),
              ),
            ),
            const SizedBox(height: 20),

            // Loading Text
            Text(
              'Initializing...',
              style: TextStyle(
                color: Colors.white.withOpacity(0.7),
                fontSize: 14,
                fontWeight: FontWeight.w500,
              ),
            ),
          ],
        ),
      ),
    );

}

Widget \_buildSettingsFlow(bool isEnglish) {
switch (\_currentStep) {
case 1:
return \_buildLanguageStep(isEnglish);
case 2:
return \_buildThemeStep(isEnglish);
case 3:
return \_buildReadyStep(isEnglish);
default:
return \_buildWelcomeScreen();
}
}

Widget \_buildProgressIndicator() {
return Padding(
padding: const EdgeInsets.only(bottom: 32),
child: Column(
children: [
// Step Indicators
Row(
mainAxisAlignment: MainAxisAlignment.center,
children: List.generate(2, (index) {
return Container(
width: _currentStep == index + 1 ? 24 : 12,
height: 4,
margin: const EdgeInsets.symmetric(horizontal: 4),
decoration: BoxDecoration(
borderRadius: BorderRadius.circular(2),
color: _currentStep >= index + 1
? Colors.white
: Colors.white.withOpacity(0.3),
),
);
}),
),
const SizedBox(height: 12),
// Step Text
Text(
'$_currentStep of 2',
style: TextStyle(
color: Colors.white.withOpacity(0.7),
fontSize: 12,
fontWeight: FontWeight.w500,
),
),
],
),
);
}

Widget \_buildLanguageStep(bool isEnglish) {
return SingleChildScrollView(
child: Padding(
padding: const EdgeInsets.symmetric(vertical: 20),
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
// Icon
Icon(
Icons.language_rounded,
size: 64,
color: Colors.white,
),
const SizedBox(height: 24),

            // Title
            Text(
              isEnglish ? 'Choose Language' : '·âã·äï·âã ·ã≠·àù·à®·å°',
              style: const TextStyle(
                color: Colors.white,
                fontSize: 28,
                fontWeight: FontWeight.w700,
              ),
            ),
            const SizedBox(height: 8),

            // Subtitle
            Text(
              isEnglish ? 'Select your preferred language' : '·ã®·àö·çà·àç·åâ·âµ·äï ·âã·äï·âã ·ã≠·àù·à®·å°',
              style: TextStyle(
                color: Colors.white.withOpacity(0.7),
                fontSize: 16,
                fontWeight: FontWeight.w400,
              ),
            ),
            const SizedBox(height: 40),

            // Language Options
            Column(
              children: _languages
                  .map((language) => _buildLanguageOption(language, isEnglish))
                  .toList(),
            ),
          ],
        ),
      ),
    );

}

Widget \_buildLanguageOption(Map<String, dynamic> language, bool isEnglish) {
final isSelected =
ref.watch(languageProvider).languageCode == language['code'];

    return Container(
      margin: const EdgeInsets.only(bottom: 12),
      child: Material(
        color: isSelected ? Colors.white : Colors.white.withOpacity(0.1),
        borderRadius: BorderRadius.circular(16),
        child: InkWell(
          onTap: () => _selectLanguage(language['code']),
          borderRadius: BorderRadius.circular(16),
          child: Container(
            padding: const EdgeInsets.all(20),
            child: Row(
              children: [
                // Flag
                Text(
                  language['flag'],
                  style: const TextStyle(fontSize: 28),
                ),
                const SizedBox(width: 16),

                // Language Info
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        language['nativeName'],
                        style: TextStyle(
                          fontSize: 18,
                          fontWeight: FontWeight.w600,
                          color: isSelected
                              ? Theme.of(context).colorScheme.primary
                              : Colors.white,
                        ),
                      ),
                      const SizedBox(height: 4),
                      Text(
                        language['name'],
                        style: TextStyle(
                          fontSize: 14,
                          color: isSelected
                              ? Theme.of(context)
                                  .colorScheme
                                  .primary
                                  .withOpacity(0.7)
                              : Colors.white.withOpacity(0.7),
                        ),
                      ),
                    ],
                  ),
                ),

                // Selection Indicator
                if (isSelected)
                  Icon(
                    Icons.check_circle_rounded,
                    color: Theme.of(context).colorScheme.primary,
                    size: 24,
                  ),
              ],
            ),
          ),
        ),
      ),
    );

}

Widget \_buildThemeStep(bool isEnglish) {
return SingleChildScrollView(
child: Padding(
padding: const EdgeInsets.symmetric(vertical: 20),
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
// Icon
Icon(
Icons.palette_rounded,
size: 64,
color: Colors.white,
),
const SizedBox(height: 24),

            // Title
            Text(
              isEnglish ? 'Choose Theme' : '·åà·åΩ·â≥ ·ã≠·àù·à®·å°',
              style: const TextStyle(
                color: Colors.white,
                fontSize: 28,
                fontWeight: FontWeight.w700,
              ),
            ),
            const SizedBox(height: 8),

            // Subtitle
            Text(
              isEnglish
                  ? 'Select your preferred appearance'
                  : '·ã®·àö·çà·àç·åâ·âµ·äï ·åà·åΩ·â≥ ·ã≠·àù·à®·å°',
              style: TextStyle(
                color: Colors.white.withOpacity(0.7),
                fontSize: 16,
                fontWeight: FontWeight.w400,
              ),
            ),
            const SizedBox(height: 40),

            // Theme Options
            Wrap(
              spacing: 16,
              runSpacing: 16,
              alignment: WrapAlignment.center,
              children: _themes
                  .map((theme) => _buildThemeOption(theme, isEnglish))
                  .toList(),
            ),
          ],
        ),
      ),
    );

}

Widget \_buildThemeOption(Map<String, dynamic> theme, bool isEnglish) {
final isSelected = ref.watch(themeProvider) == theme['mode'];

    return Material(
      color: isSelected ? Colors.white : Colors.white.withOpacity(0.1),
      borderRadius: BorderRadius.circular(20),
      child: InkWell(
        onTap: () => _selectTheme(theme['mode']),
        borderRadius: BorderRadius.circular(20),
        child: Container(
          width: 140,
          height: 140,
          padding: const EdgeInsets.all(20),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              // Icon
              Icon(
                isSelected ? theme['selectedIcon'] : theme['icon'],
                size: 36,
                color: isSelected
                    ? Theme.of(context).colorScheme.primary
                    : Colors.white.withOpacity(0.8),
              ),
              const SizedBox(height: 12),

              // Theme Name
              Text(
                _getThemeDisplayName(theme['mode'], isEnglish),
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w600,
                  color: isSelected
                      ? Theme.of(context).colorScheme.primary
                      : Colors.white,
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 4),

              // Description
              Text(
                theme['description'],
                style: TextStyle(
                  fontSize: 12,
                  color: isSelected
                      ? Theme.of(context).colorScheme.primary.withOpacity(0.7)
                      : Colors.white.withOpacity(0.6),
                ),
                textAlign: TextAlign.center,
              ),
            ],
          ),
        ),
      ),
    );

}

Widget \_buildReadyStep(bool isEnglish) {
return Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
// Success Icon
Container(
width: 100,
height: 100,
decoration: BoxDecoration(
color: Colors.white,
borderRadius: BorderRadius.circular(50),
boxShadow: [
BoxShadow(
color: Colors.black.withOpacity(0.1),
blurRadius: 20,
offset: const Offset(0, 10),
),
],
),
child: Icon(
Icons.check_rounded,
size: 48,
color: Theme.of(context).colorScheme.primary,
),
),
const SizedBox(height: 32),

        // Title
        Text(
          isEnglish ? 'You\'re All Set!' : '·àÅ·àâ·àù ·äê·åà·à≠ ·ãù·åç·åÅ ·äê·ãç!',
          style: const TextStyle(
            color: Colors.white,
            fontSize: 32,
            fontWeight: FontWeight.w700,
          ),
        ),
        const SizedBox(height: 16),

        // Message
        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 20),
          child: Text(
            isEnglish
                ? 'Your preferences have been saved. Welcome to Andalus Smart POS!'
                : '·àù·à≠·å´·ãé·âΩ·ãé ·â∞·âÄ·àù·å†·ãã·àç·ç¢ ·ãà·ã∞ ·ä†·äï·ã≥·àâ·àµ ·àõ·à≠·â≤·äï ·çñ·àµ ·ä•·äï·ä≥·äï ·â†·ã∞·àÖ·äì ·àò·å°!',
            style: TextStyle(
              color: Colors.white.withOpacity(0.8),
              fontSize: 16,
              fontWeight: FontWeight.w400,
            ),
            textAlign: TextAlign.center,
          ),
        ),
        const SizedBox(height: 40),

        // Continue Button
        SizedBox(
          width: double.infinity,
          child: ElevatedButton(
            onPressed: _proceedToApp,
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.white,
              foregroundColor: Theme.of(context).colorScheme.primary,
              padding: const EdgeInsets.symmetric(vertical: 16),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(16),
              ),
              elevation: 0,
            ),
            child: Text(
              isEnglish ? 'Get Started' : '·åÄ·àù·à≠',
              style: const TextStyle(
                fontSize: 16,
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
        ),
      ],
    );

}

Widget \_buildNavigationButtons(bool isEnglish) {
return Container(
padding: const EdgeInsets.only(top: 20),
child: Row(
children: [
if (_currentStep > 1)
Expanded(
child: OutlinedButton(
onPressed: _previousStep,
style: OutlinedButton.styleFrom(
foregroundColor: Colors.white,
side: const BorderSide(color: Colors.white),
padding: const EdgeInsets.symmetric(vertical: 16),
shape: RoundedRectangleBorder(
borderRadius: BorderRadius.circular(16),
),
),
child: Text(isEnglish ? 'Back' : '·â∞·àò·àà·àµ'),
),
),
if (_currentStep > 1) const SizedBox(width: 12),
Expanded(
child: ElevatedButton(
onPressed: _nextStep,
style: ElevatedButton.styleFrom(
backgroundColor: Colors.white,
foregroundColor: Theme.of(context).colorScheme.primary,
padding: const EdgeInsets.symmetric(vertical: 16),
shape: RoundedRectangleBorder(
borderRadius: BorderRadius.circular(16),
),
elevation: 0,
),
child: Text(
isEnglish ? 'Continue' : '·âÄ·å£·ã≠',
style: const TextStyle(
fontWeight: FontWeight.w600,
),
),
),
),
],
),
);
}

String \_getThemeDisplayName(ThemeMode themeMode, bool isEnglish) {
switch (themeMode) {
case ThemeMode.light:
return isEnglish ? 'Light' : '·â•·à≠·àÉ·äï';
case ThemeMode.dark:
return isEnglish ? 'Dark' : '·å®·àà·àõ';
case ThemeMode.system:
return isEnglish ? 'System' : '·àµ·à≠·ä†·âµ';
}
}
}

// ui/screens/subscription_plans_screen.dart
// Screen for displaying and managing subscription plans.
import 'package:andalus_smart_pos/src/widgets/common/custom_card.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/data/models/subscription.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
import 'package:andalus_smart_pos/src/utils/formatters.dart';

class SubscriptionPlansScreen extends ConsumerStatefulWidget {
const SubscriptionPlansScreen({super.key});

@override
ConsumerState<SubscriptionPlansScreen> createState() =>
\_SubscriptionPlansScreenState();
}

class \_SubscriptionPlansScreenState
extends ConsumerState<SubscriptionPlansScreen> {
SubscriptionPlan? \_selectedPlan;
BillingCycle \_billingCycle = BillingCycle.monthly;
PaymentMethod \_selectedPaymentMethod = PaymentMethod.telebirr;

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);

    return Scaffold(
      appBar: AppBar(
        title: Text(localizations.translate('subscriptionPlans')),
        backgroundColor: theme.colorScheme.primary,
        foregroundColor: theme.colorScheme.onPrimary,
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildHeaderSection(localizations, theme),
            const SizedBox(height: 24),
            _buildBillingCycleSelector(localizations, theme),
            const SizedBox(height: 24),
            ..._buildPlanCards(localizations, theme),
            const SizedBox(height: 32),
            if (_selectedPlan != null)
              _buildPaymentSection(localizations, theme),
          ],
        ),
      ),
    );

}

Widget \_buildHeaderSection(AppLocalizations localizations, ThemeData theme) {
return Container(
width: double.infinity,
padding: const EdgeInsets.all(20),
decoration: BoxDecoration(
gradient: LinearGradient(
begin: Alignment.topLeft,
end: Alignment.bottomRight,
colors: [
theme.colorScheme.primary.withOpacity(0.1),
theme.colorScheme.primary.withOpacity(0.05),
]),
borderRadius: BorderRadius.circular(16),
),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Icon(Icons.workspace_premium,
size: 48, color: theme.colorScheme.primary),
const SizedBox(height: 16),
Text(
localizations.translate('choosePerfectPlan'),
style: theme.textTheme.headlineSmall
?.copyWith(fontWeight: FontWeight.bold),
),
const SizedBox(height: 8),
Text(
localizations.translate('startWithFreeTrial'),
style: theme.textTheme.bodyMedium
?.copyWith(color: theme.colorScheme.outline),
),
],
),
);
}

Widget \_buildBillingCycleSelector(
AppLocalizations localizations, ThemeData theme) {
return Row(
mainAxisAlignment: MainAxisAlignment.center,
children: [
_buildBillingOption(
BillingCycle.monthly,
localizations.translate('monthly'),
theme,
),
const SizedBox(width: 16),
_buildBillingOption(
BillingCycle.yearly,
localizations.translate('yearly'),
theme,
),
],
);
}

Widget \_buildBillingOption(
BillingCycle cycle, String label, ThemeData theme) {
final isSelected = \_billingCycle == cycle;
return Expanded(
child: GestureDetector(
onTap: () => setState(() => \_billingCycle = cycle),
child: Container(
padding: const EdgeInsets.all(16),
decoration: BoxDecoration(
color: isSelected
? theme.colorScheme.primary
: theme.colorScheme.surface,
border: Border.all(
color: isSelected
? theme.colorScheme.primary
: theme.colorScheme.outline.withOpacity(0.3),
),
borderRadius: BorderRadius.circular(12),
),
child: Column(
children: [
Text(
label,
style: TextStyle(
fontWeight: FontWeight.bold,
color: isSelected
? theme.colorScheme.onPrimary
: theme.colorScheme.onSurface,
),
),
if (cycle == BillingCycle.yearly) ...[
const SizedBox(height: 4),
Text(
// localizations.translate('performanceOverview')
'Save 20%',
style: TextStyle(
fontSize: 12,
color: isSelected
? theme.colorScheme.onPrimary
: theme.colorScheme.primary,
),
),
],
],
),
),
),
);
}

List<Widget> \_buildPlanCards(
AppLocalizations localizations, ThemeData theme) {
return SubscriptionPlan.all
.map((plan) => \_buildPlanCard(plan, localizations, theme))
.toList();
}

Widget \_buildPlanCard(
SubscriptionPlan plan, AppLocalizations localizations, ThemeData theme) {
final isSelected = \_selectedPlan == plan;
final isPopular = plan.id == 'professional';

    return Container(
      margin: const EdgeInsets.only(bottom: 16),
      decoration: BoxDecoration(
        border: Border.all(
          color: isSelected ? theme.colorScheme.primary : Colors.transparent,
          width: 2,
        ),
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          if (isSelected || isPopular)
            BoxShadow(
              color: theme.colorScheme.primary.withOpacity(0.1),
              blurRadius: 8,
              offset: const Offset(0, 4),
            ),
        ],
      ),
      child: Stack(
        children: [
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header
              Container(
                width: double.infinity,
                padding: const EdgeInsets.all(20),
                decoration: BoxDecoration(
                  color: _getPlanColor(plan, theme).withOpacity(0.1),
                  borderRadius: const BorderRadius.only(
                    topLeft: Radius.circular(16),
                    topRight: Radius.circular(16),
                  ),
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Text(plan.name,
                            style: theme.textTheme.titleLarge?.copyWith(
                              fontWeight: FontWeight.bold,
                              color: _getPlanColor(plan, theme),
                            )),
                        if (isPopular)
                          Container(
                            padding: const EdgeInsets.symmetric(
                                horizontal: 12, vertical: 6),
                            decoration: BoxDecoration(
                              color: _getPlanColor(plan, theme),
                              borderRadius: BorderRadius.circular(12),
                            ),
                            child: Text(
                              localizations.translate('popular'),
                              style: const TextStyle(
                                  color: Colors.white,
                                  fontSize: 12,
                                  fontWeight: FontWeight.bold),
                            ),
                          ),
                      ],
                    ),
                    const SizedBox(height: 8),
                    Text(plan.description, style: theme.textTheme.bodyMedium),
                    const SizedBox(height: 16),
                    Text(
                      plan.getFormattedPrice(_billingCycle),
                      style: theme.textTheme.headlineSmall?.copyWith(
                        fontWeight: FontWeight.bold,
                        color: _getPlanColor(plan, theme),
                      ),
                    ),
                    if (_billingCycle == BillingCycle.yearly) ...[
                      const SizedBox(height: 4),
                      Text(
                        plan.savingsInfo,
                        style: theme.textTheme.bodySmall
                            ?.copyWith(color: Colors.green),
                      ),
                    ],
                  ],
                ),
              ),

              // Features
              Padding(
                padding: const EdgeInsets.all(20),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    ...plan.features.map((feature) => Padding(
                          padding: const EdgeInsets.symmetric(vertical: 4),
                          child: Row(
                            children: [
                              Icon(Icons.check_circle,
                                  color: _getPlanColor(plan, theme), size: 16),
                              const SizedBox(width: 8),
                              Expanded(
                                  child: Text(feature,
                                      style: theme.textTheme.bodyMedium)),
                            ],
                          ),
                        )),
                    const SizedBox(height: 20),
                    SizedBox(
                      width: double.infinity,
                      child: ElevatedButton(
                        onPressed: () => setState(() => _selectedPlan = plan),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: isSelected
                              ? _getPlanColor(plan, theme)
                              : Colors.transparent,
                          foregroundColor: isSelected
                              ? Colors.white
                              : _getPlanColor(plan, theme),
                          side: BorderSide(color: _getPlanColor(plan, theme)),
                        ),
                        child: Text(isSelected
                            ? localizations.translate('selected')
                            : localizations.translate('selectPlan')),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ],
      ),
    );

}

Widget \_buildPaymentSection(AppLocalizations localizations, ThemeData theme) {
return Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(localizations.translate('paymentMethod'),
style: theme.textTheme.titleMedium),
const SizedBox(height: 16),
_buildPaymentMethodSelector(localizations, theme),
const SizedBox(height: 24),
_buildOrderSummary(localizations, theme),
const SizedBox(height: 24),
SizedBox(
width: double.infinity,
child: ElevatedButton(
onPressed: _processPayment,
style: ElevatedButton.styleFrom(
backgroundColor: theme.colorScheme.primary,
foregroundColor: theme.colorScheme.onPrimary,
padding: const EdgeInsets.symmetric(vertical: 16),
),
child: Text(localizations.translate('subscribeNow')),
),
),
],
);
}

Widget \_buildPaymentMethodSelector(
AppLocalizations localizations, ThemeData theme) {
return Wrap(
spacing: 12,
runSpacing: 12,
children: PaymentMethod.values
.map((method) =>
\_buildPaymentMethodOption(method, localizations, theme))
.toList(),
);
}

Widget \_buildPaymentMethodOption(
PaymentMethod method, AppLocalizations localizations, ThemeData theme) {
final isSelected = \_selectedPaymentMethod == method;
return GestureDetector(
onTap: () => setState(() => \_selectedPaymentMethod = method),
child: Container(
padding: const EdgeInsets.all(16),
decoration: BoxDecoration(
color: isSelected
? theme.colorScheme.primary.withOpacity(0.1)
: theme.colorScheme.surface,
border: Border.all(
color: isSelected
? theme.colorScheme.primary
: theme.colorScheme.outline.withOpacity(0.3),
),
borderRadius: BorderRadius.circular(12),
),
child: Row(
mainAxisSize: MainAxisSize.min,
children: [
Icon(_getPaymentMethodIcon(method),
color: _getPaymentMethodColor(method)),
const SizedBox(width: 8),
Text(_getPaymentMethodName(method, localizations)),
],
),
),
);
}

Widget \_buildOrderSummary(AppLocalizations localizations, ThemeData theme) {
final price = \_selectedPlan!.getPrice(\_billingCycle);
final tax = price \* 0.15; // 15% tax
final total = price + tax;

    return CustomCard(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(localizations.translate('orderSummary'),
                style: theme.textTheme.titleMedium),
            const SizedBox(height: 16),
            _buildOrderRow(localizations.translate('plan'),
                '${_selectedPlan!.name} (${_billingCycle.displayName})'),
            _buildOrderRow(localizations.translate('price'),
                AppFormatters.formatCurrency(price)),
            _buildOrderRow(localizations.translate('tax'),
                AppFormatters.formatCurrency(tax)),
            const Divider(),
            _buildOrderRow(localizations.translate('total'),
                AppFormatters.formatCurrency(total),
                isTotal: true),
          ],
        ),
      ),
    );

}

Widget \_buildOrderRow(String label, String value, {bool isTotal = false}) {
return Padding(
padding: const EdgeInsets.symmetric(vertical: 8),
child: Row(
mainAxisAlignment: MainAxisAlignment.spaceBetween,
children: [
Text(label,
style: TextStyle(
fontWeight: isTotal ? FontWeight.bold : FontWeight.normal,
)),
Text(value,
style: TextStyle(
fontWeight: isTotal ? FontWeight.bold : FontWeight.normal,
)),
],
),
);
}

Future<void> \_processPayment() async {
if (\_selectedPlan == null) return;

    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => const PaymentProcessingDialog(),
    );

    try {
      // Simulate payment processing
      await Future.delayed(const Duration(seconds: 2));

      Navigator.pop(context); // Close loading dialog

      // Show success dialog
      _showPaymentSuccessDialog();
    } catch (e) {
      Navigator.pop(context); // Close loading dialog
      _showPaymentErrorDialog(e.toString());
    }

}

void \_showPaymentSuccessDialog() {
showDialog(
context: context,
builder: (context) => AlertDialog(
title: const Text('Payment Successful'),
content:
const Text('Your subscription has been activated successfully.'),
actions: [
TextButton(
onPressed: () {
Navigator.pop(context);
Navigator.pop(context); // Go back to reports screen
},
child: const Text('Continue'),
),
],
),
);
}

void \_showPaymentErrorDialog(String error) {
showDialog(
context: context,
builder: (context) => AlertDialog(
title: const Text('Payment Failed'),
content: Text('Error: $error'),
actions: [
TextButton(
onPressed: () => Navigator.pop(context),
child: const Text('Try Again'),
),
],
),
);
}

// Helper methods
Color \_getPlanColor(SubscriptionPlan plan, ThemeData theme) {
switch (plan.id) {
case 'basic':
return theme.colorScheme.primary;
case 'professional':
return Colors.green;
case 'enterprise':
return Colors.purple;
default:
return theme.colorScheme.outline;
}
}

IconData \_getPaymentMethodIcon(PaymentMethod method) {
switch (method) {
case PaymentMethod.telebirr:
return Icons.phone_android;
case PaymentMethod.bank:
return Icons.account_balance;
case PaymentMethod.cash:
return Icons.money;
case PaymentMethod.card:
return Icons.credit_card;
}
}

Color \_getPaymentMethodColor(PaymentMethod method) {
switch (method) {
case PaymentMethod.telebirr:
return Colors.green;
case PaymentMethod.bank:
return Colors.blue;
case PaymentMethod.cash:
return Colors.orange;
case PaymentMethod.card:
return Colors.purple;
}
}

String \_getPaymentMethodName(
PaymentMethod method, AppLocalizations localizations) {
switch (method) {
case PaymentMethod.telebirr:
return 'Telebirr';
case PaymentMethod.bank:
return localizations.translate('bankTransfer');
case PaymentMethod.cash:
return localizations.translate('cash');
case PaymentMethod.card:
return localizations.translate('card');
}
}
}

class PaymentProcessingDialog extends StatelessWidget {
const PaymentProcessingDialog({super.key});

@override
Widget build(BuildContext context) {
return Dialog(
child: Padding(
padding: const EdgeInsets.all(24),
child: Column(
mainAxisSize: MainAxisSize.min,
children: [
CircularProgressIndicator(),
const SizedBox(height: 16),
Text('Processing Payment...'),
],
),
),
);
}
}

enum PaymentMethod { telebirr, bank, cash, card }

##

// src/utils/calendar_utils.dart
// Utility functions and state management for handling Gregorian and Ethiopian calendars,
// including date conversions, formatting, and user preferences.
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'dart:convert';

enum CalendarType {
gregorian('Gregorian', '·åç·à™·åé·à≠·ã´·äï'),
ethiopian('Ethiopian', '·ä¢·âµ·ãÆ·åµ·ã´·ãä');

final String englishName;
final String amharicName;

const CalendarType(this.englishName, this.amharicName);
}

class CalendarSettings {
final CalendarType calendarType;
final double fontSizeScale;

const CalendarSettings({
this.calendarType = CalendarType.gregorian,
this.fontSizeScale = 1.0,
});

CalendarSettings copyWith({
CalendarType? calendarType,
double? fontSizeScale,
}) {
return CalendarSettings(
calendarType: calendarType ?? this.calendarType,
fontSizeScale: fontSizeScale ?? this.fontSizeScale,
);
}

Map<String, dynamic> toMap() {
return {
'calendar_type': calendarType.name,
'font_size_scale': fontSizeScale,
};
}

factory CalendarSettings.fromMap(Map<String, dynamic> map) {
return CalendarSettings(
calendarType: CalendarType.values.firstWhere(
(e) => e.name == map['calendar_type'],
orElse: () => CalendarType.gregorian,
),
fontSizeScale: map['font_size_scale']?.toDouble() ?? 1.0,
);
}
}

final calendarProvider =
StateNotifierProvider<CalendarNotifier, CalendarSettings>(
(ref) => CalendarNotifier(),
);

class CalendarNotifier extends StateNotifier<CalendarSettings> {
CalendarNotifier() : super(const CalendarSettings()) {
\_loadSettings();
}

static const String \_settingsKey = 'calendar_settings';

Future<void> \_loadSettings() async {
try {
final prefs = await SharedPreferences.getInstance();
final settingsString = prefs.getString(\_settingsKey);

      if (settingsString != null && settingsString.isNotEmpty) {
        try {
          final settingsMap =
              Map<String, dynamic>.from(json.decode(settingsString));
          state = CalendarSettings.fromMap(settingsMap);
        } catch (e) {
          print('Error parsing calendar settings: $e');
          // Fallback to default settings
          final calendarIndex = prefs.getInt('preferred_calendar') ?? 0;
          state = CalendarSettings(
            calendarType: CalendarType.values[calendarIndex],
            fontSizeScale: 1.0,
          );
        }
      } else {
        // Legacy support for old preference format
        final calendarIndex = prefs.getInt('preferred_calendar') ?? 0;
        state = CalendarSettings(
          calendarType: CalendarType.values[calendarIndex],
          fontSizeScale: 1.0,
        );
      }
    } catch (e) {
      print('Error loading calendar settings: $e');
      state = const CalendarSettings();
    }

}

Future<void> setCalendarType(CalendarType type) async {
state = state.copyWith(calendarType: type);
await \_saveSettings();
}

Future<void> setFontSizeScale(double scale) async {
state = state.copyWith(fontSizeScale: scale.clamp(0.8, 1.5));
await \_saveSettings();
}

Future<void> \_saveSettings() async {
try {
final prefs = await SharedPreferences.getInstance();
await prefs.setString(\_settingsKey, json.encode(state.toMap()));
// Also save legacy format for compatibility
await prefs.setInt('preferred_calendar', state.calendarType.index);
} catch (e) {
print('Error saving calendar settings: $e');
}
}
}

// Ethiopian Date Implementation
class EthiopianDateTime {
final int year;
final int month;
final int day;

EthiopianDateTime(
{required this.year, required this.month, required this.day});

// Convert Gregorian to Ethiopian date
// This is a simplified conversion algorithm
factory EthiopianDateTime.fromGregorian(DateTime gregorianDate) {
final gYear = gregorianDate.year;
final gMonth = gregorianDate.month;
final gDay = gregorianDate.day;

    // Ethiopian calendar starts on September 11/12 in Gregorian calendar
    final ethiopianYear = gYear - 8;

    int ethiopianMonth;
    int ethiopianDay;

    if (gMonth >= 9) {
      // September to December
      if (gMonth == 9) {
        if (gDay >= 11) {
          ethiopianMonth = 1; // Meskerem
          ethiopianDay = gDay - 10;
        } else {
          ethiopianMonth = 13; // Pagume (previous year)
          ethiopianDay = gDay + 5; // Approximate
          // Note: This is simplified - actual Pagume has 5-6 days
        }
      } else {
        ethiopianMonth = gMonth - 8;
        ethiopianDay = gDay;
      }
    } else {
      // January to August
      if (gMonth == 1) {
        if (gDay <= 10) {
          ethiopianMonth = 5; // Tir
          ethiopianDay = gDay + 20; // Approximate
        } else {
          ethiopianMonth = 6; // Yekatit
          ethiopianDay = gDay - 10;
        }
      } else {
        ethiopianMonth = gMonth + 4;
        ethiopianDay = gDay;
      }
    }

    // Adjust for edge cases (simplified)
    if (ethiopianDay > 30) {
      ethiopianDay -= 30;
      ethiopianMonth += 1;
    }

    if (ethiopianMonth > 13) {
      ethiopianMonth = 1;
      // Note: Year adjustment would go here in a complete implementation
    }

    return EthiopianDateTime(
      year: ethiopianYear,
      month: ethiopianMonth,
      day: ethiopianDay,
    );

}

// Convert Ethiopian to Gregorian date
DateTime toGregorian() {
// Simplified conversion back to Gregorian
final gregorianYear = year + 8;

    int gregorianMonth;
    int gregorianDay;

    if (month <= 4) {
      gregorianMonth = month + 8;
      gregorianDay = day;
    } else {
      gregorianMonth = month - 4;
      gregorianDay = day;
    }

    // Adjust for edge cases
    if (gregorianMonth > 12) {
      gregorianMonth -= 12;
      // Note: Year adjustment would go here
    }

    return DateTime(gregorianYear, gregorianMonth, gregorianDay);

}

@override
String toString() {
return 'EthiopianDateTime{year: $year, month: $month, day: $day}';
}
}

class CalendarUtils {
static CalendarType get currentCalendar {
return CalendarType.gregorian; // Default, will be overridden by provider
}

static Future<void> setCalendarType(CalendarType type) async {
final prefs = await SharedPreferences.getInstance();
await prefs.setInt('preferred_calendar', type.index);
}

// Date conversion utilities
static EthiopianDateTime toEthiopian(DateTime gregorianDate) {
return EthiopianDateTime.fromGregorian(gregorianDate);
}

static DateTime toGregorian(EthiopianDateTime ethiopianDate) {
return ethiopianDate.toGregorian();
}

// Format date based on selected calendar
static String formatDate(
DateTime date, CalendarType calendarType, BuildContext context) {
final locale = Localizations.localeOf(context);

    if (calendarType == CalendarType.ethiopian) {
      final ethiopianDate = toEthiopian(date);
      return '${ethiopianDate.day}/${ethiopianDate.month}/${ethiopianDate.year}';
    } else {
      return DateFormat('dd/MM/yyyy', locale.languageCode).format(date);
    }

}

static String formatFullDate(
DateTime date, CalendarType calendarType, BuildContext context) {
final locale = Localizations.localeOf(context);

    if (calendarType == CalendarType.ethiopian) {
      final ethiopianDate = toEthiopian(date);
      final monthNames = getEthiopianMonthNames(locale.languageCode);
      final weekdayNames = getEthiopianWeekdayNames(locale.languageCode);

      return '${weekdayNames[date.weekday - 1]}, ${ethiopianDate.day} ${monthNames[ethiopianDate.month - 1]} ${ethiopianDate.year}';
    } else {
      return DateFormat('EEEE, MMMM d, y', locale.languageCode).format(date);
    }

}

static String formatDateTime(
DateTime date, CalendarType calendarType, BuildContext context) {
final locale = Localizations.localeOf(context);
final timeFormat = DateFormat('HH:mm', locale.languageCode);

    if (calendarType == CalendarType.ethiopian) {
      final ethiopianDate = toEthiopian(date);
      return '${ethiopianDate.day}/${ethiopianDate.month}/${ethiopianDate.year} ${timeFormat.format(date)}';
    } else {
      return DateFormat('dd/MM/yyyy HH:mm', locale.languageCode).format(date);
    }

}

// Get current date in selected calendar
static String getCurrentDate(
CalendarType calendarType, BuildContext context) {
return formatDate(DateTime.now(), calendarType, context);
}

static String getCurrentFullDate(
CalendarType calendarType, BuildContext context) {
return formatFullDate(DateTime.now(), calendarType, context);
}

// Ethiopian calendar names
static List<String> getEthiopianMonthNames(String languageCode) {
if (languageCode == 'am') {
return [
'·àò·àµ·ä®·à®·àù',
'·å•·âÖ·àù·âµ',
'·äÖ·ã≥·à≠',
'·â≥·àÖ·à£·à•',
'·å•·à≠',
'·ã®·ä´·â≤·âµ',
'·àò·åã·â¢·âµ',
'·àö·ã´·ãù·ã´',
'·åç·äï·â¶·âµ',
'·à∞·äî',
'·àê·àù·àå',
'·äê·àê·à¥',
'·å≥·åâ·àú'
];
} else {
return [
'Meskerem',
'Tikimit',
'Hidar',
'Tahsas',
'Tir',
'Yekatit',
'Megabit',
'Miyazya',
'Ginbot',
'Sene',
'Hamle',
'Nehase',
'Pagume'
];
}
}

static List<String> getEthiopianWeekdayNames(String languageCode) {
if (languageCode == 'am') {
return ['·à∞·äû', '·àõ·ä≠·à∞·äû', '·à®·â°·ãï', '·àê·àô·àµ', '·ãì·à≠·â•', '·âÖ·ã≥·àú', '·ä•·àë·ãµ'];
} else {
return [
'Monday',
'Tuesday',
'Wednesday',
'Thursday',
'Friday',
'Saturday',
'Sunday'
];
}
}

// Date range utilities
static Map<String, DateTime> getDateRange(
CalendarType calendarType, String rangeType) {
final now = DateTime.now();

    switch (rangeType) {
      case 'today':
        return {
          'start': DateTime(now.year, now.month, now.day),
          'end': DateTime(now.year, now.month, now.day, 23, 59, 59),
        };
      case 'week':
        final start = now.subtract(Duration(days: now.weekday - 1));
        return {
          'start': DateTime(start.year, start.month, start.day),
          'end': DateTime(now.year, now.month, now.day, 23, 59, 59),
        };
      case 'month':
        return {
          'start': DateTime(now.year, now.month, 1),
          'end': DateTime(now.year, now.month + 1, 0, 23, 59, 59),
        };
      default:
        return {
          'start': DateTime(now.year, now.month, now.day),
          'end': DateTime(now.year, now.month, now.day, 23, 59, 59),
        };
    }

}

// Validation for Ethiopian dates
static bool isValidEthiopianDate(int year, int month, int day) {
if (month < 1 || month > 13) return false;
if (day < 1 || day > 30) return false;
// Pagume (13th month) has 5-6 days in leap years
if (month == 13 && day > 6) return false;
return true;
}

// Get display name for calendar type
static String getCalendarDisplayName(CalendarType type, String languageCode) {
if (languageCode == 'am') {
return type.amharicName;
} else {
return type.englishName;
}
}

// Check if date is Ethiopian New Year (September 11)
static bool isEthiopianNewYear(DateTime date) {
return date.month == 9 && date.day == 11;
}

// Get Ethiopian year from Gregorian date
static int getEthiopianYear(DateTime gregorianDate) {
final ethDate = toEthiopian(gregorianDate);
return ethDate.year;
}
}

// JSON utility for encoding/decoding

// Extension for easy JSON serialization
extension CalendarSettingsJson on CalendarSettings {
String toJson() => json.encode(toMap());

static CalendarSettings fromJson(String jsonString) {
return CalendarSettings.fromMap(json.decode(jsonString));
}
}

##

// lib/src/utils/chart_formatters.dart
// Utility class for formatting numbers in charts, including currency and percentage formats.
import 'package:intl/intl.dart';

class ChartFormatters {
static NumberFormat get currencyFormat {
return NumberFormat.currency(
symbol: 'ETB ',
decimalDigits: 2,
);
}

static NumberFormat get compactCurrency {
return NumberFormat.compactCurrency(
symbol: 'ETB ',
decimalDigits: 0,
);
}

static NumberFormat get percentageFormat {
return NumberFormat.percentPattern();
}
}

##

// lib/src/utils/database_init.dart
// Utility for initializing the database with default data such as business profile and admin user.
import 'package:andalus_smart_pos/src/data/local/database.dart';
import 'package:andalus_smart_pos/src/data/models/user.dart';
import 'package:crypto/crypto.dart';
import 'dart:convert';

import 'package:sqflite/sqflite.dart';

class DatabaseInitializer {
static Future<void> initializeDefaultData() async {
final db = await AppDatabase.database;

    // First, create a default business profile if it doesn't exist
    await _createDefaultBusiness(db);

    // Then create default admin user
    await _createDefaultAdminUser(db);

}

static Future<void> \_createDefaultBusiness(Database db) async {
final businesses = await db.query('business_profile');
if (businesses.isEmpty) {
final now = DateTime.now().millisecondsSinceEpoch;
await db.insert('business_profile', {
'business_id': 'business_001',
'name': 'Andalus POS Shop',
'name_am': '·ä†·äï·ã∞·àâ·àµ ·çñ·àµ ·à±·âÖ',
'business_type': 'Retail',
'phone': '+251911223344',
'email': 'info@andaluspos.com',
'address': 'Addis Ababa, Ethiopia',
'city': 'Addis Ababa',
'region': 'Addis Ababa',
'tin_number': '0000000000',
'vat_number': 'VAT000000',
'business_license': 'LIC001',
'owner_name': 'Admin User',
'owner_phone': '+251911223344',
'owner_email': 'admin@andaluspos.com',
'currency': 'ETB',
'logo_path': null,
'receipt_header':
'Andalus Smart POS\nMobile-first POS for Ethiopian Shops',
'receipt_footer': 'Thank you for your business!',
'is_active': 1,
'created_at': now,
'updated_at': now,
});
print('Default business profile created');
}
}

static Future<void> \_createDefaultAdminUser(Database db) async {
final users = await db.query('users');
if (users.isEmpty) {
// Create default admin user with password hash
final adminUser = User(
id: 'admin_001',
name: 'Admin User',
phone: '+911223344', // Change this to your admin phone
email: 'admin@andaluspos.com',
role: UserRole.owner,
createdAt: DateTime.now(),
isActive: true,
isVerified: true,
businessId: 'business_001',
passwordHash: \_hashPassword('admin123'), // Set password hash directly
);

      await db.insert('users', adminUser.toMap());
      print(
          'Default admin user created with phone: ${adminUser.phone} and password: admin123');
    }

}

static String \_hashPassword(String password) {
// Simple hashing for demo - in production use more secure hashing
final bytes = utf8.encode(password);
final digest = sha256.convert(bytes);
return digest.toString();
}
}

##

// src/utils/date_utils.dart
// Utility class for date and time formatting, conversions, and calculations,
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import 'package:andalus_smart_pos/src/providers/calendar_provider.dart';
import 'package:andalus_smart_pos/src/providers/language_provider.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart'; // Import the actual AppLocalizations
import 'ethiopian_calendar.dart';

class AppDateUtils {
// Date formats
static final DateFormat \_dateFormat = DateFormat('dd/MM/yyyy');
static final DateFormat \_timeFormat = DateFormat('HH:mm');
static final DateFormat \_dateTimeFormat = DateFormat('dd/MM/yyyy HH:mm');
static final DateFormat \_fullDateFormat = DateFormat('EEEE, MMMM d, y');
static final DateFormat \_monthYearFormat = DateFormat('MMMM y');
static final DateFormat \_weekdayFormat = DateFormat('EEEE');
static final DateFormat \_shortDateFormat = DateFormat('MMM d, y');

// Ethiopian date formats (Amharic)
static final DateFormat \_ethiopianDateFormat =
DateFormat('dd/MM/yyyy', 'am_ET');
static final DateFormat \_ethiopianDateTimeFormat =
DateFormat('dd/MM/yyyy HH:mm', 'am_ET');

// Basic date formatting
static String formatDate(DateTime date) {
return \_dateFormat.format(date);
}

static String formatTime(DateTime date) {
return \_timeFormat.format(date);
}

static String formatDateTime(DateTime date) {
return \_dateTimeFormat.format(date);
}

static String formatFullDate(DateTime date) {
return \_fullDateFormat.format(date);
}

static String formatMonthYear(DateTime date) {
return \_monthYearFormat.format(date);
}

static String formatWeekday(DateTime date) {
return \_weekdayFormat.format(date);
}

static String formatShortDate(DateTime date) {
return \_shortDateFormat.format(date);
}

// Ethiopian date formatting
static String formatEthiopianDate(DateTime date) {
return \_ethiopianDateFormat.format(date);
}

static String formatEthiopianDateTime(DateTime date) {
return \_ethiopianDateTimeFormat.format(date);
}

// Get current date in selected calendar
static String getCurrentDate(BuildContext context, WidgetRef ref) {
final calendarSettings = ref.read(calendarProvider);
final now = DateTime.now();

    if (calendarSettings.calendarType == CalendarType.ethiopian) {
      final ethDate = EthiopianCalendar.gregorianToEthiopian(now);
      return '${ethDate.day}/${ethDate.month}/${ethDate.year}';
    } else {
      return formatDate(now);
    }

}

static String getCurrentFullDate(BuildContext context, WidgetRef ref) {
final calendarSettings = ref.read(calendarProvider);
final now = DateTime.now();
final locale = Localizations.localeOf(context);

    if (calendarSettings.calendarType == CalendarType.ethiopian) {
      final ethDate = EthiopianCalendar.gregorianToEthiopian(now);
      return EthiopianCalendar.formatDate(ethDate, locale.languageCode);
    } else {
      return formatFullDate(now);
    }

}

static String getCurrentDateDisplay(WidgetRef ref) {
final now = DateTime.now();
final calendarSettings = ref.read(calendarProvider);
final locale = ref.read(languageProvider);

    if (calendarSettings.calendarType == CalendarType.ethiopian) {
      final ethDate = EthiopianCalendar.gregorianToEthiopian(now);
      return '${ethDate.day}/${ethDate.month}/${ethDate.year}';
    } else {
      return formatDate(now);
    }

}

static String formatLiveTime(DateTime time, WidgetRef ref) {
return DateFormat('HH:mm:ss').format(time);
}

static String formatDateBasedOnCalendar(
DateTime date, CalendarType calendarType, BuildContext context) {
if (calendarType == CalendarType.ethiopian) {
final ethDate = EthiopianCalendar.gregorianToEthiopian(date);
return '${ethDate.day}/${ethDate.month}/${ethDate.year}';
} else {
return formatDate(date);
}
}

static String formatFullDateBasedOnCalendar(
DateTime date, CalendarType calendarType, BuildContext context) {
if (calendarType == CalendarType.ethiopian) {
final ethDate = EthiopianCalendar.gregorianToEthiopian(date);
final locale = Localizations.localeOf(context);
return EthiopianCalendar.formatDate(ethDate, locale.languageCode);
} else {
return formatFullDate(date);
}
}

// Get live date time with proper ref
static String getLiveDateTime(BuildContext context, WidgetRef ref) {
final now = DateTime.now();
final calendarSettings = ref.read(calendarProvider);
final timeFormat = DateFormat('HH:mm:ss');

    if (calendarSettings.calendarType == CalendarType.ethiopian) {
      final ethDate = EthiopianCalendar.gregorianToEthiopian(now);
      return '${ethDate.day}/${ethDate.month}/${ethDate.year} ${timeFormat.format(now)}';
    } else {
      return DateFormat('dd/MM/yyyy HH:mm:ss').format(now);
    }

}

// Relative time formatting
static String formatRelativeTime(DateTime date) {
final now = DateTime.now();
final difference = now.difference(date);

    if (difference.inSeconds < 60) {
      return 'Just now';
    } else if (difference.inMinutes < 60) {
      return '${difference.inMinutes} min ago';
    } else if (difference.inHours < 24) {
      return '${difference.inHours} hr ago';
    } else if (difference.inDays < 7) {
      return '${difference.inDays} days ago';
    } else {
      return formatDate(date);
    }

}

// Business date utilities
static DateTime get startOfToday {
final now = DateTime.now();
return DateTime(now.year, now.month, now.day);
}

static DateTime get endOfToday {
final now = DateTime.now();
return DateTime(now.year, now.month, now.day, 23, 59, 59, 999);
}

static DateTime get startOfWeek {
final now = DateTime.now();
final weekday = now.weekday;
return DateTime(now.year, now.month, now.day - weekday + 1);
}

static DateTime get endOfWeek {
final now = DateTime.now();
final weekday = now.weekday;
return DateTime(
now.year, now.month, now.day + (7 - weekday), 23, 59, 59, 999);
}

static DateTime get startOfMonth {
final now = DateTime.now();
return DateTime(now.year, now.month, 1);
}

static DateTime get endOfMonth {
final now = DateTime.now();
return DateTime(now.year, now.month + 1, 0, 23, 59, 59, 999);
}

static DateTime get startOfYear {
final now = DateTime.now();
return DateTime(now.year, 1, 1);
}

static DateTime get endOfYear {
final now = DateTime.now();
return DateTime(now.year, 12, 31, 23, 59, 59, 999);
}

// Date range utilities
static List<DateTime> getLast7Days() {
final List<DateTime> days = [];
for (int i = 6; i >= 0; i--) {
days.add(DateTime.now().subtract(Duration(days: i)));
}
return days;
}

static List<DateTime> getLast30Days() {
final List<DateTime> days = [];
for (int i = 29; i >= 0; i--) {
days.add(DateTime.now().subtract(Duration(days: i)));
}
return days;
}

static List<DateTime> getLast90Days() {
final List<DateTime> days = [];
for (int i = 89; i >= 0; i--) {
days.add(DateTime.now().subtract(Duration(days: i)));
}
return days;
}

static List<DateTime> getLast365Days() {
final List<DateTime> days = [];
for (int i = 364; i >= 0; i--) {
days.add(DateTime.now().subtract(Duration(days: i)));
}
return days;
}

// Validation utilities
static bool isToday(DateTime date) {
final now = DateTime.now();
return date.year == now.year &&
date.month == now.month &&
date.day == now.day;
}

static bool isYesterday(DateTime date) {
final yesterday = DateTime.now().subtract(const Duration(days: 1));
return date.year == yesterday.year &&
date.month == yesterday.month &&
date.day == yesterday.day;
}

static bool isThisWeek(DateTime date) {
final now = DateTime.now();
final startOfWeek =
DateTime(now.year, now.month, now.day - now.weekday + 1);
final endOfWeek =
DateTime(now.year, now.month, now.day + (7 - now.weekday), 23, 59, 59);
return date.isAfter(startOfWeek) && date.isBefore(endOfWeek);
}

static bool isThisMonth(DateTime date) {
final now = DateTime.now();
return date.year == now.year && date.month == now.month;
}

static bool isThisYear(DateTime date) {
final now = DateTime.now();
return date.year == now.year;
}

// Age calculation
static int calculateAge(DateTime birthDate) {
final now = DateTime.now();
int age = now.year - birthDate.year;
if (now.month < birthDate.month ||
(now.month == birthDate.month && now.day < birthDate.day)) {
age--;
}
return age;
}

// Due date calculations for credit management
static DateTime calculateDueDate(DateTime fromDate, int days) {
return fromDate.add(Duration(days: days));
}

static bool isOverdue(DateTime dueDate) {
return DateTime.now().isAfter(dueDate);
}

static int daysUntilDue(DateTime dueDate) {
final now = DateTime.now();
final difference = dueDate.difference(now);
return difference.inDays;
}

static int daysOverdue(DateTime dueDate) {
final now = DateTime.now();
final difference = now.difference(dueDate);
return difference.inDays;
}

static String formatDueDate(DateTime dueDate) {
if (isOverdue(dueDate)) {
final int overdueDays = daysOverdue(dueDate);

      return '$overdueDays days overdue';
    } else {
      final daysUntil = daysUntilDue(dueDate);
      return 'Due in $daysUntil days';
    }

}

// Sales period formatting
static String formatSalesPeriod(DateTime start, DateTime end) {
if (isToday(start) && isToday(end)) {
return 'Today';
} else if (isThisWeek(start) && isThisWeek(end)) {
return 'This Week';
} else if (isThisMonth(start) && isThisMonth(end)) {
return 'This Month';
} else {
return '${formatDate(start)} - ${formatDate(end)}';
}
}

// Ethiopian calendar utilities
static EthiopianDate toEthiopianDate(DateTime gregorianDate) {
return EthiopianCalendar.gregorianToEthiopian(gregorianDate);
}

static DateTime toGregorianDate(EthiopianDate ethiopianDate) {
return EthiopianCalendar.ethiopianToGregorian(ethiopianDate);
}

// Time utility for business hours
static bool isBusinessHours(DateTime time) {
final hour = time.hour;
return hour >= 8 && hour <= 20; // 8 AM to 8 PM
}

static String formatBusinessHours(DateTime time) {
if (isBusinessHours(time)) {
return 'Open';
} else {
return 'Closed';
}
}

// Duration formatting
static String formatDuration(Duration duration) {
if (duration.inDays > 0) {
return '${duration.inDays}d ${duration.inHours.remainder(24)}h ${duration.inMinutes.remainder(60)}m';
    } else if (duration.inHours > 0) {
      return '${duration.inHours}h ${duration.inMinutes.remainder(60)}m';
    } else if (duration.inMinutes > 0) {
      return '${duration.inMinutes}m';
} else {
return '${duration.inSeconds}s';
}
}

static String formatDurationShort(Duration duration) {
if (duration.inDays > 0) {
return '${duration.inDays}d';
    } else if (duration.inHours > 0) {
      return '${duration.inHours}h';
} else if (duration.inMinutes > 0) {
return '${duration.inMinutes}m';
    } else {
      return '${duration.inSeconds}s';
}
}

// Date comparison for sorting
static int compareDates(DateTime a, DateTime b) {
return b.compareTo(a); // Descending order (newest first)
}

static int compareDatesAscending(DateTime a, DateTime b) {
return a.compareTo(b); // Ascending order (oldest first)
}

// Get readable time ago string
static String getTimeAgo(DateTime date) {
final now = DateTime.now();
final difference = now.difference(date);

    if (difference.inDays > 365) {
      final years = (difference.inDays / 365).floor();
      return '$years year${years > 1 ? 's' : ''} ago';
    } else if (difference.inDays > 30) {
      final months = (difference.inDays / 30).floor();
      return '$months month${months > 1 ? 's' : ''} ago';
    } else if (difference.inDays > 0) {
      return '${difference.inDays} day${difference.inDays > 1 ? 's' : ''} ago';
    } else if (difference.inHours > 0) {
      return '${difference.inHours} hour${difference.inHours > 1 ? 's' : ''} ago';
    } else if (difference.inMinutes > 0) {
      return '${difference.inMinutes} minute${difference.inMinutes > 1 ? 's' : ''} ago';
    } else {
      return 'Just now';
    }

}

// Quick date presets for reports and analytics
static Map<String, DateTimeRange> getDatePresets() {
final now = DateTime.now();
return {
'today': DateTimeRange(
start: DateTime(now.year, now.month, now.day),
end: DateTime(now.year, now.month, now.day, 23, 59, 59),
),
'yesterday': DateTimeRange(
start: DateTime(now.year, now.month, now.day - 1),
end: DateTime(now.year, now.month, now.day - 1, 23, 59, 59),
),
'this_week': DateTimeRange(
start: DateTime(now.year, now.month, now.day - now.weekday + 1),
end: DateTime(now.year, now.month, now.day, 23, 59, 59),
),
'last_week': DateTimeRange(
start: DateTime(now.year, now.month, now.day - now.weekday - 6),
end: DateTime(now.year, now.month, now.day - now.weekday, 23, 59, 59),
),
'this_month': DateTimeRange(
start: DateTime(now.year, now.month, 1),
end: DateTime(now.year, now.month + 1, 0, 23, 59, 59),
),
'last_month': DateTimeRange(
start: DateTime(now.year, now.month - 1, 1),
end: DateTime(now.year, now.month, 0, 23, 59, 59),
),
'last_3_months': DateTimeRange(
start: DateTime(now.year, now.month - 3, 1),
end: DateTime(now.year, now.month, 0, 23, 59, 59),
),
'last_6_months': DateTimeRange(
start: DateTime(now.year, now.month - 6, 1),
end: DateTime(now.year, now.month, 0, 23, 59, 59),
),
'this_year': DateTimeRange(
start: DateTime(now.year, 1, 1),
end: DateTime(now.year, 12, 31, 23, 59, 59),
),
'last_year': DateTimeRange(
start: DateTime(now.year - 1, 1, 1),
end: DateTime(now.year - 1, 12, 31, 23, 59, 59),
),
};
}

// Get display name for date presets
static String getDatePresetDisplayName(
String presetKey, BuildContext context) {
final localizations = AppLocalizations.of(context);

    switch (presetKey) {
      case 'today':
        return localizations.today;
      case 'yesterday':
        return localizations.translate('yesterday');
      case 'this_week':
        return localizations.translate('thisWeek');
      case 'last_week':
        return localizations.translate('lastWeek');
      case 'this_month':
        return localizations.thisMonth;
      case 'last_month':
        return localizations.translate('lastMonth');
      case 'last_3_months':
        return localizations.translate('last3Months');
      case 'last_6_months':
        return localizations.translate('last6Months');
      case 'this_year':
        return localizations.translate('thisYear');
      case 'last_year':
        return localizations.translate('lastYear');
      default:
        return presetKey;
    }

}

// Date range calculations
static int getDaysBetween(DateTime from, DateTime to) {
return to.difference(from).inDays;
}

static int getMonthsBetween(DateTime from, DateTime to) {
return (to.year - from.year) \* 12 + to.month - from.month;
}

static int getYearsBetween(DateTime from, DateTime to) {
return to.year - from.year;
}

// Ethiopian calendar specific utilities
static bool isEthiopianLeapYear(int ethYear) {
return EthiopianCalendar.isEthiopianLeapYear(ethYear);
}

static String getEthiopianMonthName(int month, String languageCode) {
final monthNames = EthiopianCalendar.getMonthNames(languageCode);
return monthNames[month - 1];
}

static String getEthiopianWeekdayName(int weekday, String languageCode) {
final weekdayNames = EthiopianCalendar.getWeekdayNames(languageCode);
return weekdayNames[weekday - 1];
}

// Date validation
static bool isValidDate(int year, int month, int day) {
try {
DateTime(year, month, day);
return true;
} catch (e) {
return false;
}
}

static bool isValidEthiopianDate(int year, int month, int day) {
return EthiopianCalendar.isValidEthiopianDate(year, month, day);
}

// Date manipulation
static DateTime addDays(DateTime date, int days) {
return date.add(Duration(days: days));
}

static DateTime subtractDays(DateTime date, int days) {
return date.subtract(Duration(days: days));
}

static DateTime addMonths(DateTime date, int months) {
return DateTime(date.year, date.month + months, date.day);
}

static DateTime subtractMonths(DateTime date, int months) {
return DateTime(date.year, date.month - months, date.day);
}

static DateTime addYears(DateTime date, int years) {
return DateTime(date.year + years, date.month, date.day);
}

static DateTime subtractYears(DateTime date, int years) {
return DateTime(date.year - years, date.month, date.day);
}

// First and last day of month
static DateTime getFirstDayOfMonth(DateTime date) {
return DateTime(date.year, date.month, 1);
}

static DateTime getLastDayOfMonth(DateTime date) {
return DateTime(date.year, date.month + 1, 0);
}

// Week number calculations
static int getWeekNumber(DateTime date) {
final firstDayOfYear = DateTime(date.year, 1, 1);
final days = date.difference(firstDayOfYear).inDays;
return ((days + firstDayOfYear.weekday - 1) / 7).floor() + 1;
}

// Quarter calculations
static int getQuarter(DateTime date) {
return ((date.month - 1) / 3).floor() + 1;
}

static DateTime getFirstDayOfQuarter(DateTime date) {
final quarter = getQuarter(date);
final month = (quarter - 1) \* 3 + 1;
return DateTime(date.year, month, 1);
}

static DateTime getLastDayOfQuarter(DateTime date) {
final quarter = getQuarter(date);
final month = quarter \* 3;
return DateTime(date.year, month + 1, 0);
}

// Ethiopian calendar quarter calculations
static int getEthiopianQuarter(EthiopianDate ethDate) {
return ((ethDate.month - 1) / 3).floor() + 1;
}

static EthiopianDate getFirstDayOfEthiopianQuarter(EthiopianDate ethDate) {
final quarter = getEthiopianQuarter(ethDate);
final month = (quarter - 1) \* 3 + 1;
return EthiopianDate(year: ethDate.year, month: month, day: 1);
}

static EthiopianDate getLastDayOfEthiopianQuarter(EthiopianDate ethDate) {
final quarter = getEthiopianQuarter(ethDate);
final month = quarter \* 3;
return EthiopianDate(year: ethDate.year, month: month, day: 30);
}

// Date range string for display
static String formatDateRange(
DateTimeRange range, BuildContext context, WidgetRef ref) {
final calendarSettings = ref.read(calendarProvider);

    final start = formatDateBasedOnCalendar(
        range.start, calendarSettings.calendarType, context);
    final end = formatDateBasedOnCalendar(
        range.end, calendarSettings.calendarType, context);

    return '$start - $end';

}

// Check if date is within range
static bool isDateInRange(DateTime date, DateTimeRange range) {
return (date.isAfter(range.start) || date.isAtSameMomentAs(range.start)) &&
(date.isBefore(range.end) || date.isAtSameMomentAs(range.end));
}

// Get current Ethiopian date
static EthiopianDate getCurrentEthiopianDate() {
return EthiopianCalendar.getCurrentEthiopianDate();
}

// Format Ethiopian date for display
static String formatEthiopianDateForDisplay(
EthiopianDate ethDate, String languageCode) {
return ethDate.toFormattedString(languageCode);
}

// Get Ethiopian date components
static Map<String, dynamic> getEthiopianDateComponents(
DateTime gregorianDate) {
final ethDate = EthiopianCalendar.gregorianToEthiopian(gregorianDate);
return {
'year': ethDate.year,
'month': ethDate.month,
'day': ethDate.day,
'month_name_en': EthiopianCalendar.getMonthNames('en')[ethDate.month - 1],
'month_name_am': EthiopianCalendar.getMonthNames('am')[ethDate.month - 1],
'weekday_en':
EthiopianCalendar.getWeekdayNames('en')[gregorianDate.weekday - 1],
'weekday_am':
EthiopianCalendar.getWeekdayNames('am')[gregorianDate.weekday - 1],
};
}
}

##

// utils/ethiopian_calendar.dart
// Utility class for Ethiopian calendar conversions and date handling.
// Provides functions to convert between Gregorian and Ethiopian dates,
// check leap years, and format Ethiopian dates.

class EthiopianCalendar {
// Accurate Ethiopian calendar conversion constants
static const int ETHIOPIAN_YEAR_OFFSET = 8;
static const int JDN_OFFSET = 1723856;
static const int ETHIOPIAN_EPOCH = 1724221; // JD of 1 M√§sk√§r√§m 1 ETH

static const List<int> MONTH_DAYS = [
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
5
];
static const List<String> MONTH_NAMES_EN = [
'Meskerem',
'Tikimit',
'Hidar',
'Tahsas',
'Tir',
'Yekatit',
'Megabit',
'Miyazya',
'Ginbot',
'Sene',
'Hamle',
'Nehase',
'Pagume'
];
static const List<String> MONTH_NAMES_AM = [
'·àò·àµ·ä®·à®·àù',
'·å•·âÖ·àù·âµ',
'·äÖ·ã≥·à≠',
'·â≥·àÖ·à£·à•',
'·å•·à≠',
'·ã®·ä´·â≤·âµ',
'·àò·åã·â¢·âµ',
'·àö·ã´·ãù·ã´',
'·åç·äï·â¶·âµ',
'·à∞·äî',
'·àê·àù·àå',
'·äê·àÉ·à¥',
'·å≥·åâ·àú'
];
static const List<String> WEEKDAY_NAMES_EN = [
'Monday',
'Tuesday',
'Wednesday',
'Thursday',
'Friday',
'Saturday',
'Sunday'
];
static const List<String> WEEKDAY_NAMES_AM = [
'·à∞·äû',
'·àõ·ä≠·à∞·äû',
'·à®·â°·ãï',
'·àê·àô·àµ',
'·ãì·à≠·â•',
'·âÖ·ã≥·àú',
'·ä•·àë·ãµ'
];

// Convert Gregorian to Julian Day Number
static int \_toJulianDay(DateTime gregorianDate) {
int year = gregorianDate.year;
int month = gregorianDate.month;
int day = gregorianDate.day;

    int a = (14 - month) ~/ 12;
    int y = year + 4800 - a;
    int m = month + 12 * a - 3;

    return day +
        (153 * m + 2) ~/ 5 +
        365 * y +
        y ~/ 4 -
        y ~/ 100 +
        y ~/ 400 -
        32045;

}

// Convert Julian Day Number to Gregorian
static DateTime \_fromJulianDay(int jd) {
int a = jd + 32044;
int b = (4 _ a + 3) ~/ 146097;
int c = a - (146097 _ b) ~/ 4;
int d = (4 _ c + 3) ~/ 1461;
int e = c - (1461 _ d) ~/ 4;
int m = (5 \* e + 2) ~/ 153;

    int day = e - (153 * m + 2) ~/ 5 + 1;
    int month = m + 3 - 12 * (m ~/ 10);
    int year = 100 * b + d - 4800 + (m ~/ 10);

    return DateTime(year, month, day);

}

// Convert Gregorian to Ethiopian date (ACCURATE)
static EthiopianDate gregorianToEthiopian(DateTime gregorianDate) {
int jd = \_toJulianDay(gregorianDate);

    // Calculate Ethiopian date from Julian Day
    int n = jd - ETHIOPIAN_EPOCH;
    int year = 4 * n ~/ 1461;
    int remainder = n - 1461 * year ~/ 4;
    int month = remainder ~/ 30 + 1;
    int day = remainder % 30 + 1;

    return EthiopianDate(year: year + 1, month: month, day: day);

}

// Convert Ethiopian to Gregorian date (ACCURATE)
static DateTime ethiopianToGregorian(EthiopianDate ethDate) {
int jd = ETHIOPIAN_EPOCH +
365 _ (ethDate.year - 1) +
(ethDate.year - 1) ~/ 4 +
30 _ (ethDate.month - 1) +
(ethDate.day - 1);

    return _fromJulianDay(jd);

}

// Check if Ethiopian year is leap year
static bool isEthiopianLeapYear(int ethYear) {
return (ethYear % 4) == 3;
}

// Get month names
static List<String> getMonthNames(String languageCode) {
return languageCode == 'am' ? MONTH_NAMES_AM : MONTH_NAMES_EN;
}

// Get weekday names
static List<String> getWeekdayNames(String languageCode) {
return languageCode == 'am' ? WEEKDAY_NAMES_AM : WEEKDAY_NAMES_EN;
}

// Format Ethiopian date
static String formatDate(EthiopianDate ethDate, String languageCode) {
final monthNames = getMonthNames(languageCode);
final weekdayNames = getWeekdayNames(languageCode);

    final gregorianDate = ethiopianToGregorian(ethDate);
    final weekday = gregorianDate.weekday - 1;

    return '${weekdayNames[weekday]}, ${ethDate.day} ${monthNames[ethDate.month - 1]} ${ethDate.year}';

}

// Get current Ethiopian date
static EthiopianDate getCurrentEthiopianDate() {
return gregorianToEthiopian(DateTime.now());
}

// Validate Ethiopian date
static bool isValidEthiopianDate(int year, int month, int day) {
if (month < 1 || month > 13) return false;
if (day < 1) return false;

    if (month == 13) {
      // Pagume has 5-6 days
      int maxDays = isEthiopianLeapYear(year) ? 6 : 5;
      return day <= maxDays;
    } else {
      return day <= 30;
    }

}
}

class EthiopianDate {
final int year;
final int month;
final int day;

const EthiopianDate({
required this.year,
required this.month,
required this.day,
});

@override
String toString() {
return '$day/$month/$year';
}

String toFormattedString(String languageCode) {
final monthNames = EthiopianCalendar.getMonthNames(languageCode);
return '${day} ${monthNames[month - 1]} ${year}';
}
}

##

// lib/src/utils/formatters.dart
// Utility class for various formatting needs across the app,

import 'package:intl/intl.dart';

class AppFormatters {
// Currency formatting for Ethiopian Birr
static final NumberFormat \_currencyFormat = NumberFormat.currency(
symbol: 'ETB ',
decimalDigits: 2,
);

static final NumberFormat \_compactCurrency = NumberFormat.compactCurrency(
symbol: 'ETB ',
decimalDigits: 0,
);

// Number formatting
static final NumberFormat \_numberFormat = NumberFormat('#,##0');
static final NumberFormat \_decimalFormat = NumberFormat('#,##0.00');

static String formatCurrency(double amount) {
return \_currencyFormat.format(amount);
}

static String formatCompactCurrency(double amount) {
return \_compactCurrency.format(amount);
}

static String formatNumber(int number) {
return \_numberFormat.format(number);
}

static String formatDecimal(double number) {
return \_decimalFormat.format(number);
}

static String formatPercentage(double value) {
return '${(value \* 100).toStringAsFixed(1)}%';
}

// Phone number formatting for Ethiopia
static String formatPhoneNumber(String phone) {
if (phone.startsWith('+251')) {
return phone.replaceFirstMapped(RegExp(r'(\+251)(\d{2})(\d{3})(\d{4})'),
(match) => '${match[1]} ${match[2]} ${match[3]} ${match[4]}');
    } else if (phone.startsWith('251')) {
      return phone.replaceFirstMapped(RegExp(r'(251)(\d{2})(\d{3})(\d{4})'),
          (match) => '+${match[1]} ${match[2]} ${match[3]} ${match[4]}');
} else if (phone.startsWith('0')) {
return phone.replaceFirstMapped(RegExp(r'(0)(\d{2})(\d{3})(\d{4})'),
(match) => '+251 ${match[2]} ${match[3]} ${match[4]}');
}
return phone;
}

// TIN number formatting
static String formatTIN(String tin) {
if (tin.length == 10) {
return '${tin.substring(0, 3)}-${tin.substring(3, 6)}-${tin.substring(6)}';
}
return tin;
}

// Text capitalization
static String capitalize(String text) {
if (text.isEmpty) return text;
return text[0].toUpperCase() + text.substring(1).toLowerCase();
}

static String titleCase(String text) {
if (text.isEmpty) return text;
return text.split(' ').map((word) => capitalize(word)).join(' ');
}
}

##

// lib/src/utils/print_service.dart
// Service for managing Bluetooth printer connections and printing receipts using ESC/POS commands.
// Supports scanning for printers, connecting, and printing formatted receipts.
import 'package:andalus_smart_pos/src/data/models/sale.dart';
import 'package:esc_pos_utils_plus/esc_pos_utils_plus.dart';
import 'package:flutter/material.dart';
import 'package:flutter_blue_plus/flutter_blue_plus.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
// import 'package:esc_pos_utils/esc_pos_utils.dart';
import '../localization/app_localizations.dart';
import '../utils/formatters.dart';

class PrintService {
static BluetoothDevice? \_connectedDevice;
static BluetoothCharacteristic? \_printCharacteristic;
final printServiceProvider = Provider<PrintService>((ref) {
return PrintService();
});

// Scan for Bluetooth printers
static Stream<List<BluetoothDevice>> scanForPrinters() {
return FlutterBluePlus.scanResults.map((results) => results
.where((r) => \_isPotentialPrinter(r.device))
.map((r) => r.device)
.toList());
}

static bool \_isPotentialPrinter(BluetoothDevice device) {
// Thermal printers often have these in their name
final printerNames = [
'printer',
'print',
'pos',
'thermal',
'bt',
'bluetooth'
];
return printerNames
.any((name) => device.localName.toLowerCase().contains(name));
}

static Future<void> startScan() async {
await FlutterBluePlus.startScan(timeout: const Duration(seconds: 10));
}

static Future<void> stopScan() async {
await FlutterBluePlus.stopScan();
}

// Connect to a printer
static Future<bool> connectToPrinter(BluetoothDevice device) async {
try {
await device.connect();
final services = await device.discoverServices();

      for (var service in services) {
        for (var characteristic in service.characteristics) {
          // Look for the characteristic that supports writing (printing)
          if (characteristic.properties.write) {
            _printCharacteristic = characteristic;
            _connectedDevice = device;
            return true;
          }
        }
      }
      return false;
    } catch (e) {
      print('Connection error: $e');
      return false;
    }

}

// Disconnect from printer
static Future<void> disconnect() async {
if (\_connectedDevice != null) {
await \_connectedDevice!.disconnect();
\_connectedDevice = null;
\_printCharacteristic = null;
}
}

// Main print function
static Future<bool> printReceipt({
required BuildContext context,
required String shopName,
required String shopNameAm,
required String address,
required String phone,
required String tinNumber,
required String receiptNumber,
required DateTime dateTime,
required List<Map<String, dynamic>> items,
required double subtotal,
required double tax,
required double discount,
required double total,
required String paymentMethod,
String? telebirrRef,
required Sale sale,
required Map<String, String> businessInfo,
}) async {
if (\_printCharacteristic == null) {
\_showError(context, 'No printer connected');
return false;
}

    try {
      // Generate ESC/POS commands
      final bytes = await _generateReceiptBytes(
        context: context,
        shopName: shopName,
        shopNameAm: shopNameAm,
        address: address,
        phone: phone,
        tinNumber: tinNumber,
        receiptNumber: receiptNumber,
        dateTime: dateTime,
        items: items,
        subtotal: subtotal,
        tax: tax,
        discount: discount,
        total: total,
        paymentMethod: paymentMethod,
        telebirrRef: telebirrRef,
      );

      // Send to printer
      await _printCharacteristic!.write(bytes, withoutResponse: true);

      _showSuccess(context, 'Receipt printed successfully');
      return true;
    } catch (e) {
      _showError(context, 'Printing failed: $e');
      return false;
    }

}

static Future<List<int>> \_generateReceiptBytes({
required BuildContext context,
required String shopName,
required String shopNameAm,
required String address,
required String phone,
required String tinNumber,
required String receiptNumber,
required DateTime dateTime,
required List<Map<String, dynamic>> items,
required double subtotal,
required double tax,
required double discount,
required double total,
required String paymentMethod,
String? telebirrRef,
}) async {
final profile = await CapabilityProfile.load();
final generator = Generator(PaperSize.mm80, profile);
List<int> bytes = [];

    // Header
    bytes += generator.text(shopName,
        styles: const PosStyles(
            align: PosAlign.center, bold: true, height: PosTextSize.size2));
    bytes += generator.text(shopNameAm,
        styles: const PosStyles(align: PosAlign.center));
    bytes += generator.text(address,
        styles: const PosStyles(align: PosAlign.center));
    bytes += generator.text('Tel: ${AppFormatters.formatPhoneNumber(phone)}',
        styles: const PosStyles(align: PosAlign.center));
    bytes += generator.text('TIN: ${AppFormatters.formatTIN(tinNumber)}',
        styles: const PosStyles(align: PosAlign.center));

    bytes += generator.hr();

    // Receipt info
    bytes += generator.text('Receipt: $receiptNumber');
    bytes += generator.text('Date: ${_formatDate(dateTime)}');
    bytes += generator.text('Time: ${_formatTime(dateTime)}');

    bytes += generator.hr();

    // Items header
    bytes += generator.row([
      PosColumn(text: 'Item', width: 8, styles: const PosStyles(bold: true)),
      PosColumn(text: 'Qty', width: 2, styles: const PosStyles(bold: true)),
      PosColumn(text: 'Price', width: 4, styles: const PosStyles(bold: true)),
      PosColumn(text: 'Total', width: 6, styles: const PosStyles(bold: true)),
    ]);

    bytes += generator.hr();

    // Items
    for (final item in items) {
      final name = (item['name'] as String).length > 16
          ? '${(item['name'] as String).substring(0, 16)}.'
          : item['name'] as String;

      bytes += generator.row([
        PosColumn(text: name, width: 8),
        PosColumn(text: '${item['quantity']}', width: 2),
        PosColumn(
            text: '${(item['price'] as double).toStringAsFixed(2)}', width: 4),
        PosColumn(
            text: '${(item['total'] as double).toStringAsFixed(2)}', width: 6),
      ]);
    }

    bytes += generator.hr();

    // Totals
    bytes += generator.row([
      PosColumn(text: 'Subtotal:', width: 10),
      PosColumn(text: 'ETB ${subtotal.toStringAsFixed(2)}', width: 10),
    ]);

    if (tax > 0) {
      bytes += generator.row([
        PosColumn(text: 'Tax:', width: 10),
        PosColumn(text: 'ETB ${tax.toStringAsFixed(2)}', width: 10),
      ]);
    }

    if (discount > 0) {
      bytes += generator.row([
        PosColumn(text: 'Discount:', width: 10),
        PosColumn(text: '-ETB ${discount.toStringAsFixed(2)}', width: 10),
      ]);
    }

    bytes += generator.hr();

    bytes += generator.row([
      PosColumn(text: 'TOTAL:', width: 10, styles: const PosStyles(bold: true)),
      PosColumn(
          text: 'ETB ${total.toStringAsFixed(2)}',
          width: 10,
          styles: const PosStyles(bold: true)),
    ]);

    bytes += generator.hr();

    // Payment info
    bytes += generator.text(
        'Payment: ${_getPaymentMethodName(paymentMethod, AppLocalizations.of(context))}');

    if (telebirrRef != null) {
      bytes += generator.text('Ref: $telebirrRef');
    }

    bytes += generator.text('');
    bytes += generator.text('Thank you for your business!',
        styles: const PosStyles(align: PosAlign.center, bold: true));
    bytes += generator.text('·ä•·äì·àò·à∞·åç·äì·àà·äï!',
        styles: const PosStyles(align: PosAlign.center));

    bytes += generator.text('');
    bytes += generator.text('');

    // Cut paper
    bytes += generator.cut();

    return bytes;

}

static String \_getPaymentMethodName(
String method, AppLocalizations localizations) {
switch (method.toLowerCase()) {
case 'cash':
return localizations.cash;
case 'telebirr':
return localizations.telebirr;
case 'card':
return localizations.card;
case 'credit':
return localizations.credit;
case 'bank_transfer':
return localizations.bankTransfer;
default:
return method;
}
}

static String \_formatDate(DateTime date) {
return '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';
}

static String \_formatTime(DateTime date) {
return '${date.hour.toString().padLeft(2, '0')}:${date.minute.toString().padLeft(2, '0')}';
}

static void \_showError(BuildContext context, String message) {
ScaffoldMessenger.of(context).showSnackBar(
SnackBar(
content: Text(message),
backgroundColor: Colors.red,
),
);
}

static void \_showSuccess(BuildContext context, String message) {
ScaffoldMessenger.of(context).showSnackBar(
SnackBar(
content: Text(message),
backgroundColor: Colors.green,
),
);
}

// Get connection status
static bool get isConnected => \_connectedDevice != null;

static String get connectedDeviceName =>
\_connectedDevice?.localName ?? 'No printer connected';
}

##

// lib/src/utils/reports_data_calculator.dart
// Utility class for calculating and generating various reports data
// such as sales, products, customers, and financial summaries.
// It processes data from repositories and applies business logic
// based on the subscription plan to provide insights and analytics.
// It supports advanced analytics for higher-tier subscription plans.
// It is used by the ReportsController to fetch and prepare data for reporting screens.
// It includes methods for filtering sales by date range, calculating top-selling products,
// customer retention rates, inventory turnover, and financial metrics.
// It returns structured data models for easy consumption by the UI.
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../data/models/sale.dart';
import '../data/models/product.dart';
import '../data/models/customer.dart';
import '../data/models/subscription.dart';
import '../data/repositories/sale_repository.dart';
import '../data/repositories/product_repository.dart';
import '../data/repositories/customer_repository.dart';

class ReportsDataCalculator {
static Future<ReportsData> generateReports({
required Ref ref,
required DateTimeRange dateRange,
required SubscriptionPlan plan,
}) async {
final saleRepo = ref.read(saleRepositoryProvider);
final productRepo = ref.read(productRepositoryProvider);
final customerRepo = ref.read(customerRepositoryProvider);

    final sales = await saleRepo.getAllSales();
    final products = await productRepo.getAllProducts();
    final customers = await customerRepo.getAllCustomers();

    final filteredSales = _filterSalesByDateRange(sales, dateRange);

    return ReportsData(
      salesData: await _generateSalesReport(filteredSales, plan),
      productsData:
          await _generateProductsReport(products, filteredSales, plan),
      customersData:
          await _generateCustomersReport(customers, filteredSales, plan),
      financialData: await _generateFinancialReport(filteredSales, plan),
    );

}

static List<Sale> \_filterSalesByDateRange(
List<Sale> sales, DateTimeRange range) {
return sales
.where((sale) =>
sale.createdAt.isAfter(range.start) &&
sale.createdAt.isBefore(range.end.add(const Duration(days: 1))))
.toList();
}

static Future<SalesReportData> \_generateSalesReport(
List<Sale> sales, SubscriptionPlan plan) async {
final totalSales = sales.fold(0.0, (sum, sale) => sum + sale.finalAmount);
final totalOrders = sales.length;
final averageOrderValue = totalOrders > 0 ? totalSales / totalOrders : 0.0;

    final salesByPaymentMethod = _calculateSalesByPaymentMethod(sales);
    final revenueByDay = _calculateRevenueByDay(sales);
    final dailySalesTrend = _calculateDailySalesTrend(sales);
    final topSellingHours = _calculateTopSellingHours(sales);

    // Advanced analytics for higher plans
    final customerRetention =
        plan.id != 'basic' ? _calculateCustomerRetentionRate(sales) : null;
    final salesVelocity =
        plan.id == 'enterprise' ? _calculateSalesVelocity(sales) : null;

    return SalesReportData(
      totalSales: totalSales,
      totalOrders: totalOrders,
      averageOrderValue: averageOrderValue,
      salesByPaymentMethod: salesByPaymentMethod,
      revenueByDay: revenueByDay,
      dailySalesTrend: dailySalesTrend,
      topSellingHours: topSellingHours,
      customerRetention: customerRetention,
      salesVelocity: salesVelocity,
    );

}

static Map<String, double> \_calculateSalesByPaymentMethod(List<Sale> sales) {
final methodSales = <String, double>{};
for (final sale in sales) {
methodSales.update(
sale.paymentMethod,
(value) => value + sale.finalAmount,
ifAbsent: () => sale.finalAmount,
);
}
return methodSales;
}

static Map<String, double> \_calculateRevenueByDay(List<Sale> sales) {
final revenueByDay = <String, double>{};
final days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];

    // Initialize with zeros
    for (final day in days) {
      revenueByDay[day] = 0.0;
    }

    for (final sale in sales) {
      final dayName = _getDayName(sale.createdAt.weekday);
      revenueByDay[dayName] = (revenueByDay[dayName] ?? 0) + sale.finalAmount;
    }

    return revenueByDay;

}

static List<DailySalesData> \_calculateDailySalesTrend(List<Sale> sales) {
final dailySales = <DateTime, double>{};

    for (final sale in sales) {
      final date = DateTime(
          sale.createdAt.year, sale.createdAt.month, sale.createdAt.day);
      dailySales.update(
        date,
        (value) => value + sale.finalAmount,
        ifAbsent: () => sale.finalAmount,
      );
    }

    return dailySales.entries
        .map((entry) => DailySalesData(date: entry.key, amount: entry.value))
        .toList()
      ..sort((a, b) => a.date.compareTo(b.date));

}

static List<HourlySalesData> \_calculateTopSellingHours(List<Sale> sales) {
final hourSales = <int, double>{};

    for (final sale in sales) {
      final hour = sale.createdAt.hour;
      hourSales.update(
        hour,
        (value) => value + sale.finalAmount,
        ifAbsent: () => sale.finalAmount,
      );
    }

    return hourSales.entries
        .map((entry) => HourlySalesData(hour: entry.key, amount: entry.value))
        .toList()
      ..sort((a, b) => b.amount.compareTo(a.amount));

}

static double \_calculateCustomerRetentionRate(List<Sale> sales) {
// Simplified retention calculation
if (sales.isEmpty) return 0.0;

    final customerSales = <String, int>{};
    for (final sale in sales) {
      if (sale.customerId != null) {
        customerSales.update(
          sale.customerId! as String,
          (value) => value + 1,
          ifAbsent: () => 1,
        );
      }
    }

    final repeatCustomers =
        customerSales.values.where((count) => count > 1).length;
    final totalCustomers = customerSales.length;

    return totalCustomers > 0 ? (repeatCustomers / totalCustomers) * 100 : 0.0;

}

static double \_calculateSalesVelocity(List<Sale> sales) {
if (sales.length < 2) return 0.0;

    final sortedSales = List<Sale>.from(sales)
      ..sort((a, b) => a.createdAt.compareTo(b.createdAt));

    final firstSale = sortedSales.first;
    final lastSale = sortedSales.last;
    final daysBetween =
        lastSale.createdAt.difference(firstSale.createdAt).inDays;

    return daysBetween > 0
        ? sales.length / daysBetween
        : sales.length.toDouble();

}

static Future<ProductsReportData> \_generateProductsReport(
List<Product> products, List<Sale> sales, SubscriptionPlan plan) async {
final totalProducts = products.length;
final lowStockCount = products.where((p) => p.isLowStock).length;
final outOfStockCount = products.where((p) => p.isOutOfStock).length;

    final topSellingProducts =
        await _calculateTopSellingProducts(products, sales);
    final stockValue = _calculateStockValue(products);
    final profitMarginSummary = _calculateProfitMarginSummary(products, sales);

    // Advanced analytics
    final inventoryTurnover = plan.id != 'basic'
        ? _calculateInventoryTurnover(products, sales)
        : null;
    final abcAnalysis =
        plan.id == 'enterprise' ? _calculateABCAnalysis(products, sales) : null;

    return ProductsReportData(
      totalProducts: totalProducts,
      lowStockCount: lowStockCount,
      outOfStockCount: outOfStockCount,
      topSellingProducts: topSellingProducts,
      stockValue: stockValue,
      profitMarginSummary: profitMarginSummary,
      inventoryTurnover: inventoryTurnover,
      abcAnalysis: abcAnalysis,
    );

}

static Future<CustomersReportData> \_generateCustomersReport(
List<Customer> customers, List<Sale> sales, SubscriptionPlan plan) async {
final totalCustomers = customers.length;
final customersWithBalance =
customers.where((c) => c.currentBalance > 0).length;
final overdueCustomers = customers.where((c) => c.isOverdue).length;
final totalOutstanding =
customers.fold(0.0, (sum, c) => sum + c.currentBalance);

    final topCustomers = _calculateTopCustomers(customers, sales);
    final averageCustomerValue =
        _calculateAverageCustomerValue(customers, sales);

    return CustomersReportData(
      totalCustomers: totalCustomers,
      customersWithBalance: customersWithBalance,
      overdueCustomers: overdueCustomers,
      totalOutstanding: totalOutstanding,
      topCustomers: topCustomers,
      averageCustomerValue: averageCustomerValue,
    );

}

static Future<FinancialReportData> \_generateFinancialReport(
List<Sale> sales, SubscriptionPlan plan) async {
final totalRevenue = sales.fold(0.0, (sum, sale) => sum + sale.finalAmount);
final totalTax =
sales.fold(0.0, (sum, sale) => sum + (sale.taxAmount ?? 0.0));
final totalDiscount =
sales.fold(0.0, (sum, sale) => sum + (sale.discountAmount ?? 0.0));
final netRevenue = totalRevenue - totalTax;
final profitMargin = \_calculateProfitMargin(sales);

    return FinancialReportData(
      totalRevenue: totalRevenue,
      totalTax: totalTax,
      totalDiscount: totalDiscount,
      netRevenue: netRevenue,
      profitMargin: profitMargin,
    );

}

static String \_getDayName(int weekday) {
switch (weekday) {
case 1:
return 'Mon';
case 2:
return 'Tue';
case 3:
return 'Wed';
case 4:
return 'Thu';
case 5:
return 'Fri';
case 6:
return 'Sat';
case 7:
return 'Sun';
default:
return 'Mon';
}
}

// Additional calculation methods...
static Future<List<TopSellingProduct>> \_calculateTopSellingProducts(
List<Product> products, List<Sale> sales) async {
// Implementation for top selling products
return [];
}

static double \_calculateStockValue(List<Product> products) {
return products.fold(0.0, (sum, product) {
final cost = product.costPrice ?? product.price _ 0.6;
return sum + (cost _ product.stockQuantity);
});
}

static double \_calculateProfitMargin(List<Sale> sales) {
if (sales.isEmpty) return 0.0;
// Simplified profit margin calculation
return 25.0; // Example value
}

static Map<String, dynamic> \_calculateProfitMarginSummary(
List<Product> products, List<Sale> sales) {
return {};
}

static double? \_calculateInventoryTurnover(
List<Product> products, List<Sale> sales) {
return null;
}

static Map<String, dynamic>? \_calculateABCAnalysis(
List<Product> products, List<Sale> sales) {
return null;
}

static List<TopCustomer> \_calculateTopCustomers(
List<Customer> customers, List<Sale> sales) {
return [];
}

static double \_calculateAverageCustomerValue(
List<Customer> customers, List<Sale> sales) {
return 0.0;
}
}

// Data models for reports
class ReportsData {
final SalesReportData salesData;
final ProductsReportData productsData;
final CustomersReportData customersData;
final FinancialReportData financialData;

const ReportsData({
required this.salesData,
required this.productsData,
required this.customersData,
required this.financialData,
});
}

class SalesReportData {
final double totalSales;
final int totalOrders;
final double averageOrderValue;
final Map<String, double> salesByPaymentMethod;
final Map<String, double> revenueByDay;
final List<DailySalesData> dailySalesTrend;
final List<HourlySalesData> topSellingHours;
final double? customerRetention;
final double? salesVelocity;

const SalesReportData({
required this.totalSales,
required this.totalOrders,
required this.averageOrderValue,
required this.salesByPaymentMethod,
required this.revenueByDay,
required this.dailySalesTrend,
required this.topSellingHours,
this.customerRetention,
this.salesVelocity,
});
}

class ProductsReportData {
final int totalProducts;
final int lowStockCount;
final int outOfStockCount;
final List<TopSellingProduct> topSellingProducts;
final double stockValue;
final Map<String, dynamic> profitMarginSummary;
final double? inventoryTurnover;
final Map<String, dynamic>? abcAnalysis;

const ProductsReportData({
required this.totalProducts,
required this.lowStockCount,
required this.outOfStockCount,
required this.topSellingProducts,
required this.stockValue,
required this.profitMarginSummary,
this.inventoryTurnover,
this.abcAnalysis,
});
}

class CustomersReportData {
final int totalCustomers;
final int customersWithBalance;
final int overdueCustomers;
final double totalOutstanding;
final List<TopCustomer> topCustomers;
final double averageCustomerValue;

const CustomersReportData({
required this.totalCustomers,
required this.customersWithBalance,
required this.overdueCustomers,
required this.totalOutstanding,
required this.topCustomers,
required this.averageCustomerValue,
});
}

class FinancialReportData {
final double totalRevenue;
final double totalTax;
final double totalDiscount;
final double netRevenue;
final double profitMargin;

const FinancialReportData({
required this.totalRevenue,
required this.totalTax,
required this.totalDiscount,
required this.netRevenue,
required this.profitMargin,
});
}

class DailySalesData {
final DateTime date;
final double amount;

const DailySalesData({required this.date, required this.amount});
}

class HourlySalesData {
final int hour;
final double amount;

const HourlySalesData({required this.hour, required this.amount});
}

class TopSellingProduct {
final String id;
final String name;
final double revenue;
final int quantitySold;
final double profitMargin;

const TopSellingProduct({
required this.id,
required this.name,
required this.revenue,
required this.quantitySold,
required this.profitMargin,
});
}

class TopCustomer {
final String id;
final String name;
final double totalSpent;
final int orderCount;
final DateTime lastPurchase;

const TopCustomer({
required this.id,
required this.name,
required this.totalSpent,
required this.orderCount,
required this.lastPurchase,
});
}

##

// utils/sync_manager.dart
// Utility class for managing data synchronization between local database and remote server.
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'dart:async';
import 'package:sqflite/sqflite.dart';
import '../data/local/database.dart';
import '../data/remote/api_client.dart';

final syncManagerProvider = Provider<SyncManager>((ref) {
final syncManager = SyncManager(ref);
syncManager.initialize();
return syncManager;
});

class SyncManager {
final Ref ref;
Timer? \_syncTimer;
bool \_isSyncing = false;

SyncManager(this.ref);

Future<void> initialize() async {
// Start periodic sync every 5 minutes
\_syncTimer = Timer.periodic(const Duration(minutes: 5), (timer) async {
if (!\_isSyncing) {
await syncPendingRecords();
}
});
}

Future<void> syncPendingRecords() async {
if (\_isSyncing) return;

    _isSyncing = true;
    try {
      await _uploadPendingRecords();
      await _downloadUpdates();
    } catch (e) {
      // Log error but don't throw - sync will retry
      print('Sync error: $e');
    } finally {
      _isSyncing = false;
    }

}

Future<void> \_uploadPendingRecords() async {
final db = await AppDatabase.database;

    try {
      // Get unsynced sales
      final unsyncedSales = await db.query(
        'sales',
        where: 'is_synced = ?',
        whereArgs: [0],
        limit: 50,
      );

      if (unsyncedSales.isEmpty) return;

      // Get sale items for each unsynced sale
      final salesWithItems = <Map<String, dynamic>>[];

      for (final sale in unsyncedSales) {
        final saleItems = await db.query(
          'sale_items',
          where: 'sale_id = ?',
          whereArgs: [sale['id']],
        );

        salesWithItems.add({
          'sale': sale,
          'items': saleItems,
        });
      }

      // Upload to server (simplified - implement your API call)
      // await _uploadToServer(salesWithItems);

      // Mark as synced
      final batch = db.batch();
      for (final sale in unsyncedSales) {
        batch.update(
          'sales',
          {
            'is_synced': 1,
            'updated_at': DateTime.now().millisecondsSinceEpoch,
          },
          where: 'id = ?',
          whereArgs: [sale['id']],
        );
      }
      await batch.commit();

      print('Successfully synced ${unsyncedSales.length} sales');
    } catch (e) {
      print('Upload error: $e');
      rethrow;
    }

}

Future<void> \_downloadUpdates() async {
try {
final lastSync = await \_getLastSyncTimestamp();
print('Downloading updates since: $lastSync');

      // Implement your download logic here
      // final updates = await ref.read(apiClientProvider).downloadUpdates(lastSync);
      // await _applyServerUpdates(updates);
    } catch (e) {
      print('Download updates error: $e');
    }

}

Future<int> \_getLastSyncTimestamp() async {
final db = await AppDatabase.database;
final result = await db.rawQuery('''
SELECT MAX(updated_at) as last_sync FROM sales
WHERE is_synced = 1
''');

    return result.first['last_sync'] as int? ?? 0;

}

Future<void> forceSync() async {
await syncPendingRecords();
}

Future<Map<String, dynamic>> getSyncStatus() async {
final db = await AppDatabase.database;

    final pendingResult = await db.rawQuery('''
      SELECT COUNT(*) as count FROM sales WHERE is_synced = 0
    ''');

    return {
      'pending': pendingResult.first['count'] as int,
      'isSyncing': _isSyncing,
      'lastSync': await _getLastSyncTimestamp(),
    };

}

void dispose() {
\_syncTimer?.cancel();
}
}

##

// lib/src/utils/validators.dart
// Utility class for validating various input fields such as product details, customer information, and sales data.
import 'package:intl/intl.dart';

class Validators {
// === PRODUCT VALIDATION ===
static String? validateProductName(String? value) {
if (value == null || value.isEmpty) {
return 'Product name is required';
}
if (value.length < 2) {
return 'Product name must be at least 2 characters';
}
if (value.length > 100) {
return 'Product name cannot exceed 100 characters';
}
return null;
}

static String? validatePrice(String? value) {
if (value == null || value.isEmpty) {
return 'Price is required';
}

    final price = double.tryParse(value);
    if (price == null) {
      return 'Please enter a valid number';
    }
    if (price < 0) {
      return 'Price cannot be negative';
    }
    if (price > 10000000) {
      return 'Price cannot exceed 10,000,000';
    }
    return null;

}

static String? validateBarcode(String? value) {
if (value == null || value.isEmpty) {
return 'Barcode is required';
}

    value = value.trim();

    // Check length
    if (value.length < 8 || value.length > 14) {
      return 'Barcode must be 8-14 digits';
    }

    // Check if all digits
    if (!RegExp(r'^[0-9]+$').hasMatch(value)) {
      return 'Barcode must contain only numbers';
    }

    // Validate check digit for EAN-13
    if (value.length == 13) {
      if (!_validateEAN13CheckDigit(value)) {
        return 'Invalid EAN-13 barcode (check digit mismatch)';
      }
    }

    return null;

}

static bool \_validateEAN13CheckDigit(String code) {
if (code.length != 13) return false;

    int sum = 0;
    for (int i = 0; i < 12; i++) {
      int digit = int.parse(code[i]);
      sum += (i % 2 == 0) ? digit : digit * 3;
    }

    int checkDigit = (10 - (sum % 10)) % 10;
    return checkDigit == int.parse(code[12]);

}

static String? validateStock(String? value) {
if (value == null || value.isEmpty) {
return 'Stock quantity is required';
}

    final stock = int.tryParse(value);
    if (stock == null) {
      return 'Please enter a valid number';
    }
    if (stock < 0) {
      return 'Stock cannot be negative';
    }
    if (stock > 1000000) {
      return 'Stock cannot exceed 1,000,000';
    }
    return null;

}

// === CUSTOMER VALIDATION ===
static String? validatePhoneNumber(String? value, {bool isEthiopian = true}) {
if (value == null || value.isEmpty) {
return 'Phone number is required';
}

    // Clean the number
    String cleaned = value.replaceAll(RegExp(r'[^\d+]'), '');

    if (isEthiopian) {
      // Ethiopian phone validation
      if (!cleaned.startsWith('+251') &&
          !cleaned.startsWith('251') &&
          !cleaned.startsWith('0')) {
        return 'Please enter a valid Ethiopian phone number';
      }

      // Standardize to +251 format
      if (cleaned.startsWith('0')) {
        cleaned = '+251${cleaned.substring(1)}';
      } else if (cleaned.startsWith('251')) {
        cleaned = '+$cleaned';
      }

      // Check length
      if (cleaned.length != 13) {
        // +251XXXXXXXXX
        return 'Phone number must be 9 digits after +251';
      }
    }

    return null;

}

static String? validateEmail(String? value) {
if (value == null || value.isEmpty) {
return null; // Email is optional
}

    final emailRegex = RegExp(
      r'^[a-zA-Z0-9.!#$%&‚Äô*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$',
    );

    if (!emailRegex.hasMatch(value)) {
      return 'Please enter a valid email address';
    }

    return null;

}

static String? validateTIN(String? value) {
if (value == null || value.isEmpty) {
return 'TIN number is required';
}

    // Ethiopian TIN validation (basic)
    if (!RegExp(r'^\d{9,10}$').hasMatch(value)) {
      return 'TIN must be 9 or 10 digits';
    }

    return null;

}

// === SALE VALIDATION ===
static String? validatePaymentAmount(String? value, double maxAmount) {
if (value == null || value.isEmpty) {
return 'Amount is required';
}

    final amount = double.tryParse(value);
    if (amount == null) {
      return 'Please enter a valid number';
    }
    if (amount <= 0) {
      return 'Amount must be greater than 0';
    }
    if (amount > maxAmount) {
      return 'Amount cannot exceed ${NumberFormat.currency(symbol: 'ETB ').format(maxAmount)}';
    }
    return null;

}

static String? validateCreditLimit(String? value) {
if (value == null || value.isEmpty) {
return 'Credit limit is required';
}

    final limit = double.tryParse(value);
    if (limit == null) {
      return 'Please enter a valid number';
    }
    if (limit < 0) {
      return 'Credit limit cannot be negative';
    }
    if (limit > 1000000) {
      return 'Credit limit cannot exceed 1,000,000';
    }
    return null;

}

// === GENERAL VALIDATION ===
static String? validateRequired(String? value, String fieldName) {
if (value == null || value.trim().isEmpty) {
return '$fieldName is required';
}
return null;
}

static String? validateLength(
String? value, int min, int max, String fieldName) {
if (value == null) return null;

    if (value.length < min) {
      return '$fieldName must be at least $min characters';
    }
    if (value.length > max) {
      return '$fieldName cannot exceed $max characters';
    }
    return null;

}

static String? validateNumberRange(
String? value, double min, double max, String fieldName) {
if (value == null || value.isEmpty) {
return '$fieldName is required';
}

    final number = double.tryParse(value);
    if (number == null) {
      return 'Please enter a valid number';
    }
    if (number < min) {
      return '$fieldName must be at least $min';
    }
    if (number > max) {
      return '$fieldName cannot exceed $max';
    }
    return null;

}

// === DATE VALIDATION ===
static String? validateDate(String? value) {
if (value == null || value.isEmpty) {
return 'Date is required';
}

    try {
      DateTime.parse(value);
      return null;
    } catch (e) {
      return 'Please enter a valid date';
    }

}

static bool isValidDate(DateTime? date) {
if (date == null) return false;
return date
.isBefore(DateTime.now().add(const Duration(days: 1))); // Not in future
}

// === PASSWORD VALIDATION ===
static String? validatePassword(String? value) {
if (value == null || value.isEmpty) {
return 'Password is required';
}

    if (value.length < 6) {
      return 'Password must be at least 6 characters';
    }

    // Optional: Add complexity requirements
    // if (!RegExp(r'^(?=.*[A-Z])(?=.*[!@#$%^&*(),.?":{}|<>]).+$').hasMatch(value)) {
    //   return 'Password must contain uppercase and special characters';
    // }

    return null;

}

static String? validateConfirmPassword(
String? value, String? originalPassword) {
if (value == null || value.isEmpty) {
return 'Please confirm your password';
}

    if (value != originalPassword) {
      return 'Passwords do not match';
    }

    return null;

}

// === BATCH VALIDATION ===
static Map<String, String?> validateProductData(Map<String, dynamic> data) {
return {
'name': validateProductName(data['name']),
'price': validatePrice(data['price']?.toString()),
'barcode': validateBarcode(data['barcode']),
'stock': validateStock(data['stock']?.toString()),
'categoryId': validateRequired(data['categoryId'], 'Category'),
};
}

static Map<String, String?> validateCustomerData(Map<String, dynamic> data) {
return {
'name': validateRequired(data['name'], 'Name'),
'phone': validatePhoneNumber(data['phone']),
'email': validateEmail(data['email']),
'creditLimit': validateCreditLimit(data['creditLimit']?.toString()),
};
}

// === UTILITY METHODS ===
static bool hasValidationErrors(Map<String, String?> errors) {
return errors.values.any((error) => error != null);
}

static String getFirstError(Map<String, String?> errors) {
final error =
errors.values.firstWhere((error) => error != null, orElse: () => null);
return error ?? '';
}

static String formatValidationErrors(Map<String, String?> errors) {
final errorMessages =
errors.values.where((error) => error != null).toList();
return errorMessages.join('\n');
}
}

##

// src/ui/widgets/app_button.dart
// A reusable button widget with loading state and multiple styles (primary, secondary, outlined).
import 'package:flutter/material.dart';

class AppButton extends StatelessWidget {
final VoidCallback? onPressed;
final Widget child;
final bool isLoading;
final ButtonType type;

const AppButton({
super.key,
required this.onPressed,
required this.child,
this.isLoading = false,
this.type = ButtonType.primary,
});

// Add this factory constructor for outlined button
factory AppButton.outlined({
required VoidCallback? onPressed,
required Widget child,
bool isLoading = false,
}) {
return AppButton(
onPressed: onPressed,
child: child,
isLoading: isLoading,
type: ButtonType.outlined,
);
}

factory AppButton.primary({
required VoidCallback? onPressed,
required Widget child,
bool isLoading = false,
}) {
return AppButton(
onPressed: onPressed,
child: child,
isLoading: isLoading,
type: ButtonType.primary,
);
}

factory AppButton.secondary({
required VoidCallback? onPressed,
required Widget child,
bool isLoading = false,
}) {
return AppButton(
onPressed: onPressed,
child: child,
isLoading: isLoading,
type: ButtonType.secondary,
);
}

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);

    return ElevatedButton(
      onPressed: isLoading ? null : onPressed,
      style: _getButtonStyle(theme),
      child: isLoading
          ? SizedBox(
              height: 20,
              width: 20,
              child: CircularProgressIndicator(
                strokeWidth: 2,
                color: _getLoadingColor(theme),
              ),
            )
          : child,
    );

}

ButtonStyle \_getButtonStyle(ThemeData theme) {
switch (type) {
case ButtonType.primary:
return ElevatedButton.styleFrom(
backgroundColor: theme.colorScheme.primary,
foregroundColor: theme.colorScheme.onPrimary,
);
case ButtonType.secondary:
return ElevatedButton.styleFrom(
backgroundColor: theme.colorScheme.surface,
foregroundColor: theme.colorScheme.onSurface,
);
case ButtonType.outlined: // ADD THIS CASE
return ElevatedButton.styleFrom(
backgroundColor: Colors.transparent,
foregroundColor: theme.colorScheme.primary,
side: BorderSide(color: theme.colorScheme.primary),
elevation: 0,
);
}
}

Color \_getLoadingColor(ThemeData theme) {
switch (type) {
case ButtonType.primary:
return theme.colorScheme.onPrimary;
case ButtonType.secondary:
return theme.colorScheme.onSurface;
case ButtonType.outlined:
return theme.colorScheme.primary;
}
}
}

// Update the enum to include outlined
enum ButtonType {
primary,
secondary,
outlined,
}

##

// src/ui/widgets/app_text_field.dart
// A reusable text field widget with various customization options.
import 'package:flutter/material.dart';

class AppTextField extends StatelessWidget {
final TextEditingController? controller;
final String label;
final String? hintText;
final String? helperText;
final String? prefixText;
final Widget? prefixIcon;
final Widget? suffixIcon;
final TextInputType? keyboardType;
final bool obscureText;
final bool autocorrect;
final bool enableSuggestions;
final TextInputAction? textInputAction;
final int? maxLines;
final int? minLines;
final int? maxLength;
final String? Function(String?)? validator;
final void Function(String)? onChanged;
final void Function(String)? onSubmitted;
final FocusNode? focusNode;
final bool enabled;
final bool readOnly;
final VoidCallback? onTap;
final String? initialValue; // Add this

const AppTextField({
super.key,
this.controller,
required this.label,
this.hintText,
this.helperText,
this.prefixText,
this.prefixIcon,
this.suffixIcon,
this.keyboardType,
this.obscureText = false,
this.autocorrect = true,
this.enableSuggestions = true,
this.textInputAction,
this.maxLines = 1,
this.minLines,
this.maxLength,
this.validator,
this.onChanged,
this.onSubmitted,
this.focusNode,
this.enabled = true,
this.readOnly = false,
this.onTap,
this.initialValue, // Add this
}) : assert(controller == null || initialValue == null,
'Cannot provide both a controller and an initialValue');

@override
Widget build(BuildContext context) {
return TextFormField(
controller: controller,
initialValue: initialValue,
focusNode: focusNode,
decoration: InputDecoration(
labelText: label,
hintText: hintText,
helperText: helperText,
prefixText: prefixText,
prefixIcon: prefixIcon,
suffixIcon: suffixIcon,
border: const OutlineInputBorder(),
contentPadding:
const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
counterText: maxLength != null ? null : '',
enabled: enabled,
),
keyboardType: keyboardType,
obscureText: obscureText,
autocorrect: autocorrect,
enableSuggestions: enableSuggestions,
textInputAction: textInputAction,
maxLines: maxLines,
minLines: minLines,
maxLength: maxLength,
validator: validator,
onChanged: onChanged,
onFieldSubmitted: onSubmitted,
enabled: enabled,
readOnly: readOnly,
onTap: onTap,
);
}
}

##

// src/ui/widgets/common/custom_card.dart
// A customizable card widget with tap and long-press functionality, padding, margin, and styling
import 'package:flutter/material.dart';

class CustomCard extends StatelessWidget {
final Widget child;
final EdgeInsetsGeometry padding;
final VoidCallback? onTap;
final VoidCallback? onLongPress;
final Color? backgroundColor;
final double elevation;
final BorderRadiusGeometry borderRadius;
final EdgeInsetsGeometry? margin;
final bool showBorder;
final Color? borderColor;
final double? width;
final double? height;

const CustomCard({
super.key,
required this.child,
this.padding = const EdgeInsets.all(16),
this.onTap,
this.onLongPress,
this.backgroundColor,
this.elevation = 2,
this.borderRadius = const BorderRadius.all(Radius.circular(16)),
this.margin,
this.showBorder = false,
this.borderColor,
this.width,
this.height,
});

@override
Widget build(BuildContext context) {
return Container(
margin: margin,
width: width,
height: height,
child: Card(
elevation: elevation,
color: backgroundColor ?? Theme.of(context).colorScheme.surface,
surfaceTintColor: Theme.of(context).colorScheme.surfaceTint,
shape: RoundedRectangleBorder(
borderRadius: borderRadius,
side: showBorder
? BorderSide(
color: borderColor ??
Theme.of(context).colorScheme.outline.withOpacity(0.2),
width: 1,
)
: BorderSide.none,
),
child: InkWell(
onTap: onTap,
onLongPress: onLongPress,
borderRadius: \_getBorderRadius(borderRadius),
child: Padding(
padding: padding,
child: child,
),
),
),
);
}

BorderRadius \_getBorderRadius(BorderRadiusGeometry borderRadius) {
if (borderRadius is BorderRadius) {
return borderRadius;
} else if (borderRadius is RoundedRectangleBorder) {
// return (borderRadius.borderRadius as BorderRadius?) ??
// BorderRadius.circular(16);
return BorderRadius.circular(16);
} else {
return BorderRadius.circular(16);
}
}
}

##

// widgets/common/date_range_picker.dart
// A date range picker widget that supports both Gregorian and Ethiopian calendars,
// allowing users to select a date range with proper formatting and validation.√•√•
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/providers/calendar_provider.dart';
import 'package:andalus_smart_pos/src/utils/ethiopian_calendar.dart';

class ProfessionalDateRangePicker extends ConsumerWidget {
final DateTimeRange? initialDateRange;
final Function(DateTimeRange) onDateRangeSelected;
final String? title;

const ProfessionalDateRangePicker({
super.key,
this.initialDateRange,
required this.onDateRangeSelected,
this.title,
});

@override
Widget build(BuildContext context, WidgetRef ref) {
final calendarSettings = ref.watch(calendarProvider);

    Future<void> _selectDateRange(BuildContext context) async {
      final DateTimeRange? picked = await showDateRangePicker(
        context: context,
        firstDate: DateTime(2020),
        lastDate: DateTime.now().add(const Duration(days: 365)),
        currentDate: DateTime.now(),
        saveText: 'Apply',
        builder: (context, child) {
          return Theme(
            data: Theme.of(context).copyWith(
              colorScheme: ColorScheme.light(
                primary: Theme.of(context).colorScheme.primary,
                onPrimary: Colors.white,
                surface: Theme.of(context).cardColor,
                onSurface: Theme.of(context).colorScheme.onBackground,
              ),
            ),
            child: child!,
          );
        },
      );

      if (picked != null) {
        onDateRangeSelected(picked);
      }
    }

    String _formatSingleDate(DateTime date, CalendarType calendarType) {
      if (calendarType == CalendarType.ethiopian) {
        final ethDate = EthiopianCalendar.gregorianToEthiopian(date);
        return '${ethDate.day}/${ethDate.month}/${ethDate.year}';
      } else {
        return '${date.day}/${date.month}/${date.year}';
      }
    }

    String _formatDateRange(DateTimeRange range) {
      final start =
          _formatSingleDate(range.start, calendarSettings.calendarType);
      final end = _formatSingleDate(range.end, calendarSettings.calendarType);
      return '$start - $end';
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        if (title != null) ...[
          Text(
            title!,
            style: Theme.of(context).textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.w600,
                ),
          ),
          const SizedBox(height: 8),
        ],
        Container(
          decoration: BoxDecoration(
            border: Border.all(
              color: Theme.of(context).colorScheme.outline.withOpacity(0.3),
            ),
            borderRadius: BorderRadius.circular(12),
          ),
          child: ListTile(
            leading: Icon(
              Icons.calendar_today,
              color: Theme.of(context).colorScheme.primary,
            ),
            title: Text(
              initialDateRange != null
                  ? _formatDateRange(initialDateRange!)
                  : 'Select Date Range',
              style: Theme.of(context).textTheme.bodyMedium,
            ),
            trailing: const Icon(Icons.arrow_drop_down),
            onTap: () => _selectDateRange(context),
          ),
        ),
      ],
    );

}
}

##

// lib/src/widgets/common/loading_shimmer.dart
// A customizable loading shimmer widget for indicating loading states in the UI.
import 'package:flutter/material.dart';

class LoadingShimmer extends StatelessWidget {
final double height;
final double width;
final double borderRadius;
final EdgeInsetsGeometry margin;

const LoadingShimmer({
super.key,
this.height = 60,
this.width = double.infinity,
this.borderRadius = 8,
this.margin = EdgeInsets.zero,
});

@override
Widget build(BuildContext context) {
return Container(
margin: margin,
height: height,
width: width,
decoration: BoxDecoration(
color: Colors.grey.shade300,
borderRadius: BorderRadius.circular(borderRadius),
),
child: ClipRRect(
borderRadius: BorderRadius.circular(borderRadius),
child: ShimmerLoader(),
),
);
}
}

class ShimmerLoader extends StatefulWidget {
const ShimmerLoader({super.key});

@override
State<ShimmerLoader> createState() => \_ShimmerLoaderState();
}

class \_ShimmerLoaderState extends State<ShimmerLoader>
with SingleTickerProviderStateMixin {
late AnimationController \_controller;

@override
void initState() {
super.initState();
\_controller = AnimationController(
vsync: this,
duration: const Duration(milliseconds: 1500),
)..repeat();
}

@override
void dispose() {
\_controller.dispose();
super.dispose();
}

@override
Widget build(BuildContext context) {
return AnimatedBuilder(
animation: \_controller,
builder: (context, child) {
return CustomPaint(
painter: ShimmerPainter(\_controller.value),
);
},
);
}
}

class ShimmerPainter extends CustomPainter {
final double progress;

ShimmerPainter(this.progress);

@override
void paint(Canvas canvas, Size size) {
final gradient = LinearGradient(
colors: [
Colors.grey.shade300!,
Colors.grey.shade100!,
Colors.grey.shade300!,
],
stops: const [0.0, 0.5, 1.0],
);

    final rect = Rect.fromLTWH(-size.width, 0, size.width * 3, size.height);
    final paint = Paint()
      ..shader = gradient.createShader(rect)
      ..maskFilter = MaskFilter.blur(BlurStyle.solid, 4);

    final x = size.width * progress * 2 - size.width;
    final shimmerRect = Rect.fromLTWH(x, 0, size.width * 0.3, size.height);

    canvas.drawRect(shimmerRect, paint);

}

@override
bool shouldRepaint(covariant ShimmerPainter oldDelegate) {
return oldDelegate.progress != progress;
}
}

// Pre-built shimmer components for common use cases
class ListItemShimmer extends StatelessWidget {
final bool hasLeading;
final bool hasTrailing;

const ListItemShimmer({
super.key,
this.hasLeading = true,
this.hasTrailing = true,
});

@override
Widget build(BuildContext context) {
return Container(
padding: const EdgeInsets.all(16),
child: Row(
children: [
if (hasLeading)
Container(
width: 48,
height: 48,
margin: const EdgeInsets.only(right: 16),
decoration: BoxDecoration(
color: Colors.grey.shade300,
borderRadius: BorderRadius.circular(24),
),
),
Expanded(
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Container(
width: double.infinity,
height: 16,
margin: const EdgeInsets.only(bottom: 8),
decoration: BoxDecoration(
color: Colors.grey.shade300,
borderRadius: BorderRadius.circular(4),
),
),
Container(
width: 120,
height: 14,
decoration: BoxDecoration(
color: Colors.grey.shade300,
borderRadius: BorderRadius.circular(4),
),
),
],
),
),
if (hasTrailing)
Container(
width: 60,
height: 16,
margin: const EdgeInsets.only(left: 16),
decoration: BoxDecoration(
color: Colors.grey.shade300,
borderRadius: BorderRadius.circular(4),
),
),
],
),
);
}
}

class GridShimmer extends StatelessWidget {
final int crossAxisCount;
final double childAspectRatio;
final int itemCount;

const GridShimmer({
super.key,
this.crossAxisCount = 2,
this.childAspectRatio = 1.0,
this.itemCount = 4,
});

@override
Widget build(BuildContext context) {
return GridView.builder(
shrinkWrap: true,
physics: const NeverScrollableScrollPhysics(),
gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
crossAxisCount: crossAxisCount,
crossAxisSpacing: 16,
mainAxisSpacing: 16,
childAspectRatio: childAspectRatio,
),
itemCount: itemCount,
itemBuilder: (context, index) {
return const LoadingShimmer(
height: 120,
borderRadius: 12,
);
},
);
}
}

class CardShimmer extends StatelessWidget {
final bool hasImage;
final bool hasActions;

const CardShimmer({
super.key,
this.hasImage = false,
this.hasActions = true,
});

@override
Widget build(BuildContext context) {
return Container(
padding: const EdgeInsets.all(16),
decoration: BoxDecoration(
color: Colors.white,
borderRadius: BorderRadius.circular(12),
boxShadow: [
BoxShadow(
color: Colors.black.withOpacity(0.1),
blurRadius: 4,
offset: const Offset(0, 2),
),
],
),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
if (hasImage)
Container(
width: double.infinity,
height: 120,
margin: const EdgeInsets.only(bottom: 12),
decoration: BoxDecoration(
color: Colors.grey.shade300,
borderRadius: BorderRadius.circular(8),
),
),
Container(
width: double.infinity,
height: 20,
margin: const EdgeInsets.only(bottom: 8),
decoration: BoxDecoration(
color: Colors.grey.shade300,
borderRadius: BorderRadius.circular(4),
),
),
Container(
width: 160,
height: 16,
margin: const EdgeInsets.only(bottom: 12),
decoration: BoxDecoration(
color: Colors.grey.shade300,
borderRadius: BorderRadius.circular(4),
),
),
if (hasActions)
Row(
children: [
Container(
width: 80,
height: 36,
margin: const EdgeInsets.only(right: 8),
decoration: BoxDecoration(
color: Colors.grey.shade300,
borderRadius: BorderRadius.circular(8),
),
),
Container(
width: 80,
height: 36,
decoration: BoxDecoration(
color: Colors.grey.shade300,
borderRadius: BorderRadius.circular(8),
),
),
],
),
],
),
);
}
}

##

// lib/src/widgets/common/search_field.dart
// A reusable search field widget with customizable hint text and callbacks.
import 'package:flutter/material.dart';

class SearchField extends StatelessWidget {
final TextEditingController controller;
final String hintText;
final Function(String)? onChanged;
final Function(String)? onSubmitted;

const SearchField({
super.key,
required this.controller,
required this.hintText,
this.onChanged,
this.onSubmitted,
});

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);

    return TextField(
      controller: controller,
      decoration: InputDecoration(
        labelText: hintText,
        prefixIcon: const Icon(Icons.search),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
        ),
        contentPadding: const EdgeInsets.symmetric(horizontal: 16),
        filled: true,
        fillColor: theme.colorScheme.surface,
      ),
      onChanged: onChanged,
      onSubmitted: onSubmitted,
    );

}
}

##

// widgets/dashboard/dashboard_cards.dart
// Dashboard cards displaying key metrics like sales, products, customers, and revenue.
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
import 'package:andalus_smart_pos/src/utils/formatters.dart';

class DashboardCard extends StatelessWidget {
final String title;
final String value;
final String subtitle;
final IconData icon;
final Color color;
final VoidCallback onTap;
final bool isWarning;

const DashboardCard({
super.key,
required this.title,
required this.value,
required this.subtitle,
required this.icon,
required this.color,
required this.onTap,
this.isWarning = false,
});

@override
Widget build(BuildContext context) {
return Card(
elevation: 0,
shape: RoundedRectangleBorder(
borderRadius: BorderRadius.circular(16),
side: BorderSide(
color: Theme.of(context).colorScheme.outline.withOpacity(0.1),
),
),
child: InkWell(
onTap: onTap,
borderRadius: BorderRadius.circular(16),
child: Container(
padding: const EdgeInsets.all(16),
height: 130, // Reduced fixed height
decoration: BoxDecoration(
gradient: LinearGradient(
begin: Alignment.topLeft,
end: Alignment.bottomRight,
colors: [
color.withOpacity(0.05),
color.withOpacity(0.02),
],
),
borderRadius: BorderRadius.circular(16),
),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
// Top row with icon and arrow - Fixed height
SizedBox(
height: 32, // Fixed height for top row
child: Row(
mainAxisAlignment: MainAxisAlignment.spaceBetween,
children: [
Container(
padding: const EdgeInsets.all(6), // Smaller padding
decoration: BoxDecoration(
color: color.withOpacity(0.1),
borderRadius: BorderRadius.circular(8),
),
child: Icon(icon, color: color, size: 18), // Smaller icon
),
Icon(
Icons.arrow_forward_ios_rounded,
color: color.withOpacity(0.6),
size: 12, // Smaller arrow
),
],
),
),

              const Spacer(),

              // Content area with strict height constraints
              SizedBox(
                height: 60, // Fixed height for content
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                  children: [
                    // Main value - with strict constraints
                    SizedBox(
                      height: 24, // Fixed height for main value
                      child: FittedBox(
                        fit: BoxFit.scaleDown,
                        alignment: Alignment.centerLeft,
                        child: Text(
                          value,
                          style: Theme.of(context)
                              .textTheme
                              .titleLarge
                              ?.copyWith(
                                fontWeight: FontWeight.w700,
                                color: isWarning
                                    ? const Color(0xFFEF4444)
                                    : Theme.of(context).colorScheme.onSurface,
                                fontSize: 16, // Smaller font
                              ),
                          maxLines: 1,
                        ),
                      ),
                    ),

                    // Subtitle - with strict constraints
                    SizedBox(
                      height: 16, // Fixed height for subtitle
                      child: Text(
                        subtitle,
                        style: Theme.of(context).textTheme.bodySmall?.copyWith(
                              color: Theme.of(context).colorScheme.outline,
                              fontWeight: FontWeight.w500,
                              fontSize: 11, // Smaller font
                              height: 1.2, // Tighter line height
                            ),
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),

                    // Title - with strict constraints
                    SizedBox(
                      height: 16, // Fixed height for title
                      child: Text(
                        title,
                        style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                              color: Theme.of(context).colorScheme.outline,
                              fontWeight: FontWeight.w600,
                              fontSize: 12, // Smaller font
                              height: 1.2, // Tighter line height
                            ),
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );

}
}

class SalesCard extends ConsumerWidget {
final double todaySales;
final int itemsSold;
final VoidCallback onTap;

const SalesCard({
super.key,
required this.todaySales,
required this.itemsSold,
required this.onTap,
});

@override
Widget build(BuildContext context, WidgetRef ref) {
final localizations = AppLocalizations.of(context);

    return DashboardCard(
      title: localizations.translate('Sales'),
      value: AppFormatters.formatCurrency(todaySales),
      subtitle: '$itemsSold ${localizations.translate('items sold')}',
      icon: Icons.shopping_cart_rounded,
      color: const Color(0xFF10B981),
      onTap: onTap,
    );

}
}

class ProductsCard extends ConsumerWidget {
final int totalProducts;
final int totalItems;
final int totalCategories;
final VoidCallback onTap;

const ProductsCard({
super.key,
required this.totalProducts,
required this.totalItems,
required this.totalCategories,
required this.onTap,
});

@override
Widget build(BuildContext context, WidgetRef ref) {
final localizations = AppLocalizations.of(context);

    // Use shorter text to prevent overflow
    final subtitle = '$totalItems items ‚Ä¢ $totalCategories cats';

    return DashboardCard(
      title: localizations.translate('Products'),
      value: totalProducts.toString(),
      subtitle: subtitle,
      icon: Icons.inventory_2_rounded,
      color: const Color(0xFF3B82F6),
      onTap: onTap,
    );

}
}

class CustomersCard extends ConsumerWidget {
final int totalCustomers;
final int customersWithBalance;
final VoidCallback onTap;

const CustomersCard({
super.key,
required this.totalCustomers,
required this.customersWithBalance,
required this.onTap,
});

@override
Widget build(BuildContext context, WidgetRef ref) {
final localizations = AppLocalizations.of(context);

    // Use shorter text
    final subtitle = '$customersWithBalance with balance';

    return DashboardCard(
      title: localizations.translate('Customers'),
      value: totalCustomers.toString(),
      subtitle: subtitle,
      icon: Icons.people_alt_rounded,
      color: const Color(0xFF8B5CF6),
      onTap: onTap,
    );

}
}

class RevenueCard extends ConsumerWidget {
final double totalRevenue;
final double outstandingCredit;
final VoidCallback onTap;

const RevenueCard({
super.key,
required this.totalRevenue,
required this.outstandingCredit,
required this.onTap,
});

@override
Widget build(BuildContext context, WidgetRef ref) {
final localizations = AppLocalizations.of(context);

    // Use compact format for large numbers
    final formattedRevenue = totalRevenue > 10000
        ? AppFormatters.formatCompactCurrency(totalRevenue)
        : AppFormatters.formatCurrency(totalRevenue);

    final formattedCredit = outstandingCredit > 10000
        ? AppFormatters.formatCompactCurrency(outstandingCredit)
        : AppFormatters.formatCurrency(outstandingCredit);

    // Use shorter text
    final subtitle = 'Out: $formattedCredit';

    return DashboardCard(
      title: localizations.translate('Revenue'),
      value: formattedRevenue,
      subtitle: subtitle,
      icon: Icons.attach_money_rounded,
      color: outstandingCredit > 0
          ? const Color(0xFFF59E0B)
          : const Color(0xFF10B981),
      onTap: onTap,
      isWarning: outstandingCredit > 0,
    );

}
}

##

// lib/src/widgets/dashboard/enhanced_dashboard.dart - SIMPLIFIED VERSION
// An enhanced dashboard widget with tabs for overview, sales analytics, and performance metrics.
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import '../../localization/app_localizations.dart';
import '../../controllers/sale_controller.dart';

class EnhancedDashboard extends ConsumerStatefulWidget {
const EnhancedDashboard({super.key});

@override
ConsumerState<EnhancedDashboard> createState() => \_EnhancedDashboardState();
}

class \_EnhancedDashboardState extends ConsumerState<EnhancedDashboard>
with SingleTickerProviderStateMixin {
late TabController \_tabController;

@override
void initState() {
super.initState();
\_tabController = TabController(length: 3, vsync: this);
}

@override
Widget build(BuildContext context) {
final salesState = ref.watch(saleControllerProvider);
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);

    return Scaffold(
      body: NestedScrollView(
        headerSliverBuilder: (context, innerBoxIsScrolled) {
          return [
            SliverAppBar(
              title: Text(localizations.dashboard),
              floating: true,
              snap: true,
              actions: [
                IconButton(
                  icon: const Icon(Icons.refresh),
                  onPressed: () {},
                  tooltip: localizations.refresh,
                ),
              ],
              bottom: TabBar(
                controller: _tabController,
                tabs: [
                  Tab(text: localizations.translate('overview')),
                  Tab(text: localizations.salesAnalytics),
                  Tab(text: localizations.translate('performance')),
                ],
              ),
            ),
          ];
        },
        body: TabBarView(
          controller: _tabController,
          children: [
            _buildOverviewTab(salesState, localizations, theme),
            _buildAnalyticsTab(localizations, theme),
            _buildPerformanceTab(localizations, theme),
          ],
        ),
      ),
    );

}

Widget \_buildOverviewTab(
SaleState salesState, AppLocalizations localizations, ThemeData theme) {
return CustomScrollView(
slivers: [
SliverToBoxAdapter(
child: Padding(
padding: const EdgeInsets.all(16),
child: GridView.count(
shrinkWrap: true,
physics: const NeverScrollableScrollPhysics(),
crossAxisCount: 2,
crossAxisSpacing: 16,
mainAxisSpacing: 16,
children: [
_buildStatCard(
title: localizations.todayRevenue,
value: 'ETB ${salesState.total.toStringAsFixed(2)}',
icon: Icons.trending_up,
color: Colors.green,
context: context,
),
_buildStatCard(
title: localizations.todayOrders,
value: salesState.cartItems.length
.toString(), // FIXED: Use cartItems.length
icon: Icons.shopping_cart,
color: Colors.blue,
context: context,
),
_buildStatCard(
title: 'Products',
value: '125',
icon: Icons.inventory,
color: Colors.orange,
context: context,
),
_buildStatCard(
title: 'Customers',
value: '45',
icon: Icons.people,
color: Colors.purple,
context: context,
),
],
),
),
),
],
);
}

Widget \_buildAnalyticsTab(AppLocalizations localizations, ThemeData theme) {
return Center(
child: Text(
'Sales Analytics - Coming Soon',
style: theme.textTheme.titleLarge,
),
);
}

Widget \_buildPerformanceTab(AppLocalizations localizations, ThemeData theme) {
return Center(
child: Text(
'Performance Metrics - Coming Soon',
style: theme.textTheme.titleLarge,
),
);
}

Widget \_buildStatCard({
required String title,
required String value,
required IconData icon,
required Color color,
required BuildContext context,
}) {
return Card(
elevation: 2,
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
Icon(icon, size: 32, color: color),
const SizedBox(height: 8),
Text(
value,
style: Theme.of(context).textTheme.headlineSmall?.copyWith(
fontWeight: FontWeight.bold,
color: color,
),
),
const SizedBox(height: 4),
Text(
title,
style: Theme.of(context).textTheme.bodySmall?.copyWith(
color: Colors.grey.shade600,
),
textAlign: TextAlign.center,
),
],
),
),
);
}
}

// Remove or comment out the SalesData class if not needed

##

// widgets/dashboard/live_datetime_widget.dart
// A live date and time widget that displays the current date and time,
// supporting both Gregorian and Ethiopian calendars with localization.
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/utils/date_utils.dart';
import 'package:andalus_smart_pos/src/providers/calendar_provider.dart';
import 'package:andalus_smart_pos/src/providers/language_provider.dart';
import 'package:andalus_smart_pos/src/utils/ethiopian_calendar.dart';
import 'package:intl/intl.dart';

class LiveDateTimeWidget extends ConsumerStatefulWidget {
const LiveDateTimeWidget({super.key});

@override
ConsumerState<LiveDateTimeWidget> createState() => \_LiveDateTimeWidgetState();
}

class \_LiveDateTimeWidgetState extends ConsumerState<LiveDateTimeWidget> {
late Timer \_timer;
DateTime \_currentTime = DateTime.now();

@override
void initState() {
super.initState();
\_timer = Timer.periodic(const Duration(seconds: 1), (timer) {
setState(() {
\_currentTime = DateTime.now();
});
});
}

@override
void dispose() {
\_timer.cancel();
super.dispose();
}

String \_getEthiopianDate() {
final ethDate = EthiopianCalendar.gregorianToEthiopian(\_currentTime);
final isAmharic = ref.read(languageProvider).languageCode == 'am';
return EthiopianCalendar.formatDate(ethDate, isAmharic ? 'am' : 'en');
}

String \_getCalendarLabel() {
final calendarSettings = ref.read(calendarProvider);
final isAmharic = ref.read(languageProvider).languageCode == 'am';

    if (calendarSettings.calendarType == CalendarType.ethiopian) {
      return isAmharic ? '·ä¢·âµ·ãÆ·åµ·ã´·ãä ·âÄ·äï ·àò·âÅ·å†·à™·ã´' : 'Ethiopian Calendar';
    } else {
      return isAmharic ? '·åç·à™·åé·à≠·ã´·äï ·âÄ·äï ·àò·âÅ·å†·à™·ã´' : 'Gregorian Calendar';
    }

}

@override
Widget build(BuildContext context) {
final calendarSettings = ref.read(calendarProvider);
final isAmharic = ref.read(languageProvider).languageCode == 'am';

    return Container(
      margin: const EdgeInsets.symmetric(horizontal: 20, vertical: 8),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        gradient: LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [
            Theme.of(context).colorScheme.primary.withOpacity(0.1),
            Theme.of(context).colorScheme.primary.withOpacity(0.05),
          ],
        ),
        borderRadius: BorderRadius.circular(16),
        border: Border.all(
          color: Theme.of(context).colorScheme.primary.withOpacity(0.2),
        ),
      ),
      child: Row(
        children: [
          Icon(
            Icons.calendar_today_rounded,
            color: Theme.of(context).colorScheme.primary,
            size: 24,
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  _getCalendarLabel(),
                  style: Theme.of(context).textTheme.labelSmall?.copyWith(
                        color: Theme.of(context).colorScheme.primary,
                        fontWeight: FontWeight.w600,
                      ),
                ),
                const SizedBox(height: 4),
                Text(
                  calendarSettings.calendarType == CalendarType.ethiopian
                      ? _getEthiopianDate()
                      : AppDateUtils.getCurrentFullDate(context, ref),
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.w700,
                        color: Theme.of(context).colorScheme.onBackground,
                      ),
                ),
                const SizedBox(height: 2),
                Text(
                  DateFormat('HH:mm:ss').format(_currentTime),
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                        color: Theme.of(context).colorScheme.outline,
                        fontFamily: 'RobotoMono',
                      ),
                ),
              ],
            ),
          ),
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
            decoration: BoxDecoration(
              color: Theme.of(context).colorScheme.primary.withOpacity(0.1),
              borderRadius: BorderRadius.circular(8),
            ),
            child: Text(
              calendarSettings.calendarType == CalendarType.ethiopian
                  ? 'ETH'
                  : 'GREG',
              style: Theme.of(context).textTheme.labelSmall?.copyWith(
                    color: Theme.of(context).colorScheme.primary,
                    fontWeight: FontWeight.w700,
                  ),
            ),
          ),
        ],
      ),
    );

}
}

##

// mobile/lib/src/widgets/dashboard/metric_card.dart
// A reusable metric card widget for displaying key performance indicators on the dashboard.
import 'package:flutter/material.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';

class MetricCard extends StatelessWidget {
final String label;
final String value;
final IconData icon;
final bool isWarning;
final AppLocalizations localizations;

const MetricCard({
super.key,
required this.label,
required this.value,
required this.icon,
this.isWarning = false,
required this.localizations,
});

@override
Widget build(BuildContext context) {
return Container(
padding: const EdgeInsets.all(16),
decoration: BoxDecoration(
color: Theme.of(context).colorScheme.surfaceVariant.withOpacity(0.3),
borderRadius: BorderRadius.circular(16),
border: Border.all(
color: Theme.of(context).colorScheme.outline.withOpacity(0.1),
),
),
child: Row(
children: [
Icon(
icon,
size: 20,
color: isWarning
? const Color(0xFFEF4444)
: Theme.of(context).colorScheme.primary,
),
const SizedBox(width: 12),
Expanded(
child: Text(
label,
style: Theme.of(context).textTheme.bodyMedium?.copyWith(
color: Theme.of(context).colorScheme.onSurfaceVariant,
fontWeight: FontWeight.w500,
),
),
),
Text(
value,
style: Theme.of(context).textTheme.bodyLarge?.copyWith(
fontWeight: FontWeight.w700,
color: isWarning
? const Color(0xFFEF4444)
: Theme.of(context).colorScheme.onSurface,
),
),
],
),
);
}
}

##

// mobile/lib/src/widgets/dashboard/quick_actions_widget.dart
// A quick actions widget providing shortcuts to common tasks on the dashboard.
import 'package:flutter/material.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';

class QuickActionsWidget extends StatelessWidget {
final AppLocalizations localizations;

const QuickActionsWidget({
super.key,
required this.localizations,
});

@override
Widget build(BuildContext context) {
final actions = [
{
'icon': Icons.point_of_sale_rounded,
'label': localizations.translate('newSale'),
'route': '/pos',
'color': const Color(0xFF10B981),
},
{
'icon': Icons.inventory_2_rounded,
'label': localizations.translate('addProduct'),
'route': '/products',
'color': const Color(0xFF3B82F6),
},
{
'icon': Icons.people_rounded,
'label': localizations.translate('addCustomer'),
'route': '/customers',
'color': const Color(0xFF8B5CF6),
},
{
'icon': Icons.bar_chart_rounded,
'label': localizations.translate('reports'),
'route': '/reports',
'color': const Color(0xFFF59E0B),
},
];

    return Card(
      elevation: 0,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(20),
        side: BorderSide(
          color: Theme.of(context).colorScheme.outline.withOpacity(0.1),
        ),
      ),
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              localizations.translate('quickActions'),
              style: Theme.of(context).textTheme.titleLarge?.copyWith(
                    fontWeight: FontWeight.w700,
                  ),
            ),
            const SizedBox(height: 16),
            Wrap(
              spacing: 12,
              runSpacing: 12,
              children: actions
                  .map((action) => _buildActionChip(context, action))
                  .toList(),
            ),
          ],
        ),
      ),
    );

}

Widget \_buildActionChip(BuildContext context, Map<String, dynamic> action) {
return ActionChip(
avatar: Container(
padding: const EdgeInsets.all(4),
decoration: BoxDecoration(
color: action['color'].withOpacity(0.1),
borderRadius: BorderRadius.circular(8),
),
child: Icon(
action['icon'],
size: 16,
color: action['color'],
),
),
label: Text(
action['label'],
style: TextStyle(
fontSize: 12,
fontWeight: FontWeight.w600,
color: action['color'],
),
),
onPressed: () => Navigator.pushNamed(context, action['route']),
backgroundColor: action['color'].withOpacity(0.05),
side: BorderSide(
color: action['color'].withOpacity(0.2),
),
);
}
}

##

// mobile/lib/src/widgets/dashboard/recent_sales_list.dart
// A recent sales list widget displaying the latest sales transactions on the dashboard.
import 'package:flutter/material.dart';
import 'package:andalus_smart_pos/src/data/models/sale.dart';
import 'package:andalus_smart_pos/src/utils/date_utils.dart';
import 'package:andalus_smart_pos/src/utils/formatters.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';

class RecentSalesList extends StatelessWidget {
final List<Sale> sales;
final AppLocalizations localizations;

const RecentSalesList({
super.key,
required this.sales,
required this.localizations,
});

@override
Widget build(BuildContext context) {
return Card(
elevation: 0,
shape: RoundedRectangleBorder(
borderRadius: BorderRadius.circular(20),
side: BorderSide(
color: Theme.of(context).colorScheme.outline.withOpacity(0.1),
),
),
child: Padding(
padding: const EdgeInsets.all(24),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Row(
children: [
Container(
padding: const EdgeInsets.all(8),
decoration: BoxDecoration(
color:
Theme.of(context).colorScheme.primary.withOpacity(0.1),
borderRadius: BorderRadius.circular(12),
),
child: Icon(
Icons.receipt_long_rounded,
color: Theme.of(context).colorScheme.primary,
size: 24,
),
),
const SizedBox(width: 12),
Text(
localizations.translate('recentSales'),
style: Theme.of(context).textTheme.titleLarge?.copyWith(
fontWeight: FontWeight.w700,
),
),
const Spacer(),
Container(
padding:
const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
decoration: BoxDecoration(
color:
Theme.of(context).colorScheme.primary.withOpacity(0.1),
borderRadius: BorderRadius.circular(8),
),
child: Text(
localizations.translate('today'),
style: Theme.of(context).textTheme.bodySmall?.copyWith(
color: Theme.of(context).colorScheme.primary,
fontWeight: FontWeight.w600,
),
),
),
],
),
const SizedBox(height: 20),
if (sales.isEmpty)
\_buildEmptyState(context)
else
Column(
children: sales
.take(5)
.map((sale) => \_buildSaleItem(context, sale))
.toList(),
),
],
),
),
);
}

Widget \_buildSaleItem(BuildContext context, Sale sale) {
final paymentColor = \_getPaymentMethodColor(sale.paymentMethod);
final idString = sale.id?.toString();
final displayId = idString == null
? 'N/A' // Handle null case
: (idString.length <= 6
? idString // If 6 chars or less, show the whole string
: idString.substring(idString.length - 6));
return Container(
margin: const EdgeInsets.only(bottom: 12),
padding: const EdgeInsets.all(16),
decoration: BoxDecoration(
color: Theme.of(context).colorScheme.surfaceVariant.withOpacity(0.3),
borderRadius: BorderRadius.circular(16),
),
child: Row(
children: [
Container(
width: 44,
height: 44,
decoration: BoxDecoration(
color: paymentColor.withOpacity(0.1),
borderRadius: BorderRadius.circular(12),
),
child: Icon(
\_getPaymentMethodIcon(sale.paymentMethod),
color: paymentColor,
size: 20,
),
),
const SizedBox(width: 16),
Expanded(
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
// Text(
// '${localizations.translate('sale')} #${sale.id?.substring(sale.id!.length - 6) ?? 'N/A'}',
// style: Theme.of(context).textTheme.bodyLarge?.copyWith(
// fontWeight: FontWeight.w600,
// ),
// ),
Text(
'${localizations.translate('sale')} #$displayId',
style: Theme.of(context).textTheme.bodyLarge?.copyWith(
fontWeight: FontWeight.w600,
),
),
const SizedBox(height: 2),
Text(
'${AppDateUtils.formatTime(sale.createdAt)} ‚Ä¢ ${_formatPaymentMethod(sale.paymentMethod, localizations)}',
style: Theme.of(context).textTheme.bodySmall?.copyWith(
color: Theme.of(context).colorScheme.outline,
),
),
],
),
),
Column(
crossAxisAlignment: CrossAxisAlignment.end,
children: [
Text(
sale.formattedTotal,
style: Theme.of(context).textTheme.bodyLarge?.copyWith(
fontWeight: FontWeight.w700,
color: Theme.of(context).colorScheme.primary,
),
),
Text(
AppDateUtils.formatDate(sale.createdAt),
style: Theme.of(context).textTheme.bodySmall?.copyWith(
color: Theme.of(context).colorScheme.outline,
),
),
],
),
],
),
);
}

Widget \_buildEmptyState(BuildContext context) {
return Column(
children: [
const SizedBox(height: 20),
Icon(
Icons.receipt_long_outlined,
size: 64,
color: Theme.of(context).colorScheme.outline.withOpacity(0.5),
),
const SizedBox(height: 16),
Text(
localizations.translate('noSalesToday'),
style: Theme.of(context).textTheme.titleMedium?.copyWith(
fontWeight: FontWeight.w600,
),
),
const SizedBox(height: 8),
Text(
localizations.translate('completeFirstSale'),
style: Theme.of(context).textTheme.bodyMedium?.copyWith(
color: Theme.of(context).colorScheme.outline,
),
textAlign: TextAlign.center,
),
],
);
}

Color \_getPaymentMethodColor(String method) {
switch (method.toLowerCase()) {
case 'cash':
return const Color(0xFF10B981);
case 'telebirr':
return const Color(0xFF3B82F6);
case 'card':
return const Color(0xFF8B5CF6);
case 'credit':
return const Color(0xFFF59E0B);
default:
return const Color(0xFF6B7280);
}
}

IconData \_getPaymentMethodIcon(String method) {
switch (method.toLowerCase()) {
case 'cash':
return Icons.money_rounded;
case 'telebirr':
return Icons.qr_code_rounded;
case 'card':
return Icons.credit_card_rounded;
case 'credit':
return Icons.credit_score_rounded;
default:
return Icons.payment_rounded;
}
}

String \_formatPaymentMethod(String method, AppLocalizations localizations) {
switch (method.toLowerCase()) {
case 'cash':
return localizations.translate('cash');
case 'telebirr':
return localizations.translate('telebirr');
case 'card':
return localizations.translate('card');
case 'credit':
return localizations.translate('credit');
default:
return method;
}
}
}

##

// widgets/dashboard/sales_analytics.dart
// A sales analytics widget displaying sales data with charts and statistics on the dashboard.
import 'package:andalus_smart_pos/src/data/repositories/sale_repository.dart';
import 'package:flutter/material.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
import 'package:andalus_smart_pos/src/utils/formatters.dart';

class SalesAnalyticsWidget extends ConsumerStatefulWidget {
final SalesSummary salesData;
final AppLocalizations localizations;

const SalesAnalyticsWidget({
super.key,
required this.salesData,
required this.localizations,
});

@override
ConsumerState<SalesAnalyticsWidget> createState() =>
\_SalesAnalyticsWidgetState();
}

class \_SalesAnalyticsWidgetState extends ConsumerState<SalesAnalyticsWidget> {
int \_selectedChartIndex = 0;
final List<String> \_chartTypes = ['daily', 'weekly', 'monthly'];

@override
Widget build(BuildContext context) {
return Card(
elevation: 0,
shape: RoundedRectangleBorder(
borderRadius: BorderRadius.circular(16), // Smaller radius
side: BorderSide(
color: Theme.of(context).colorScheme.outline.withOpacity(0.1),
),
),
child: Container(
padding: const EdgeInsets.all(16), // Reduced padding
constraints: const BoxConstraints(
minHeight: 320, // Fixed minimum height
),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
mainAxisSize: MainAxisSize.min,
children: [
// Header - More compact
Row(
children: [
Container(
padding: const EdgeInsets.all(6), // Smaller
decoration: BoxDecoration(
color:
Theme.of(context).colorScheme.primary.withOpacity(0.1),
borderRadius: BorderRadius.circular(8),
),
child: Icon(
Icons.analytics_rounded,
color: Theme.of(context).colorScheme.primary,
size: 20, // Smaller icon
),
),
const SizedBox(width: 8),
Expanded(
child: Text(
widget.localizations.translate('salesAnalytics'),
style: Theme.of(context).textTheme.titleMedium?.copyWith(
fontWeight: FontWeight.w700,
),
maxLines: 1,
overflow: TextOverflow.ellipsis,
),
),
const SizedBox(width: 8),
// Chart Type Selector - More compact
Container(
padding:
const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
decoration: BoxDecoration(
color: Theme.of(context).colorScheme.surface,
borderRadius: BorderRadius.circular(8),
border: Border.all(
color: Theme.of(context)
.colorScheme
.outline
.withOpacity(0.2),
),
),
child: DropdownButton<int>(
value: _selectedChartIndex,
underline: const SizedBox(),
icon: Icon(
Icons.arrow_drop_down_rounded,
color: Theme.of(context).colorScheme.primary,
size: 16,
),
items: _chartTypes.asMap().entries.map((entry) {
return DropdownMenuItem<int>(
value: entry.key,
child: Text(
_getChartTypeName(entry.value),
style: TextStyle(
fontSize: 10,
color: Theme.of(context).colorScheme.onSurface,
),
),
);
}).toList(),
onChanged: (value) {
setState(() {
_selectedChartIndex = value!;
});
},
),
),
],
),
const SizedBox(height: 16),

            // Chart - Fixed height
            SizedBox(
              height: 160, // Reduced height
              child: _buildSalesChart(),
            ),
            const SizedBox(height: 12),

            // Statistics - More compact
            _buildStatistics(),
          ],
        ),
      ),
    );

}

String \_getChartTypeName(String type) {
switch (type) {
case 'daily':
return widget.localizations.translate('today');
case 'weekly':
return widget.localizations.translate('weeklySales');
case 'monthly':
return widget.localizations.translate('thisMonth');
default:
return type;
}
}

Widget \_buildSalesChart() {
final chartData = \_getChartData();

    return LineChart(
      LineChartData(
        gridData: FlGridData(
          show: true,
          drawVerticalLine: false, // Remove vertical lines for cleaner look
          horizontalInterval: _getHorizontalInterval(chartData),
          getDrawingHorizontalLine: (value) {
            return FlLine(
              color: Theme.of(context).colorScheme.outline.withOpacity(0.1),
              strokeWidth: 1,
            );
          },
        ),
        titlesData: FlTitlesData(
          show: true,
          rightTitles: const AxisTitles(
            sideTitles: SideTitles(showTitles: false),
          ),
          topTitles: const AxisTitles(
            sideTitles: SideTitles(showTitles: false),
          ),
          bottomTitles: AxisTitles(
            sideTitles: SideTitles(
              showTitles: true,
              reservedSize: 20, // Smaller reserved size
              interval: 1,
              getTitlesWidget: (value, meta) {
                if (value.toInt() >= chartData.length) return const SizedBox();
                return Padding(
                  padding: const EdgeInsets.only(top: 4.0),
                  child: Text(
                    _getBottomTitle(value.toInt(), chartData.length),
                    style: TextStyle(
                      fontSize: 9, // Smaller font
                      color: Theme.of(context).colorScheme.outline,
                    ),
                  ),
                );
              },
            ),
          ),
          leftTitles: AxisTitles(
            sideTitles: SideTitles(
              showTitles: true,
              interval: _getHorizontalInterval(chartData),
              reservedSize: 32, // Smaller reserved size
              getTitlesWidget: (value, meta) {
                return Text(
                  AppFormatters.formatCompactCurrency(value),
                  style: TextStyle(
                    fontSize: 9, // Smaller font
                    color: Theme.of(context).colorScheme.outline,
                  ),
                );
              },
            ),
          ),
        ),
        borderData: FlBorderData(
          show: false, // Remove border for cleaner look
        ),
        minX: 0,
        maxX: chartData.length > 0 ? (chartData.length - 1).toDouble() : 0,
        minY: 0,
        maxY: chartData.isNotEmpty
            ? chartData.reduce((a, b) => a > b ? a : b) * 1.1
            : 1000,
        lineBarsData: [
          LineChartBarData(
            spots: chartData.asMap().entries.map((entry) {
              return FlSpot(entry.key.toDouble(), entry.value);
            }).toList(),
            isCurved: true,
            color: Theme.of(context).colorScheme.primary,
            barWidth: 2, // Thinner line
            isStrokeCapRound: true,
            dotData: const FlDotData(show: false),
            belowBarData: BarAreaData(
              show: true,
              color: Theme.of(context)
                  .colorScheme
                  .primary
                  .withOpacity(0.05), // Lighter fill
            ),
          ),
        ],
      ),
    );

}

List<double> \_getChartData() {
switch (\_chartTypes[_selectedChartIndex]) {
case 'daily':
// Simulate hourly data for today - smaller values
return [
300,
500,
800,
600,
900,
1200,
1000,
1400,
1600,
1800,
2000,
2200
];
case 'weekly':
// Last 7 days data - smaller values
return [
widget.salesData.weeklySales * 0.08,
widget.salesData.weeklySales * 0.12,
widget.salesData.weeklySales * 0.15,
widget.salesData.weeklySales * 0.20,
widget.salesData.weeklySales * 0.18,
widget.salesData.weeklySales * 0.15,
widget.salesData.weeklySales * 0.12,
];
case 'monthly':
// Last 30 days aggregated by week - smaller values
return [
widget.salesData.totalSales * 0.08,
widget.salesData.totalSales * 0.12,
widget.salesData.totalSales * 0.20,
widget.salesData.totalSales * 0.25,
widget.salesData.totalSales * 0.18,
];
default:
return [0, 0, 0, 0, 0];
}
}

double \_getHorizontalInterval(List<double> data) {
if (data.isEmpty) return 1000;
final maxValue = data.reduce((a, b) => a > b ? a : b);
if (maxValue > 10000) return 5000;
if (maxValue > 5000) return 2000;
if (maxValue > 1000) return 500;
if (maxValue > 500) return 200;
return 100;
}

String \_getBottomTitle(int index, int total) {
switch (\_chartTypes[_selectedChartIndex]) {
case 'daily':
final hours = ['6', '8', '10', '12', '2', '4', '6', '8', '10'];
return index < hours.length ? hours[index] : '';
case 'weekly':
final days = ['M', 'T', 'W', 'T', 'F', 'S', 'S'];
return index < days.length ? days[index] : '';
case 'monthly':
final weeks = ['W1', 'W2', 'W3', 'W4', 'W5'];
return index < weeks.length ? weeks[index] : '';
default:
return index.toString();
}
}

Widget \_buildStatistics() {
return Container(
padding: const EdgeInsets.all(12), // Reduced padding
decoration: BoxDecoration(
color: Theme.of(context).colorScheme.surface,
borderRadius: BorderRadius.circular(8), // Smaller radius
border: Border.all(
color: Theme.of(context).colorScheme.outline.withOpacity(0.1),
),
),
child: Row(
mainAxisAlignment: MainAxisAlignment.spaceAround,
children: [
_buildStatItem(
widget.localizations.translate('todayRevenue'),
AppFormatters.formatCurrency(widget.salesData.todaysSales),
Icons.today_rounded,
const Color(0xFF10B981),
),
_buildStatItem(
widget.localizations.translate('weeklySales'),
AppFormatters.formatCurrency(widget.salesData.weeklySales),
Icons.calendar_view_week_rounded,
const Color(0xFF3B82F6),
),
_buildStatItem(
widget.localizations.translate('totalRevenue'),
AppFormatters.formatCompactCurrency(widget.salesData.totalSales),
Icons.bar_chart_rounded,
const Color(0xFF8B5CF6),
),
],
),
);
}

Widget \_buildStatItem(
String label, String value, IconData icon, Color color) {
return Expanded(
child: Column(
mainAxisSize: MainAxisSize.min,
children: [
Container(
padding: const EdgeInsets.all(6), // Smaller
decoration: BoxDecoration(
color: color.withOpacity(0.1),
borderRadius: BorderRadius.circular(6),
),
child: Icon(icon, color: color, size: 16), // Smaller icon
),
const SizedBox(height: 6),
FittedBox(
fit: BoxFit.scaleDown,
child: Text(
value,
style: Theme.of(context).textTheme.bodyMedium?.copyWith(
fontWeight: FontWeight.w700,
color: Theme.of(context).colorScheme.onSurface,
fontSize: 12, // Smaller font
),
maxLines: 1,
textAlign: TextAlign.center,
),
),
const SizedBox(height: 2),
Text(
label,
style: Theme.of(context).textTheme.bodySmall?.copyWith(
color: Theme.of(context).colorScheme.outline,
fontSize: 9, // Smaller font
),
maxLines: 1,
overflow: TextOverflow.ellipsis,
textAlign: TextAlign.center,
),
],
),
);
}
}

##

// mobile/lib/src/widgets/dashboard/sales_charts.dart
// A sales analytics widget displaying sales data with charts and statistics on the dashboard.
import 'package:andalus_smart_pos/src/data/repositories/sale_repository.dart';
import 'package:flutter/material.dart';
import 'package:andalus_smart_pos/src/data/models/sale.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';

class SalesChartsWidget extends StatelessWidget {
final SalesSummary salesData;
final AppLocalizations localizations;

const SalesChartsWidget({
super.key,
required this.salesData,
required this.localizations,
});

@override
Widget build(BuildContext context) {
return Card(
elevation: 0,
shape: RoundedRectangleBorder(
borderRadius: BorderRadius.circular(20),
side: BorderSide(
color: Theme.of(context).colorScheme.outline.withOpacity(0.1),
),
),
child: Padding(
padding: const EdgeInsets.all(24),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
localizations.translate('salesAnalytics'),
style: Theme.of(context).textTheme.titleLarge?.copyWith(
fontWeight: FontWeight.w700,
),
),
const SizedBox(height: 16),
Container(
height: 200,
decoration: BoxDecoration(
color: Theme.of(context)
.colorScheme
.surfaceVariant
.withOpacity(0.3),
borderRadius: BorderRadius.circular(16),
),
child: Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
Icon(
Icons.bar_chart_rounded,
size: 48,
color: Theme.of(context)
.colorScheme
.outline
.withOpacity(0.5),
),
const SizedBox(height: 12),
Text(
localizations.translate('chartsComingSoon'),
style: Theme.of(context).textTheme.bodyMedium?.copyWith(
color: Theme.of(context).colorScheme.outline,
),
),
Text(
localizations.translate('installFlChart'),
style: Theme.of(context).textTheme.bodySmall?.copyWith(
color: Theme.of(context).colorScheme.outline,
),
),
],
),
),
),
],
),
),
);
}
}

##

// mobile/lib/src/widgets/dashboard/stat_card.dart
// A reusable stat card widget for displaying key statistics on the dashboard.
import 'package:flutter/material.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';

class StatCard extends StatelessWidget {
final String title;
final String value;
final IconData icon;
final Color color;
final int? trend;
final String? subtitle;
final bool isWarning;
final AppLocalizations localizations;

const StatCard({
super.key,
required this.title,
required this.value,
required this.icon,
required this.color,
this.trend,
this.subtitle,
this.isWarning = false,
required this.localizations,
});

@override
Widget build(BuildContext context) {
return Card(
elevation: 0,
shape: RoundedRectangleBorder(
borderRadius: BorderRadius.circular(16),
side: BorderSide(
color: Theme.of(context).colorScheme.outline.withOpacity(0.1),
),
),
child: Padding(
padding: const EdgeInsets.all(20),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
mainAxisAlignment: MainAxisAlignment.spaceBetween,
children: [
Row(
mainAxisAlignment: MainAxisAlignment.spaceBetween,
children: [
Container(
padding: const EdgeInsets.all(8),
decoration: BoxDecoration(
color: color.withOpacity(0.1),
borderRadius: BorderRadius.circular(12),
),
child: Icon(icon, color: color, size: 20),
),
if (trend != null) ...[
Container(
padding:
const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
decoration: BoxDecoration(
color: trend! > 0
? Colors.green.withOpacity(0.1)
: Colors.red.withOpacity(0.1),
borderRadius: BorderRadius.circular(8),
),
child: Row(
children: [
Icon(
trend! > 0 ? Icons.trending_up : Icons.trending_down,
color: trend! > 0 ? Colors.green : Colors.red,
size: 14,
),
const SizedBox(width: 2),
Text(
trend! > 0
? localizations.translate('up')
: localizations.translate('down'),
style: TextStyle(
fontSize: 10,
fontWeight: FontWeight.w600,
color: trend! > 0 ? Colors.green : Colors.red,
),
),
],
),
),
],
],
),
Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
value,
style: Theme.of(context).textTheme.headlineSmall?.copyWith(
fontWeight: FontWeight.w700,
color: isWarning
? const Color(0xFFEF4444)
: Theme.of(context).colorScheme.onSurface,
),
maxLines: 1,
overflow: TextOverflow.ellipsis,
),
if (subtitle != null) ...[
const SizedBox(height: 4),
Text(
subtitle!,
style: Theme.of(context).textTheme.bodySmall?.copyWith(
color: Theme.of(context).colorScheme.outline,
),
),
],
const SizedBox(height: 4),
Text(
title,
style: Theme.of(context).textTheme.bodyMedium?.copyWith(
color: Theme.of(context).colorScheme.outline,
fontWeight: FontWeight.w500,
),
),
],
),
],
),
),
);
}
}

##

// mobile/lib/src/widgets/dashboard/stock_alert_widget.dart
// A stock alert widget that notifies about low stock products on the dashboard.
import 'package:flutter/material.dart';
import 'package:andalus_smart_pos/src/data/models/product.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';

class StockAlertWidget extends StatelessWidget {
final List<Product> products;
final AppLocalizations localizations;

const StockAlertWidget({
super.key,
required this.products,
required this.localizations,
});

@override
Widget build(BuildContext context) {
final hasLowStock = products.isNotEmpty;

    return Card(
      elevation: 0,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(20),
        side: BorderSide(
          color: hasLowStock
              ? const Color(0xFFEF4444).withOpacity(0.2)
              : Theme.of(context).colorScheme.outline.withOpacity(0.1),
        ),
      ),
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Container(
                  padding: const EdgeInsets.all(6),
                  decoration: BoxDecoration(
                    color: hasLowStock
                        ? const Color(0xFFEF4444).withOpacity(0.1)
                        : const Color(0xFF10B981).withOpacity(0.1),
                    borderRadius: BorderRadius.circular(10),
                  ),
                  child: Icon(
                    hasLowStock
                        ? Icons.warning_amber_rounded
                        : Icons.inventory_2_rounded,
                    color: hasLowStock
                        ? const Color(0xFFEF4444)
                        : const Color(0xFF10B981),
                    size: 20,
                  ),
                ),
                const SizedBox(width: 12),
                Text(
                  localizations.translate('stockAlert'),
                  style: Theme.of(context).textTheme.titleLarge?.copyWith(
                        fontWeight: FontWeight.w700,
                      ),
                ),
              ],
            ),
            const SizedBox(height: 16),
            if (products.isEmpty)
              Text(
                localizations.translate('allProductsWellStocked'),
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                      color: Theme.of(context).colorScheme.outline,
                    ),
              )
            else
              Column(
                children: products
                    .take(4)
                    .map((product) => _buildProductItem(context, product))
                    .toList(),
              ),
            if (products.length > 4) ...[
              const SizedBox(height: 8),
              Text(
                localizations.translate('moreProducts',
                    params: {'count': (products.length - 4).toString()}),
                style: Theme.of(context).textTheme.bodySmall?.copyWith(
                      color: Theme.of(context).colorScheme.outline,
                      fontStyle: FontStyle.italic,
                    ),
              ),
            ],
          ],
        ),
      ),
    );

}

Widget \_buildProductItem(BuildContext context, Product product) {
return Container(
margin: const EdgeInsets.only(bottom: 8),
padding: const EdgeInsets.all(12),
decoration: BoxDecoration(
color: const Color(0xFFFEF3F2),
borderRadius: BorderRadius.circular(12),
border: Border.all(
color: const Color(0xFFFECDCA),
),
),
child: Row(
children: [
Expanded(
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
product.name,
style: Theme.of(context).textTheme.bodyMedium?.copyWith(
fontWeight: FontWeight.w600,
),
maxLines: 1,
overflow: TextOverflow.ellipsis,
),
const SizedBox(height: 2),
Text(
'SKU: ${product.sku ?? 'N/A'}',
style: Theme.of(context).textTheme.bodySmall?.copyWith(
color: Theme.of(context).colorScheme.outline,
),
),
],
),
),
Container(
padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
decoration: BoxDecoration(
color: const Color(0xFFEF4444).withOpacity(0.1),
borderRadius: BorderRadius.circular(8),
),
child: Text(
'${product.stockQuantity} ${localizations.translate('left')}',
style: const TextStyle(
fontSize: 12,
fontWeight: FontWeight.w700,
color: Color(0xFFEF4444),
),
),
),
],
),
);
}
}

##

// lib/src/widgets/reports/advanced_product_analytics.dart
// Advanced product analytics widget displaying detailed product performance metrics.
// This includes ABC analysis and profit margin distribution charts.
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import '../../localization/app_localizations.dart';
import '../../utils/reports_data_calculator.dart';
import '../common/custom_card.dart';

class AdvancedProductAnalytics extends StatelessWidget {
final ProductsReportData productsData;

const AdvancedProductAnalytics({super.key, required this.productsData});

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);

    return Column(
      children: [
        // ABC Analysis Chart
        CustomCard(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'ABC Analysis - Product Segmentation',
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                SizedBox(
                  height: 300,
                  child: SfCartesianChart(
                    primaryXAxis: const CategoryAxis(),
                    primaryYAxis: NumericAxis(
                      numberFormat: NumberFormat.percentPattern(),
                    ),
                    series: <CartesianSeries<ABCAnalysisData, String>>[
                      BarSeries<ABCAnalysisData, String>(
                        dataSource: _generateABCAnalysisData(),
                        xValueMapper: (data, _) => data.category,
                        yValueMapper: (data, _) => data.percentage,
                        dataLabelSettings:
                            const DataLabelSettings(isVisible: true),
                      )
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
        const SizedBox(height: 16),

        // Profit Margin Distribution
        CustomCard(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Profit Margin Distribution',
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                SizedBox(
                  height: 250,
                  child: SfCircularChart(
                    series: <CircularSeries>[
                      PieSeries<MarginDistributionData, String>(
                        dataSource: _generateMarginDistributionData(),
                        xValueMapper: (data, _) => data.range,
                        yValueMapper: (data, _) => data.count,
                        dataLabelSettings:
                            const DataLabelSettings(isVisible: true),
                      )
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ],
    );

}

List<ABCAnalysisData> \_generateABCAnalysisData() {
return [
ABCAnalysisData('A - High Value (20%)', 0.75),
ABCAnalysisData('B - Medium Value (30%)', 0.20),
ABCAnalysisData('C - Low Value (50%)', 0.05),
];
}

List<MarginDistributionData> \_generateMarginDistributionData() {
return [
MarginDistributionData('0-10%', 5),
MarginDistributionData('10-20%', 12),
MarginDistributionData('20-30%', 25),
MarginDistributionData('30-40%', 18),
MarginDistributionData('40%+', 8),
];
}
}

class ABCAnalysisData {
final String category;
final double percentage;

ABCAnalysisData(this.category, this.percentage);
}

class MarginDistributionData {
final String range;
final int count;

MarginDistributionData(this.range, this.count);
}

##

// lib/src/widgets/reports/advanced_sales_charts.dart
// Advanced sales analytics widget displaying detailed sales performance metrics.
// This includes sales velocity and customer retention charts.
import 'package:flutter/material.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import '../../localization/app_localizations.dart';
import '../../utils/reports_data_calculator.dart';
import '../common/custom_card.dart';

class AdvancedSalesCharts extends StatelessWidget {
final SalesReportData salesData;

const AdvancedSalesCharts({super.key, required this.salesData});

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);

    return Column(
      children: [
        // Sales Velocity Chart
        CustomCard(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Sales Velocity',
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                SizedBox(
                  height: 250,
                  child: SfCartesianChart(
                    primaryXAxis: const CategoryAxis(),
                    primaryYAxis: NumericAxis(
                      title: AxisTitle(text: 'Sales per Day'),
                    ),
                    series: <CartesianSeries<SalesVelocityData, String>>[
                      LineSeries<SalesVelocityData, String>(
                        dataSource: _generateSalesVelocityData(),
                        xValueMapper: (data, _) => data.period,
                        yValueMapper: (data, _) => data.velocity,
                        markerSettings: const MarkerSettings(isVisible: true),
                        animationDuration: 1000,
                      )
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
        const SizedBox(height: 16),

        // Customer Retention Chart
        CustomCard(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Customer Retention',
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                SizedBox(
                  height: 250,
                  child: SfCircularChart(
                    series: <CircularSeries>[
                      DoughnutSeries<RetentionData, String>(
                        dataSource: _generateRetentionData(),
                        xValueMapper: (data, _) => data.category,
                        yValueMapper: (data, _) => data.value,
                        dataLabelSettings:
                            const DataLabelSettings(isVisible: true),
                      )
                    ],
                    legend: Legend(isVisible: true),
                  ),
                ),
              ],
            ),
          ),
        ),
      ],
    );

}

List<SalesVelocityData> \_generateSalesVelocityData() {
return [
SalesVelocityData('Week 1', 15.2),
SalesVelocityData('Week 2', 18.5),
SalesVelocityData('Week 3', 16.8),
SalesVelocityData('Week 4', 22.1),
];
}

List<RetentionData> \_generateRetentionData() {
return [
RetentionData('Repeat Customers', 65),
RetentionData('New Customers', 25),
RetentionData('Lost Customers', 10),
];
}
}

class SalesVelocityData {
final String period;
final double velocity;

SalesVelocityData(this.period, this.velocity);
}

class RetentionData {
final String category;
final double value;

RetentionData(this.category, this.value);
}

##

// lib/src/widgets/reports/customer_analytics_section.dart
// Customer analytics widget displaying customer behavior and lifetime value metrics.
// This includes customer lifetime value and churn risk analysis charts.
import 'package:flutter/material.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import '../../localization/app_localizations.dart';
import '../../utils/reports_data_calculator.dart';
import '../common/custom_card.dart';

class CustomerAnalyticsSection extends StatelessWidget {
final CustomersReportData customersData;

const CustomerAnalyticsSection({super.key, required this.customersData});

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);

    return Column(
      children: [
        // Customer Lifetime Value
        CustomCard(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Customer Lifetime Value Analysis',
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                SizedBox(
                  height: 300,
                  child: SfCartesianChart(
                    primaryXAxis: const CategoryAxis(),
                    primaryYAxis: NumericAxis(
                      title: AxisTitle(text: 'Lifetime Value (ETB)'),
                    ),
                    series: <CartesianSeries<LTVData, String>>[
                      BarSeries<LTVData, String>(
                        dataSource: _generateLTVData(),
                        xValueMapper: (data, _) => data.segment,
                        yValueMapper: (data, _) => data.value,
                        dataLabelSettings:
                            const DataLabelSettings(isVisible: true),
                      )
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
        const SizedBox(height: 16),

        // Churn Risk Analysis
        CustomCard(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Customer Churn Risk Analysis',
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                SizedBox(
                  height: 250,
                  child: SfCircularChart(
                    series: <CircularSeries>[
                      DoughnutSeries<ChurnData, String>(
                        dataSource: _generateChurnData(),
                        xValueMapper: (data, _) => data.risk,
                        yValueMapper: (data, _) => data.percentage,
                        dataLabelSettings:
                            const DataLabelSettings(isVisible: true),
                      )
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ],
    );

}

List<LTVData> \_generateLTVData() {
return [
LTVData('High Value', 12500),
LTVData('Medium Value', 6500),
LTVData('Low Value', 1800),
LTVData('New Customers', 500),
];
}

List<ChurnData> \_generateChurnData() {
return [
ChurnData('Low Risk', 60),
ChurnData('Medium Risk', 25),
ChurnData('High Risk', 15),
];
}
}

class LTVData {
final String segment;
final double value;

LTVData(this.segment, this.value);
}

class ChurnData {
final String risk;
final double percentage;

ChurnData(this.risk, this.percentage);
}

##

// lib/src/widgets/reports/customer_report_section.dart
// Customer report section widget displaying key customer metrics and charts.
// This includes overview stats, top customers, and outstanding balance analysis.
import 'package:andalus_smart_pos/src/data/models/subscription.dart';
import 'package:andalus_smart_pos/src/utils/chart_formatters.dart';
import 'package:flutter/material.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import '../../localization/app_localizations.dart';
import '../../utils/formatters.dart';
import '../../utils/reports_data_calculator.dart';
import '../common/custom_card.dart';

class CustomerReportSection extends StatelessWidget {
final CustomersReportData customersData;
final SubscriptionPlan plan;

const CustomerReportSection({
super.key,
required this.customersData,
required this.plan,
});

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);

    return ListView(
      padding: const EdgeInsets.all(16),
      children: [
        _buildCustomersOverview(localizations, theme),
        const SizedBox(height: 16),
        _buildTopCustomersChart(localizations, theme),
        const SizedBox(height: 16),
        _buildOutstandingBalanceChart(localizations, theme),
        if (plan.id == 'enterprise') ...[
          const SizedBox(height: 16),
          _buildAdvancedCustomerAnalytics(localizations, theme),
        ],
      ],
    );

}

Widget \_buildCustomersOverview(
AppLocalizations localizations, ThemeData theme) {
return CustomCard(
child: Padding(
padding: const EdgeInsets.all(20),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
localizations.customersOverview,
style: theme.textTheme.titleLarge?.copyWith(
fontWeight: FontWeight.bold,
color: theme.colorScheme.primary,
),
),
const SizedBox(height: 16),
GridView.count(
shrinkWrap: true,
physics: const NeverScrollableScrollPhysics(),
crossAxisCount: 2,
crossAxisSpacing: 16,
mainAxisSpacing: 16,
children: [
_buildMetricCard(
theme,
// localizations.totalCustomers,
localizations.translate('total_customers'),
customersData.totalCustomers.toString(),
Icons.people,
Colors.blue,
),
_buildMetricCard(
theme,
localizations.customersWithBalance,
customersData.customersWithBalance.toString(),
Icons.credit_card,
Colors.orange,
),
_buildMetricCard(
theme,
localizations.overdue,
customersData.overdueCustomers.toString(),
Icons.warning,
Colors.red,
),
_buildMetricCard(
theme,
localizations.outstandingCredit,
AppFormatters.formatCurrency(customersData.totalOutstanding),
Icons.money_off,
Colors.purple,
),
],
),
],
),
),
);
}

Widget \_buildMetricCard(
ThemeData theme, String title, String value, IconData icon, Color color) {
return Container(
decoration: BoxDecoration(
color: theme.colorScheme.surface,
borderRadius: BorderRadius.circular(12),
border: Border.all(color: theme.colorScheme.outline.withOpacity(0.2)),
),
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Row(
children: [
Container(
padding: const EdgeInsets.all(8),
decoration: BoxDecoration(
color: color.withOpacity(0.1),
borderRadius: BorderRadius.circular(8),
),
child: Icon(icon, color: color, size: 20),
),
const Spacer(),
Text(
value,
style: theme.textTheme.titleLarge?.copyWith(
fontWeight: FontWeight.bold,
),
),
],
),
const SizedBox(height: 8),
Text(
title,
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.7),
),
),
],
),
),
);
}

Widget _buildTopCustomersChart(
AppLocalizations localizations, ThemeData theme) {
return CustomCard(
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
localizations.topCustomers,
style: theme.textTheme.titleMedium?.copyWith(
fontWeight: FontWeight.bold,
),
),
const SizedBox(height: 16),
SizedBox(
height: 300,
child: customersData.topCustomers.isNotEmpty
? SfCartesianChart(
primaryXAxis: CategoryAxis(
labelRotation: -45,
majorGridLines: const MajorGridLines(width: 0),
),
primaryYAxis: NumericAxis(
numberFormat: ChartFormatters.currencyFormat,
),
series: <CartesianSeries<TopCustomer, String>>[
BarSeries<TopCustomer, String>(
dataSource:
customersData.topCustomers.take(8).toList(),
xValueMapper: (customer, _) => customer.name,
yValueMapper: (customer, \_) => customer.totalSpent,
color: theme.colorScheme.secondary,
dataLabelSettings:
const DataLabelSettings(isVisible: true),
)
],
)
: Center(
child: Text(
'No customer data available',
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.outline,
),
),
),
),
],
),
),
);
}

Widget \_buildOutstandingBalanceChart(
AppLocalizations localizations, ThemeData theme) {
// Simplified implementation - you can enhance this with real data
return CustomCard(
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
'Outstanding Balance Analysis',
style: theme.textTheme.titleMedium?.copyWith(
fontWeight: FontWeight.bold,
),
),
const SizedBox(height: 16),
Container(
height: 200,
alignment: Alignment.center,
child: Text(
'Advanced customer analytics available in Enterprise plan',
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.outline,
),
textAlign: TextAlign.center,
),
),
],
),
),
);
}

Widget \_buildAdvancedCustomerAnalytics(
AppLocalizations localizations, ThemeData theme) {
return CustomCard(
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
'Advanced Customer Analytics',
style: theme.textTheme.titleMedium?.copyWith(
fontWeight: FontWeight.bold,
),
),
const SizedBox(height: 16),
// Add enterprise-level customer analytics here
Text(
'Customer Lifetime Value, Churn Analysis, Segmentation',
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.outline,
),
),
],
),
),
);
}
}

##

// lib/src/widgets/reports/customers_overview_card.dart
// Customers overview card widget displaying key customer metrics.
import 'package:flutter/material.dart';
import '../../localization/app_localizations.dart';
import '../../utils/formatters.dart';
import '../../utils/reports_data_calculator.dart';
import '../common/custom_card.dart';

class CustomersOverviewCard extends StatelessWidget {
final CustomersReportData customersData;

const CustomersOverviewCard({super.key, required this.customersData});

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);

    return CustomCard(
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              localizations.customersOverview,
              style: theme.textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
                color: theme.colorScheme.primary,
              ),
            ),
            const SizedBox(height: 16),
            GridView.count(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              crossAxisCount: 2,
              crossAxisSpacing: 16,
              mainAxisSpacing: 16,
              children: [
                _buildMetricCard(
                  theme,
                  // localizations.totalCustomers,
                  localizations.translate('total_customers'),
                  AppFormatters.formatNumber(customersData.totalCustomers),
                  Icons.people,
                  Colors.blue,
                ),
                _buildMetricCard(
                  theme,
                  localizations.translate('customers_with_balance'),
                  AppFormatters.formatNumber(
                      customersData.customersWithBalance),
                  Icons.credit_card,
                  Colors.orange,
                ),
                _buildMetricCard(
                  theme,
                  localizations.overdue,
                  AppFormatters.formatNumber(customersData.overdueCustomers),
                  Icons.warning,
                  Colors.red,
                ),
                _buildMetricCard(
                  theme,
                  'Avg Customer Value',
                  AppFormatters.formatCurrency(
                      customersData.averageCustomerValue),
                  Icons.attach_money,
                  Colors.green,
                ),
              ],
            ),
          ],
        ),
      ),
    );

}

Widget \_buildMetricCard(
ThemeData theme, String title, String value, IconData icon, Color color) {
return Container(
decoration: BoxDecoration(
color: theme.colorScheme.surface,
borderRadius: BorderRadius.circular(12),
border: Border.all(color: theme.colorScheme.outline.withOpacity(0.2)),
),
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Row(
children: [
Container(
padding: const EdgeInsets.all(8),
decoration: BoxDecoration(
color: color.withOpacity(0.1),
borderRadius: BorderRadius.circular(8),
),
child: Icon(icon, color: color, size: 20),
),
const Spacer(),
Text(
value,
style: theme.textTheme.titleLarge?.copyWith(
fontWeight: FontWeight.bold,
),
),
],
),
const SizedBox(height: 8),
Text(
title,
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.7),
),
),
],
),
),
);
}
}

##

// lib/src/widgets/reports/financial_ratios_section.dart
// Financial ratios widget displaying key financial metrics and break-even analysis charts.
import 'package:flutter/material.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import '../../localization/app_localizations.dart';
import '../../utils/reports_data_calculator.dart';
import '../common/custom_card.dart';

class FinancialRatiosSection extends StatelessWidget {
final FinancialReportData financialData;

const FinancialRatiosSection({super.key, required this.financialData});

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);

    return Column(
      children: [
        // Key Financial Ratios
        CustomCard(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Key Financial Ratios',
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                SizedBox(
                  height: 300,
                  child: SfCartesianChart(
                    primaryXAxis: const CategoryAxis(),
                    primaryYAxis: NumericAxis(),
                    series: <CartesianSeries<FinancialRatio, String>>[
                      BarSeries<FinancialRatio, String>(
                        dataSource: _generateFinancialRatios(),
                        xValueMapper: (data, _) => data.ratio,
                        yValueMapper: (data, _) => data.value,
                        dataLabelSettings:
                            const DataLabelSettings(isVisible: true),
                      )
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
        const SizedBox(height: 16),

        // Break-Even Analysis
        CustomCard(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Break-Even Analysis',
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                SizedBox(
                  height: 250,
                  child: SfCartesianChart(
                    primaryXAxis: const CategoryAxis(),
                    primaryYAxis: NumericAxis(
                      title: AxisTitle(text: 'Amount (ETB)'),
                    ),
                    series: <CartesianSeries<BreakEvenData, String>>[
                      LineSeries<BreakEvenData, String>(
                        dataSource: _generateBreakEvenData(),
                        xValueMapper: (data, _) => data.month,
                        yValueMapper: (data, _) => data.revenue,
                        name: 'Revenue',
                        markerSettings: const MarkerSettings(isVisible: true),
                      ),
                      LineSeries<BreakEvenData, String>(
                        dataSource: _generateBreakEvenData(),
                        xValueMapper: (data, _) => data.month,
                        yValueMapper: (data, _) => data.costs,
                        name: 'Total Costs',
                        markerSettings: const MarkerSettings(isVisible: true),
                      ),
                    ],
                    legend: Legend(isVisible: true),
                  ),
                ),
              ],
            ),
          ),
        ),
      ],
    );

}

List<FinancialRatio> \_generateFinancialRatios() {
return [
FinancialRatio('Gross Margin', 35.2),
FinancialRatio('Net Margin', 22.8),
FinancialRatio('ROI', 18.5),
FinancialRatio('Current Ratio', 2.1),
FinancialRatio('Quick Ratio', 1.5),
];
}

List<BreakEvenData> \_generateBreakEvenData() {
return [
BreakEvenData('Jan', 80000, 95000),
BreakEvenData('Feb', 95000, 92000),
BreakEvenData('Mar', 110000, 98000),
BreakEvenData('Apr', 125000, 105000),
BreakEvenData('May', 140000, 110000),
BreakEvenData('Jun', 155000, 115000),
];
}
}

class FinancialRatio {
final String ratio;
final double value;

FinancialRatio(this.ratio, this.value);
}

class BreakEvenData {
final String month;
final double revenue;
final double costs;

BreakEvenData(this.month, this.revenue, this.costs);
}

##

// lib/src/widgets/reports/financial_report_section.dart
// Financial report section widget displaying key financial metrics and charts.
// This includes financial KPIs, profit margin trends, and cash flow analysis.
import 'package:andalus_smart_pos/src/utils/chart_formatters.dart';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import '../../localization/app_localizations.dart';
import '../../utils/formatters.dart';
import '../../utils/reports_data_calculator.dart';
import '../common/custom_card.dart';

class FinancialReportSection extends StatelessWidget {
final FinancialReportData financialData;

const FinancialReportSection({super.key, required this.financialData});

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);

    return ListView(
      padding: const EdgeInsets.all(16),
      children: [
        FinancialKPICards(financialData: financialData),
        const SizedBox(height: 16),
        ProfitMarginTrendChart(financialData: financialData),
        const SizedBox(height: 16),
        CashFlowAnalysisChart(financialData: financialData),
      ],
    );

}
}

class FinancialKPICards extends StatelessWidget {
final FinancialReportData financialData;

const FinancialKPICards({super.key, required this.financialData});

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);

    return CustomCard(
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Financial KPIs',
              style: theme.textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
                color: theme.colorScheme.primary,
              ),
            ),
            const SizedBox(height: 16),
            GridView.count(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              crossAxisCount: 2,
              crossAxisSpacing: 16,
              mainAxisSpacing: 16,
              children: [
                _buildKPICard(
                  theme,
                  'Total Revenue',
                  AppFormatters.formatCurrency(financialData.totalRevenue),
                  Icons.attach_money,
                  Colors.green,
                ),
                _buildKPICard(
                  theme,
                  'Net Revenue',
                  AppFormatters.formatCurrency(financialData.netRevenue),
                  Icons.account_balance,
                  Colors.blue,
                ),
                _buildKPICard(
                  theme,
                  'Profit Margin',
                  '${financialData.profitMargin.toStringAsFixed(1)}%',
                  Icons.trending_up,
                  Colors.orange,
                ),
                _buildKPICard(
                  theme,
                  'Total Tax',
                  AppFormatters.formatCurrency(financialData.totalTax),
                  Icons.receipt,
                  Colors.purple,
                ),
              ],
            ),
          ],
        ),
      ),
    );

}

Widget \_buildKPICard(
ThemeData theme, String title, String value, IconData icon, Color color) {
return Container(
decoration: BoxDecoration(
color: theme.colorScheme.surface,
borderRadius: BorderRadius.circular(12),
border: Border.all(color: theme.colorScheme.outline.withOpacity(0.2)),
),
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Row(
children: [
Container(
padding: const EdgeInsets.all(8),
decoration: BoxDecoration(
color: color.withOpacity(0.1),
borderRadius: BorderRadius.circular(8),
),
child: Icon(icon, color: color, size: 20),
),
const Spacer(),
Text(
value,
style: theme.textTheme.titleLarge?.copyWith(
fontWeight: FontWeight.bold,
),
),
],
),
const SizedBox(height: 8),
Text(
title,
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.7),
),
),
],
),
),
);
}
}

class ProfitMarginTrendChart extends StatelessWidget {
final FinancialReportData financialData;

const ProfitMarginTrendChart({super.key, required this.financialData});

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);

    return CustomCard(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Profit Margin Trend',
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            SizedBox(
              height: 300,
              child: SfCartesianChart(
                primaryXAxis: const CategoryAxis(),
                primaryYAxis: NumericAxis(
                  numberFormat:
                      NumberFormat.decimalPercentPattern(decimalDigits: 1),
                ),
                series: <CartesianSeries<ProfitData, String>>[
                  LineSeries<ProfitData, String>(
                    dataSource: _generateSampleProfitData(),
                    xValueMapper: (data, _) => data.period,
                    yValueMapper: (data, _) => data.margin,
                    markerSettings: const MarkerSettings(isVisible: true),
                    animationDuration: 1000,
                  )
                ],
              ),
            ),
          ],
        ),
      ),
    );

}

List<ProfitData> \_generateSampleProfitData() {
return [
ProfitData('Jan', 22.5),
ProfitData('Feb', 24.1),
ProfitData('Mar', 23.8),
ProfitData('Apr', 25.2),
ProfitData('May', 26.0),
ProfitData('Jun', 25.5),
];
}
}

class CashFlowAnalysisChart extends StatelessWidget {
final FinancialReportData financialData;

const CashFlowAnalysisChart({super.key, required this.financialData});

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);

    return CustomCard(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Cash Flow Analysis',
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            SizedBox(
              height: 300,
              child: SfCartesianChart(
                primaryXAxis: const CategoryAxis(),
                primaryYAxis: NumericAxis(
                  numberFormat: ChartFormatters.currencyFormat,
                ),
                series: <CartesianSeries<CashFlowData, String>>[
                  ColumnSeries<CashFlowData, String>(
                    dataSource: _generateSampleCashFlowData(),
                    xValueMapper: (data, _) => data.period,
                    yValueMapper: (data, _) => data.amount,
                    animationDuration: 1000,
                  )
                ],
              ),
            ),
          ],
        ),
      ),
    );

}

List<CashFlowData> \_generateSampleCashFlowData() {
return [
CashFlowData('Jan', 150000),
CashFlowData('Feb', 165000),
CashFlowData('Mar', 142000),
CashFlowData('Apr', 178000),
CashFlowData('May', 195000),
CashFlowData('Jun', 210000),
];
}
}

class ProfitData {
final String period;
final double margin;

ProfitData(this.period, this.margin);
}

class CashFlowData {
final String period;
final double amount;

CashFlowData(this.period, this.amount);
}

##

// lib/src/widgets/reports/inventory_analysis_section.dart
// Inventory analysis section widget displaying key inventory metrics and charts.
// This includes inventory turnover ratios and stock aging analysis.
import 'package:flutter/material.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import '../../localization/app_localizations.dart';
import '../../utils/reports_data_calculator.dart';
import '../common/custom_card.dart';

class InventoryAnalysisSection extends StatelessWidget {
final ProductsReportData productsData;

const InventoryAnalysisSection({super.key, required this.productsData});

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);

    return Column(
      children: [
        // Inventory Turnover Chart
        CustomCard(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Inventory Turnover Analysis',
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                SizedBox(
                  height: 300,
                  child: SfCartesianChart(
                    primaryXAxis: const CategoryAxis(),
                    primaryYAxis: NumericAxis(
                      title: AxisTitle(text: 'Turnover Ratio'),
                    ),
                    series: <CartesianSeries<TurnoverData, String>>[
                      ColumnSeries<TurnoverData, String>(
                        dataSource: _generateTurnoverData(),
                        xValueMapper: (data, _) => data.category,
                        yValueMapper: (data, _) => data.ratio,
                        dataLabelSettings:
                            const DataLabelSettings(isVisible: true),
                      )
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
        const SizedBox(height: 16),

        // Stock Movement Analysis
        CustomCard(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Stock Movement Analysis',
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                SizedBox(
                  height: 250,
                  child: SfCartesianChart(
                    primaryXAxis: const CategoryAxis(),
                    primaryYAxis: NumericAxis(title: AxisTitle(text: 'Units')),
                    series: <CartesianSeries<StockMovementData, String>>[
                      LineSeries<StockMovementData, String>(
                        dataSource: _generateStockMovementData(),
                        xValueMapper: (data, _) => data.period,
                        yValueMapper: (data, _) => data.units,
                        markerSettings: const MarkerSettings(isVisible: true),
                      )
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ],
    );

}

List<TurnoverData> \_generateTurnoverData() {
return [
TurnoverData('Fast Moving', 8.5),
TurnoverData('Medium Moving', 4.2),
TurnoverData('Slow Moving', 1.8),
];
}

List<StockMovementData> \_generateStockMovementData() {
return [
StockMovementData('Jan', 450),
StockMovementData('Feb', 520),
StockMovementData('Mar', 480),
StockMovementData('Apr', 610),
StockMovementData('May', 580),
StockMovementData('Jun', 720),
];
}
}

class TurnoverData {
final String category;
final double ratio;

TurnoverData(this.category, this.ratio);
}

class StockMovementData {
final String period;
final int units;

StockMovementData(this.period, this.units);
}

##

// lib/src/widgets/reports/outstanding_balance_chart.dart
// Outstanding balance chart widget displaying analysis of customer balances.
// This includes a breakdown of outstanding balances by range.
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import '../../localization/app_localizations.dart';
import '../../utils/formatters.dart';
import '../../utils/reports_data_calculator.dart';
import '../common/custom_card.dart';

class OutstandingBalanceChart extends StatelessWidget {
final CustomersReportData customersData;

const OutstandingBalanceChart({super.key, required this.customersData});

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);

    return CustomCard(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Outstanding Balance Analysis',
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            SizedBox(
              height: 300,
              child: SfCartesianChart(
                primaryXAxis: const CategoryAxis(),
                primaryYAxis: NumericAxis(
                  numberFormat: NumberFormat.currency(symbol: 'ETB '),
                ),
                series: <CartesianSeries<BalanceData, String>>[
                  ColumnSeries<BalanceData, String>(
                    dataSource: _generateBalanceData(),
                    xValueMapper: (data, _) => data.range,
                    yValueMapper: (data, _) => data.amount,
                    dataLabelSettings: const DataLabelSettings(isVisible: true),
                  )
                ],
              ),
            ),
          ],
        ),
      ),
    );

}

List<BalanceData> \_generateBalanceData() {
return [
BalanceData('0-1,000', 45000),
BalanceData('1,000-5,000', 125000),
BalanceData('5,000-10,000', 85000),
BalanceData('10,000+', 250000),
];
}
}

class BalanceData {
final String range;
final double amount;

BalanceData(this.range, this.amount);
}

##

// lib/src/widgets/reports/outstanding_balance_chart.dart
// Outstanding balance chart widget displaying analysis of customer balances.
// This includes a breakdown of outstanding balances by range.
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import '../../localization/app_localizations.dart';
import '../../utils/formatters.dart';
import '../../utils/reports_data_calculator.dart';
import '../common/custom_card.dart';

class OutstandingBalanceChart extends StatelessWidget {
final CustomersReportData customersData;

const OutstandingBalanceChart({super.key, required this.customersData});

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);

    return CustomCard(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Outstanding Balance Analysis',
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            SizedBox(
              height: 300,
              child: SfCartesianChart(
                primaryXAxis: const CategoryAxis(),
                primaryYAxis: NumericAxis(
                  numberFormat: NumberFormat.currency(symbol: 'ETB '),
                ),
                series: <CartesianSeries<BalanceData, String>>[
                  ColumnSeries<BalanceData, String>(
                    dataSource: _generateBalanceData(),
                    xValueMapper: (data, _) => data.range,
                    yValueMapper: (data, _) => data.amount,
                    dataLabelSettings: const DataLabelSettings(isVisible: true),
                  )
                ],
              ),
            ),
          ],
        ),
      ),
    );

}

List<BalanceData> \_generateBalanceData() {
return [
BalanceData('0-1,000', 45000),
BalanceData('1,000-5,000', 125000),
BalanceData('5,000-10,000', 85000),
BalanceData('10,000+', 250000),
];
}
}

class BalanceData {
final String range;
final double amount;

BalanceData(this.range, this.amount);
}

##

// lib/src/widgets/reports/payment_method_chart.dart
// Payment method chart widget displaying sales distribution by payment methods.
// This includes a doughnut chart visualizing the breakdown of sales by different payment types.
import 'package:flutter/material.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import '../../localization/app_localizations.dart';
import '../common/custom_card.dart';

class PaymentMethodChart extends StatelessWidget {
final Map<String, double> paymentMethods;

const PaymentMethodChart({super.key, required this.paymentMethods});

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);

    final chartData = paymentMethods.entries
        .map((entry) => _ChartData(
            _getPaymentMethodName(entry.key, localizations), entry.value))
        .toList();

    return CustomCard(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              localizations.salesByPaymentMethod,
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            SizedBox(
              height: 300,
              child: SfCircularChart(
                palette: [
                  theme.colorScheme.primary,
                  theme.colorScheme.secondary,
                  theme.colorScheme.tertiary,
                  Colors.amber,
                  Colors.teal,
                ],
                series: <CircularSeries>[
                  DoughnutSeries<_ChartData, String>(
                    dataSource: chartData,
                    xValueMapper: (_ChartData data, _) => data.x,
                    yValueMapper: (_ChartData data, _) => data.y,
                    dataLabelSettings: DataLabelSettings(
                      isVisible: true,
                      labelPosition: ChartDataLabelPosition.outside,
                      textStyle: theme.textTheme.bodySmall,
                      labelIntersectAction: LabelIntersectAction.shift,
                    ),
                    animationDuration: 1000,
                  )
                ],
                legend: Legend(
                  isVisible: true,
                  position: LegendPosition.bottom,
                  overflowMode: LegendItemOverflowMode.wrap,
                  textStyle: theme.textTheme.bodyMedium,
                ),
                tooltipBehavior: TooltipBehavior(
                  enable: true,
                  format: 'point.x : ETB point.y',
                ),
              ),
            ),
          ],
        ),
      ),
    );

}

String \_getPaymentMethodName(String method, AppLocalizations localizations) {
switch (method.toLowerCase()) {
case 'cash':
return localizations.cash;
case 'telebirr':
return localizations.telebirr;
case 'card':
return localizations.card;
case 'credit':
return localizations.credit;
case 'bank_transfer':
return localizations.bankTransfer;
default:
return method;
}
}
}

class \_ChartData {
final String x;
final double y;

\_ChartData(this.x, this.y);
}

##

// lib/src/widgets/reports/products_overview_card.dart
// Products overview card widget displaying key product metrics.
import 'package:flutter/material.dart';
import '../../localization/app_localizations.dart';
import '../../utils/formatters.dart';
import '../../utils/reports_data_calculator.dart';
import '../common/custom_card.dart';

class ProductsOverviewCard extends StatelessWidget {
final ProductsReportData productsData;

const ProductsOverviewCard({super.key, required this.productsData});

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);

    return CustomCard(
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              localizations.productsOverview,
              style: theme.textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
                color: theme.colorScheme.primary,
              ),
            ),
            const SizedBox(height: 16),
            GridView.count(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              crossAxisCount: 2,
              crossAxisSpacing: 16,
              mainAxisSpacing: 16,
              children: [
                _buildMetricCard(
                  theme,
                  localizations.totalProducts,
                  AppFormatters.formatNumber(productsData.totalProducts),
                  Icons.inventory_2,
                  Colors.blue,
                ),
                _buildMetricCard(
                  theme,
                  localizations.lowStock,
                  AppFormatters.formatNumber(productsData.lowStockCount),
                  Icons.warning,
                  Colors.orange,
                ),
                _buildMetricCard(
                  theme,
                  localizations.outOfStock,
                  AppFormatters.formatNumber(productsData.outOfStockCount),
                  Icons.error,
                  Colors.red,
                ),
                _buildMetricCard(
                  theme,
                  'Stock Value',
                  AppFormatters.formatCurrency(productsData.stockValue),
                  Icons.warehouse,
                  Colors.green,
                ),
              ],
            ),
          ],
        ),
      ),
    );

}

Widget \_buildMetricCard(
ThemeData theme, String title, String value, IconData icon, Color color) {
return Container(
decoration: BoxDecoration(
color: theme.colorScheme.surface,
borderRadius: BorderRadius.circular(12),
border: Border.all(color: theme.colorScheme.outline.withOpacity(0.2)),
),
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Row(
children: [
Container(
padding: const EdgeInsets.all(8),
decoration: BoxDecoration(
color: color.withOpacity(0.1),
borderRadius: BorderRadius.circular(8),
),
child: Icon(icon, color: color, size: 20),
),
const Spacer(),
Text(
value,
style: theme.textTheme.titleLarge?.copyWith(
fontWeight: FontWeight.bold,
),
),
],
),
const SizedBox(height: 8),
Text(
title,
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.7),
),
),
],
),
),
);
}
}

##

// lib/src/widgets/reports/revenue_by_day_chart.dart
// Revenue by day chart widget displaying daily revenue trends.
// This includes a bar chart visualizing revenue for each day of the week.
import 'package:flutter/material.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import 'package:intl/intl.dart';
import '../../localization/app_localizations.dart';
import '../common/custom_card.dart';

class RevenueByDayChart extends StatelessWidget {
final Map<String, double> revenueByDay;

const RevenueByDayChart({super.key, required this.revenueByDay});

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);

    final chartData = _getOrderedChartData();

    return CustomCard(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              localizations.revenueByDay,
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            SizedBox(
              height: 300,
              child: SfCartesianChart(
                primaryXAxis: CategoryAxis(
                  majorGridLines: const MajorGridLines(width: 0),
                ),
                primaryYAxis: NumericAxis(
                  numberFormat: NumberFormat.currency(symbol: 'ETB '),
                  majorGridLines: const MajorGridLines(width: 0.5),
                ),
                series: <CartesianSeries<_ChartData, String>>[
                  ColumnSeries<_ChartData, String>(
                    dataSource: chartData,
                    xValueMapper: (data, _) => data.x,
                    yValueMapper: (data, _) => data.y,
                    color: theme.colorScheme.secondary,
                    dataLabelSettings: DataLabelSettings(
                      isVisible: true,
                      textStyle: theme.textTheme.bodySmall,
                    ),
                    animationDuration: 1000,
                  )
                ],
                tooltipBehavior: TooltipBehavior(
                  enable: true,
                  format: 'point.x : ETB point.y',
                ),
              ),
            ),
          ],
        ),
      ),
    );

}

List<\_ChartData> \_getOrderedChartData() {
const dayOrder = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
return dayOrder
.map(
(day) => \_ChartData(\_getFullDayName(day), revenueByDay[day] ?? 0.0))
.toList();
}

String \_getFullDayName(String shortDay) {
switch (shortDay) {
case 'Mon':
return 'Monday';
case 'Tue':
return 'Tuesday';
case 'Wed':
return 'Wednesday';
case 'Thu':
return 'Thursday';
case 'Fri':
return 'Friday';
case 'Sat':
return 'Saturday';
case 'Sun':
return 'Sunday';
default:
return shortDay;
}
}
}

class \_ChartData {
final String x;
final double y;

\_ChartData(this.x, this.y);
}

##

// lib/src/widgets/reports/sales_overview_card.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../localization/app_localizations.dart';
import '../../utils/formatters.dart';
import '../../utils/reports_data_calculator.dart';
import '../common/custom_card.dart';

class SalesOverviewCard extends ConsumerWidget {
final SalesReportData salesData;

const SalesOverviewCard({super.key, required this.salesData});

@override
Widget build(BuildContext context, WidgetRef ref) {
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);

    return CustomCard(
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              localizations.salesOverview,
              style: theme.textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
                color: theme.colorScheme.primary,
              ),
            ),
            const SizedBox(height: 16),
            GridView.count(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              crossAxisCount: 2,
              crossAxisSpacing: 16,
              mainAxisSpacing: 16,
              children: [
                _buildMetricCard(
                  context,
                  localizations.totalRevenue,
                  AppFormatters.formatCurrency(salesData.totalSales),
                  Icons.attach_money,
                  Colors.green,
                ),
                _buildMetricCard(
                  context,
                  localizations.totalOrders,
                  salesData.totalOrders.toString(),
                  Icons.shopping_cart,
                  Colors.blue,
                ),
                _buildMetricCard(
                  context,
                  localizations.averageOrderValue,
                  AppFormatters.formatCurrency(salesData.averageOrderValue),
                  Icons.trending_up,
                  Colors.orange,
                ),
                _buildMetricCard(
                  context,
                  'Growth Rate',
                  '+12.5%',
                  Icons.analytics,
                  Colors.purple,
                ),
              ],
            ),
          ],
        ),
      ),
    );

}

Widget \_buildMetricCard(
BuildContext context,
String title,
String value,
IconData icon,
Color color,
) {
final theme = Theme.of(context);

    return Container(
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: theme.colorScheme.outline.withOpacity(0.2)),
        boxShadow: [
          BoxShadow(
            color: theme.colorScheme.shadow.withOpacity(0.1),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: color.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Icon(icon, color: color, size: 20),
                ),
                const Spacer(),
                Text(
                  value,
                  style: theme.textTheme.titleLarge?.copyWith(
                    fontWeight: FontWeight.bold,
                    color: theme.colorScheme.onSurface,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 8),
            Text(
              title,
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.onSurface.withOpacity(0.7),
              ),
            ),
          ],
        ),
      ),
    );

}
}

##

// lib/src/widgets/reports/subscription_info_card.dart
// Subscription info card widget displaying current subscription plan details.
import 'package:flutter/material.dart';
import '../../localization/app_localizations.dart';
import '../../data/models/subscription.dart';
import '../common/custom_card.dart';

class SubscriptionInfoCard extends StatelessWidget {
final SubscriptionPlan plan;

const SubscriptionInfoCard({super.key, required this.plan});

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);

    final planColor = _getPlanColor(theme);
    final planDescription = _getPlanDescription(localizations);

    return Container(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: CustomCard(
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              Icon(Icons.workspace_premium, color: planColor, size: 24),
              const SizedBox(width: 12),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      '${plan.name} ${localizations.plan}',
                      style: TextStyle(
                        fontWeight: FontWeight.bold,
                        color: planColor,
                        fontSize: 16,
                      ),
                    ),
                    Text(
                      planDescription,
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: theme.colorScheme.outline,
                      ),
                    ),
                    if (plan.id == 'basic') ...[
                      const SizedBox(height: 4),
                      Text(
                        localizations.upgradeForAdvancedReports,
                        style: TextStyle(
                          fontSize: 12,
                          color: planColor,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ],
                  ],
                ),
              ),
              if (plan.id == 'basic')
                TextButton(
                  onPressed: () => _showUpgradeDialog(context),
                  child: Text(localizations.upgrade),
                ),
            ],
          ),
        ),
      ),
    );

}

Color \_getPlanColor(ThemeData theme) {
switch (plan.id) {
case 'basic':
return theme.colorScheme.primary;
case 'professional':
return Colors.green;
case 'enterprise':
return Colors.purple;
default:
return theme.colorScheme.outline;
}
}

String \_getPlanDescription(AppLocalizations localizations) {
switch (plan.id) {
case 'basic':
return localizations.basicReportsDescription;
case 'professional':
return localizations.professionalReportsDescription;
case 'enterprise':
return localizations.enterpriseReportsDescription;
default:
return localizations.basicReportsDescription;
}
}

void \_showUpgradeDialog(BuildContext context) {
final localizations = AppLocalizations.of(context);
showDialog(
context: context,
builder: (context) => AlertDialog(
title: Text(localizations.upgradeYourPlan),
content: Text(localizations.upgradeForAdvancedAnalytics),
actions: [
TextButton(
onPressed: () => Navigator.pop(context),
child: Text(localizations.cancel),
),
ElevatedButton(
onPressed: () {
Navigator.pop(context);
// Navigate to subscription plans screen
},
child: Text(localizations.viewPlans),
),
],
),
);
}
}

##

// lib/src/widgets/reports/top_customers_chart.dart
// Top customers chart widget displaying the highest spending customers.
import 'package:flutter/material.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import 'package:intl/intl.dart';
import '../../localization/app_localizations.dart';
import '../../utils/formatters.dart';
import '../../utils/reports_data_calculator.dart';
import '../common/custom_card.dart';

class TopCustomersChart extends StatelessWidget {
final List<TopCustomer> customers;

const TopCustomersChart({super.key, required this.customers});

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);

    return CustomCard(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              localizations.topCustomers,
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            SizedBox(
              height: 400,
              child: customers.isNotEmpty
                  ? SfCartesianChart(
                      primaryXAxis: CategoryAxis(
                        labelRotation: -45,
                        majorGridLines: const MajorGridLines(width: 0),
                      ),
                      primaryYAxis: NumericAxis(
                        numberFormat: NumberFormat.currency(symbol: 'ETB '),
                        majorGridLines: const MajorGridLines(width: 0.5),
                      ),
                      series: <CartesianSeries<TopCustomer, String>>[
                        BarSeries<TopCustomer, String>(
                          dataSource: customers.take(10).toList(),
                          xValueMapper: (customer, _) =>
                              _truncateName(customer.name),
                          yValueMapper: (customer, _) => customer.totalSpent,
                          color: theme.colorScheme.primary,
                          width: 0.6,
                          dataLabelSettings: DataLabelSettings(
                            isVisible: true,
                            labelAlignment: ChartDataLabelAlignment.outer,
                            textStyle: theme.textTheme.bodySmall,
                          ),
                          animationDuration: 1000,
                        )
                      ],
                      tooltipBehavior: TooltipBehavior(
                        enable: true,
                        format: 'point.x : ETB point.y',
                      ),
                    )
                  : Container(
                      height: 200,
                      alignment: Alignment.center,
                      child: Text(
                        'No customer data available',
                        style: theme.textTheme.bodyMedium?.copyWith(
                          color: theme.colorScheme.outline,
                        ),
                      ),
                    ),
            ),
          ],
        ),
      ),
    );

}

String \_truncateName(String name) {
return name.length > 15 ? '${name.substring(0, 15)}...' : name;
}
}

##

// lib/src/widgets/reports/top_products_chart.dart
// Top products chart widget displaying the highest revenue-generating products.
import 'package:andalus_smart_pos/src/utils/chart_formatters.dart';
import 'package:flutter/material.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import '../../localization/app_localizations.dart';
import '../../utils/formatters.dart';
import '../../utils/reports_data_calculator.dart';
import '../common/custom_card.dart';

class TopProductsChart extends StatelessWidget {
final List<TopSellingProduct> products;

const TopProductsChart({super.key, required this.products});

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);

    return CustomCard(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              localizations.topSellingProducts,
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            SizedBox(
              height: 400,
              child: SfCartesianChart(
                primaryXAxis: CategoryAxis(
                  labelRotation: -45,
                  majorGridLines: const MajorGridLines(width: 0),
                ),
                primaryYAxis: NumericAxis(
                  numberFormat: ChartFormatters.currencyFormat,
                  majorGridLines: const MajorGridLines(width: 0.5),
                ),
                series: <CartesianSeries<TopSellingProduct, String>>[
                  BarSeries<TopSellingProduct, String>(
                    dataSource: products.take(10).toList(),
                    xValueMapper: (product, _) => product.name,
                    yValueMapper: (product, _) => product.revenue,
                    color: theme.colorScheme.primary,
                    width: 0.6,
                    dataLabelSettings: DataLabelSettings(
                      isVisible: true,
                      labelAlignment: ChartDataLabelAlignment.outer,
                      textStyle: theme.textTheme.bodySmall,
                    ),
                    animationDuration: 1000,
                  )
                ],
                tooltipBehavior: TooltipBehavior(
                  enable: true,
                  format: 'point.x : ETB point.y',
                ),
              ),
            ),
            if (products.isEmpty)
              Container(
                height: 200,
                alignment: Alignment.center,
                child: Text(
                  'No product data available',
                  style: theme.textTheme.bodyMedium?.copyWith(
                    color: theme.colorScheme.outline,
                  ),
                ),
              ),
          ],
        ),
      ),
    );

}
}

##

// mobile/lib/src/app.dart
// Main application widget for Andalus Smart POS.
import 'package:andalus_smart_pos/src/ui/screens/ReportsScreen.dart';
import 'package:andalus_smart_pos/src/ui/screens/auth/registration_screen.dart';
import 'package:andalus_smart_pos/src/ui/screens/customer_management_screen.dart';
import 'package:andalus_smart_pos/src/ui/screens/onboarding/onboarding_screen.dart';
import 'package:andalus_smart_pos/src/ui/screens/pos_screen.dart';
import 'package:andalus_smart_pos/src/ui/screens/product_management_screen.dart';
import 'package:andalus_smart_pos/src/ui/screens/splash_screen.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:andalus_smart_pos/src/config/app_theme.dart';
import 'package:andalus_smart_pos/src/ui/screens/main_navigation.dart';
import 'package:andalus_smart_pos/src/providers/theme_provider.dart';
import 'package:andalus_smart_pos/src/providers/language_provider.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
import 'package:andalus_smart_pos/src/providers/auth_provider.dart';
import 'package:andalus_smart_pos/src/ui/screens/auth/phone_login_screen.dart';

// Updated AndalusApp widget
class AndalusApp extends ConsumerWidget {
const AndalusApp({super.key});

@override
Widget build(BuildContext context, WidgetRef ref) {
final themeMode = ref.watch(themeProvider);
final locale = ref.watch(languageProvider);
final fontTheme = ref.watch(fontThemeProvider);

    return MaterialApp(
      title: 'Andalus Smart POS',
      theme: AppTheme.lightTheme(ref),
      darkTheme: AppTheme.darkTheme(ref),
      themeMode: themeMode,
      locale: locale,
      localizationsDelegates: const [
        AppLocalizations.delegate,
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [
        Locale('en', 'US'),
        Locale('am', 'ET'),
      ],
      home: const SplashScreen(),
      debugShowCheckedModeBanner: false,
      routes: {
        '/pos': (context) => const PosScreen(),
        '/products': (context) => const ProductManagementScreen(),
        '/customers': (context) => const CustomerManagementScreen(),
        '/reports': (context) => const ReportsScreen(),
        '/register': (context) => const OnboardingScreen(),
      },
    );

}
}

##

// mobile/lib/main.dart
// Main entry point for Andalus Smart POS application.
import 'dart:ui';

import 'package:andalus_smart_pos/src/data/local/database.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'src/app.dart';
import 'src/utils/database_init.dart';

void main() async {
WidgetsFlutterBinding.ensureInitialized();

FlutterError.onError = (FlutterErrorDetails details) {
FlutterError.presentError(details);
print('Flutter Error: ${details.exception}');
};
PlatformDispatcher.instance.onError = (error, stack) {
print('Platform Error: $error');
return true;
};
// Initialize and migrate database
try {
await AppDatabase.migrateDatabase();
await AppDatabase.verifyOTPTable();
await AppDatabase.migrateSalesTable();
await DatabaseInitializer.initializeDefaultData();
print('App initialization completed successfully');
} catch (e) {
print('App initialization error: $e');
}

runApp(const ProviderScope(child: AndalusApp()));
}

=======

//TODO: GENERATED FILE, DO NOT EDIT. for coloring and theming purposes only.
//lib/src/config/theme/color_schemes.g.dart
import 'package:flutter/material.dart';

const lightColorScheme = ColorScheme(
brightness: Brightness.light,
primary: Color(0xFF10B981),
onPrimary: Color(0xFFFFFFFF),
primaryContainer: Color(0xFFA7F4D0),
onPrimaryContainer: Color(0xFF002116),
secondary: Color(0xFF059669),
onSecondary: Color(0xFFFFFFFF),
secondaryContainer: Color(0xFF9BF7D2),
onSecondaryContainer: Color(0xFF002116),
tertiary: Color(0xFF7C5800),
onTertiary: Color(0xFFFFFFFF),
tertiaryContainer: Color(0xFFFFDEA6),
onTertiaryContainer: Color(0xFF271900),
error: Color(0xFFBA1A1A),
errorContainer: Color(0xFFFFDAD6),
onError: Color(0xFFFFFFFF),
onErrorContainer: Color(0xFF410002),
background: Color(0xFFF9FAFB),
onBackground: Color(0xFF1A1C1A),
surface: Color(0xFFF9FAFB),
onSurface: Color(0xFF1A1C1A),
surfaceVariant: Color(0xFFDCE5DD),
onSurfaceVariant: Color(0xFF404942),
outline: Color(0xFF707973),
onInverseSurface: Color(0xFFF0F1EC),
inverseSurface: Color(0xFF2E312E),
inversePrimary: Color(0xFF8BD9B5),
shadow: Color(0xFF000000),
surfaceTint: Color(0xFF006D46),
);

const darkColorScheme = ColorScheme(
brightness: Brightness.dark,
primary: Color(0xFF8BD9B5),
onPrimary: Color(0xFF003827),
primaryContainer: Color(0xFF005139),
onPrimaryContainer: Color(0xFFA7F4D0),
secondary: Color(0xFF7FDAB6),
onSecondary: Color(0xFF003827),
secondaryContainer: Color(0xFF005139),
onSecondaryContainer: Color(0xFF9BF7D2),
tertiary: Color(0xFFF5BD49),
onTertiary: Color(0xFF402D00),
tertiaryContainer: Color(0xFF5E4300),
onTertiaryContainer: Color(0xFFFFDEA6),
error: Color(0xFFFFB4AB),
errorContainer: Color(0xFF93000A),
onError: Color(0xFF690005),
onErrorContainer: Color(0xFFFFDAD6),
background: Color(0xFF1A1C1A),
onBackground: Color(0xFFE2E3DE),
surface: Color(0xFF1A1C1A),
onSurface: Color(0xFFE2E3DE),
surfaceVariant: Color(0xFF404942),
onSurfaceVariant: Color(0xFFC0C9C1),
outline: Color(0xFF8A938C),
onInverseSurface: Color(0xFF1A1C1A),
inverseSurface: Color(0xFFE2E3DE),
inversePrimary: Color(0xFF006D46),
shadow: Color(0xFF000000),
surfaceTint: Color(0xFF8BD9B5),
);

##// src/config/theme/app_theme.dart
// App theme configuration using generated color schemes and font themes.
import 'package:andalus_smart_pos/src/config/theme/color_schemes.g.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'font_theme.dart';

class AppTheme {
static ThemeData lightTheme(WidgetRef ref) {
final fontTheme = ref.read(fontThemeProvider);

    return ThemeData(
      useMaterial3: true,
      colorScheme: lightColorScheme,
      fontFamily: fontTheme.englishFont.fontFamily,
      typography: Typography.material2021(
        englishLike: Typography.englishLike2021,
        dense: Typography.dense2021,
        tall: Typography.tall2021,
      ),
      textTheme: _buildTextTheme(fontTheme, Brightness.light),
      appBarTheme: AppBarTheme(
        backgroundColor: lightColorScheme.primary,
        foregroundColor: lightColorScheme.onPrimary,
        elevation: 0,
        centerTitle: true,
        surfaceTintColor: Colors.transparent,
        titleTextStyle: TextStyle(
          fontFamily: fontTheme.englishFont.fontFamily,
          fontSize: 18 * fontTheme.fontSizeScale,
          fontWeight: FontWeight.w600,
          color: lightColorScheme.onPrimary,
        ),
      ),
      cardTheme: CardThemeData(
        elevation: 2,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: Colors.grey.shade300),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: Colors.grey.shade300),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: Color(0xFF10B981), width: 2),
        ),
        filled: true,
        fillColor: Colors.white,
        contentPadding:
            const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
        labelStyle: TextStyle(
          fontFamily: fontTheme.englishFont.fontFamily,
          fontSize: 14 * fontTheme.fontSizeScale,
        ),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: const Color(0xFF10B981),
          foregroundColor: Colors.white,
          elevation: 2,
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 16),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
          ),
          textStyle: TextStyle(
            fontFamily: fontTheme.englishFont.fontFamily,
            fontWeight: FontWeight.w600,
            fontSize: 16 * fontTheme.fontSizeScale,
          ),
        ),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          foregroundColor: const Color(0xFF10B981),
          side: const BorderSide(color: Color(0xFF10B981)),
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 16),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
          ),
          textStyle: TextStyle(
            fontFamily: fontTheme.englishFont.fontFamily,
            fontSize: 16 * fontTheme.fontSizeScale,
          ),
        ),
      ),
      floatingActionButtonTheme: FloatingActionButtonThemeData(
        backgroundColor: const Color(0xFF10B981),
        foregroundColor: Colors.white,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
        ),
      ),
      bottomNavigationBarTheme: BottomNavigationBarThemeData(
        backgroundColor: Colors.white,
        selectedItemColor: const Color(0xFF10B981),
        unselectedItemColor: Colors.grey.shade600,
        elevation: 8,
        type: BottomNavigationBarType.fixed,
        showSelectedLabels: true,
        showUnselectedLabels: true,
        selectedLabelStyle: TextStyle(
          fontFamily: fontTheme.englishFont.fontFamily,
          fontSize: 12 * fontTheme.fontSizeScale,
        ),
        unselectedLabelStyle: TextStyle(
          fontFamily: fontTheme.englishFont.fontFamily,
          fontSize: 12 * fontTheme.fontSizeScale,
        ),
      ),
    );

}

static ThemeData darkTheme(WidgetRef ref) {
final fontTheme = ref.read(fontThemeProvider);

    return ThemeData(
      useMaterial3: true,
      colorScheme: darkColorScheme,
      fontFamily: fontTheme.englishFont.fontFamily,
      typography: Typography.material2021(
        englishLike: Typography.englishLike2021,
        dense: Typography.dense2021,
        tall: Typography.tall2021,
      ),
      textTheme: _buildTextTheme(fontTheme, Brightness.dark),
      appBarTheme: AppBarTheme(
        backgroundColor: Colors.grey.shade900,
        foregroundColor: Colors.white,
        elevation: 0,
        centerTitle: true,
        surfaceTintColor: Colors.transparent,
        titleTextStyle: TextStyle(
          fontFamily: fontTheme.englishFont.fontFamily,
          fontSize: 18 * fontTheme.fontSizeScale,
          fontWeight: FontWeight.w600,
          color: Colors.white,
        ),
      ),
      cardTheme: CardThemeData(
        elevation: 3,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
        ),
        color: Colors.grey.shade800,
      ),
      inputDecorationTheme: InputDecorationTheme(
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: Colors.grey.shade600),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: Colors.grey.shade600),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: Color(0xFF10B981), width: 2),
        ),
        filled: true,
        fillColor: Colors.grey.shade800,
        contentPadding:
            const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
        labelStyle: TextStyle(
          fontFamily: fontTheme.englishFont.fontFamily,
          fontSize: 14 * fontTheme.fontSizeScale,
          color: Colors.grey.shade300,
        ),
      ),
      bottomNavigationBarTheme: BottomNavigationBarThemeData(
        backgroundColor: Colors.grey.shade900,
        selectedItemColor: const Color(0xFF10B981),
        unselectedItemColor: Colors.grey.shade500,
        elevation: 8,
        type: BottomNavigationBarType.fixed,
        showSelectedLabels: true,
        showUnselectedLabels: true,
        selectedLabelStyle: TextStyle(
          fontFamily: fontTheme.englishFont.fontFamily,
          fontSize: 12 * fontTheme.fontSizeScale,
        ),
        unselectedLabelStyle: TextStyle(
          fontFamily: fontTheme.englishFont.fontFamily,
          fontSize: 12 * fontTheme.fontSizeScale,
        ),
      ),
      cardColor: Colors.grey.shade800,
      dialogBackgroundColor: Colors.grey.shade800,
      bottomSheetTheme: BottomSheetThemeData(
        backgroundColor: Colors.grey.shade900,
      ),
      floatingActionButtonTheme: FloatingActionButtonThemeData(
        backgroundColor: const Color(0xFF10B981),
        foregroundColor: Colors.white,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
        ),
      ),
    );

}

static TextTheme \_buildTextTheme(FontTheme fontTheme, Brightness brightness) {
final baseTextTheme = brightness == Brightness.light
? Typography.material2021().black
: Typography.material2021().white;

    return baseTextTheme.copyWith(
      displayLarge: baseTextTheme.displayLarge!.copyWith(
        fontFamily: fontTheme.englishFont.fontFamily,
        fontSize: 96 * fontTheme.fontSizeScale,
        fontWeight: FontWeight.w300,
        letterSpacing: -1.5,
      ),
      displayMedium: baseTextTheme.displayMedium!.copyWith(
        fontFamily: fontTheme.englishFont.fontFamily,
        fontSize: 60 * fontTheme.fontSizeScale,
        fontWeight: FontWeight.w300,
        letterSpacing: -0.5,
      ),
      displaySmall: baseTextTheme.displaySmall!.copyWith(
        fontFamily: fontTheme.englishFont.fontFamily,
        fontSize: 48 * fontTheme.fontSizeScale,
        fontWeight: FontWeight.w400,
      ),
      headlineMedium: baseTextTheme.headlineMedium!.copyWith(
        fontFamily: fontTheme.englishFont.fontFamily,
        fontSize: 34 * fontTheme.fontSizeScale,
        fontWeight: FontWeight.w400,
        letterSpacing: 0.25,
      ),
      headlineSmall: baseTextTheme.headlineSmall!.copyWith(
        fontFamily: fontTheme.englishFont.fontFamily,
        fontSize: 24 * fontTheme.fontSizeScale,
        fontWeight: FontWeight.w400,
      ),
      titleLarge: baseTextTheme.titleLarge!.copyWith(
        fontFamily: fontTheme.englishFont.fontFamily,
        fontSize: 20 * fontTheme.fontSizeScale,
        fontWeight: FontWeight.w500,
        letterSpacing: 0.15,
      ),
      titleMedium: baseTextTheme.titleMedium!.copyWith(
        fontFamily: fontTheme.englishFont.fontFamily,
        fontSize: 16 * fontTheme.fontSizeScale,
        fontWeight: FontWeight.w400,
        letterSpacing: 0.15,
      ),
      titleSmall: baseTextTheme.titleSmall!.copyWith(
        fontFamily: fontTheme.englishFont.fontFamily,
        fontSize: 14 * fontTheme.fontSizeScale,
        fontWeight: FontWeight.w500,
        letterSpacing: 0.1,
      ),
      bodyLarge: baseTextTheme.bodyLarge!.copyWith(
        fontFamily: fontTheme.englishFont.fontFamily,
        fontSize: 16 * fontTheme.fontSizeScale,
        fontWeight: FontWeight.w400,
        letterSpacing: 0.5,
      ),
      bodyMedium: baseTextTheme.bodyMedium!.copyWith(
        fontFamily: fontTheme.englishFont.fontFamily,
        fontSize: 14 * fontTheme.fontSizeScale,
        fontWeight: FontWeight.w400,
        letterSpacing: 0.25,
      ),
      labelLarge: baseTextTheme.labelLarge!.copyWith(
        fontFamily: fontTheme.englishFont.fontFamily,
        fontSize: 14 * fontTheme.fontSizeScale,
        fontWeight: FontWeight.w500,
        letterSpacing: 1.25,
      ),
      bodySmall: baseTextTheme.bodySmall!.copyWith(
        fontFamily: fontTheme.englishFont.fontFamily,
        fontSize: 12 * fontTheme.fontSizeScale,
        fontWeight: FontWeight.w400,
        letterSpacing: 0.4,
      ),
      labelSmall: baseTextTheme.labelSmall!.copyWith(
        fontFamily: fontTheme.englishFont.fontFamily,
        fontSize: 10 * fontTheme.fontSizeScale,
        fontWeight: FontWeight.w400,
        letterSpacing: 1.5,
      ),
    );

}
}

// Font Theme Provider
final fontThemeProvider =
StateNotifierProvider<FontThemeNotifier, FontTheme>((ref) {
return FontThemeNotifier();
});

class FontThemeNotifier extends StateNotifier<FontTheme> {
FontThemeNotifier() : super(const FontTheme());

void updateEnglishFont(AppFontFamily font) {
state = state.copyWith(englishFont: font);
}

void updateAmharicFont(AppFontFamily font) {
state = state.copyWith(amharicFont: font);
}

void updateFontScale(double scale) {
state = state.copyWith(fontSizeScale: scale);
}
}

##// src/config/theme/font_theme.dart
// Font theme configuration for the application.
class FontTheme {
final AppFontFamily englishFont;
final AppFontFamily amharicFont;
final double fontSizeScale;

const FontTheme({
this.englishFont = AppFontFamily.inter,
this.amharicFont = AppFontFamily.notoSansEthiopic,
this.fontSizeScale = 1.0,
});

FontTheme copyWith({
AppFontFamily? englishFont,
AppFontFamily? amharicFont,
double? fontSizeScale,
}) {
return FontTheme(
englishFont: englishFont ?? this.englishFont,
amharicFont: amharicFont ?? this.amharicFont,
fontSizeScale: fontSizeScale ?? this.fontSizeScale,
);
}
}

enum AppFontFamily {
inter('Inter'),
roboto('Roboto'),
openSans('OpenSans'),
notoSansEthiopic('NotoSansEthiopic'),
AbyssinicaSIL('AbyssinicaSIL');

final String fontFamily;
const AppFontFamily(this.fontFamily);

String get name {
switch (this) {
case AppFontFamily.inter:
return 'Inter';
case AppFontFamily.roboto:
return 'Roboto';
case AppFontFamily.openSans:
return 'Open Sans';
case AppFontFamily.notoSansEthiopic:
return 'Noto Sans Ethiopic';
case AppFontFamily.AbyssinicaSIL:
return 'Abyssinica SIL';
}
}
}

##

// lib/src/controllers/customer_controller.dart
// Controller for managing customer-related state and actions.
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../data/models/customer.dart';
import '../data/repositories/customer_repository.dart';

class CustomerState {
final List<Customer> customers;
final bool isLoading;
final String? error;
final String? searchQuery;

const CustomerState({
this.customers = const [],
this.isLoading = false,
this.error,
this.searchQuery,
});

CustomerState copyWith({
List<Customer>? customers,
bool? isLoading,
String? error,
String? searchQuery,
}) {
return CustomerState(
customers: customers ?? this.customers,
isLoading: isLoading ?? this.isLoading,
error: error ?? this.error,
searchQuery: searchQuery ?? this.searchQuery,
);
}
}

class CustomerController extends StateNotifier<CustomerState> {
final CustomerRepository \_customerRepository;

CustomerController(this.\_customerRepository) : super(const CustomerState());

Future<void> loadCustomers() async {
state = state.copyWith(isLoading: true, error: null);
try {
final customers = await \_customerRepository.getAllCustomers();
state = state.copyWith(customers: customers, isLoading: false);
} catch (e) {
state = state.copyWith(error: e.toString(), isLoading: false);
}
}

Future<void> searchCustomers(String query) async {
state = state.copyWith(searchQuery: query);
// Implement search logic
}

void clearError() {
state = state.copyWith(error: null);
}
}

final customerControllerProvider =
StateNotifierProvider<CustomerController, CustomerState>(
(ref) => CustomerController(ref.read(customerRepositoryProvider)),
);

##

// lib/src/controllers/product_controller.dart
// Controller for managing product-related state and actions.
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../data/models/product.dart';
import '../data/repositories/product_repository.dart';

class ProductState {
final List<Product> products;
final bool isLoading;
final String? error;
final String? searchQuery;
final String? selectedCategory;

const ProductState({
this.products = const [],
this.isLoading = false,
this.error,
this.searchQuery,
this.selectedCategory,
});

ProductState copyWith({
List<Product>? products,
bool? isLoading,
String? error,
String? searchQuery,
String? selectedCategory,
}) {
return ProductState(
products: products ?? this.products,
isLoading: isLoading ?? this.isLoading,
error: error ?? this.error,
searchQuery: searchQuery ?? this.searchQuery,
selectedCategory: selectedCategory ?? this.selectedCategory,
);
}
}

class ProductController extends StateNotifier<ProductState> {
final ProductRepository \_productRepository;

ProductController(this.\_productRepository) : super(const ProductState());

Future<void> loadProducts() async {
state = state.copyWith(isLoading: true, error: null);
try {
final products = await \_productRepository.getAllProducts();
state = state.copyWith(products: products, isLoading: false);
} catch (e) {
state = state.copyWith(error: e.toString(), isLoading: false);
}
}

Future<void> searchProducts(String query) async {
state = state.copyWith(searchQuery: query);
// Implement search logic
}

void filterByCategory(String? categoryId) {
state = state.copyWith(selectedCategory: categoryId);
}

void clearError() {
state = state.copyWith(error: null);
}
}

final productControllerProvider =
StateNotifierProvider<ProductController, ProductState>(
(ref) => ProductController(ref.read(productRepositoryProvider)),
);

##

// lib/src/controllers/reports_controller.dart
// Controller for managing reports-related state and actions.
import 'package:andalus_smart_pos/src/ui/screens/ReportsScreen.dart';
import 'package:andalus_smart_pos/src/utils/reports_data_calculator.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import 'package:intl/intl.dart';
import '../data/models/subscription.dart';
import '../data/models/sale.dart';
import '../data/models/product.dart';
import '../data/models/customer.dart';
import '../data/repositories/sale_repository.dart';
import '../data/repositories/product_repository.dart';
import '../data/repositories/customer_repository.dart';
import '../data/repositories/subscription_repository.dart';
import '../utils/formatters.dart';

final reportsControllerProvider =
StateNotifierProvider.autoDispose<ReportsController, ReportsState>((ref) {
return ReportsController(ref);
});

class ReportsState {
final bool isLoading;
final SubscriptionPlan currentPlan;
final ReportType selectedReportType;
final DateTimeRange dateRange;
final SalesReportData? salesData;
final ProductsReportData? productsData;
final CustomersReportData? customersData;
final FinancialReportData? financialData;
final String? error;

const ReportsState({
this.isLoading = true,
required this.currentPlan,
this.selectedReportType = ReportType.sales,
required this.dateRange,
this.salesData,
this.productsData,
this.customersData,
this.financialData,
this.error,
});

ReportsState copyWith({
bool? isLoading,
SubscriptionPlan? currentPlan,
ReportType? selectedReportType,
DateTimeRange? dateRange,
SalesReportData? salesData,
ProductsReportData? productsData,
CustomersReportData? customersData,
FinancialReportData? financialData,
String? error,
}) {
return ReportsState(
isLoading: isLoading ?? this.isLoading,
currentPlan: currentPlan ?? this.currentPlan,
selectedReportType: selectedReportType ?? this.selectedReportType,
dateRange: dateRange ?? this.dateRange,
salesData: salesData ?? this.salesData,
productsData: productsData ?? this.productsData,
customersData: customersData ?? this.customersData,
financialData: financialData ?? this.financialData,
error: error ?? this.error,
);
}
}

class ReportsController extends StateNotifier<ReportsState> {
final Ref ref;

ReportsController(this.ref)
: super(
ReportsState(
currentPlan: SubscriptionPlan.basic,
dateRange: DateTimeRange(
start: DateTime.now().subtract(const Duration(days: 30)),
end: DateTime.now(),
),
),
) {
\_initialize();
}

Future<void> \_initialize() async {
await \_loadSubscription();
await \_loadReports();
}

Future<void> \_loadSubscription() async {
try {
final subscription = await ref
.read(subscriptionRepositoryProvider)
.getCurrentSubscription();
final currentPlan = subscription?.plan ?? SubscriptionPlan.basic;
state = state.copyWith(currentPlan: currentPlan);
} catch (e) {
state = state.copyWith(currentPlan: SubscriptionPlan.basic);
}
}

Future<void> \_loadReports() async {
state = state.copyWith(isLoading: true, error: null);

    try {
      final reportsData = await ReportsDataCalculator.generateReports(
        ref: ref,
        dateRange: state.dateRange,
        plan: state.currentPlan,
      );

      state = state.copyWith(
        isLoading: false,
        salesData: reportsData.salesData,
        productsData: reportsData.productsData,
        customersData: reportsData.customersData,
        financialData: reportsData.financialData,
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: 'Failed to load reports: $e',
      );
    }

}

void setDateRange(DateTimeRange range) {
state = state.copyWith(dateRange: range);
\_loadReports();
}

void setReportType(ReportType type) {
state = state.copyWith(selectedReportType: type);
}

void refresh() => \_loadReports();
}

##

// lib/src/controllers/sale_controller.dart - CORRECTED VERSION
import 'dart:async';
import 'package:andalus_smart_pos/src/service/sync_service.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:connectivity_plus/connectivity_plus.dart';
import '../data/models/sale.dart';
import '../data/models/sale_item.dart';
import '../data/models/product.dart';
import '../data/models/user.dart';
import '../data/repositories/sale_repository.dart';
import '../data/repositories/product_repository.dart';
import '../data/repositories/customer_repository.dart';
// import '../services/sync_service.dart';
import '../utils/print_service.dart';
import '../providers/auth_provider.dart';

class SaleState {
final Sale? currentSale;
final List<SaleItem> cartItems;
final bool isLoading;
final String? error;
final bool isPrinting;
final double subtotal;
final double tax;
final double discount;
final double total;

const SaleState({
this.currentSale,
this.cartItems = const [],
this.isLoading = false,
this.error,
this.isPrinting = false,
this.subtotal = 0,
this.tax = 0,
this.discount = 0,
this.total = 0,
});

SaleState copyWith({
Sale? currentSale,
List<SaleItem>? cartItems,
bool? isLoading,
String? error,
bool? isPrinting,
double? subtotal,
double? tax,
double? discount,
double? total,
}) {
return SaleState(
currentSale: currentSale ?? this.currentSale,
cartItems: cartItems ?? this.cartItems,
isLoading: isLoading ?? this.isLoading,
error: error ?? this.error,
isPrinting: isPrinting ?? this.isPrinting,
subtotal: subtotal ?? this.subtotal,
tax: tax ?? this.tax,
discount: discount ?? this.discount,
total: total ?? this.total,
);
}

int get cartItemCount => cartItems.length;
bool get isCartEmpty => cartItems.isEmpty;
}

class SaleController extends StateNotifier<SaleState> {
final Ref \_ref;
final SaleRepository \_saleRepository;
final ProductRepository \_productRepository;
final CustomerRepository \_customerRepository;
final SyncService \_syncService;

static const double \_taxRate = 0.15;
static const int \_maxCartItems = 100;

SaleController(
this.\_ref, {
required SaleRepository saleRepository,
required ProductRepository productRepository,
required CustomerRepository customerRepository,
required SyncService syncService,
}) : \_saleRepository = saleRepository,
\_productRepository = productRepository,
\_customerRepository = customerRepository,
\_syncService = syncService,
super(const SaleState());

// === CART MANAGEMENT ===
Future<void> addToCart({
required Product product,
required int quantity,
double? customPrice,
double? discount,
}) async {
try {
// Validate product
if (!product.canSellQuantity(quantity)) {
throw Exception(
'Cannot add $quantity of ${product.name}. Available: ${product.stockQuantity}');
}

      // Check cart limits
      if (state.cartItems.length >= _maxCartItems) {
        throw Exception('Cart is full. Maximum $_maxCartItems items allowed');
      }

      // Check if product already in cart
      final existingIndex = state.cartItems
          .indexWhere((item) => item.productId == product.productId);

      if (existingIndex >= 0) {
        // Update existing item
        final existingItem = state.cartItems[existingIndex];
        final newQuantity = existingItem.quantity + quantity;

        if (!product.canSellQuantity(newQuantity)) {
          throw Exception(
              'Cannot add $quantity more. Total would be $newQuantity, available: ${product.stockQuantity}');
        }

        final updatedItems = List<SaleItem>.from(state.cartItems);
        updatedItems[existingIndex] = SaleItem.create(
          saleId: existingItem.saleId,
          productId: product.productId,
          productName: product.name,
          productNameAm: product.nameAm,
          quantity: newQuantity,
          unitPrice: customPrice ?? product.price,
          costPrice: product.costPrice,
          discount: discount ?? existingItem.discount,
          barcode: product.barcode,
          unit: product.unit,
        );

        _updateCart(updatedItems);
      } else {
        // Add new item
        final newItem = SaleItem.create(
          saleId: 'temp',
          productId: product.productId,
          productName: product.name,
          productNameAm: product.nameAm,
          quantity: quantity,
          unitPrice: customPrice ?? product.price,
          costPrice: product.costPrice,
          discount: discount ?? 0,
          barcode: product.barcode,
          unit: product.unit,
        );

        final updatedItems = [...state.cartItems, newItem];
        _updateCart(updatedItems);
      }
    } catch (e) {
      state = state.copyWith(error: e.toString());
      rethrow;
    }

}

void updateCartItemQuantity(String productId, int newQuantity) {
try {
if (newQuantity <= 0) {
removeFromCart(productId);
return;
}

      final index =
          state.cartItems.indexWhere((item) => item.productId == productId);
      if (index == -1) return;

      final item = state.cartItems[index];
      final updatedItem = SaleItem.create(
        saleId: item.saleId,
        productId: item.productId,
        productName: item.productName,
        productNameAm: item.productNameAm,
        quantity: newQuantity,
        unitPrice: item.unitPrice,
        costPrice: item.costPrice,
        discount: item.discount,
        barcode: item.barcode,
        unit: item.unit,
      );

      final updatedItems = List<SaleItem>.from(state.cartItems);
      updatedItems[index] = updatedItem;
      _updateCart(updatedItems);
    } catch (e) {
      state = state.copyWith(error: e.toString());
    }

}

void removeFromCart(String productId) {
final updatedItems =
state.cartItems.where((item) => item.productId != productId).toList();
\_updateCart(updatedItems);
}

void clearCart() {
\_updateCart([]);
}

void \_updateCart(List<SaleItem> items) {
// Calculate totals
final subtotal =
items.fold(0.0, (sum, item) => sum + (item.unitPrice _ item.quantity));
final discount = items.fold(0.0, (sum, item) => sum + item.discount);
final tax = (subtotal - discount) _ \_taxRate;
final total = subtotal + tax - discount;

    state = state.copyWith(
      cartItems: items,
      subtotal: double.parse(subtotal.toStringAsFixed(2)),
      tax: double.parse(tax.toStringAsFixed(2)),
      discount: double.parse(discount.toStringAsFixed(2)),
      total: double.parse(total.toStringAsFixed(2)),
      error: null,
    );

}

// === SALE PROCESSING ===
Future<Sale> processSale({
required String paymentMethod,
String? paymentReference,
int? customerId,
String? customerName,
double additionalDiscount = 0,
String? notes,
required BuildContext context,
}) async {
try {
state = state.copyWith(isLoading: true, error: null);

      // Validate cart
      if (state.cartItems.isEmpty) {
        throw Exception('Cart is empty');
      }

      // Validate stock for all items
      await _validateStockAvailability();

      // Get user info (from auth provider)
      final authState = _ref.read(authProvider);
      final User? user = authState.user;
      if (user == null) throw Exception('User not authenticated');

      // Convert userId from String to int
      int userId;
      try {
        userId = int.parse(user.id);
      } catch (e) {
        // If user.id is not a number, use a default or hash
        userId = user.id.hashCode.abs();
      }

      // Create sale
      final sale = Sale.createNew(
        items: state.cartItems,
        userId: userId,
        userName: user.name,
        shopId: 1,
        paymentMethod: paymentMethod,
        paymentReference: paymentReference,
        customerId: customerId,
        customerName: customerName,
        discountAmount: additionalDiscount,
        notes: notes,
      );

      // Process in transaction
      final completedSale = await _processSaleTransaction(sale);

      // Print receipt
      await _printReceipt(completedSale, context);

      // Update state
      state = state.copyWith(
        currentSale: completedSale,
        cartItems: [],
        subtotal: 0,
        tax: 0,
        discount: 0,
        total: 0,
        isLoading: false,
      );

      // Trigger sync if online
      final connectivity = await Connectivity().checkConnectivity();
      if (connectivity != ConnectivityResult.none) {
        await _syncService.syncAllData();
      }

      return completedSale;
    } catch (e, stackTrace) {
      state = state.copyWith(isLoading: false, error: e.toString());
      print('Sale processing error: $e\n$stackTrace');
      rethrow;
    }

}

Future<void> \_validateStockAvailability() async {
for (final item in state.cartItems) {
try {
// Use getProductById which we added to ProductRepository
final product = await \_productRepository.getProductById(item.productId);
if (product == null) {
throw Exception('Product ${item.productName} not found');
}

        if (!product.canSellQuantity(item.quantity)) {
          throw Exception(
              'Insufficient stock for ${product.name}. Available: ${product.stockQuantity}, Requested: ${item.quantity}');
        }
      } catch (e) {
        throw Exception('Stock validation failed for ${item.productName}: $e');
      }
    }

}

Future<Sale> \_processSaleTransaction(Sale sale) async {
try {
// Save sale
final saleId = await \_saleRepository.createSale(sale, state.cartItems);

      // Update product stock - using updateStockAfterSale which we added
      for (final item in state.cartItems) {
        await _productRepository.updateStockAfterSale(
          productId: item.productId,
          quantitySold: item.quantity,
        );
      }

      // Update customer balance if credit sale
      if (sale.paymentMethod == 'credit' && sale.customerId != null) {
        // Use updateCustomerBalance which we added to CustomerRepository
        await _customerRepository.updateCustomerBalance(
          customerId: sale.customerId!,
          amount: sale.finalAmount,
          transactionType: 'sale',
          reference: sale.saleId,
        );
      }

      // Get the saved sale - use getSimpleSaleById which returns Sale, not SaleWithItems
      final savedSale = await _saleRepository.getSimpleSaleById(saleId);
      if (savedSale == null) {
        throw Exception('Failed to retrieve saved sale');
      }
      return savedSale;
    } catch (e) {
      throw Exception('Transaction failed: $e');
    }

}

Future<void> \_printReceipt(Sale sale, BuildContext context) async {
try {
state = state.copyWith(isPrinting: true);

      // Convert sale items for printing
      final printItems = state.cartItems.map((item) {
        return {
          'name': item.productName,
          'quantity': item.quantity,
          'price': item.unitPrice,
          'total': item.totalPrice,
        };
      }).toList();

      // Get business info
      final businessInfo = {
        'shopName': 'Andalus Smart POS',
        'shopNameAm': '·ä†·äï·ã≥·àâ·àµ ·àµ·àõ·à≠·âµ ·çñ·àµ',
        'address': 'Addis Ababa, Ethiopia',
        'phone': '+251911223344',
        'tinNumber': '1234567890',
      };

      // Call PrintService with correct parameters matching your existing interface
      await PrintService.printReceipt(
        context: context,
        shopName: businessInfo['shopName']!,
        shopNameAm: businessInfo['shopNameAm']!,
        address: businessInfo['address']!,
        phone: businessInfo['phone']!,
        tinNumber: businessInfo['tinNumber']!,
        receiptNumber: sale.saleId,
        dateTime: sale.createdAt,
        items: printItems,
        subtotal: state.subtotal,
        tax: state.tax,
        discount: state.discount,
        total: state.total,
        paymentMethod: sale.paymentMethod,
        telebirrRef: sale.paymentReference,
        sale: sale,
        businessInfo: businessInfo,
      );

      state = state.copyWith(isPrinting: false);
    } catch (e) {
      state = state.copyWith(isPrinting: false);
      print('Printing failed: $e');
    }

}

// === SALE QUERIES ===
Future<List<Sale>> getTodaySales() async {
try {
state = state.copyWith(isLoading: true);
final sales = await \_saleRepository.getTodaysSales();
state = state.copyWith(isLoading: false);
return sales;
} catch (e) {
state = state.copyWith(isLoading: false, error: e.toString());
rethrow;
}
}

Future<SalesSummary> getSalesSummary({DateTimeRange? dateRange}) async {
try {
return await \_saleRepository.getSalesSummary(dateRange: dateRange);
} catch (e) {
throw Exception('Failed to get sales summary: $e');
}
}

Future<List<Sale>> searchSales({
String? query,
DateTime? startDate,
DateTime? endDate,
String? paymentMethod,
String? status,
int? customerId,
}) async {
return await \_saleRepository.searchSales(
query: query,
startDate: startDate,
endDate: endDate,
paymentMethod: paymentMethod,
status: status,
customerId: customerId,
);
}

// === REFUNDS ===
Future<Sale> refundSale({
required int saleId,
required String reason,
bool fullRefund = true,
List<String>? itemIds,
Map<String, int>? partialQuantities,
}) async {
try {
state = state.copyWith(isLoading: true);

      // Get original sale
      final originalSaleWithItems = await _saleRepository.getSaleById(saleId);
      if (originalSaleWithItems == null) {
        throw Exception('Sale not found');
      }

      final originalSale = originalSaleWithItems.sale;

      // Check if can be refunded
      if (!originalSale.canBeRefunded) {
        throw Exception('Sale cannot be refunded');
      }

      // Process refund using refundSale method we added
      final refundedSale = await _saleRepository.refundSale(
        saleId: saleId,
        reason: reason,
        fullRefund: fullRefund,
        itemIds: itemIds,
        partialQuantities: partialQuantities,
      );

      // Restore stock if full refund
      if (fullRefund) {
        await _restoreStockForRefund(originalSale);
      }

      state = state.copyWith(isLoading: false);
      return refundedSale;
    } catch (e) {
      state = state.copyWith(isLoading: false, error: e.toString());
      rethrow;
    }

}

Future<void> \_restoreStockForRefund(Sale sale) async {
final items = await \_saleRepository.getSaleItems(sale.id!);

    for (final item in items) {
      await _productRepository.updateStockAfterRefund(
        productId: item.productId,
        quantityRefunded: item.quantity,
      );
    }

}

// === UTILITIES ===
void clearError() {
state = state.copyWith(error: null);
}

@override
void dispose() {
super.dispose();
}
}

// === PROVIDERS ===
final saleControllerProvider = StateNotifierProvider<SaleController, SaleState>(
(ref) => SaleController(
ref,
saleRepository: ref.read(saleRepositoryProvider),
productRepository: ref.read(productRepositoryProvider),
customerRepository: ref.read(customerRepositoryProvider),
syncService: ref.read(syncServiceProvider),
),
);

##

// mobile/lib/src/data/local/database.dart
// my question here for deepseek ai is for optimizing the following for making this app not crushy fast and reliable applying best practices for flutter sqflite database management and stll keeping all the existing functionalities and migrations
// and also adding any missing functionalities that are important for a pos app database management feasible to the back end laravel api design
import 'package:andalus_smart_pos/src/data/models/otp.dart';
import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';

class AppDatabase {
static const \_databaseName = "andalus_pos.db";
// static const \_databaseVersion = 6; // Increment version to trigger migration
static const \_databaseVersion = 8; // Increment version to trigger migration

static Database? \_database;

static Future<Database> get database async {
if (\_database != null) return \_database!;
\_database = await \_initDatabase();
return \_database!;
}

static Future<void> \_createIndexes(Database db) async {
await db.execute('CREATE INDEX idx_sales_created ON sales(created_at)');
await db
.execute('CREATE INDEX idx_products_category ON products(category_id)');
await db.execute('CREATE INDEX idx_customers_phone ON customers(phone)');
}

static Future<Database> \_initDatabase() async {
final databasesPath = await getDatabasesPath();
final path = join(databasesPath, \_databaseName);

    print('Database path: $path');
    print('Database version: $_databaseVersion');

    return await openDatabase(
      path,
      version: _databaseVersion,
      onCreate: _onCreate,
      onConfigure: _onConfigure,
      onUpgrade: _onUpgrade,
      onDowngrade: onDatabaseDowngradeDelete,
    );

}

static Future<void> \_onConfigure(Database db) async {
await db.execute('PRAGMA foreign_keys = ON');
}

static Future<void> \_onCreate(Database db, int version) async {
print('Creating database with version: $version');
await \_createAllTables(db);
}

static Future<void> ensureOTPTable() async {
final db = await database;

    try {
      await db.execute('''
      CREATE TABLE IF NOT EXISTS otps (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        otp_id TEXT UNIQUE NOT NULL,
        phone TEXT NOT NULL,
        code TEXT NOT NULL,
        type TEXT NOT NULL,
        is_used INTEGER DEFAULT 0,
        expires_at INTEGER NOT NULL,
        created_at INTEGER NOT NULL
      )
    ''');
      print('‚úÖ OTP table ensured');
    } catch (e) {
      print('‚ùå Error ensuring OTP table: $e');
    }

}

static Future<void> \_onUpgrade(
Database db, int oldVersion, int newVersion) async {
print('Upgrading database from $oldVersion to $newVersion');

    // Handle incremental migrations
    if (oldVersion < 2) {
      await _createCustomerTables(db);
    }

    if (oldVersion < 3) {
      await _migrateToVersion3(db);
    }

    if (oldVersion < 4) {
      await _migrateToVersion4(db);
    }

    if (oldVersion < 5) {
      await _migrateToVersion5(db);
    }

    if (oldVersion < 6) {
      await _migrateToVersion6(db);
    }
    if (oldVersion < 7) {
      await _migrateToVersion7(db);
    }

    if (oldVersion < 8) {
      await _migrateToVersion8(db);
    }

}

static Future<void> \_migrateToVersion8(Database db) async {
print(
'Migrating to version 8 - Making email column nullable in users table');

    try {
      // Create a temporary table without the UNIQUE constraint on email
      await db.execute('''
      CREATE TABLE users_temp (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT UNIQUE NOT NULL,
        name TEXT NOT NULL,
        phone TEXT UNIQUE NOT NULL,
        email TEXT,
        password_hash TEXT,
        role TEXT NOT NULL DEFAULT 'cashier',
        is_verified INTEGER DEFAULT 0,
        is_active INTEGER DEFAULT 1,
        business_id TEXT,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        last_login_at INTEGER
      )
    ''');

      // Copy data from old table to new table
      await db.execute('''
      INSERT INTO users_temp
      SELECT * FROM users
    ''');

      // Drop old table
      await db.execute('DROP TABLE users');

      // Rename new table
      await db.execute('ALTER TABLE users_temp RENAME TO users');

      print('‚úÖ Users table updated successfully - email is now nullable');
    } catch (e) {
      print('‚ùå Error in version 8 migration: $e');
      // If migration fails, the app should still work
    }

}

static Future<void> \_migrateToVersion7(Database db) async {
print('Migrating to version 7 - Recreating OTP table with correct schema');

    try {
      // Simply drop and recreate the OTP table
      await db.execute('DROP TABLE IF EXISTS otps');

      await db.execute('''
      CREATE TABLE otps (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        otp_id TEXT UNIQUE NOT NULL,
        phone TEXT NOT NULL,
        code TEXT NOT NULL,
        type TEXT NOT NULL,
        is_used INTEGER DEFAULT 0,
        expires_at INTEGER NOT NULL,
        created_at INTEGER NOT NULL
      )
    ''');

      print('‚úÖ OTP table recreated successfully in version 7 migration');

      // Add any indexes for better performance
      await db
          .execute('CREATE INDEX IF NOT EXISTS idx_otp_phone ON otps(phone)');
      await db.execute(
          'CREATE INDEX IF NOT EXISTS idx_otp_expires ON otps(expires_at)');
    } catch (e) {
      print('‚ùå Error in version 7 migration: $e');
      rethrow;
    }

}

static Future<void> \_migrateToVersion6(Database db) async {
print('Migrating to version 6 - Adding status column to subscriptions');
await \_addStatusColumnToSubscriptions(db);
}

static Future<void> \_migrateToVersion5(Database db) async {
print('Migrating to version 5 - Adding user management and OTP tables');
await \_createUserManagementTables(db);
}

static Future<void> \_migrateToVersion4(Database db) async {
print('Migrating to version 4 - Adding business and category tables');
await \_createBusinessTables(db);
}

static Future<void> \_migrateToVersion3(Database db) async {
print('Migrating to version 3 - No migration steps defined');
}

static Future<void> \_addStatusColumnToSubscriptions(Database db) async {
// Check if status column exists
final tableInfo = await db.rawQuery("PRAGMA table_info(subscriptions)");
final hasStatusColumn = tableInfo.any((col) => col['name'] == 'status');

    if (!hasStatusColumn) {
      print('Adding status column to subscriptions table');
      await db.execute(
          'ALTER TABLE subscriptions ADD COLUMN status TEXT DEFAULT "active"');
    }

    // Check if payment_reference column exists
    final hasPaymentRefColumn =
        tableInfo.any((col) => col['name'] == 'payment_reference');
    if (!hasPaymentRefColumn) {
      print('Adding payment_reference column to subscriptions table');
      await db.execute(
          'ALTER TABLE subscriptions ADD COLUMN payment_reference TEXT');
    }

}

static Future<void> \_createAllTables(Database db) async {
// Create all existing tables
await \_createCustomerTables(db);
await \_createSalesTables(db);
await \_createBusinessTables(db);
await \_createUserManagementTables(db);

    print('All tables created successfully');

}

// User Management Tables - Updated with correct schema
static Future<void> \_createUserManagementTables(Database db) async {
// Enhanced users table without foreign key constraint for now
await db.execute('''
CREATE TABLE IF NOT EXISTS users (
id INTEGER PRIMARY KEY AUTOINCREMENT,
user_id TEXT UNIQUE NOT NULL,
name TEXT NOT NULL,
phone TEXT UNIQUE NOT NULL,
email TEXT,
password_hash TEXT,
role TEXT NOT NULL DEFAULT 'cashier',
is_verified INTEGER DEFAULT 0,
is_active INTEGER DEFAULT 1,
business_id TEXT,
created_at INTEGER NOT NULL,
updated_at INTEGER NOT NULL,
last_login_at INTEGER
)
''');

    // OTP table for phone verification
    await db.execute('''
      CREATE TABLE IF NOT EXISTS otps (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        otp_id TEXT UNIQUE NOT NULL,
        phone TEXT NOT NULL,
        code TEXT NOT NULL,
        type TEXT NOT NULL,
        is_used INTEGER DEFAULT 0,
        expires_at INTEGER NOT NULL,
        created_at INTEGER NOT NULL
      )
    ''');

    // Enhanced subscription table with ALL columns
    await db.execute('''
    CREATE TABLE IF NOT EXISTS subscriptions (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      subscription_id TEXT UNIQUE NOT NULL,
      business_id TEXT NOT NULL,
      user_id TEXT NOT NULL,
      plan TEXT NOT NULL,
      billing_cycle TEXT NOT NULL,
      status TEXT NOT NULL DEFAULT "active",
      amount REAL NOT NULL,
      start_date INTEGER NOT NULL,
      end_date INTEGER NOT NULL,
      is_active INTEGER DEFAULT 1,
      currency TEXT DEFAULT 'ETB',
      payment_reference TEXT,
      created_at INTEGER NOT NULL,
      updated_at INTEGER NOT NULL,
      FOREIGN KEY (business_id) REFERENCES business_profile (business_id),
      FOREIGN KEY (user_id) REFERENCES users (user_id)
    )

''');

    print('User management tables created successfully');

}

// Add this to lib/src/data/local/database.dart
static Future<void> debugOTPTable() async {
final db = await database;

    try {
      // Check if table exists
      final tableInfo = await db.rawQuery(
          "SELECT name FROM sqlite_master WHERE type='table' AND name='otps'");
      print('üìã OTP table exists: ${tableInfo.isNotEmpty}');

      if (tableInfo.isNotEmpty) {
        // Check table schema
        final schema = await db.rawQuery("PRAGMA table_info(otps)");
        print('üîç OTP Table Schema:');
        for (var column in schema) {
          print('   ${column['name']} - ${column['type']}');
        }

        // Check all OTPs in table
        final allOtps = await db.query('otps');
        print('üìä Total OTPs in database: ${allOtps.length}');
        for (var otp in allOtps) {
          print(
              '   OTP: ${otp['otp_id']} - ${otp['phone']} - ${otp['code']} - Used: ${otp['is_used']}');
        }
      }
    } catch (e) {
      print('‚ùå Error debugging OTP table: $e');
    }

}

// ... rest of your existing methods remain the same
static Future<void> \_createSalesTables(Database db) async {
await db.execute('''
CREATE TABLE IF NOT EXISTS sales (
id INTEGER PRIMARY KEY AUTOINCREMENT,
sale_id TEXT UNIQUE NOT NULL,
customer_id INTEGER,
total_amount REAL NOT NULL,
final_amount REAL NOT NULL,
tax_amount REAL DEFAULT 0,
discount_amount REAL DEFAULT 0,
payment_method TEXT NOT NULL,
payment_status TEXT DEFAULT 'completed',
sale_status TEXT DEFAULT 'completed',
user_id INTEGER NOT NULL,
shop_id INTEGER NOT NULL,
is_synced INTEGER DEFAULT 0,
sync_attempts INTEGER DEFAULT 0,
created_at INTEGER NOT NULL,
updated_at INTEGER,
FOREIGN KEY (customer_id) REFERENCES customers (id) ON DELETE SET NULL
)
''');

    await db.execute('''
    CREATE TABLE IF NOT EXISTS sale_items (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      sale_id TEXT NOT NULL,
      product_id TEXT NOT NULL,
      product_name TEXT NOT NULL,
      quantity INTEGER NOT NULL,
      unit_price REAL NOT NULL,
      total_price REAL NOT NULL,
      created_at INTEGER NOT NULL,
      FOREIGN KEY (sale_id) REFERENCES sales (sale_id) ON DELETE CASCADE
    )

''');
}

static Future<void> \_createBusinessTables(Database db) async {
await db.execute('''
CREATE TABLE IF NOT EXISTS business_profile (
id INTEGER PRIMARY KEY AUTOINCREMENT,
business_id TEXT UNIQUE NOT NULL,
name TEXT NOT NULL,
name_am TEXT NOT NULL,
business_type TEXT NOT NULL,
phone TEXT NOT NULL,
email TEXT,
address TEXT NOT NULL,
city TEXT,
region TEXT,
tin_number TEXT NOT NULL,
vat_number TEXT,
business_license TEXT,
owner_name TEXT,
owner_phone TEXT,
owner_email TEXT,
currency TEXT DEFAULT 'ETB',
logo_path TEXT,
receipt_header TEXT,
receipt_footer TEXT,
is_active INTEGER DEFAULT 1,
created_at INTEGER NOT NULL,
updated_at INTEGER NOT NULL
)
''');

    await db.execute('''
      CREATE TABLE IF NOT EXISTS product_categories (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        category_id TEXT UNIQUE NOT NULL,
        name TEXT NOT NULL,
        name_am TEXT NOT NULL,
        description TEXT,
        color TEXT,
        icon TEXT,
        parent_id INTEGER,
        sort_order INTEGER DEFAULT 0,
        is_active INTEGER DEFAULT 1,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        FOREIGN KEY (parent_id) REFERENCES product_categories (id)
      )
    ''');

    await db.execute('''
      CREATE TABLE IF NOT EXISTS products (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        product_id TEXT UNIQUE NOT NULL,
        name TEXT NOT NULL,
        name_am TEXT NOT NULL,
        description TEXT,
        price REAL NOT NULL,
        cost_price REAL,
        stock_quantity INTEGER NOT NULL,
        min_stock_level INTEGER,
        barcode TEXT NOT NULL,
        sku TEXT,
        category_id TEXT NOT NULL,
        unit TEXT,
        brand TEXT,
        supplier TEXT,
        weight REAL,
        size TEXT,
        color TEXT,
        image_path TEXT,
        track_inventory INTEGER DEFAULT 1,
        is_active INTEGER DEFAULT 1,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        FOREIGN KEY (category_id) REFERENCES product_categories (category_id)
      )
    ''');

}

static Future<void> \_createCustomerTables(Database db) async {
await db.execute('''
CREATE TABLE IF NOT EXISTS customers (
id INTEGER PRIMARY KEY AUTOINCREMENT,
local_id TEXT UNIQUE NOT NULL,
name TEXT NOT NULL,
business_name TEXT,
phone TEXT NOT NULL,
whatsapp_number TEXT,
email TEXT,
address TEXT,
tin_number TEXT,
credit_limit REAL DEFAULT 0,
current_balance REAL DEFAULT 0,
due_date INTEGER,
last_transaction_date INTEGER,
allow_credit INTEGER DEFAULT 0,
payment_terms TEXT,
notes TEXT,
is_active INTEGER DEFAULT 1,
created_at INTEGER NOT NULL,
updated_at INTEGER NOT NULL
)
''');

    await db.execute('''
      CREATE TABLE IF NOT EXISTS credit_transactions (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        local_id TEXT UNIQUE NOT NULL,
        customer_id INTEGER NOT NULL,
        customer_name TEXT NOT NULL,
        type TEXT NOT NULL,
        amount REAL NOT NULL,
        balance_before REAL NOT NULL,
        balance_after REAL NOT NULL,
        reference TEXT,
        notes TEXT,
        created_at INTEGER NOT NULL,
        FOREIGN KEY (customer_id) REFERENCES customers (id) ON DELETE CASCADE
      )
    ''');

}

// Add to lib/src/data/local/database.dart
static Future<void> debugUsersTable() async {
final db = await database;

    try {
      final users = await db.query('users');
      print('üë• Total users in database: ${users.length}');

      for (var user in users) {
        print(
            'üìÑ User: ${user['user_id']} - ${user['name']} - ${user['phone']} - ${user['role']} - Active: ${user['is_active']}');
      }

      // Check specifically for our test user
      final testUser = await db
          .query('users', where: 'phone = ?', whereArgs: ['+251911223344']);
      print('üîç Test user query result: ${testUser.length} users found');
    } catch (e) {
      print('‚ùå Error debugging users table: $e');
    }

}

// Add to lib/src/data/local/database.dart
static Future<void> verifyOTPTable() async {
final db = await database;

    try {
      // Check if table exists
      final tableInfo = await db.rawQuery(
          "SELECT name FROM sqlite_master WHERE type='table' AND name='otps'");

      if (tableInfo.isEmpty) {
        print('‚ùå OTP table does not exist after migration!');
        return;
      }

      print('‚úÖ OTP table exists');

      // Check schema
      final schema = await db.rawQuery("PRAGMA table_info(otps)");
      final expectedColumns = [
        'id',
        'otp_id',
        'phone',
        'code',
        'type',
        'is_used',
        'expires_at',
        'created_at'
      ];
      final actualColumns = schema.map((col) => col['name'] as String).toList();

      print('üìã OTP Table columns: $actualColumns');

      // Test insert and query
      final testOTP = OTP.create(phone: '+251911223344', type: 'test');
      await db.insert('otps', testOTP.toMap());

      final retrieved = await db.query(
        'otps',
        where: 'phone = ? AND code = ?',
        whereArgs: [testOTP.phone, testOTP.code],
      );

      if (retrieved.isNotEmpty) {
        print('‚úÖ OTP table working correctly - can insert and query');
      } else {
        print('‚ùå OTP table not working - cannot retrieve inserted data');
      }

      // Clean up test data
      await db.delete('otps', where: 'phone = ?', whereArgs: [testOTP.phone]);
    } catch (e) {
      print('‚ùå Error verifying OTP table: $e');
    }

}

// Helper methods
static Future<bool> tableExists(String tableName) async {
final db = await database;
final result = await db.rawQuery(
"SELECT name FROM sqlite_master WHERE type='table' AND name=?",
[tableName],
);
return result.isNotEmpty;
}

static Future<void> migrateDatabase() async {
final db = await database;
// Check and create missing tables
final userTableExists = await tableExists('users');
final otpTableExists = await tableExists('otps');
final subscriptionTableExists = await tableExists('subscriptions');

    if (!userTableExists || !otpTableExists || !subscriptionTableExists) {
      print('Creating missing user management tables...');
      await _createUserManagementTables(db);
    }

    print('Database migration completed');

}

static Future<void> resetDatabase() async {
final databasesPath = await getDatabasesPath();
final path = join(databasesPath, \_databaseName);

    if (_database != null) {
      await _database!.close();
      _database = null;
    }

    await deleteDatabase(path);
    print('Database reset complete');
    _database = await _initDatabase();

}

static Future<void> migrateSalesTable() async {
final db = await database;

    try {
      // Check if final_amount column exists
      final tableInfo = await db.rawQuery("PRAGMA table_info(sales)");
      final hasFinalAmount =
          tableInfo.any((col) => col['name'] == 'final_amount');

      if (!hasFinalAmount) {
        print('Migrating sales table to add final_amount column...');

        // Create backup
        await db.execute(
            'CREATE TABLE IF NOT EXISTS sales_backup AS SELECT * FROM sales');

        // Drop and recreate table with new schema
        await db.execute('DROP TABLE IF EXISTS sales_old');
        await db.execute('ALTER TABLE sales RENAME TO sales_old');

        await _createSalesTables(db);

        // Copy data with final_amount = total_amount for existing records
        await db.execute('''
        INSERT INTO sales
        SELECT id, sale_id, customer_id, total_amount, total_amount as final_amount,
               tax_amount, discount_amount, payment_method, payment_status, sale_status,
               user_id, shop_id, is_synced, sync_attempts, created_at, updated_at
        FROM sales_old
      ''');

        await db.execute('DROP TABLE sales_old');
        print('Sales table migration completed successfully');
      }
    } catch (e) {
      print('Sales table migration error: $e');
      // Try to restore from backup if migration fails
      try {
        await db.execute('DROP TABLE IF EXISTS sales');
        await db.execute('ALTER TABLE sales_backup RENAME TO sales');
      } catch (restoreError) {
        print('Restore from backup failed: $restoreError');
      }
    }

}
}

##

// lib/models/extensions/sale_refund_extension.dart

import 'dart:core';
// Assuming your Sale model is here (adjust path as needed)
import '../sale.dart';

// Add this extension to Sale class for canBeRefunded
extension SaleRefundExtension on Sale {
bool get canBeRefunded {
// 1. Check if it's already refunded
if (isRefunded) return false;

    // 2. Check if the sale and payment are fully processed
    if (saleStatus != 'completed') return false;
    if (paymentStatus != 'completed') return false;

    // 3. Check the 30-day refund window
    final thirtyDaysAgo = DateTime.now().subtract(const Duration(days: 30));

    // Check if the sale creation date is *after* the date 30 days ago.
    return createdAt.isAfter(thirtyDaysAgo);

}
}

##

//src/data/models/business.dart
class BusinessType {
final String id;
final String name;
final String nameAm;
final String description;

const BusinessType({
required this.id,
required this.name,
required this.nameAm,
required this.description,
});

static const List<BusinessType> allTypes = [
BusinessType(
id: 'retail',
name: 'Retail Shop',
nameAm: '·ã®·åà·â†·ã´ ·à±·âÖ',
description: 'General retail store selling various products',
),
BusinessType(
id: 'supermarket',
name: 'Supermarket',
nameAm: '·à±·çê·à≠·àõ·à≠·ä¨·âµ',
description: 'Large retail store with multiple departments',
),
BusinessType(
id: 'restaurant',
name: 'Restaurant/Cafe',
nameAm: '·àù·åç·â• ·â§·âµ/·ä´·çå',
description: 'Food and beverage service establishment',
),
BusinessType(
id: 'pharmacy',
name: 'Pharmacy',
nameAm: '·çã·à≠·àõ·à≤',
description: 'Medical and pharmaceutical products',
),
BusinessType(
id: 'electronics',
name: 'Electronics Store',
nameAm: '·ã®·ä§·àå·ä≠·âµ·àÆ·äí·ä≠·àµ ·à±·âÖ',
description: 'Electronic devices and accessories',
),
BusinessType(
id: 'clothing',
name: 'Clothing Store',
nameAm: '·ã®·àç·â•·àµ ·à±·âÖ',
description: 'Fashion and apparel retail',
),
BusinessType(
id: 'hardware',
name: 'Hardware Store',
nameAm: '·ã®·àõ·àΩ·äê·à™ ·à±·âÖ',
description: 'Construction materials and tools',
),
BusinessType(
id: 'wholesale',
name: 'Wholesale',
nameAm: '·åÖ·àù·àã',
description: 'Bulk goods distribution',
),
BusinessType(
id: 'service',
name: 'Service Provider',
nameAm: '·ä†·åà·àç·åç·àé·âµ ·ä†·âÖ·à´·â¢',
description: 'Service-based business',
),
BusinessType(
id: 'other',
name: 'Other',
nameAm: '·àå·àã',
description: 'Other business types',
),
];
}

class BusinessProfile {
final int? id;
final String businessId;
final String name;
final String nameAm;
final String businessType;
final String phone;
final String? email;
final String address;
final String? city;
final String? region;
final String tinNumber;
final String? vatNumber;
final String? businessLicense;
final String? ownerName;
final String? ownerPhone;
final String? ownerEmail;
final String currency;
final String? logoPath;
final String? receiptHeader;
final String? receiptFooter;
final bool isActive;
final DateTime createdAt;
final DateTime updatedAt;

BusinessProfile({
this.id,
required this.businessId,
required this.name,
required this.nameAm,
required this.businessType,
required this.phone,
this.email,
required this.address,
this.city,
this.region,
required this.tinNumber,
this.vatNumber,
this.businessLicense,
this.ownerName,
this.ownerPhone,
this.ownerEmail,
this.currency = 'ETB',
this.logoPath,
this.receiptHeader,
this.receiptFooter,
this.isActive = true,
required this.createdAt,
required this.updatedAt,
});

Map<String, dynamic> toMap() {
return {
'id': id,
'business_id': businessId,
'name': name,
'name_am': nameAm,
'business_type': businessType,
'phone': phone,
'email': email,
'address': address,
'city': city,
'region': region,
'tin_number': tinNumber,
'vat_number': vatNumber,
'business_license': businessLicense,
'owner_name': ownerName,
'owner_phone': ownerPhone,
'owner_email': ownerEmail,
'currency': currency,
'logo_path': logoPath,
'receipt_header': receiptHeader,
'receipt_footer': receiptFooter,
'is_active': isActive ? 1 : 0,
'created_at': createdAt.millisecondsSinceEpoch,
'updated_at': updatedAt.millisecondsSinceEpoch,
};
}

factory BusinessProfile.fromMap(Map<String, dynamic> map) {
return BusinessProfile(
id: map['id'],
businessId: map['business_id'],
name: map['name'],
nameAm: map['name_am'],
businessType: map['business_type'],
phone: map['phone'],
email: map['email'],
address: map['address'],
city: map['city'],
region: map['region'],
tinNumber: map['tin_number'],
vatNumber: map['vat_number'],
businessLicense: map['business_license'],
ownerName: map['owner_name'],
ownerPhone: map['owner_phone'],
ownerEmail: map['owner_email'],
currency: map['currency'] ?? 'ETB',
logoPath: map['logo_path'],
receiptHeader: map['receipt_header'],
receiptFooter: map['receipt_footer'],
isActive: map['is_active'] == 1,
createdAt: DateTime.fromMillisecondsSinceEpoch(map['created_at']),
updatedAt: DateTime.fromMillisecondsSinceEpoch(map['updated_at']),
);
}

BusinessProfile copyWith({
String? name,
String? nameAm,
String? businessType,
String? phone,
String? email,
String? address,
String? city,
String? region,
String? tinNumber,
String? vatNumber,
String? businessLicense,
String? ownerName,
String? ownerPhone,
String? ownerEmail,
String? currency,
String? logoPath,
String? receiptHeader,
String? receiptFooter,
bool? isActive,
}) {
return BusinessProfile(
id: id,
businessId: businessId,
name: name ?? this.name,
nameAm: nameAm ?? this.nameAm,
businessType: businessType ?? this.businessType,
phone: phone ?? this.phone,
email: email ?? this.email,
address: address ?? this.address,
city: city ?? this.city,
region: region ?? this.region,
tinNumber: tinNumber ?? this.tinNumber,
vatNumber: vatNumber ?? this.vatNumber,
businessLicense: businessLicense ?? this.businessLicense,
ownerName: ownerName ?? this.ownerName,
ownerPhone: ownerPhone ?? this.ownerPhone,
ownerEmail: ownerEmail ?? this.ownerEmail,
currency: currency ?? this.currency,
logoPath: logoPath ?? this.logoPath,
receiptHeader: receiptHeader ?? this.receiptHeader,
receiptFooter: receiptFooter ?? this.receiptFooter,
isActive: isActive ?? this.isActive,
createdAt: createdAt,
updatedAt: DateTime.now(),
);
}
}

##

// mobile/lib/src/data/models/cart_item.dart
// Model representing an item in the shopping cart.
class CartItem {
final int productId;
final String productName;
final double unitPrice;
final int quantity;

const CartItem({
required this.productId,
required this.productName,
required this.unitPrice,
required this.quantity,
});

double get totalPrice => unitPrice \* quantity;

String get formattedUnitPrice => 'ETB ${unitPrice.toStringAsFixed(2)}';
String get formattedTotalPrice => 'ETB ${totalPrice.toStringAsFixed(2)}';

CartItem copyWith({
int? productId,
String? productName,
double? unitPrice,
int? quantity,
}) {
return CartItem(
productId: productId ?? this.productId,
productName: productName ?? this.productName,
unitPrice: unitPrice ?? this.unitPrice,
quantity: quantity ?? this.quantity,
);
}

@override
bool operator ==(Object other) {
if (identical(this, other)) return true;
return other is CartItem && other.productId == productId;
}

@override
int get hashCode => productId.hashCode;
}

##

// mobile/lib/src/data/models/category.dart
// Model representing a product category.
// Includes sample categories for different business types.
// later on we can extend this to support hierarchical categories if needed. and supporting different business types with default categories
class ProductCategory {
final int? id;
final String categoryId;
final String name;
final String nameAm;
final String? description;
final String? color;
final String? icon;
final int? parentId;
final int sortOrder;
final bool isActive;
final DateTime createdAt;
final DateTime updatedAt;

ProductCategory({
this.id,
required this.categoryId,
required this.name,
required this.nameAm,
this.description,
this.color,
this.icon,
this.parentId,
this.sortOrder = 0,
this.isActive = true,
required this.createdAt,
required this.updatedAt,
});

Map<String, dynamic> toMap() {
return {
'id': id,
'category_id': categoryId,
'name': name,
'name_am': nameAm,
'description': description,
'color': color,
'icon': icon,
'parent_id': parentId,
'sort_order': sortOrder,
'is_active': isActive ? 1 : 0,
'created_at': createdAt.millisecondsSinceEpoch,
'updated_at': updatedAt.millisecondsSinceEpoch,
};
}

factory ProductCategory.fromMap(Map<String, dynamic> map) {
return ProductCategory(
id: map['id'],
categoryId: map['category_id'],
name: map['name'],
nameAm: map['name_am'],
description: map['description'],
color: map['color'],
icon: map['icon'],
parentId: map['parent_id'],
sortOrder: map['sort_order'] ?? 0,
isActive: map['is_active'] == 1,
createdAt: DateTime.fromMillisecondsSinceEpoch(map['created_at']),
updatedAt: DateTime.fromMillisecondsSinceEpoch(map['updated_at']),
);
}

ProductCategory copyWith({
String? name,
String? nameAm,
String? description,
String? color,
String? icon,
int? parentId,
int? sortOrder,
bool? isActive,
}) {
return ProductCategory(
id: id,
categoryId: categoryId,
name: name ?? this.name,
nameAm: nameAm ?? this.nameAm,
description: description ?? this.description,
color: color ?? this.color,
icon: icon ?? this.icon,
parentId: parentId ?? this.parentId,
sortOrder: sortOrder ?? this.sortOrder,
isActive: isActive ?? this.isActive,
createdAt: createdAt,
updatedAt: DateTime.now(),
);
}

bool get hasParent => parentId != null;
}

// Sample categories for different business types
class DefaultCategories {
static List<ProductCategory> forBusinessType(String businessType) {
switch (businessType) {
case 'retail':
case 'supermarket':
return [
ProductCategory(
categoryId: 'food_beverages',
name: 'Food & Beverages',
nameAm: '·àù·åç·â• ·ä•·äì ·àò·å†·å•',
description: 'Food items and beverages',
color: '#4CAF50',
icon: 'local_grocery_store',
sortOrder: 1,
createdAt: DateTime.now(),
updatedAt: DateTime.now(),
),
ProductCategory(
categoryId: 'personal_care',
name: 'Personal Care',
nameAm: '·ã®·åç·àå ·ä•·äï·ä≠·â•·ä´·â§',
description: 'Personal hygiene and care products',
color: '#2196F3',
icon: 'spa',
sortOrder: 2,
createdAt: DateTime.now(),
updatedAt: DateTime.now(),
),
ProductCategory(
categoryId: 'household',
name: 'Household Items',
nameAm: '·ã®·â§·âµ ·ä•·âÉ·ãé·âΩ',
description: 'Household and cleaning supplies',
color: '#FF9800',
icon: 'home',
sortOrder: 3,
createdAt: DateTime.now(),
updatedAt: DateTime.now(),
),
];

      case 'restaurant':
        return [
          ProductCategory(
            categoryId: 'main_courses',
            name: 'Main Courses',
            nameAm: '·ãã·äì ·àù·åç·â¶·âΩ',
            description: 'Main dishes and entrees',
            color: '#F44336',
            icon: 'restaurant',
            sortOrder: 1,
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          ),
          ProductCategory(
            categoryId: 'beverages',
            name: 'Beverages',
            nameAm: '·àò·å†·å¶·âΩ',
            description: 'Drinks and beverages',
            color: '#4CAF50',
            icon: 'local_cafe',
            sortOrder: 2,
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          ),
          ProductCategory(
            categoryId: 'desserts',
            name: 'Desserts',
            nameAm: '·àù·äï·å£·çé·âΩ',
            description: 'Sweets and desserts',
            color: '#9C27B0',
            icon: 'cake',
            sortOrder: 3,
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          ),
        ];

      case 'pharmacy':
        return [
          ProductCategory(
            categoryId: 'prescription',
            name: 'Prescription Drugs',
            nameAm: '·ã®·ã∂·ä≠·â∞·à≠ ·ä•·ãò·ãù ·àò·ãµ·àÉ·äí·â∂·âΩ',
            description: 'Prescription medications',
            color: '#F44336',
            icon: 'medical_services',
            sortOrder: 1,
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          ),
          ProductCategory(
            categoryId: 'otc',
            name: 'Over-the-Counter',
            nameAm: '·ã´·àà ·ä•·ãò·ãù ·àò·ãµ·àÉ·äí·â∂·âΩ',
            description: 'Non-prescription medications',
            color: '#2196F3',
            icon: 'local_pharmacy',
            sortOrder: 2,
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          ),
          ProductCategory(
            categoryId: 'personal_care',
            name: 'Personal Care',
            nameAm: '·ã®·åç·àå ·ä•·äï·ä≠·â•·ä´·â§',
            description: 'Health and personal care',
            color: '#4CAF50',
            icon: 'spa',
            sortOrder: 3,
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          ),
        ];

      default:
        return [
          ProductCategory(
            categoryId: 'general',
            name: 'General',
            nameAm: '·ä†·å†·âÉ·àã·ã≠',
            description: 'General products',
            color: '#607D8B',
            icon: 'category',
            sortOrder: 1,
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          ),
        ];
    }

}
}

##

// mobile/lib/src/data/models/category.dart
// Model representing a product category.
// Includes sample categories for different business types.
// later on we can extend this to support hierarchical categories if needed. and supporting different business types with default categories
class ProductCategory {
final int? id;
final String categoryId;
final String name;
final String nameAm;
final String? description;
final String? color;
final String? icon;
final int? parentId;
final int sortOrder;
final bool isActive;
final DateTime createdAt;
final DateTime updatedAt;

ProductCategory({
this.id,
required this.categoryId,
required this.name,
required this.nameAm,
this.description,
this.color,
this.icon,
this.parentId,
this.sortOrder = 0,
this.isActive = true,
required this.createdAt,
required this.updatedAt,
});

Map<String, dynamic> toMap() {
return {
'id': id,
'category_id': categoryId,
'name': name,
'name_am': nameAm,
'description': description,
'color': color,
'icon': icon,
'parent_id': parentId,
'sort_order': sortOrder,
'is_active': isActive ? 1 : 0,
'created_at': createdAt.millisecondsSinceEpoch,
'updated_at': updatedAt.millisecondsSinceEpoch,
};
}

factory ProductCategory.fromMap(Map<String, dynamic> map) {
return ProductCategory(
id: map['id'],
categoryId: map['category_id'],
name: map['name'],
nameAm: map['name_am'],
description: map['description'],
color: map['color'],
icon: map['icon'],
parentId: map['parent_id'],
sortOrder: map['sort_order'] ?? 0,
isActive: map['is_active'] == 1,
createdAt: DateTime.fromMillisecondsSinceEpoch(map['created_at']),
updatedAt: DateTime.fromMillisecondsSinceEpoch(map['updated_at']),
);
}

ProductCategory copyWith({
String? name,
String? nameAm,
String? description,
String? color,
String? icon,
int? parentId,
int? sortOrder,
bool? isActive,
}) {
return ProductCategory(
id: id,
categoryId: categoryId,
name: name ?? this.name,
nameAm: nameAm ?? this.nameAm,
description: description ?? this.description,
color: color ?? this.color,
icon: icon ?? this.icon,
parentId: parentId ?? this.parentId,
sortOrder: sortOrder ?? this.sortOrder,
isActive: isActive ?? this.isActive,
createdAt: createdAt,
updatedAt: DateTime.now(),
);
}

bool get hasParent => parentId != null;
}

// Sample categories for different business types
class DefaultCategories {
static List<ProductCategory> forBusinessType(String businessType) {
switch (businessType) {
case 'retail':
case 'supermarket':
return [
ProductCategory(
categoryId: 'food_beverages',
name: 'Food & Beverages',
nameAm: '·àù·åç·â• ·ä•·äì ·àò·å†·å•',
description: 'Food items and beverages',
color: '#4CAF50',
icon: 'local_grocery_store',
sortOrder: 1,
createdAt: DateTime.now(),
updatedAt: DateTime.now(),
),
ProductCategory(
categoryId: 'personal_care',
name: 'Personal Care',
nameAm: '·ã®·åç·àå ·ä•·äï·ä≠·â•·ä´·â§',
description: 'Personal hygiene and care products',
color: '#2196F3',
icon: 'spa',
sortOrder: 2,
createdAt: DateTime.now(),
updatedAt: DateTime.now(),
),
ProductCategory(
categoryId: 'household',
name: 'Household Items',
nameAm: '·ã®·â§·âµ ·ä•·âÉ·ãé·âΩ',
description: 'Household and cleaning supplies',
color: '#FF9800',
icon: 'home',
sortOrder: 3,
createdAt: DateTime.now(),
updatedAt: DateTime.now(),
),
];

      case 'restaurant':
        return [
          ProductCategory(
            categoryId: 'main_courses',
            name: 'Main Courses',
            nameAm: '·ãã·äì ·àù·åç·â¶·âΩ',
            description: 'Main dishes and entrees',
            color: '#F44336',
            icon: 'restaurant',
            sortOrder: 1,
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          ),
          ProductCategory(
            categoryId: 'beverages',
            name: 'Beverages',
            nameAm: '·àò·å†·å¶·âΩ',
            description: 'Drinks and beverages',
            color: '#4CAF50',
            icon: 'local_cafe',
            sortOrder: 2,
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          ),
          ProductCategory(
            categoryId: 'desserts',
            name: 'Desserts',
            nameAm: '·àù·äï·å£·çé·âΩ',
            description: 'Sweets and desserts',
            color: '#9C27B0',
            icon: 'cake',
            sortOrder: 3,
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          ),
        ];

      case 'pharmacy':
        return [
          ProductCategory(
            categoryId: 'prescription',
            name: 'Prescription Drugs',
            nameAm: '·ã®·ã∂·ä≠·â∞·à≠ ·ä•·ãò·ãù ·àò·ãµ·àÉ·äí·â∂·âΩ',
            description: 'Prescription medications',
            color: '#F44336',
            icon: 'medical_services',
            sortOrder: 1,
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          ),
          ProductCategory(
            categoryId: 'otc',
            name: 'Over-the-Counter',
            nameAm: '·ã´·àà ·ä•·ãò·ãù ·àò·ãµ·àÉ·äí·â∂·âΩ',
            description: 'Non-prescription medications',
            color: '#2196F3',
            icon: 'local_pharmacy',
            sortOrder: 2,
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          ),
          ProductCategory(
            categoryId: 'personal_care',
            name: 'Personal Care',
            nameAm: '·ã®·åç·àå ·ä•·äï·ä≠·â•·ä´·â§',
            description: 'Health and personal care',
            color: '#4CAF50',
            icon: 'spa',
            sortOrder: 3,
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          ),
        ];

      default:
        return [
          ProductCategory(
            categoryId: 'general',
            name: 'General',
            nameAm: '·ä†·å†·âÉ·àã·ã≠',
            description: 'General products',
            color: '#607D8B',
            icon: 'category',
            sortOrder: 1,
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          ),
        ];
    }

}
}

##

// mobile/lib/src/data/models/credit_transaction.dart
// Model representing a credit transaction for a customer.
import 'package:flutter/material.dart';

class CreditTransaction {
final int? id;
final String localId;
final int customerId;
final String customerName;
final String type; // 'sale', 'payment', 'adjustment'
final double amount;
final double balanceBefore;
final double balanceAfter;
final String? reference; // sale_id or payment reference
final String? notes;
final DateTime createdAt;

CreditTransaction({
this.id,
required this.localId,
required this.customerId,
required this.customerName,
required this.type,
required this.amount,
required this.balanceBefore,
required this.balanceAfter,
this.reference,
this.notes,
required this.createdAt,
});

Map<String, dynamic> toMap() {
return {
'id': id,
'local_id': localId,
'customer_id': customerId,
'customer_name': customerName,
'type': type,
'amount': amount,
'balance_before': balanceBefore,
'balance_after': balanceAfter,
'reference': reference,
'notes': notes,
'created_at': createdAt.millisecondsSinceEpoch,
};
}

factory CreditTransaction.fromMap(Map<String, dynamic> map) {
return CreditTransaction(
id: map['id'],
localId: map['local_id'],
customerId: map['customer_id'],
customerName: map['customer_name'],
type: map['type'],
amount: map['amount'],
balanceBefore: map['balance_before'],
balanceAfter: map['balance_after'],
reference: map['reference'],
notes: map['notes'],
createdAt: DateTime.fromMillisecondsSinceEpoch(map['created_at']),
);
}

// Helper methods
bool get isSale => type == 'sale';
bool get isPayment => type == 'payment';
bool get isAdjustment => type == 'adjustment';

String get formattedAmount {
if (isSale) {
return '+ETB ${amount.toStringAsFixed(2)}';
} else if (isPayment) {
return '-ETB ${amount.toStringAsFixed(2)}';
} else {
return 'ETB ${amount.toStringAsFixed(2)}';
}
}

String get description {
switch (type) {
case 'sale':
return 'Credit Sale';
case 'payment':
return 'Payment Received';
case 'adjustment':
return 'Credit Limit Adjustment';
default:
return 'Transaction';
}
}

Color get amountColor {
switch (type) {
case 'sale':
return Colors.red;
case 'payment':
return Colors.green;
default:
return Colors.orange;
}
}

IconData get icon {
switch (type) {
case 'sale':
return Icons.shopping_cart;
case 'payment':
return Icons.payment;
case 'adjustment':
return Icons.tune;
default:
return Icons.receipt;
}
}
}

##

// mobile/lib/src/data/models/customer.dart
// Model representing a customer in the POS system.
class Customer {
final int? id;
final String localId;
final String name;
final String? businessName;
final String phone;
final String? whatsappNumber;
final String? email;
final String? address;
final String? tinNumber;
final double creditLimit;
final double currentBalance;
final DateTime? dueDate;
final DateTime? lastTransactionDate;
final bool allowCredit;
final String? paymentTerms;
final String? notes;
final bool isActive;
final DateTime createdAt;
final DateTime updatedAt;

Customer({
this.id,
required this.localId,
required this.name,
this.businessName,
required this.phone,
this.whatsappNumber,
this.email,
this.address,
this.tinNumber,
this.creditLimit = 0,
this.currentBalance = 0,
this.dueDate,
this.lastTransactionDate,
this.allowCredit = false,
this.paymentTerms,
this.notes,
this.isActive = true,
required this.createdAt,
required this.updatedAt,
});

Map<String, dynamic> toMap() {
return {
'id': id,
'local_id': localId,
'name': name,
'business_name': businessName,
'phone': phone,
'whatsapp_number': whatsappNumber,
'email': email,
'address': address,
'tin_number': tinNumber,
'credit_limit': creditLimit,
'current_balance': currentBalance,
'due_date': dueDate?.millisecondsSinceEpoch,
'last_transaction_date': lastTransactionDate?.millisecondsSinceEpoch,
'allow_credit': allowCredit ? 1 : 0,
'payment_terms': paymentTerms,
'notes': notes,
'is_active': isActive ? 1 : 0,
'created_at': createdAt.millisecondsSinceEpoch,
'updated_at': updatedAt.millisecondsSinceEpoch,
};
}

factory Customer.fromMap(Map<String, dynamic> map) {
return Customer(
id: map['id'],
localId: map['local_id'],
name: map['name'],
businessName: map['business_name'],
phone: map['phone'],
whatsappNumber: map['whatsapp_number'],
email: map['email'],
address: map['address'],
tinNumber: map['tin_number'],
creditLimit: map['credit_limit'] ?? 0,
currentBalance: map['current_balance'] ?? 0,
dueDate: map['due_date'] != null
? DateTime.fromMillisecondsSinceEpoch(map['due_date'])
: null,
lastTransactionDate: map['last_transaction_date'] != null
? DateTime.fromMillisecondsSinceEpoch(map['last_transaction_date'])
: null,
allowCredit: map['allow_credit'] == 1,
paymentTerms: map['payment_terms'],
notes: map['notes'],
isActive: map['is_active'] == 1,
createdAt: DateTime.fromMillisecondsSinceEpoch(map['created_at']),
updatedAt: DateTime.fromMillisecondsSinceEpoch(map['updated_at']),
);
}

// Helper methods
bool get hasCredit => allowCredit && creditLimit > 0;

double get overdueAmount {
if (currentBalance <= 0) return 0;
if (dueDate == null) return 0;
if (DateTime.now().isAfter(dueDate!)) {
return currentBalance;
}
return 0;
}

bool get isOverdue => overdueAmount > 0;

double get availableCredit => hasCredit ? creditLimit - currentBalance : 0;

bool get canMakeCreditSale => availableCredit > 0;

String get balanceStatus {
if (currentBalance == 0) return 'Paid';
if (isOverdue) return 'Overdue: ETB ${currentBalance.toStringAsFixed(2)}';
if (currentBalance > 0) {
return 'Owes: ETB ${currentBalance.toStringAsFixed(2)}';
}
return 'Credit: ETB ${(-currentBalance).toStringAsFixed(2)}';
}

String get formattedBalance {
if (currentBalance >= 0) {
return 'ETB ${currentBalance.toStringAsFixed(2)}';
} else {
return 'ETB ${(-currentBalance).toStringAsFixed(2)}';
}
}

Customer copyWith({
int? id,
String? localId,
String? name,
String? businessName,
String? phone,
String? whatsappNumber,
String? email,
String? address,
String? tinNumber,
double? creditLimit,
double? currentBalance,
DateTime? dueDate,
DateTime? lastTransactionDate,
bool? allowCredit,
String? paymentTerms,
String? notes,
bool? isActive,
DateTime? createdAt,
DateTime? updatedAt,
}) {
return Customer(
id: id ?? this.id,
localId: localId ?? this.localId,
name: name ?? this.name,
businessName: businessName ?? this.businessName,
phone: phone ?? this.phone,
whatsappNumber: whatsappNumber ?? this.whatsappNumber,
email: email ?? this.email,
address: address ?? this.address,
tinNumber: tinNumber ?? this.tinNumber,
creditLimit: creditLimit ?? this.creditLimit,
currentBalance: currentBalance ?? this.currentBalance,
dueDate: dueDate ?? this.dueDate,
lastTransactionDate: lastTransactionDate ?? this.lastTransactionDate,
allowCredit: allowCredit ?? this.allowCredit,
paymentTerms: paymentTerms ?? this.paymentTerms,
notes: notes ?? this.notes,
isActive: isActive ?? this.isActive,
createdAt: createdAt ?? this.createdAt,
updatedAt: updatedAt ?? this.updatedAt,
);
}

factory Customer.createSample() {
return Customer(
localId: 'cust*sample*${DateTime.now().millisecondsSinceEpoch}',
name: 'Sample Customer',
businessName: 'Sample Business',
phone: '+251911223344',
whatsappNumber: '+251911223344',
email: 'sample@email.com',
address: 'Addis Ababa, Ethiopia',
tinNumber: '1234567890',
creditLimit: 1000.0,
currentBalance: 250.0,
dueDate: DateTime.now().add(const Duration(days: 30)),
allowCredit: true,
paymentTerms: '30',
notes: 'Sample customer for testing',
isActive: true,
createdAt: DateTime.now(),
updatedAt: DateTime.now(),
);
}

factory Customer.createSampleWithIndex(int index) {
final customers = [
{
'name': 'Abebe Kebede',
'business': 'Abebe Store',
'phone': '+251911001100',
'balance': 0.0
},
{
'name': 'Marta Solomon',
'business': 'Marta Trading',
'phone': '+251922002200',
'balance': 500.0
},
{
'name': 'Tesfaye Hailu',
'business': 'Tesfaye Shop',
'phone': '+251933003300',
'balance': 1200.0
},
{
'name': 'Hana Michael',
'business': 'Hana Retail',
'phone': '+251944004400',
'balance': 0.0
},
{
'name': 'Dawit Asrat',
'business': 'Dawit Wholesale',
'phone': '+251955005500',
'balance': 750.0
},
];

    final customerData = customers[index % customers.length];
    final hasBalance = (customerData['balance'] as double) > 0;

    return Customer(
      localId: 'cust_sample_${DateTime.now().millisecondsSinceEpoch}_$index',
      name: customerData['name'] as String,
      businessName: customerData['business'] as String,
      phone: customerData['phone'] as String,
      whatsappNumber: customerData['phone'] as String,
      email: 'customer${index + 1}@email.com',
      address: 'Addis Ababa, Ethiopia',
      tinNumber: 'TIN${index.toString().padLeft(7, '0')}',
      creditLimit: 2000.0,
      currentBalance: customerData['balance'] as double,
      dueDate: hasBalance
          ? DateTime.now().add(Duration(days: 30 - (index * 5)))
          : null,
      allowCredit: true,
      paymentTerms: '30',
      notes: 'Regular customer',
      isActive: true,
      createdAt: DateTime.now().subtract(Duration(days: index * 10)),
      updatedAt: DateTime.now(),
    );

}
}

##

// mobile/lib/src/data/models/otp.dart
// Model representing a One-Time Password (OTP) used for authentication and verification. used on registration login password reset and phone verification
class OTP {
final String id;
final String phone;
final String code;
final String type; // 'login', 'reset_password', 'verify_phone'
final bool isUsed;
final DateTime expiresAt;
final DateTime createdAt;

OTP({
required this.id,
required this.phone,
required this.code,
required this.type,
this.isUsed = false,
required this.expiresAt,
required this.createdAt,
});

factory OTP.create({
required String phone,
required String type,
int validityMinutes = 10,
}) {
final now = DateTime.now();
return OTP(
id: 'otp\_${now.millisecondsSinceEpoch}',
phone: phone,
code: \_generateOTP(),
type: type,
expiresAt: now.add(Duration(minutes: validityMinutes)),
createdAt: now,
);
}

static String \_generateOTP() {
final random = DateTime.now().millisecondsSinceEpoch;
return (random % 900000 + 100000).toString().substring(0, 6);
}

Map<String, dynamic> toMap() {
return {
'otp_id': id,
'phone': phone,
'code': code,
'type': type,
'is_used': isUsed ? 1 : 0,
'expires_at': expiresAt.millisecondsSinceEpoch,
'created_at': createdAt.millisecondsSinceEpoch,
};
}

factory OTP.fromMap(Map<String, dynamic> map) {
return OTP(
id: map['otp_id'],
phone: map['phone'],
code: map['code'],
type: map['type'],
isUsed: map['is_used'] == 1,
expiresAt: DateTime.fromMillisecondsSinceEpoch(map['expires_at']),
createdAt: DateTime.fromMillisecondsSinceEpoch(map['created_at']),
);
}

bool get isValid => !isUsed && DateTime.now().isBefore(expiresAt);

OTP markAsUsed() {
return OTP(
id: id,
phone: phone,
code: code,
type: type,
isUsed: true,
expiresAt: expiresAt,
createdAt: createdAt,
);
}
}

##

// lib/src/data/models/product.dart
// Model representing a product in the POS system.
import 'dart:convert';
import 'dart:ui' as ui;
import 'package:flutter/material.dart';
import 'package:crypto/crypto.dart';

class Product {
final int? id;
final String productId;
final String name;
final String nameAm;
final String? description;
final double price;
final double? costPrice;
final int stockQuantity;
final int? minStockLevel;
final String barcode;
final String? sku;
final String categoryId;
final String? categoryName;
final String? unit;
final String? brand;
final String? supplier;
final double? weight;
final String? size;
final String? color;
final String? imagePath;
final bool trackInventory;
final bool isActive;
final DateTime createdAt;
final DateTime updatedAt;
late final String checksum; // For data integrity
final int version; // For optimistic locking

Product({
this.id,
required this.productId,
required this.name,
required this.nameAm,
this.description,
required double price,
this.costPrice,
required int stockQuantity,
int? minStockLevel,
required String barcode,
this.sku,
required this.categoryId,
this.categoryName,
this.unit,
this.brand,
this.supplier,
this.weight,
this.size,
this.color,
this.imagePath,
this.trackInventory = true,
this.isActive = true,
required this.createdAt,
required this.updatedAt,
this.checksum = '',
this.version = 1,
}) : price = \_validatePrice(price),
stockQuantity = \_validateStock(stockQuantity),
barcode = \_validateBarcode(barcode),
minStockLevel = \_validateMinStock(minStockLevel) {
// Generate checksum
checksum = \_generateChecksum();
}

// === VALIDATION METHODS ===
static double \_validatePrice(double price) {
if (price < 0) throw ArgumentError('Price cannot be negative: $price');
if (price > 10000000) {
throw ArgumentError('Price exceeds maximum allowed: $price');
}
return double.parse(price.toStringAsFixed(2)); // Round to 2 decimals
}

static int \_validateStock(int stock) {
if (stock < 0) throw ArgumentError('Stock cannot be negative: $stock');
if (stock > 1000000)
throw ArgumentError('Stock exceeds maximum allowed: $stock');
return stock;
}

static String \_validateBarcode(String barcode) {
if (barcode.isEmpty) throw ArgumentError('Barcode cannot be empty');
barcode = barcode.trim();

    // Validate common barcode formats
    final validFormats = [
      RegExp(r'^[0-9]{12,13}$'), // EAN-13, UPC-A
      RegExp(r'^[0-9]{8}$'), // EAN-8
      RegExp(r'^[0-9]{14}$'), // GTIN-14
    ];

    final isValid = validFormats.any((regex) => regex.hasMatch(barcode));
    if (!isValid) {
      throw ArgumentError('Invalid barcode format: $barcode');
    }

    return barcode;

}

static int? \_validateMinStock(int? minStock) {
if (minStock != null) {
if (minStock < 0)
throw ArgumentError('Minimum stock cannot be negative: $minStock');
if (minStock > 1000000)
throw ArgumentError('Minimum stock exceeds maximum: $minStock');
}
return minStock;
}

String \_generateChecksum() {
final data =
'$productId$name$nameAm$price$stockQuantity$barcode$categoryId';
final bytes = utf8.encode(data);
final digest = sha256.convert(bytes);
return digest.toString();
}

bool verifyChecksum() {
return checksum == \_generateChecksum();
}

// === BUSINESS METHODS ===
bool canSellQuantity(int quantity) {
if (!trackInventory) return true;
if (quantity <= 0) return false;
if (quantity > stockQuantity) return false;
if (!isActive) return false;
return true;
}

Product reduceStock(int quantity) {
if (!canSellQuantity(quantity)) {
throw StateError(
'Cannot sell $quantity of $name. Available: $stockQuantity');
}

    return copyWith(
      stockQuantity: stockQuantity - quantity,
      version: version + 1,
    );

}

Product increaseStock(int quantity) {
if (quantity <= 0)
throw ArgumentError('Quantity must be positive: $quantity');

    return copyWith(
      stockQuantity: stockQuantity + quantity,
      version: version + 1,
    );

}

double getPriceWithTax(double taxRate) {
return double.parse((price \* (1 + taxRate)).toStringAsFixed(2));
}

double getProfit() {
if (costPrice == null) return 0;
return double.parse((price - costPrice!).toStringAsFixed(2));
}

double getProfitPercentage() {
if (costPrice == null || costPrice == 0) return 0;
return double.parse(
(((price - costPrice!) / costPrice!) \* 100).toStringAsFixed(2));
}

// === COPY WITH METHOD (ENHANCED) ===
Product copyWith({
String? name,
String? nameAm,
String? description,
double? price,
double? costPrice,
int? stockQuantity,
int? minStockLevel,
String? barcode,
String? sku,
String? categoryId,
String? unit,
String? brand,
String? supplier,
double? weight,
String? size,
String? color,
String? imagePath,
bool? trackInventory,
bool? isActive,
int? version,
}) {
return Product(
id: id,
productId: productId,
name: name ?? this.name,
nameAm: nameAm ?? this.nameAm,
description: description ?? this.description,
price: price ?? this.price,
costPrice: costPrice ?? this.costPrice,
stockQuantity: stockQuantity ?? this.stockQuantity,
minStockLevel: minStockLevel ?? this.minStockLevel,
barcode: barcode ?? this.barcode,
sku: sku ?? this.sku,
categoryId: categoryId ?? this.categoryId,
unit: unit ?? this.unit,
brand: brand ?? this.brand,
supplier: supplier ?? this.supplier,
weight: weight ?? this.weight,
size: size ?? this.size,
color: color ?? this.color,
imagePath: imagePath ?? this.imagePath,
trackInventory: trackInventory ?? this.trackInventory,
isActive: isActive ?? this.isActive,
createdAt: createdAt,
updatedAt: DateTime.now(),
version: version ?? this.version + 1,
);
}

// === TO/FROM MAP ===
Map<String, dynamic> toMap() {
return {
'id': id,
'product_id': productId,
'name': name,
'name_am': nameAm,
'description': description,
'price': price,
'cost_price': costPrice,
'stock_quantity': stockQuantity,
'min_stock_level': minStockLevel,
'barcode': barcode,
'sku': sku,
'category_id': categoryId,
'unit': unit,
'brand': brand,
'supplier': supplier,
'weight': weight,
'size': size,
'color': color,
'image_path': imagePath,
'track_inventory': trackInventory ? 1 : 0,
'is_active': isActive ? 1 : 0,
'created_at': createdAt.millisecondsSinceEpoch,
'updated_at': updatedAt.millisecondsSinceEpoch,
'checksum': checksum,
'version': version,
};
}

factory Product.fromMap(Map<String, dynamic> map) {
return Product(
id: map['id'],
productId: map['product_id'],
name: map['name'],
nameAm: map['name_am'],
description: map['description'],
price: map['price'],
costPrice: map['cost_price'],
stockQuantity: map['stock_quantity'],
minStockLevel: map['min_stock_level'],
barcode: map['barcode'],
sku: map['sku'],
categoryId: map['category_id'],
unit: map['unit'],
brand: map['brand'],
supplier: map['supplier'],
weight: map['weight'],
size: map['size'],
color: map['color'],
imagePath: map['image_path'],
trackInventory: map['track_inventory'] == 1,
isActive: map['is_active'] == 1,
createdAt: DateTime.fromMillisecondsSinceEpoch(map['created_at']),
updatedAt: DateTime.fromMillisecondsSinceEpoch(map['updated_at']),
checksum: map['checksum'] ?? '',
version: map['version'] ?? 1,
);
}

// === HELPER PROPERTIES ===
String get formattedPrice => 'ETB ${price.toStringAsFixed(2)}';
String get formattedCostPrice =>
costPrice != null ? 'ETB ${costPrice!.toStringAsFixed(2)}' : 'N/A';

bool get isLowStock =>
trackInventory &&
minStockLevel != null &&
stockQuantity <= minStockLevel!;

bool get isOutOfStock => trackInventory && stockQuantity <= 0;

String get stockStatus {
if (!trackInventory) return 'Not Tracked';
if (isOutOfStock) return 'Out of Stock';
if (isLowStock) return 'Low Stock';
return 'In Stock';
}

Color get stockStatusColor {
if (!trackInventory) return Colors.grey;
if (isOutOfStock) return const Color(0xFFEF4444);
if (isLowStock) return const Color(0xFFF59E0B);
return const Color(0xFF10B981);
}

// === FACTORY METHODS ===
factory Product.create({
required String name,
required String nameAm,
required double price,
required int stockQuantity,
required String barcode,
required String categoryId,
String? description,
double? costPrice,
int? minStockLevel,
String? unit,
String? brand,
String? supplier,
}) {
return Product(
productId: 'PROD\_${DateTime.now().millisecondsSinceEpoch}',
name: name,
nameAm: nameAm,
description: description,
price: price,
costPrice: costPrice,
stockQuantity: stockQuantity,
minStockLevel: minStockLevel,
barcode: barcode,
categoryId: categoryId,
unit: unit,
brand: brand,
supplier: supplier,
createdAt: DateTime.now(),
updatedAt: DateTime.now(),
);
}

@override
String toString() {
return 'Product(id: $id, name: $name, price: $price, stock: $stockQuantity, barcode: $barcode)';
}

@override
bool operator ==(Object other) {
if (identical(this, other)) return true;
return other is Product &&
other.productId == productId &&
other.version == version;
}

@override
int get hashCode => productId.hashCode ^ version.hashCode;
}

##

// mobile/lib/src/data/models/registration.dart
// Models for business and user registration data.
import 'package:andalus_smart_pos/src/data/models/user.dart';

class BusinessRegistration {
final String businessName;
final String businessNameAm;
final String businessType;
final String phone;
final String? email; // Make email nullable
final String address;
final String city;
final String region;
final String tinNumber;
final String ownerName;
final String ownerPhone;
final String? ownerEmail; // Make ownerEmail nullable

BusinessRegistration({
required this.businessName,
required this.businessNameAm,
required this.businessType,
required this.phone,
this.email, // Now nullable
required this.address,
required this.city,
required this.region,
required this.tinNumber,
required this.ownerName,
required this.ownerPhone,
this.ownerEmail, // Now nullable
});

Map<String, dynamic> toMap() {
return {
'name': businessName,
'name_am': businessNameAm,
'business_type': businessType,
'phone': phone,
'email': email, // Can be null
'address': address,
'city': city,
'region': region,
'tin_number': tinNumber,
'owner_name': ownerName,
'owner_phone': ownerPhone,
'owner_email': ownerEmail, // Can be null
};
}
}

class UserRegistration {
final String name;
final String phone;
final String? email; // Make email nullable
final String password;
final UserRole role;

UserRegistration({
required this.name,
required this.phone,
this.email, // Now nullable
required this.password,
this.role = UserRole.owner,
});

Map<String, dynamic> toMap() {
return {
'name': name,
'phone': phone,
'email': email, // Can be null
'password': password,
'role': role.name,
};
}
}

##

// mobile/lib/src/data/models/sale_item.dart
// Model representing an item in a sale transaction.
class SaleItem {
final int? id;
final String saleId;
final String productId;
final String productName;
final String? productNameAm;
final int quantity;
final double unitPrice;
final double totalPrice;
final double? costPrice;
final double discount;
final String? barcode;
final String? unit;
final DateTime createdAt;
final bool isSynced;

SaleItem({
this.id,
required this.saleId,
required this.productId,
required this.productName,
this.productNameAm,
required this.quantity,
required this.unitPrice,
required this.totalPrice,
this.costPrice,
this.discount = 0,
this.barcode,
this.unit,
required this.createdAt,
this.isSynced = false,
}) : assert(quantity > 0, 'Quantity must be positive: $quantity'),
assert(unitPrice >= 0, 'Unit price cannot be negative: $unitPrice'),
assert(totalPrice >= 0, 'Total price cannot be negative: $totalPrice');

SaleItem copyWith({
int? id,
String? saleId,
String? productId,
String? productName,
String? productNameAm,
int? quantity,
double? unitPrice,
double? totalPrice,
double? costPrice,
double? discount,
String? barcode,
String? unit,
DateTime? createdAt,
bool? isSynced,
}) {
return SaleItem(
id: id ?? this.id,
saleId: saleId ?? this.saleId,
productId: productId ?? this.productId,
productName: productName ?? this.productName,
productNameAm: productNameAm ?? this.productNameAm,
quantity: quantity ?? this.quantity,
unitPrice: unitPrice ?? this.unitPrice,
totalPrice: totalPrice ?? this.totalPrice,
costPrice: costPrice ?? this.costPrice,
discount: discount ?? this.discount,
barcode: barcode ?? this.barcode,
unit: unit ?? this.unit,
createdAt: createdAt ?? this.createdAt,
isSynced: isSynced ?? this.isSynced,
);
}

factory SaleItem.create({
required String saleId,
required String productId,
required String productName,
String? productNameAm,
required int quantity,
required double unitPrice,
double? costPrice,
double discount = 0,
String? barcode,
String? unit,
}) {
final totalPrice = (unitPrice \* quantity) - discount;

    return SaleItem(
      saleId: saleId,
      productId: productId,
      productName: productName,
      productNameAm: productNameAm,
      quantity: quantity,
      unitPrice: unitPrice,
      totalPrice: totalPrice,
      costPrice: costPrice,
      discount: discount,
      barcode: barcode,
      unit: unit,
      createdAt: DateTime.now(),
    );

}

Map<String, dynamic> toMap() {
return {
'id': id,
'sale_id': saleId,
'product_id': productId,
'product_name': productName,
'product_name_am': productNameAm,
'quantity': quantity,
'unit_price': unitPrice,
'total_price': totalPrice,
'cost_price': costPrice,
'discount': discount,
'barcode': barcode,
'unit': unit,
'created_at': createdAt.millisecondsSinceEpoch,
'is_synced': isSynced ? 1 : 0,
};
}

factory SaleItem.fromMap(Map<String, dynamic> map) {
return SaleItem(
id: map['id'],
saleId: map['sale_id'],
productId: map['product_id'],
productName: map['product_name'],
productNameAm: map['product_name_am'],
quantity: map['quantity'],
unitPrice: map['unit_price'],
totalPrice: map['total_price'],
costPrice: map['cost_price'],
discount: map['discount'] ?? 0,
barcode: map['barcode'],
unit: map['unit'],
createdAt: DateTime.fromMillisecondsSinceEpoch(map['created_at']),
isSynced: map['is_synced'] == 1,
);
}

double get profit {
if (costPrice == null) return 0;
return totalPrice - (costPrice! \* quantity);
}

String get formattedUnitPrice => 'ETB ${unitPrice.toStringAsFixed(2)}';
String get formattedTotal => 'ETB ${totalPrice.toStringAsFixed(2)}';
}

##

// mobile/lib/src/data/models/sale.dart
import 'dart:convert';
import 'package:andalus_smart_pos/src/data/models/sale_item.dart';
import 'package:crypto/crypto.dart';

class Sale {
final int? id;
final String saleId;
final String localId;
final int? customerId;
final String? customerName;
final double totalAmount;
final double finalAmount;
final double taxAmount;
final double discountAmount;
final String paymentMethod;
final String paymentReference;
final String paymentStatus;
final String saleStatus;
final int userId;
final String? userName;
final int shopId;
final bool isSynced;
final int syncAttempts;
final DateTime createdAt;
final DateTime? updatedAt;
final DateTime? syncedAt;
late final String checksum;
final String? notes;
final bool isRefunded;
final String? refundReason;
final DateTime? refundedAt;

Sale({
this.id,
required this.saleId,
required this.localId,
this.customerId,
this.customerName,
required this.totalAmount,
required this.finalAmount,
this.taxAmount = 0,
this.discountAmount = 0,
required this.paymentMethod,
this.paymentReference = '',
this.paymentStatus = 'completed',
this.saleStatus = 'completed',
required this.userId,
this.userName,
required this.shopId,
this.isSynced = false,
this.syncAttempts = 0,
required this.createdAt,
this.updatedAt,
this.syncedAt,
this.checksum = '',
this.notes,
this.isRefunded = false,
this.refundReason,
this.refundedAt,
}) : assert(totalAmount >= 0, 'Total amount cannot be negative'),
assert(finalAmount >= 0, 'Final amount cannot be negative'),
assert(taxAmount >= 0, 'Tax amount cannot be negative'),
assert(discountAmount >= 0, 'Discount amount cannot be negative'),
assert(paymentMethod.isNotEmpty, 'Payment method required'),
assert(userId > 0, 'User ID must be positive'),
assert(shopId > 0, 'Shop ID must be positive') {
// Generate checksum if not provided
if (checksum.isEmpty) {
checksum = \_generateChecksum();
}
}

String \_generateChecksum() {
final data =
'$saleId$totalAmount$finalAmount$paymentMethod$userId$shopId${createdAt.millisecondsSinceEpoch}';
final bytes = utf8.encode(data);
final digest = sha256.convert(bytes);
return digest.toString();
}

bool verifyChecksum() {
return checksum == \_generateChecksum();
}

// === BUSINESS VALIDATION ===
bool isValid() {
return saleId.isNotEmpty &&
localId.isNotEmpty &&
totalAmount >= 0 &&
finalAmount >= 0 &&
paymentMethod.isNotEmpty &&
userId > 0 &&
shopId > 0 &&
verifyChecksum();
}

bool get isTotalValid {
// Allow small rounding differences (0.01)
final calculated = totalAmount + taxAmount - discountAmount;
return (finalAmount - calculated).abs() < 0.01;
}

bool get canBeRefunded {
return !isRefunded &&
saleStatus == 'completed' &&
paymentStatus == 'completed' &&
createdAt.isAfter(DateTime.now()
.subtract(const Duration(days: 30))); // 30-day refund window
}

// === FACTORY METHODS ===
factory Sale.createNew({
required List<SaleItem> items,
required int userId,
required String userName,
required int shopId,
String paymentMethod = 'cash',
String? paymentReference,
int? customerId,
String? customerName,
double taxRate = 0.15,
double discountAmount = 0,
String? notes,
}) {
// Calculate amounts
final subtotal = items.fold(0.0, (sum, item) => sum + item.totalPrice);
final taxAmount = subtotal \* taxRate;
final totalAmount = subtotal + taxAmount;
final finalAmount = totalAmount - discountAmount;

    // Validate amounts
    if (finalAmount < 0) {
      throw ArgumentError('Final amount cannot be negative after discount');
    }

    final now = DateTime.now();
    final saleId =
        'SALE_${now.year}${now.month.toString().padLeft(2, '0')}${now.day.toString().padLeft(2, '0')}_${now.millisecondsSinceEpoch}';

    return Sale(
      saleId: saleId,
      localId: 'LOCAL_${now.millisecondsSinceEpoch}',
      customerId: customerId,
      customerName: customerName,
      totalAmount: double.parse(totalAmount.toStringAsFixed(2)),
      finalAmount: double.parse(finalAmount.toStringAsFixed(2)),
      taxAmount: double.parse(taxAmount.toStringAsFixed(2)),
      discountAmount: double.parse(discountAmount.toStringAsFixed(2)),
      paymentMethod: paymentMethod,
      paymentReference: paymentReference ?? '',
      userId: userId,
      userName: userName,
      shopId: shopId,
      createdAt: now,
      updatedAt: now,
      notes: notes,
    );

}

Sale markAsSynced() {
return copyWith(
isSynced: true,
syncedAt: DateTime.now(),
);
}

Sale markAsRefunded(String reason) {
return copyWith(
isRefunded: true,
refundReason: reason,
refundedAt: DateTime.now(),
saleStatus: 'refunded',
);
}

// === COPY WITH ===
Sale copyWith({
int? id,
String? saleId,
String? localId,
int? customerId,
String? customerName,
double? totalAmount,
double? finalAmount,
double? taxAmount,
double? discountAmount,
String? paymentMethod,
String? paymentReference,
String? paymentStatus,
String? saleStatus,
int? userId,
String? userName,
int? shopId,
bool? isSynced,
int? syncAttempts,
DateTime? createdAt,
DateTime? updatedAt,
DateTime? syncedAt,
String? checksum,
String? notes,
bool? isRefunded,
String? refundReason,
DateTime? refundedAt,
}) {
return Sale(
id: id ?? this.id,
saleId: saleId ?? this.saleId,
localId: localId ?? this.localId,
customerId: customerId ?? this.customerId,
customerName: customerName ?? this.customerName,
totalAmount: totalAmount ?? this.totalAmount,
finalAmount: finalAmount ?? this.finalAmount,
taxAmount: taxAmount ?? this.taxAmount,
discountAmount: discountAmount ?? this.discountAmount,
paymentMethod: paymentMethod ?? this.paymentMethod,
paymentReference: paymentReference ?? this.paymentReference,
paymentStatus: paymentStatus ?? this.paymentStatus,
saleStatus: saleStatus ?? this.saleStatus,
userId: userId ?? this.userId,
userName: userName ?? this.userName,
shopId: shopId ?? this.shopId,
isSynced: isSynced ?? this.isSynced,
syncAttempts: syncAttempts ?? this.syncAttempts,
createdAt: createdAt ?? this.createdAt,
updatedAt: updatedAt ?? DateTime.now(),
syncedAt: syncedAt ?? this.syncedAt,
checksum: checksum ?? this.checksum,
notes: notes ?? this.notes,
isRefunded: isRefunded ?? this.isRefunded,
refundReason: refundReason ?? this.refundReason,
refundedAt: refundedAt ?? this.refundedAt,
);
}

// === TO/FROM MAP ===
Map<String, dynamic> toMap() {
return {
'id': id,
'sale_id': saleId,
'local_id': localId,
'customer_id': customerId,
'customer_name': customerName,
'total_amount': totalAmount,
'final_amount': finalAmount,
'tax_amount': taxAmount,
'discount_amount': discountAmount,
'payment_method': paymentMethod,
'payment_reference': paymentReference,
'payment_status': paymentStatus,
'sale_status': saleStatus,
'user_id': userId,
'user_name': userName,
'shop_id': shopId,
'is_synced': isSynced ? 1 : 0,
'sync_attempts': syncAttempts,
'created_at': createdAt.millisecondsSinceEpoch,
'updated_at': updatedAt?.millisecondsSinceEpoch,
'synced_at': syncedAt?.millisecondsSinceEpoch,
'checksum': checksum,
'notes': notes,
'is_refunded': isRefunded ? 1 : 0,
'refund_reason': refundReason,
'refunded_at': refundedAt?.millisecondsSinceEpoch,
};
}

factory Sale.fromMap(Map<String, dynamic> map) {
return Sale(
id: map['id'],
saleId: map['sale_id'],
localId: map['local_id'] ?? '',
customerId: map['customer_id'],
customerName: map['customer_name'],
totalAmount: map['total_amount'],
finalAmount: map['final_amount'] ?? map['total_amount'],
taxAmount: map['tax_amount'] ?? 0,
discountAmount: map['discount_amount'] ?? 0,
paymentMethod: map['payment_method'],
paymentReference: map['payment_reference'] ?? '',
paymentStatus: map['payment_status'] ?? 'completed',
saleStatus: map['sale_status'] ?? 'completed',
userId: map['user_id'],
userName: map['user_name'],
shopId: map['shop_id'],
isSynced: map['is_synced'] == 1,
syncAttempts: map['sync_attempts'] ?? 0,
createdAt: DateTime.fromMillisecondsSinceEpoch(map['created_at']),
updatedAt: map['updated_at'] != null
? DateTime.fromMillisecondsSinceEpoch(map['updated_at'])
: null,
syncedAt: map['synced_at'] != null
? DateTime.fromMillisecondsSinceEpoch(map['synced_at'])
: null,
checksum: map['checksum'] ?? '',
notes: map['notes'],
isRefunded: map['is_refunded'] == 1,
refundReason: map['refund_reason'],
refundedAt: map['refunded_at'] != null
? DateTime.fromMillisecondsSinceEpoch(map['refunded_at'])
: null,
);
}

// === HELPER METHODS ===
String get formattedTotal => 'ETB ${finalAmount.toStringAsFixed(2)}';
  String get formattedDate =>
      '${createdAt.day}/${createdAt.month}/${createdAt.year}';
String get formattedTime =>
'${createdAt.hour.toString().padLeft(2, '0')}:${createdAt.minute.toString().padLeft(2, '0')}';
String get formattedDateTime => '$formattedDate $formattedTime';

double get subtotal => totalAmount - taxAmount + discountAmount;

@override
String toString() {
return 'Sale(id: $id, saleId: $saleId, total: $formattedTotal, status: $saleStatus)';
}

@override
bool operator ==(Object other) {
if (identical(this, other)) return true;
return other is Sale && other.saleId == saleId;
}

@override
int get hashCode => saleId.hashCode;
}

##

// mobile/lib/src/data/models/settings.dart
// Model representing application settings for the POS system. includes new settings for credit system and stock notifications.
//dark mode language selection currency selection calander format etc can be selected from
class AppSettings {
final String shopName;
final String shopNameAm;
final String address;
final String phone;
final String tinNumber;
final String currency;
final bool enableTax;
final double taxRate;
final bool enableDiscounts;
final bool autoPrintReceipts;
final String defaultPaymentMethod;
final bool enableSync;
final int syncInterval;

// New fields for enhanced settings
final bool enableCreditSystem;
final double defaultCreditLimit;
final String defaultPaymentTerms;
final bool enableCustomerSelection;
final bool lowStockNotifications;
final int lowStockThreshold;

AppSettings({
required this.shopName,
required this.shopNameAm,
required this.address,
required this.phone,
required this.tinNumber,
required this.currency,
required this.enableTax,
required this.taxRate,
required this.enableDiscounts,
required this.autoPrintReceipts,
required this.defaultPaymentMethod,
required this.enableSync,
required this.syncInterval,

    // New fields with default values
    this.enableCreditSystem = true,
    this.defaultCreditLimit = 1000.0,
    this.defaultPaymentTerms = '30',
    this.enableCustomerSelection = true,
    this.lowStockNotifications = true,
    this.lowStockThreshold = 10,

});

Map<String, dynamic> toMap() {
return {
'shopName': shopName,
'shopNameAm': shopNameAm,
'address': address,
'phone': phone,
'tinNumber': tinNumber,
'currency': currency,
'enableTax': enableTax,
'taxRate': taxRate,
'enableDiscounts': enableDiscounts,
'autoPrintReceipts': autoPrintReceipts,
'defaultPaymentMethod': defaultPaymentMethod,
'enableSync': enableSync,
'syncInterval': syncInterval,
'enableCreditSystem': enableCreditSystem,
'defaultCreditLimit': defaultCreditLimit,
'defaultPaymentTerms': defaultPaymentTerms,
'enableCustomerSelection': enableCustomerSelection,
'lowStockNotifications': lowStockNotifications,
'lowStockThreshold': lowStockThreshold,
};
}

factory AppSettings.fromMap(Map<String, dynamic> map) {
return AppSettings(
shopName: map['shopName'] ?? 'Andalus Smart POS',
shopNameAm: map['shopNameAm'] ?? '·ä†·äï·ã≥·àâ·àµ ·àõ·à≠·â≤·äï ·çñ·àµ',
address: map['address'] ?? 'Addis Ababa, Ethiopia',
phone: map['phone'] ?? '+251 911 234 567',
tinNumber: map['tinNumber'] ?? 'TIN-123456789',
currency: map['currency'] ?? 'ETB',
enableTax: map['enableTax'] ?? false,
taxRate: map['taxRate'] ?? 0.15,
enableDiscounts: map['enableDiscounts'] ?? true,
autoPrintReceipts: map['autoPrintReceipts'] ?? false,
defaultPaymentMethod: map['defaultPaymentMethod'] ?? 'cash',
enableSync: map['enableSync'] ?? true,
syncInterval: map['syncInterval'] ?? 5,
enableCreditSystem: map['enableCreditSystem'] ?? true,
defaultCreditLimit: map['defaultCreditLimit'] ?? 1000.0,
defaultPaymentTerms: map['defaultPaymentTerms'] ?? '30',
enableCustomerSelection: map['enableCustomerSelection'] ?? true,
lowStockNotifications: map['lowStockNotifications'] ?? true,
lowStockThreshold: map['lowStockThreshold'] ?? 10,
);
}

AppSettings copyWith({
String? shopName,
String? shopNameAm,
String? address,
String? phone,
String? tinNumber,
String? currency,
bool? enableTax,
double? taxRate,
bool? enableDiscounts,
bool? autoPrintReceipts,
String? defaultPaymentMethod,
bool? enableSync,
int? syncInterval,
bool? enableCreditSystem,
double? defaultCreditLimit,
String? defaultPaymentTerms,
bool? enableCustomerSelection,
bool? lowStockNotifications,
int? lowStockThreshold,
}) {
return AppSettings(
shopName: shopName ?? this.shopName,
shopNameAm: shopNameAm ?? this.shopNameAm,
address: address ?? this.address,
phone: phone ?? this.phone,
tinNumber: tinNumber ?? this.tinNumber,
currency: currency ?? this.currency,
enableTax: enableTax ?? this.enableTax,
taxRate: taxRate ?? this.taxRate,
enableDiscounts: enableDiscounts ?? this.enableDiscounts,
autoPrintReceipts: autoPrintReceipts ?? this.autoPrintReceipts,
defaultPaymentMethod: defaultPaymentMethod ?? this.defaultPaymentMethod,
enableSync: enableSync ?? this.enableSync,
syncInterval: syncInterval ?? this.syncInterval,
enableCreditSystem: enableCreditSystem ?? this.enableCreditSystem,
defaultCreditLimit: defaultCreditLimit ?? this.defaultCreditLimit,
defaultPaymentTerms: defaultPaymentTerms ?? this.defaultPaymentTerms,
enableCustomerSelection:
enableCustomerSelection ?? this.enableCustomerSelection,
lowStockNotifications:
lowStockNotifications ?? this.lowStockNotifications,
lowStockThreshold: lowStockThreshold ?? this.lowStockThreshold,
);
}
}

##

// mobile/lib/src/data/models/shop_registration.dart
// Model representing shop registration data. and owner registration data.
class ShopRegistration {
final String shopName;
final String shopCategory;
final String phoneNumber;
final String city;
final String country;
final String businessAddress;
final String? shopLogo;

const ShopRegistration({
required this.shopName,
required this.shopCategory,
required this.phoneNumber,
required this.city,
required this.country,
required this.businessAddress,
this.shopLogo,
});

Map<String, dynamic> toMap() {
return {
'shop_name': shopName,
'shop_category': shopCategory,
'phone_number': phoneNumber,
'city': city,
'country': country,
'business_address': businessAddress,
'shop_logo': shopLogo,
};
}
}

class OwnerRegistration {
final String fullName;
final String phone;
final String password;
final String? email;

const OwnerRegistration({
required this.fullName,
required this.phone,
required this.password,
this.email,
});

Map<String, dynamic> toMap() {
return {
'full_name': fullName,
'phone': phone,
'password': password,
'email': email,
};
}
}

##

// mobile/lib/src/data/models/subscription.dart
// Model representing a subscription in the POS system.
class Subscription {
final String id;
final String businessId;
final String userId;
final SubscriptionPlan plan;
final BillingCycle billingCycle;
final SubscriptionStatus status;
final DateTime startDate;
final DateTime endDate;
final double amount;
final String currency;
final bool isActive;
final String? paymentReference;
final DateTime createdAt;
final DateTime updatedAt;

Subscription({
required this.id,
required this.businessId,
required this.userId,
required this.plan,
required this.billingCycle,
required this.status,
required this.startDate,
required this.endDate,
required this.amount,
this.currency = 'ETB',
this.isActive = true,
this.paymentReference,
required this.createdAt,
required this.updatedAt,
});

Map<String, dynamic> toMap() {
return {
'subscription_id': id,
'business_id': businessId,
'user_id': userId,
'plan': plan.id, // Use plan.id instead of plan.name
'billing_cycle': billingCycle.name,
'status': status.name,
'amount': amount,
'start_date': startDate.millisecondsSinceEpoch,
'end_date': endDate.millisecondsSinceEpoch,
'is_active': isActive ? 1 : 0,
'currency': currency,
'payment_reference': paymentReference,
'created_at': createdAt.millisecondsSinceEpoch,
'updated_at': updatedAt.millisecondsSinceEpoch,
};
}

factory Subscription.fromMap(Map<String, dynamic> map) {
return Subscription(
id: map['subscription_id'],
businessId: map['business_id'],
userId: map['user_id'],
plan: SubscriptionPlan.getById(map['plan']), // Use getById method
billingCycle:
BillingCycle.values.firstWhere((e) => e.name == map['billing_cycle']),
status:
SubscriptionStatus.values.firstWhere((e) => e.name == map['status']),
startDate: DateTime.fromMillisecondsSinceEpoch(map['start_date']),
endDate: DateTime.fromMillisecondsSinceEpoch(map['end_date']),
amount: map['amount'],
currency: map['currency'] ?? 'ETB',
isActive: map['is_active'] == 1,
paymentReference: map['payment_reference'],
createdAt: DateTime.fromMillisecondsSinceEpoch(map['created_at']),
updatedAt: DateTime.fromMillisecondsSinceEpoch(map['updated_at']),
);
}

bool get isExpired => endDate.isBefore(DateTime.now());
bool get isValid =>
isActive && !isExpired && status == SubscriptionStatus.active;

int get daysRemaining => endDate.difference(DateTime.now()).inDays;

String get statusDisplay {
if (!isActive) return 'Inactive';
if (isExpired) return 'Expired';
if (status == SubscriptionStatus.pastDue) return 'Past Due';
if (status == SubscriptionStatus.canceled) return 'Canceled';
return 'Active';
}

get expiryDate => endDate;

Subscription renew({String? paymentReference}) {
final now = DateTime.now();
DateTime newEndDate;

    if (billingCycle == BillingCycle.monthly) {
      newEndDate = now.add(const Duration(days: 30));
    } else {
      newEndDate = now.add(const Duration(days: 365));
    }

    return Subscription(
      id: 'sub_${now.millisecondsSinceEpoch}',
      businessId: businessId,
      userId: userId,
      plan: plan,
      billingCycle: billingCycle,
      status: SubscriptionStatus.active,
      startDate: now,
      endDate: newEndDate,
      amount: amount,
      currency: currency,
      isActive: true,
      paymentReference: paymentReference,
      createdAt: createdAt,
      updatedAt: now,
    );

}

// Add to your existing subscription model

// Update Subscription class
}

// Make sure your SubscriptionPlan class has premium defined:
class SubscriptionPlan {
final String id;
final String name;
final String description;
final double monthlyPrice;
final double yearlyPrice;
final List<String> features;

const SubscriptionPlan({
required this.id,
required this.name,
required this.description,
required this.monthlyPrice,
required this.yearlyPrice,
required this.features,
});

// Add these static instances
static const SubscriptionPlan basic = SubscriptionPlan(
id: 'basic',
name: 'Basic',
description: 'Perfect for small businesses',
monthlyPrice: 299,
yearlyPrice: 2990,
features: [
'Up to 100 products',
'Basic sales reports',
'Customer management',
'Receipt printing',
],
);

static const SubscriptionPlan professional = SubscriptionPlan(
id: 'professional',
name: 'Professional',
description: 'Ideal for growing businesses',
monthlyPrice: 599,
yearlyPrice: 5990,
features: [
'Up to 1000 products',
'Advanced analytics',
'Inventory management',
'Multi-user support',
'Customer credit system',
],
);

static const SubscriptionPlan premium = SubscriptionPlan(
// ADD THIS
id: 'premium',
name: 'Premium',
description: 'For large enterprises',
monthlyPrice: 999,
yearlyPrice: 9990,
features: [
'Unlimited products',
'Advanced reporting',
'Priority support',
'Custom integrations',
'Multi-branch support',
'API access',
],
);

// Add this method to get all plans
static List<SubscriptionPlan> get all => [basic, professional, premium];

// Helper method to get plan by ID
static SubscriptionPlan getById(String id) {
return all.firstWhere((plan) => plan.id == id, orElse: () => basic);
}

double getPrice(BillingCycle cycle) {
return cycle == BillingCycle.monthly ? monthlyPrice : yearlyPrice;
}

String getFormattedPrice(BillingCycle cycle) {
final price = getPrice(cycle);
return 'ETB ${price.toStringAsFixed(0)}/${cycle == BillingCycle.monthly ? 'month' : 'year'}';
}

String get savingsInfo {
final yearlySavings = (monthlyPrice \* 12) - yearlyPrice;
return 'Save ETB ${yearlySavings.toStringAsFixed(0)} per year';
}
}

enum BillingCycle {
monthly('Monthly'),
yearly('Yearly');

final String displayName;

const BillingCycle(this.displayName);
}

// enum SubscriptionStatus {
// pending,
// active,
// expired,
// canceled,
// }

enum SubscriptionStatus {
active('Active'),
inactive('Inactive'),
canceled('Canceled'),
pastDue('Past Due'),
pending('Pending');

final String displayName;

const SubscriptionStatus(this.displayName);
}

class PaymentResult {
final bool success;
final String? paymentReference;
final String? error;
final String? transactionId;

const PaymentResult({
required this.success,
this.paymentReference,
this.error,
this.transactionId,
});

factory PaymentResult.success(
{String? paymentReference, String? transactionId}) {
return PaymentResult(
success: true,
paymentReference: paymentReference,
transactionId: transactionId,
);
}

factory PaymentResult.failure(String error) {
return PaymentResult(success: false, error: error);
}
}

##

// mobile/lib/src/data/models/user.dart
// Model representing a user in the POS system. example roles: owner manager cashier
class User {
final String id;
final String? email;
final String name;
final String phone;
final UserRole role;
final DateTime createdAt;
final DateTime? lastLogin;
final bool isActive;
final bool isVerified;
final String? businessId;
final String? passwordHash;

User({
required this.id,
required this.email,
required this.name,
required this.phone,
required this.role,
required this.createdAt,
this.lastLogin,
this.isActive = true,
this.isVerified = false,
this.businessId,
this.passwordHash,
});

Map<String, dynamic> toMap() {
return {
'user_id': id,
'email': email,
'name': name,
'phone': phone,
'role': role.name,
'created_at': createdAt.millisecondsSinceEpoch,
'last_login_at': lastLogin?.millisecondsSinceEpoch,
'is_active': isActive ? 1 : 0,
'is_verified': isVerified ? 1 : 0,
'business_id': businessId,
'password_hash': passwordHash, // Add this line
'updated_at': DateTime.now().millisecondsSinceEpoch,
};
}

factory User.fromMap(Map<String, dynamic> map) {
return User(
id: map['user_id'],
email: map['email'],
name: map['name'],
phone: map['phone'],
role: UserRole.values.firstWhere((e) => e.name == map['role']),
createdAt: DateTime.fromMillisecondsSinceEpoch(map['created_at']),
lastLogin: map['last_login_at'] != null
? DateTime.fromMillisecondsSinceEpoch(map['last_login_at'])
: null,
isActive: map['is_active'] == 1,
isVerified: map['is_verified'] == 1,
businessId: map['business_id'],
passwordHash: map['password_hash'], // This should be here
);
}

User copyWith({
String? name,
String? phone,
String? email,
UserRole? role,
bool? isActive,
bool? isVerified,
DateTime? lastLogin,
String? passwordHash, // Add this parameter
}) {
return User(
id: id,
name: name ?? this.name,
phone: phone ?? this.phone,
email: email ?? this.email,
role: role ?? this.role,
createdAt: createdAt,
lastLogin: lastLogin ?? this.lastLogin,
isActive: isActive ?? this.isActive,
isVerified: isVerified ?? this.isVerified,
businessId: businessId,
passwordHash: passwordHash ?? this.passwordHash, // Include passwordHash
);
}

bool get isOwner => role == UserRole.owner;
bool get isManager => role == UserRole.manager;
bool get isCashier => role == UserRole.cashier;
bool get isAdmin => isOwner || isManager;

bool hasPermission(Permission permission) {
return role.permissions.contains(permission);
}

// Check if user can access specific features
bool canManageUsers() => hasPermission(Permission.manageUsers);
bool canManageProducts() => hasPermission(Permission.manageProducts);
bool canManageCustomers() => hasPermission(Permission.manageCustomers);
bool canViewReports() => hasPermission(Permission.viewReports);
bool canProcessSales() => hasPermission(Permission.processSales);
}

enum UserRole {
owner(
'Owner',
[
Permission.manageUsers,
Permission.manageProducts,
Permission.manageCustomers,
Permission.viewReports,
Permission.processSales,
Permission.manageSettings,
Permission.viewDashboard,
],
),
manager(
'Manager',
[
Permission.manageProducts,
Permission.manageCustomers,
Permission.viewReports,
Permission.processSales,
Permission.viewDashboard,
],
),
cashier(
'Cashier',
[
Permission.processSales,
Permission.viewDashboard,
],
);

final String displayName;
final List<Permission> permissions;

const UserRole(this.displayName, this.permissions);

static UserRole fromString(String role) {
return UserRole.values.firstWhere(
(e) => e.name == role.toLowerCase(),
orElse: () => UserRole.cashier,
);
}
}

enum Permission {
manageUsers('Manage Users'),
manageProducts('Manage Products'),
manageCustomers('Manage Customers'),
viewReports('View Reports'),
processSales('Process Sales'),
manageSettings('Manage Settings'),
viewDashboard('View Dashboard');

final String displayName;

const Permission(this.displayName);
}

##

//mobile/lib/src/data/remote/api_client.dart
// API client for interacting with the backend server. laravel backend.
import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:retrofit/retrofit.dart';
import 'package:andalus_smart_pos/src/data/models/product.dart';
import 'package:andalus_smart_pos/src/data/models/sale.dart';
import 'package:andalus_smart_pos/src/data/models/sale_item.dart';

final apiClientProvider = Provider<ApiClient>((ref) {
return ApiClient(ref);
});

@RestApi(baseUrl: 'https://your-backend.com/api')
abstract class ApiClient {
factory ApiClient(Ref ref) {
final dio = Dio();

    // Add interceptors
    dio.interceptors.add(
      ApiInterceptors(
        secureStorage: ref.read(secureStorageProvider),
      ),
    );

    return _ApiClient(dio);

}

// Auth endpoints
@POST('/auth/login')
Future<LoginResponse> login(@Body() LoginRequest request);

@POST('/auth/refresh')
Future<RefreshResponse> refreshToken(@Body() RefreshRequest request);

// Sync endpoints
@POST('/sync/upload')
Future<SyncResponse> uploadSyncData(@Body() Map<String, dynamic> data);

@POST('/sync/download')
Future<SyncResponse> downloadUpdates(@Body() DownloadRequest request);

// Payment endpoints
@POST('/payments/initiate')
Future<PaymentInitiationResponse> initiatePayment(
@Body() PaymentRequest request);

@GET('/payments/{paymentId}/status')
Future<PaymentStatusResponse> getPaymentStatus(
@Path('paymentId') String paymentId);
}

class ApiInterceptors extends Interceptor {
final FlutterSecureStorage secureStorage;

ApiInterceptors({required this.secureStorage});

@override
Future<void> onRequest(
RequestOptions options,
RequestInterceptorHandler handler,
) async {
// Add auth token to headers
final token = await secureStorage.read(key: 'access_token');
if (token != null) {
options.headers['Authorization'] = 'Bearer $token';
}

    options.headers['Content-Type'] = 'application/json';
    options.headers['Accept'] = 'application/json';

    handler.next(options);

}

@override
Future<void> onError(
DioException err,
ErrorInterceptorHandler handler,
) async {
// Handle token refresh on 401 errors
if (err.response?.statusCode == 401) {
// TODO: Implement token refresh logic
}

    handler.next(err);

}
}

// Request/Response DTOs
class LoginRequest {
final String email;
final String password;
final String? deviceId;

LoginRequest({
required this.email,
required this.password,
this.deviceId,
});

Map<String, dynamic> toJson() => {
'email': email,
'password': password,
'device_id': deviceId,
};
}

class LoginResponse {
final String accessToken;
final String refreshToken;
final User user;

LoginResponse({
required this.accessToken,
required this.refreshToken,
required this.user,
});

factory LoginResponse.fromJson(Map<String, dynamic> json) => LoginResponse(
accessToken: json['access_token'],
refreshToken: json['refresh_token'],
user: User.fromJson(json['user']),
);
}

class RefreshRequest {
final String refreshToken;

RefreshRequest({required this.refreshToken});

Map<String, dynamic> toJson() => {
'refresh_token': refreshToken,
};
}

class RefreshResponse {
final String accessToken;

RefreshResponse({required this.accessToken});

factory RefreshResponse.fromJson(Map<String, dynamic> json) =>
RefreshResponse(
accessToken: json['access_token'],
);
}

class DownloadRequest {
final int shopId;
final int since;

DownloadRequest({required this.shopId, required this.since});

Map<String, dynamic> toJson() => {
'shop_id': shopId,
'since': since,
};
}

class SyncResponse {
final bool success;
final String message;
final Map<String, dynamic>? data;

SyncResponse({
required this.success,
required this.message,
this.data,
});

factory SyncResponse.fromJson(Map<String, dynamic> json) => SyncResponse(
success: json['success'],
message: json['message'],
data: json['data'],
);
}

class PaymentRequest {
final String saleId;
final double amount;
final String currency;

PaymentRequest({
required this.saleId,
required this.amount,
this.currency = 'ETB',
});

Map<String, dynamic> toJson() => {
'sale_id': saleId,
'amount': amount,
'currency': currency,
};
}

class PaymentInitiationResponse {
final String paymentId;
final String? telebirrQr;
final String? deepLink;
final String status;

PaymentInitiationResponse({
required this.paymentId,
this.telebirrQr,
this.deepLink,
required this.status,
});

factory PaymentInitiationResponse.fromJson(Map<String, dynamic> json) =>
PaymentInitiationResponse(
paymentId: json['payment_id'],
telebirrQr: json['telebirr_qr'],
deepLink: json['deep_link'],
status: json['status'],
);
}

class PaymentStatusResponse {
final String paymentId;
final String status;
final String? providerReference;

PaymentStatusResponse({
required this.paymentId,
required this.status,
this.providerReference,
});

factory PaymentStatusResponse.fromJson(Map<String, dynamic> json) =>
PaymentStatusResponse(
paymentId: json['payment_id'],
status: json['status'],
providerReference: json['provider_reference'],
);
}

// User model for auth
class User {
final int id;
final String name;
final String email;
final String role;
final int shopId;

User({
required this.id,
required this.name,
required this.email,
required this.role,
required this.shopId,
});

factory User.fromJson(Map<String, dynamic> json) => User(
id: json['id'],
name: json['name'],
email: json['email'],
role: json['role'],
shopId: json['shop_id'],
);
}

// Secure Storage Provider
final secureStorageProvider = Provider<FlutterSecureStorage>((ref) {
return const FlutterSecureStorage();
});

##

// mobile/lib/src/data/repositories/auth_repository.dart
// Repository for handling authentication-related operations.
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../models/user.dart';

final authRepositoryProvider = Provider<AuthRepository>((ref) {
return AuthRepository();
});

class AuthRepository {
static const String \_userKey = 'current_user';
static const String \_tokenKey = 'auth_token';

Future<User?> getCurrentUser() async {
final prefs = await SharedPreferences.getInstance();
final userJson = prefs.getString(\_userKey);

    if (userJson != null) {
      // Parse user from JSON (simplified)
      try {
        // In real app, you'd parse proper JSON
        return User(
          id: '1',
          email: 'demo@andalus.com',
          name: 'Demo User',
          role: UserRole.owner,
          createdAt: DateTime.now(),
          isActive: true,
          businessId: 'business_1',
          phone: '',
        );
      } catch (e) {
        return null;
      }
    }
    return null;

}

Future<String?> getAuthToken() async {
final prefs = await SharedPreferences.getInstance();
return prefs.getString(\_tokenKey);
}

Future<User> login(String email, String password) async {
// Simulate API call
await Future.delayed(const Duration(seconds: 2));

    if (email == 'demo@andalus.com' && password == 'password') {
      final user = User(
        id: '1',
        email: email,
        name: 'Demo User',
        role: UserRole.owner,
        createdAt: DateTime.now(),
        lastLogin: DateTime.now(),
        isActive: true,
        businessId: 'business_1',
        phone: '',
      );

      await _saveUser(user);
      return user;
    } else {
      throw Exception('Invalid credentials');
    }

}

Future<User> register(
String email, String password, String name, String businessName) async {
// Simulate API call
await Future.delayed(const Duration(seconds: 2));

    final user = User(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      email: email,
      name: name,
      role: UserRole.owner,
      createdAt: DateTime.now(),
      isActive: true,
      businessId: 'business_${DateTime.now().millisecondsSinceEpoch}',
      phone: '',
    );

    await _saveUser(user);
    return user;

}

Future<void> logout() async {
final prefs = await SharedPreferences.getInstance();
await prefs.remove(\_userKey);
await prefs.remove(\_tokenKey);
}

Future<User> updateProfile(User user) async {
await \_saveUser(user);
return user;
}

Future<void> _saveUser(User user) async {
final prefs = await SharedPreferences.getInstance();
// In real app, you'd serialize to JSON
await prefs.setString(\_userKey, 'user_data');
await prefs.setString(\_tokenKey, 'demo_token_${user.id}');
}
}

##

//mobile/lib/src/data/repositories/business_repository.dart
// Repository for managing business profile data in the local database. we aill make it managable business information like shop name address contact details logo etc. in the laravel backend.
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:sqflite/sqflite.dart';
import '../local/database.dart';
import '../models/business.dart';

final businessRepositoryProvider = Provider<BusinessRepository>((ref) {
return BusinessRepository();
});

class BusinessRepository {
static const String businessTable = 'business_profile';

Future<Database> get \_db async => await AppDatabase.database;

Future<void> saveBusinessProfile(BusinessProfile business) async {
final db = await \_db;
await db.insert(
businessTable,
business.toMap(),
conflictAlgorithm: ConflictAlgorithm.replace,
);
}

Future<BusinessProfile?> getBusinessProfile() async {
final db = await \_db;
final maps = await db.query(businessTable, limit: 1);
if (maps.isNotEmpty) {
return BusinessProfile.fromMap(maps.first);
}
return null;
}

Future<void> updateBusinessProfile(BusinessProfile business) async {
final db = await \_db;
await db.update(
businessTable,
business.toMap(),
where: 'id = ?',
whereArgs: [business.id],
);
}

Future<bool> hasBusinessProfile() async {
final db = await \_db;
final count = Sqflite.firstIntValue(
await db.rawQuery('SELECT COUNT(\*) FROM $businessTable'));
return count != null && count > 0;
}
}

##

// mobile/lib/src/data/repositories/category_repository.dart
// Repository for managing product categories in the local database.
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:sqflite/sqflite.dart';
import '../local/database.dart';
import '../models/category.dart';

final categoryRepositoryProvider = Provider<CategoryRepository>((ref) {
return CategoryRepository();
});

class CategoryRepository {
static const String categoryTable = 'product_categories';

Future<Database> get \_db async => await AppDatabase.database;

Future<int> createCategory(ProductCategory category) async {
final db = await \_db;
return await db.insert(
categoryTable,
category.toMap(),
conflictAlgorithm: ConflictAlgorithm.replace,
);
}

Future<void> updateCategory(ProductCategory category) async {
final db = await \_db;
await db.update(
categoryTable,
category.toMap(),
where: 'id = ?',
whereArgs: [category.id],
);
}

Future<List<ProductCategory>> getAllCategories(
{bool activeOnly = true}) async {
final db = await \_db;
final where = activeOnly ? 'WHERE is_active = 1' : '';
final maps = await db.rawQuery('''
SELECT \* FROM $categoryTable $where ORDER BY sort_order, name
''');
return maps.map((map) => ProductCategory.fromMap(map)).toList();
}

Future<ProductCategory?> getCategoryById(int id) async {
final db = await \_db;
final maps = await db.query(
categoryTable,
where: 'id = ?',
whereArgs: [id],
);
if (maps.isNotEmpty) {
return ProductCategory.fromMap(maps.first);
}
return null;
}

Future<void> deleteCategory(int id) async {
final db = await \_db;
await db.delete(
categoryTable,
where: 'id = ?',
whereArgs: [id],
);
}
}

##

// mobile/lib/src/data/repositories/customer_repository.dart
// Repository for managing customer data and credit operations in the local database.
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:sqflite/sqflite.dart';
import '../local/database.dart';
import '../models/customer.dart';
import '../models/credit_transaction.dart';

final customerRepositoryProvider = Provider<CustomerRepository>((ref) {
return CustomerRepository();
});

class CustomerRepository {
static const String customerTable = 'customers';
static const String creditTransactionTable = 'credit_transactions';

Future<Database> get \_db async => await AppDatabase.database;

// Credit Control Methods

Future<CreditSaleResult> createCreditSale({
required int customerId,
required double amount,
required String saleReference,
int dueDays = 30,
String? notes,
}) async {
final db = await \_db;

    return await db.transaction((txn) async {
      // Get customer with lock to prevent race conditions
      final customerMaps = await txn.query(
        customerTable,
        where: 'id = ?',
        whereArgs: [customerId],
      );

      if (customerMaps.isEmpty) {
        return CreditSaleResult(
          success: false,
          error: 'Customer not found',
        );
      }

      final customer = Customer.fromMap(customerMaps.first);

      // Check if customer allows credit
      if (!customer.allowCredit) {
        return CreditSaleResult(
          success: false,
          error: 'Customer does not allow credit purchases',
        );
      }

      // Check credit limit
      if (customer.currentBalance + amount > customer.creditLimit) {
        return CreditSaleResult(
          success: false,
          error:
              'Credit limit exceeded. Available: ETB ${customer.availableCredit.toStringAsFixed(2)}',
        );
      }

      // Calculate due date based on customer's payment terms or default
      final dueDate = _calculateDueDate(customer, dueDays);

      // Update customer balance and due date
      final newBalance = customer.currentBalance + amount;
      await txn.update(
        customerTable,
        {
          'current_balance': newBalance,
          'due_date': dueDate?.millisecondsSinceEpoch,
          'last_transaction_date': DateTime.now().millisecondsSinceEpoch,
          'updated_at': DateTime.now().millisecondsSinceEpoch,
        },
        where: 'id = ?',
        whereArgs: [customerId],
      );

      // Create credit transaction
      final transaction = CreditTransaction(
        localId: 'sale_${DateTime.now().millisecondsSinceEpoch}',
        customerId: customerId,
        customerName: customer.name,
        type: 'sale',
        amount: amount,
        balanceBefore: customer.currentBalance,
        balanceAfter: newBalance,
        reference: saleReference,
        notes: notes,
        createdAt: DateTime.now(),
      );

      await txn.insert(
        creditTransactionTable,
        transaction.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );

      return CreditSaleResult(
        success: true,
        newBalance: newBalance,
        availableCredit: customer.creditLimit - newBalance,
      );
    });

}

// Helper method to calculate due date based on payment terms
DateTime? \_calculateDueDate(Customer customer, int defaultDueDays) {
if (customer.paymentTerms == 'none' || !customer.allowCredit) {
return null;
}

    int dueDays = defaultDueDays;

    if (customer.paymentTerms != null && customer.paymentTerms != 'custom') {
      dueDays = int.tryParse(customer.paymentTerms!) ?? defaultDueDays;
    }

    return DateTime.now().add(Duration(days: dueDays));

}

// Add method to get customers with enhanced search
Future<List<Customer>> searchCustomers(String query) async {
final db = await \_db;
final maps = await db.query(
customerTable,
where: '''
(name LIKE ? OR
business_name LIKE ? OR
phone LIKE ? OR
whatsapp_number LIKE ? OR
email LIKE ? OR
tin_number LIKE ?)
AND is_active = 1
''',
whereArgs: [
'%$query%',
'%$query%',
'%$query%',
'%$query%',
'%$query%',
'%$query%'
],
orderBy: 'name',
);
return maps.map((map) => Customer.fromMap(map)).toList();
}

/// Records a payment against customer's balance
Future<PaymentResult> recordPayment({
required int customerId,
required double amount,
required String paymentReference,
String? notes,
}) async {
final db = await \_db;

    return await db.transaction((txn) async {
      // Get customer
      final customerMaps = await txn.query(
        customerTable,
        where: 'id = ?',
        whereArgs: [customerId],
      );

      if (customerMaps.isEmpty) {
        return PaymentResult(
          success: false,
          error: 'Customer not found',
        );
      }

      final customer = Customer.fromMap(customerMaps.first);

      if (amount <= 0) {
        return PaymentResult(
          success: false,
          error: 'Payment amount must be greater than zero',
        );
      }

      if (amount > customer.currentBalance) {
        return PaymentResult(
          success: false,
          error: 'Payment amount cannot exceed current balance',
        );
      }

      // Update customer balance
      final newBalance = customer.currentBalance - amount;
      await txn.update(
        customerTable,
        {
          'current_balance': newBalance,
          'last_transaction_date': DateTime.now().millisecondsSinceEpoch,
          'updated_at': DateTime.now().millisecondsSinceEpoch,
        },
        where: 'id = ?',
        whereArgs: [customerId],
      );

      // Create payment transaction
      final transaction = CreditTransaction(
        localId: 'payment_${DateTime.now().millisecondsSinceEpoch}',
        customerId: customerId,
        customerName: customer.name,
        type: 'payment',
        amount: amount,
        balanceBefore: customer.currentBalance,
        balanceAfter: newBalance,
        reference: paymentReference,
        notes: notes,
        createdAt: DateTime.now(),
      );

      await txn.insert(
        creditTransactionTable,
        transaction.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );

      return PaymentResult(
        success: true,
        newBalance: newBalance,
        amountPaid: amount,
      );
    });

}

/// Updates customer's credit limit
Future<CreditLimitResult> updateCreditLimit({
required int customerId,
required double newCreditLimit,
}) async {
final db = await \_db;

    return await db.transaction((txn) async {
      // Get customer
      final customerMaps = await txn.query(
        customerTable,
        where: 'id = ?',
        whereArgs: [customerId],
      );

      if (customerMaps.isEmpty) {
        return CreditLimitResult(
          success: false,
          error: 'Customer not found',
        );
      }

      final customer = Customer.fromMap(customerMaps.first);

      // Validate new credit limit
      if (newCreditLimit < customer.currentBalance) {
        return CreditLimitResult(
          success: false,
          error:
              'New credit limit cannot be less than current balance (ETB ${customer.currentBalance.toStringAsFixed(2)})',
        );
      }

      // Update credit limit
      await txn.update(
        customerTable,
        {
          'credit_limit': newCreditLimit,
          'updated_at': DateTime.now().millisecondsSinceEpoch,
        },
        where: 'id = ?',
        whereArgs: [customerId],
      );

      // Create adjustment transaction
      final transaction = CreditTransaction(
        localId: 'adjustment_${DateTime.now().millisecondsSinceEpoch}',
        customerId: customerId,
        customerName: customer.name,
        type: 'adjustment',
        amount: newCreditLimit - customer.creditLimit,
        balanceBefore: customer.currentBalance,
        balanceAfter: customer.currentBalance,
        reference: 'Credit Limit Adjustment',
        notes:
            'Credit limit changed from ETB ${customer.creditLimit.toStringAsFixed(2)} to ETB ${newCreditLimit.toStringAsFixed(2)}',
        createdAt: DateTime.now(),
      );

      await txn.insert(
        creditTransactionTable,
        transaction.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );

      return CreditLimitResult(
        success: true,
        oldCreditLimit: customer.creditLimit,
        newCreditLimit: newCreditLimit,
      );
    });

}

// Existing methods with enhancements
Future<int> createCustomer(Customer customer) async {
final db = await \_db;
return await db.insert(
customerTable,
customer.toMap(),
conflictAlgorithm: ConflictAlgorithm.replace,
);
}

Future<void> updateCustomer(Customer customer) async {
final db = await \_db;
await db.update(
customerTable,
customer.toMap(),
where: 'id = ?',
whereArgs: [customer.id],
);
}

Future<void> createSampleCustomers() async {
final db = await \_db;

    // Clear existing sample customers
    await db.delete('customers',
        where: 'local_id LIKE ?', whereArgs: ['cust_sample_%']);

    final sampleCustomers = [
      {
        'local_id': 'cust_sample_1',
        'name': 'Abebe Kebede',
        'phone': '+251911001100',
        'current_balance': 0.0,
        'credit_limit': 1000.0,
        'is_active': 1,
        'created_at': DateTime.now().millisecondsSinceEpoch,
        'updated_at': DateTime.now().millisecondsSinceEpoch,
      },
      {
        'local_id': 'cust_sample_2',
        'name': 'Marta Solomon',
        'phone': '+251922002200',
        'current_balance': 500.0,
        'credit_limit': 2000.0,
        'is_active': 1,
        'created_at': DateTime.now().millisecondsSinceEpoch,
        'updated_at': DateTime.now().millisecondsSinceEpoch,
      },
      // Add more sample customers...
    ];

    final batch = db.batch();
    for (final customer in sampleCustomers) {
      batch.insert('customers', customer);
    }
    await batch.commit();

}

Future<List<Customer>> getAllCustomers({bool activeOnly = true}) async {
final db = await \_db;
try {
final where = activeOnly ? 'WHERE is_active = 1' : '';
final maps = await db.rawQuery('''
SELECT \* FROM $customerTable
$where
ORDER BY name
''');
return maps.map((map) => Customer.fromMap(map)).toList();
} catch (e) {
print('Error in getAllCustomers: $e');
rethrow;
}
}

Future<void> updateCustomerBalance({
required int customerId,
required double amount,
required String transactionType,
required String reference,
}) async {
final db = await \_db;
try {
await db.transaction((txn) async {
// Update customer balance
await txn.rawUpdate('''
UPDATE $customerTable
SET current_balance = current_balance + ?,
updated_at = ?
WHERE id = ?
''', [amount, DateTime.now().millisecondsSinceEpoch, customerId]);

        // Record transaction
        await txn.insert(creditTransactionTable, {
          'local_id': 'CREDIT_${DateTime.now().millisecondsSinceEpoch}',
          'customer_id': customerId,
          'customer_name': 'Customer $customerId', // Should fetch actual name
          'type': transactionType,
          'amount': amount,
          'balance_before': 0, // Should fetch actual balance
          'balance_after': amount,
          'reference': reference,
          'created_at': DateTime.now().millisecondsSinceEpoch,
        });
      });
    } catch (e) {
      print('Error in updateCustomerBalance: $e');
      rethrow;
    }

}

Future<Customer?> getCustomerById(int id) async {
final db = await \_db;
try {
final maps = await db.query(
customerTable,
where: 'id = ?',
whereArgs: [id],
);
if (maps.isNotEmpty) {
return Customer.fromMap(maps.first);
}
return null;
} catch (e) {
print('Error in getCustomerById: $e');
rethrow;
}
}

Future<List<Customer>> getCustomersWithBalance() async {
final db = await \_db;
final maps = await db.query(
customerTable,
where: 'current_balance != 0 AND is_active = 1',
orderBy: 'current_balance DESC',
);
return maps.map((map) => Customer.fromMap(map)).toList();
}

Future<List<Customer>> getOverdueCustomers() async {
final db = await \_db;
final now = DateTime.now().millisecondsSinceEpoch;

    try {
      // First check if due_date column exists
      final tableInfo = await db.rawQuery("PRAGMA table_info(customers)");
      final hasDueDate = tableInfo.any((col) => col['name'] == 'due_date');

      if (!hasDueDate) {
        print('due_date column does not exist, returning empty list');
        return [];
      }

      final maps = await db.rawQuery('''
      SELECT * FROM customers
      WHERE current_balance > 0
        AND due_date IS NOT NULL
        AND due_date < ?
        AND is_active = 1
      ORDER BY current_balance DESC
    ''', [now]);

      return maps.map((map) => Customer.fromMap(map)).toList();
    } catch (e) {
      print('Error in getOverdueCustomers: $e');
      // If there's an error (like missing column), return empty list
      return [];
    }

}

Future<List<CreditTransaction>> getCustomerTransactions(int customerId,
{int limit = 50}) async {
final db = await \_db;
final maps = await db.query(
creditTransactionTable,
where: 'customer_id = ?',
whereArgs: [customerId],
orderBy: 'created_at DESC',
limit: limit,
);
return maps.map((map) => CreditTransaction.fromMap(map)).toList();
}

// Add this method to your CustomerRepository class
Future<void> addCreditTransaction(CreditTransaction transaction) async {
final db = await \_db;

    await db.transaction((txn) async {
      // Insert transaction
      await txn.insert(
        creditTransactionTable,
        transaction.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );

      // Update customer balance
      await txn.update(
        customerTable,
        {
          'current_balance': transaction.balanceAfter,
          'last_transaction_date': transaction.createdAt.millisecondsSinceEpoch,
          'updated_at': DateTime.now().millisecondsSinceEpoch,
        },
        where: 'id = ?',
        whereArgs: [transaction.customerId],
      );
    });

}

// Statistics
Future<Map<String, dynamic>> getCreditSummary() async {
final db = await \_db;
final now = DateTime.now().millisecondsSinceEpoch;

    final totalResult = await db.rawQuery('''
      SELECT COUNT(*) as count, COALESCE(SUM(current_balance), 0) as total
      FROM $customerTable WHERE is_active = 1
    ''');

    final overdueResult = await db.rawQuery('''
      SELECT COUNT(*) as count, COALESCE(SUM(current_balance), 0) as total
      FROM $customerTable
      WHERE current_balance > 0
        AND due_date IS NOT NULL
        AND due_date < ?
        AND is_active = 1
    ''', [now]);

    final customersWithBalance = await db.rawQuery('''
      SELECT COUNT(*) as count FROM $customerTable
      WHERE current_balance != 0 AND is_active = 1
    ''');

    return {
      'totalCustomers': (totalResult.first['count'] as num?)?.toInt() ?? 0,
      'totalOutstanding': (totalResult.first['total'] as num?)?.toDouble() ?? 0,
      'overdueCustomers': (overdueResult.first['count'] as num?)?.toInt() ?? 0,
      'overdueAmount': (overdueResult.first['total'] as num?)?.toDouble() ?? 0,
      'customersWithBalance':
          (customersWithBalance.first['count'] as num?)?.toInt() ?? 0,
    };

}
}

// Result classes for credit operations
class CreditSaleResult {
final bool success;
final String? error;
final double? newBalance;
final double? availableCredit;

CreditSaleResult({
required this.success,
this.error,
this.newBalance,
this.availableCredit,
});
}

class PaymentResult {
final bool success;
final String? error;
final double? newBalance;
final double? amountPaid;

PaymentResult({
required this.success,
this.error,
this.newBalance,
this.amountPaid,
});
}

class CreditLimitResult {
final bool success;
final String? error;
final double? oldCreditLimit;
final double? newCreditLimit;

CreditLimitResult({
required this.success,
this.error,
this.oldCreditLimit,
this.newCreditLimit,
});
}

##

// mobile/lib/src/data/repositories/otp_repository.dart
// Repository for managing OTPs in the local database.

import 'package:andalus_smart_pos/src/data/local/database.dart';
import 'package:andalus_smart_pos/src/data/models/otp.dart';

class OTPRepository {
OTPRepository();

Future<void> createOTP(OTP otp) async {
final db = await AppDatabase.database;

    try {
      // Clean expired OTPs for this phone
      await db.delete(
        'otps',
        where: 'phone = ? AND expires_at < ?',
        whereArgs: [otp.phone, DateTime.now().millisecondsSinceEpoch],
      );

      final result = await db.insert('otps', otp.toMap());
      print('‚úÖ OTP inserted successfully. Row ID: $result');
      print(
          'üìù OTP Details - Phone: ${otp.phone}, Code: ${otp.code}, Expires: ${otp.expiresAt}');
    } catch (e) {
      print('‚ùå Error creating OTP: $e');
      rethrow;
    }

}

Future<OTP?> getValidOTP(String phone, String code, String type) async {
final db = await AppDatabase.database;

    try {
      print('üîç Searching for OTP - Phone: $phone, Code: $code, Type: $type');

      final result = await db.query(
        'otps',
        where:
            'phone = ? AND code = ? AND type = ? AND is_used = 0 AND expires_at > ?',
        whereArgs: [phone, code, type, DateTime.now().millisecondsSinceEpoch],
      );

      print('üìä OTP query found ${result.length} records');

      if (result.isNotEmpty) {
        for (var row in result) {
          print('üìÑ OTP Record: ${row.toString()}');
        }

        final otp = OTP.fromMap(result.first);
        print('‚úÖ Valid OTP found: ${otp.code} for ${otp.phone}');
        print(
            '‚è∞ OTP expires at: ${otp.expiresAt}, Current time: ${DateTime.now()}');
        print('üîë OTP is used: ${otp.isUsed}, Is valid: ${otp.isValid}');

        return otp;
      } else {
        print('‚ùå No valid OTP found');

        // Let's check what's actually in the database
        final allOtps = await db.query(
          'otps',
          where: 'phone = ?',
          whereArgs: [phone],
        );

        print('üìã All OTPs for $phone: ${allOtps.length} records');
        for (var otp in allOtps) {
          print(
              'üìÑ OTP: ${otp['code']}, Used: ${otp['is_used']}, Expires: ${DateTime.fromMillisecondsSinceEpoch(otp['expires_at'] as int)}');
        }

        return null;
      }
    } catch (e) {
      print('‚ùå Error getting OTP: $e');
      return null;
    }

}

Future<List<OTP>> getAllOTPsForPhone(String phone) async {
final db = await AppDatabase.database;
try {
final result = await db.query(
'otps',
where: 'phone = ?',
whereArgs: [phone],
orderBy: 'created_at DESC',
);

      // Convert Map to OTP objects
      return result.map((map) => OTP.fromMap(map)).toList();
    } catch (e) {
      print('‚ùå Error getting OTPs for phone: $e');
      return [];
    }

}

Future<void> markOTPAsUsed(String otpId) async {
final db = await AppDatabase.database;

    try {
      final result = await db.update(
        'otps',
        {'is_used': 1},
        where: 'otp_id = ?',
        whereArgs: [otpId],
      );

      print('‚úÖ OTP marked as used: $otpId, rows affected: $result');
    } catch (e) {
      print('‚ùå Error marking OTP as used: $e');
      rethrow;
    }

}

Future<void> cleanExpiredOTPs() async {
final db = await AppDatabase.database;
final deleted = await db.delete(
'otps',
where: 'expires_at < ?',
whereArgs: [DateTime.now().millisecondsSinceEpoch],
);
print('üßπ Cleaned $deleted expired OTPs');
}
}

##

// lib/src/data/repositories/product_repository.dart
// Repository for managing product data in the local database.
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:sqflite/sqflite.dart';
import '../local/database.dart';
import '../models/product.dart';

final productRepositoryProvider = Provider<ProductRepository>((ref) {
return ProductRepository();
});

class ProductRepository {
static const String productTable = 'products';

Future<Database> get \_db async => await AppDatabase.database;

Future<int> createProduct(Product product) async {
final db = await \_db;
return await db.insert(
productTable,
product.toMap(),
conflictAlgorithm: ConflictAlgorithm.replace,
);
}

Future<void> updateProduct(Product product) async {
final db = await \_db;
await db.update(
productTable,
product.toMap(),
where: 'id = ?',
whereArgs: [product.id],
);
}

Future<List<Product>> getAllProducts({bool activeOnly = true}) async {
final db = await \_db;
try {
final where = activeOnly ? 'WHERE p.is_active = 1' : '';
final maps = await db.rawQuery('''
SELECT p.\*, c.name as category_name
FROM $productTable p
LEFT JOIN product_categories c ON p.category_id = c.category_id
$where
ORDER BY p.name
''');
return maps.map((map) => Product.fromMap(map)).toList();
} catch (e) {
print('Error in getAllProducts: $e');
rethrow;
}
}

Future<Product?> getProductById(String productId) async {
final db = await \_db;
try {
final maps = await db.rawQuery('''
SELECT p.\*, c.name as category_name
FROM $productTable p
LEFT JOIN product_categories c ON p.category_id = c.category_id
WHERE p.product_id = ?
''', [productId]);

      if (maps.isNotEmpty) {
        return Product.fromMap(maps.first);
      }
      return null;
    } catch (e) {
      print('Error in getProductById: $e');
      rethrow;
    }

}

Future<void> updateStockAfterSale({
required String productId,
required int quantitySold,
}) async {
final db = await \_db;
try {
// Get current product
final product = await getProductById(productId);
if (product != null && product.trackInventory) {
final newStock = product.stockQuantity - quantitySold;
if (newStock >= 0) {
await db.update(
productTable,
{
'stock_quantity': newStock,
'updated_at': DateTime.now().millisecondsSinceEpoch,
},
where: 'product_id = ?',
whereArgs: [productId],
);
} else {
throw Exception('Insufficient stock for product $productId');
}
}
} catch (e) {
print('Error in updateStockAfterSale: $e');
rethrow;
}
}

Future<List<Product>> getProductsByCategory(String categoryId) async {
final db = await \_db;
try {
final maps = await db.rawQuery('''
SELECT p.\*, c.name as category_name
FROM $productTable p
LEFT JOIN product_categories c ON p.category_id = c.category_id
WHERE p.category_id = ? AND p.is_active = 1
ORDER BY p.name
''', [categoryId]);
return maps.map((map) => Product.fromMap(map)).toList();
} catch (e) {
print('Error in getProductsByCategory: $e');
rethrow;
}
}

Future<void> updateStockAfterRefund({
required String productId,
required int quantityRefunded,
}) async {
final db = await \_db;
try {
// Get current product
final product = await getProductById(productId);
if (product != null && product.trackInventory) {
final newStock = product.stockQuantity + quantityRefunded;
await db.update(
productTable,
{
'stock_quantity': newStock,
'updated_at': DateTime.now().millisecondsSinceEpoch,
},
where: 'product_id = ?',
whereArgs: [productId],
);
}
} catch (e) {
print('Error in updateStockAfterRefund: $e');
rethrow;
}
}

Future<Product?> getProductByIntId(int id) async {
final db = await \_db;
try {
final maps = await db.rawQuery('''
SELECT p.\*, c.name as category_name
FROM $productTable p
LEFT JOIN product_categories c ON p.category_id = c.category_id
WHERE p.id = ?
''', [id]);

      if (maps.isNotEmpty) {
        return Product.fromMap(maps.first);
      }
      return null;
    } catch (e) {
      print('Error in getProductByIntId: $e');
      rethrow;
    }

}

Future<List<Product>> searchProducts(String query) async {
final db = await \_db;
try {
final maps = await db.rawQuery('''
SELECT p.\*, c.name as category_name
FROM $productTable p 
        LEFT JOIN product_categories c ON p.category_id = c.category_id 
        WHERE (p.name LIKE ? OR p.name_am LIKE ? OR p.barcode LIKE ? OR p.sku LIKE ?) 
        AND p.is_active = 1 
        ORDER BY p.name
      ''', ['%$query%', '%$query%', '%$query%', '%$query%']);
return maps.map((map) => Product.fromMap(map)).toList();
} catch (e) {
print('Error in searchProducts: $e');
rethrow;
}
}

Future<void> updateStockQuantity(int productId, int newQuantity) async {
final db = await \_db;
try {
await db.update(
productTable,
{
'stock_quantity': newQuantity,
'updated_at': DateTime.now().millisecondsSinceEpoch,
},
where: 'id = ?',
whereArgs: [productId],
);
} catch (e) {
print('Error in updateStockQuantity: $e');
rethrow;
}
}

Future<List<Product>> getLowStockProducts() async {
final db = await \_db;
try {
final maps = await db.rawQuery('''
SELECT p.\*, c.name as category_name
FROM $productTable p
LEFT JOIN product_categories c ON p.category_id = c.category_id
WHERE p.track_inventory = 1
AND p.min_stock_level IS NOT NULL
AND p.stock_quantity <= p.min_stock_level
AND p.is_active = 1
ORDER BY p.stock_quantity ASC
''');
return maps.map((map) => Product.fromMap(map)).toList();
} catch (e) {
print('Error in getLowStockProducts: $e');
rethrow;
}
}

Future<List<Product>> getActiveProducts() async {
final db = await \_db;
try {
final maps = await db.rawQuery('''
SELECT p.\*, c.name as category_name
FROM $productTable p
LEFT JOIN product_categories c ON p.category_id = c.category_id
WHERE p.is_active = 1
ORDER BY p.name
''');
return maps.map((map) => Product.fromMap(map)).toList();
} catch (e) {
print('Error in getActiveProducts: $e');
rethrow;
}
}

Future<void> deactivateProduct(int productId) async {
final db = await \_db;
try {
await db.update(
productTable,
{
'is_active': 0,
'updated_at': DateTime.now().millisecondsSinceEpoch,
},
where: 'id = ?',
whereArgs: [productId],
);
} catch (e) {
print('Error in deactivateProduct: $e');
rethrow;
}
}

Future<void> activateProduct(int productId) async {
final db = await \_db;
try {
await db.update(
productTable,
{
'is_active': 1,
'updated_at': DateTime.now().millisecondsSinceEpoch,
},
where: 'id = ?',
whereArgs: [productId],
);
} catch (e) {
print('Error in activateProduct: $e');
rethrow;
}
}

Future<void> createSampleProducts(ProductRepository productRepo) async {
final sampleProducts = [
Product(
id: 1,
name: 'Sample Product 1',
sku: 'SP001',
barcode: '1234567890123',
categoryId: 'cat1',
price: 9.99,
stockQuantity: 100,
isActive: true,
trackInventory: true,
productId: '',
nameAm: '',
createdAt: DateTime.now(),
updatedAt: DateTime.now(),
),
Product(
id: 2,
name: 'Sample Product 2',
sku: 'SP002',
barcode: '1234567890124',
categoryId: 'cat2',
price: 19.99,
stockQuantity: 50,
isActive: true,
trackInventory: true,
productId: '',
nameAm: '',
createdAt: DateTime.now(),
updatedAt: DateTime.now(),
),
];

    for (var product in sampleProducts) {
      await productRepo.createProduct(product);
    }

}
}

##

// mobile/lib/src/data/repositories/sale_item_repository.dart
// Repository for managing sale item data in the local database.
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:sqflite/sqflite.dart';
import '../local/database.dart';
import '../models/sale_item.dart';

class SaleItemRepository {
Future<Database> get \_db async => await AppDatabase.database;

Future<List<SaleItem>> getSaleItemsBySaleId(int saleId) async {
final db = await \_db;
try {
final maps = await db.query(
'sale_items',
where: 'sale_id = ?',
whereArgs: [saleId],
);
return maps.map((map) => SaleItem.fromMap(map)).toList();
} catch (e) {
print('Error fetching sale items: $e');
return [];
}
}

Future<List<SaleItem>> getSaleItemsInDateRange(
DateTime start, DateTime end) async {
final db = await \_db;
try {
final maps = await db.query(
'sale_items',
where: 'created_at BETWEEN ? AND ?',
whereArgs: [start.millisecondsSinceEpoch, end.millisecondsSinceEpoch],
);
return maps.map((map) => SaleItem.fromMap(map)).toList();
} catch (e) {
print('Error fetching sale items in date range: $e');
return [];
}
}

Future<List<SaleItem>> getAllSaleItems() async {
final db = await \_db;
try {
final maps = await db.query('sale_items');
return maps.map((map) => SaleItem.fromMap(map)).toList();
} catch (e) {
print('Error fetching all sale items: $e');
return [];
}
}
}

final saleItemRepositoryProvider = Provider<SaleItemRepository>((ref) {
return SaleItemRepository();
});

##

// mobile/lib/src/data/repositories/sale_repository.dart
// Repository for managing sale data in the local database.
import 'package:flutter/src/material/date.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:sqflite/sqflite.dart';
import '../local/database.dart'; // Import AppDatabase
import '../models/sale.dart';
import '../models/sale_item.dart';

final saleRepositoryProvider = Provider<SaleRepository>((ref) {
return SaleRepository();
});

class SaleRepository {
static const String saleTable = 'sales';
static const String saleItemTable = 'sale_items';

Future<Database> get \_db async => await AppDatabase.database;

// Add this method to your SaleRepository class
Future<void> createSampleSales() async {
final db = await \_db;

    // Clear existing sample data to avoid duplicates
    await db.delete('sales', where: 'sale_id LIKE ?', whereArgs: ['SAMPLE-%']);

    final sampleSales = [
      {
        'sale_id': 'SAMPLE-${DateTime.now().millisecondsSinceEpoch}',
        'total_amount': 250.0,
        'final_amount': 250.0,
        'payment_method': 'cash',
        'user_id': 1,
        'shop_id': 1,
        'created_at': DateTime.now()
            .subtract(const Duration(hours: 1))
            .millisecondsSinceEpoch,
        'updated_at': DateTime.now().millisecondsSinceEpoch,
      },
      {
        'sale_id': 'SAMPLE-${DateTime.now().millisecondsSinceEpoch + 1}',
        'total_amount': 150.0,
        'final_amount': 150.0,
        'payment_method': 'telebirr',
        'user_id': 1,
        'shop_id': 1,
        'created_at': DateTime.now()
            .subtract(const Duration(hours: 2))
            .millisecondsSinceEpoch,
        'updated_at': DateTime.now().millisecondsSinceEpoch,
      },
      {
        'sale_id': 'SAMPLE-${DateTime.now().millisecondsSinceEpoch + 2}',
        'total_amount': 75.0,
        'final_amount': 75.0,
        'payment_method': 'card',
        'user_id': 1,
        'shop_id': 1,
        'created_at': DateTime.now()
            .subtract(const Duration(days: 1))
            .millisecondsSinceEpoch,
        'updated_at': DateTime.now().millisecondsSinceEpoch,
      },
      {
        'sale_id': 'SAMPLE-${DateTime.now().millisecondsSinceEpoch + 3}',
        'total_amount': 320.0,
        'final_amount': 320.0,
        'payment_method': 'cash',
        'user_id': 1,
        'shop_id': 1,
        'created_at': DateTime.now()
            .subtract(const Duration(days: 2))
            .millisecondsSinceEpoch,
        'updated_at': DateTime.now().millisecondsSinceEpoch,
      },
      {
        'sale_id': 'SAMPLE-${DateTime.now().millisecondsSinceEpoch + 4}',
        'total_amount': 95.0,
        'final_amount': 95.0,
        'payment_method': 'telebirr',
        'user_id': 1,
        'shop_id': 1,
        'created_at': DateTime.now()
            .subtract(const Duration(days: 3))
            .millisecondsSinceEpoch,
        'updated_at': DateTime.now().millisecondsSinceEpoch,
      },
    ];

    final batch = db.batch();

    for (final saleData in sampleSales) {
      batch.insert('sales', saleData);
    }

    await batch.commit();
    print('Sample sales data created successfully');

}

// Create a new sale with items
Future<int> createSale(Sale sale, List<SaleItem> items) async {
final db = await \_db;

    return await db.transaction((txn) async {
      // Insert sale
      final saleId = await txn.insert(
        saleTable,
        sale.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );

      // Insert sale items
      for (final item in items) {
        await txn.insert(
          saleItemTable,
          item.copyWith(saleId: saleId as String).toMap(),
          conflictAlgorithm: ConflictAlgorithm.replace,
        );
      }

      return saleId;
    });

}

// Get all sales with pagination
Future<List<Sale>> getAllSales({
int limit = 50,
int offset = 0,
}) async {
final db = await \_db;
final maps = await db.query(
saleTable,
orderBy: 'created_at DESC',
limit: limit,
offset: offset,
);

    return maps.map((map) => Sale.fromMap(map)).toList();

}

// Get sale by ID with items
Future<SaleWithItems?> getSaleById(int id) async {
final db = await \_db;

    final saleMaps = await db.query(
      saleTable,
      where: 'id = ?',
      whereArgs: [id],
    );

    if (saleMaps.isEmpty) return null;

    final sale = Sale.fromMap(saleMaps.first);
    final itemMaps = await db.query(
      saleItemTable,
      where: 'sale_id = ?',
      whereArgs: [id],
    );

    final items = itemMaps.map((map) => SaleItem.fromMap(map)).toList();

    return SaleWithItems(sale: sale, items: items);

}

// Get today's sales
Future<List<Sale>> getTodaysSales() async {
final db = await \_db;
final now = DateTime.now();
final startOfDay = DateTime(now.year, now.month, now.day);
final endOfDay = DateTime(now.year, now.month, now.day, 23, 59, 59);

    final maps = await db.query(
      saleTable,
      where: 'created_at BETWEEN ? AND ?',
      whereArgs: [
        startOfDay.millisecondsSinceEpoch,
        endOfDay.millisecondsSinceEpoch,
      ],
      orderBy: 'created_at DESC',
    );

    return maps.map((map) => Sale.fromMap(map)).toList();

}

// Get sales summary for dashboard
Future<SalesSummary> getSalesSummary(
{DateTimeRange<DateTime>? dateRange}) async {
final db = await \_db;
final now = DateTime.now();
final startOfDay = DateTime(now.year, now.month, now.day);
final endOfDay = DateTime(now.year, now.month, now.day, 23, 59, 59);
final startOfWeek = now.subtract(Duration(days: now.weekday - 1));

    try {
      final todayResult = await db.rawQuery('''
      SELECT COUNT(*) as count, COALESCE(SUM(final_amount), 0) as total
      FROM sales WHERE created_at BETWEEN ? AND ?
    ''', [startOfDay.millisecondsSinceEpoch, endOfDay.millisecondsSinceEpoch]);

      final totalResult = await db.rawQuery('''
      SELECT COUNT(*) as count, COALESCE(SUM(final_amount), 0) as total FROM sales
    ''');

      final weekResult = await db.rawQuery('''
      SELECT COUNT(*) as count, COALESCE(SUM(final_amount), 0) as total
      FROM sales WHERE created_at >= ?
    ''', [startOfWeek.millisecondsSinceEpoch]);

      return SalesSummary.fromDatabase(
        todayResult.first,
        totalResult.first,
        weekResult.first,
      );
    } catch (e) {
      print('Error in getSalesSummary: $e');
      return SalesSummary(
        todaysSales: 0.0,
        todaysOrders: 0,
        totalSales: 0.0,
        totalOrders: 0,
        weeklySales: 0.0,
        weeklyOrders: 0,
      );
    }

}

Future<List<Sale>> searchSales({
String? query,
DateTime? startDate,
DateTime? endDate,
String? paymentMethod,
String? status,
int? customerId,
}) async {
final db = await \_db;

    List<String> whereConditions = [];
    List<Object?> whereArgs = [];

    if (query != null && query.isNotEmpty) {
      whereConditions.add('(sale_id LIKE ? OR customer_name LIKE ?)');
      whereArgs.addAll(['%$query%', '%$query%']);
    }

    if (startDate != null) {
      whereConditions.add('created_at >= ?');
      whereArgs.add(startDate.millisecondsSinceEpoch);
    }

    if (endDate != null) {
      whereConditions.add('created_at <= ?');
      whereArgs.add(endDate.millisecondsSinceEpoch);
    }

    if (paymentMethod != null) {
      whereConditions.add('payment_method = ?');
      whereArgs.add(paymentMethod);
    }

    if (status != null) {
      whereConditions.add('sale_status = ?');
      whereArgs.add(status);
    }

    if (customerId != null) {
      whereConditions.add('customer_id = ?');
      whereArgs.add(customerId);
    }

    final whereClause = whereConditions.isNotEmpty
        ? 'WHERE ${whereConditions.join(' AND ')}'
        : '';

    final maps = await db.rawQuery('''
      SELECT * FROM $saleTable
      $whereClause
      ORDER BY created_at DESC
      LIMIT 100
    ''', whereArgs);

    return maps.map((map) => Sale.fromMap(map)).toList();

}

Future<Sale> refundSale({
required int saleId,
required String reason,
bool fullRefund = true,
List<String>? itemIds,
Map<String, int>? partialQuantities,
}) async {
final db = await \_db;

    return await db.transaction((txn) async {
      // Get original sale
      final saleMaps = await txn.query(
        saleTable,
        where: 'id = ?',
        whereArgs: [saleId],
      );

      if (saleMaps.isEmpty) {
        throw Exception('Sale not found');
      }

      final originalSale = Sale.fromMap(saleMaps.first);

      // Create refund sale
      final refundSale = Sale(
        saleId: 'REFUND_${originalSale.saleId}',
        localId: 'REFUND_LOCAL_${DateTime.now().millisecondsSinceEpoch}',
        customerId: originalSale.customerId,
        customerName: originalSale.customerName,
        totalAmount: originalSale.totalAmount,
        finalAmount: -originalSale.finalAmount, // Negative amount for refund
        taxAmount: originalSale.taxAmount,
        discountAmount: originalSale.discountAmount,
        paymentMethod: 'refund',
        paymentReference: 'REFUND_${originalSale.saleId}',
        paymentStatus: 'refunded',
        saleStatus: 'refunded',
        userId: originalSale.userId,
        userName: originalSale.userName,
        shopId: originalSale.shopId,
        isSynced: false,
        syncAttempts: 0,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
        notes: 'Refund: $reason',
        isRefunded: false, // This is the refund record itself
        refundReason: reason,
        refundedAt: DateTime.now(),
      );

      // Save refund sale
      final refundSaleId = await txn.insert(
        saleTable,
        refundSale.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );

      // Update original sale status
      await txn.update(
        saleTable,
        {
          'sale_status': 'refunded',
          'payment_status': 'refunded',
          'is_refunded': 1,
          'refund_reason': reason,
          'refunded_at': DateTime.now().millisecondsSinceEpoch,
          'updated_at': DateTime.now().millisecondsSinceEpoch,
        },
        where: 'id = ?',
        whereArgs: [saleId],
      );

      return refundSale.copyWith(id: refundSaleId);
    });

}

Future<List<SaleItem>> getSaleItems(int saleId) async {
final db = await \_db;
final maps = await db.query(
saleItemTable,
where: 'sale_id = ?',
whereArgs: [saleId],
);

    return maps.map((map) => SaleItem.fromMap(map)).toList();

}

Future<Sale?> getSimpleSaleById(int id) async {
final db = await \_db;
final saleMaps = await db.query(
saleTable,
where: 'id = ?',
whereArgs: [id],
);

    if (saleMaps.isEmpty) return null;
    return Sale.fromMap(saleMaps.first);

}

// Get unsynced sales for synchronization
Future<List<Sale>> getUnsyncedSales() async {
final db = await \_db;
final maps = await db.query(
saleTable,
where: 'is_synced = 0',
orderBy: 'created_at ASC',
);

    return maps.map((map) => Sale.fromMap(map)).toList();

}

// Add this method to SaleRepository class for testing
Future<void> addSampleSales() async {
final sampleSales = [
Sale(
localId: 'sample_1',
totalAmount: 150.0,
finalAmount: 150.0,
paymentMethod: 'cash',
userId: 1,
shopId: 1,
createdAt: DateTime.now().subtract(const Duration(hours: 2)),
updatedAt: DateTime.now().subtract(const Duration(hours: 2)),
saleId: '',
),
Sale(
localId: 'sample_2',
totalAmount: 75.0,
finalAmount: 75.0,
paymentMethod: 'telebirr',
userId: 1,
shopId: 1,
createdAt: DateTime.now().subtract(const Duration(hours: 1)),
updatedAt: DateTime.now().subtract(const Duration(hours: 1)),
saleId: '',
),
];

    for (final sale in sampleSales) {
      await createSale(sale, [
        SaleItem(
          saleId: '0', // Will be replaced with actual sale ID
          productId: '1',
          productName: 'Coca Cola',
          quantity: 2,
          unitPrice: 25.0,
          totalPrice: 50.0,
          createdAt: sale.createdAt,
        ),
      ]);
    }

}

// Mark sale as synced
Future<void> markAsSynced(int saleId) async {
final db = await \_db;
await db.update(
saleTable,
{
'is_synced': 1,
'updated_at': DateTime.now().millisecondsSinceEpoch,
},
where: 'id = ?',
whereArgs: [saleId],
);
}
}

// Helper class to combine sale with its items
class SaleWithItems {
final Sale sale;
final List<SaleItem> items;

SaleWithItems({required this.sale, required this.items});

double get totalAmount => items.fold(0, (sum, item) => sum + item.totalPrice);
}

extension SaleRefundExtension on Sale {
bool get canBeRefunded {
if (isRefunded) return false;
if (saleStatus != 'completed') return false;
if (paymentStatus != 'completed') return false;

    // 30-day refund window
    final thirtyDaysAgo = DateTime.now().subtract(const Duration(days: 30));
    return createdAt.isAfter(thirtyDaysAgo);

}
}

// Add this extension to SaleWithItems class
extension SaleWithItemsRefundExtension on SaleWithItems {
bool get canBeRefunded => sale.canBeRefunded;
}

// Sales summary for dashboard
class SalesSummary {
final double todaysSales;
final int todaysOrders;
final double totalSales;
final int totalOrders;
final double weeklySales;
final int weeklyOrders;

SalesSummary({
required this.todaysSales,
required this.todaysOrders,
required this.totalSales,
required this.totalOrders,
required this.weeklySales,
required this.weeklyOrders,
});
factory SalesSummary.fromDatabase(Map<String, dynamic> todayResult,
Map<String, dynamic> totalResult, Map<String, dynamic> weekResult) {
return SalesSummary(
todaysSales: (todayResult['total'] as num?)?.toDouble() ?? 0.0,
todaysOrders: (todayResult['count'] as num?)?.toInt() ?? 0,
totalSales: (totalResult['total'] as num?)?.toDouble() ?? 0.0,
totalOrders: (totalResult['count'] as num?)?.toInt() ?? 0,
weeklySales: (weekResult['total'] as num?)?.toDouble() ?? 0.0,
weeklyOrders: (weekResult['count'] as num?)?.toInt() ?? 0,
);
}
}

// Add method to create sample sales data for testing
Future<void> createSampleSales() async {
final sampleSales = [
Sale(
saleId: 'SALE-${DateTime.now().millisecondsSinceEpoch}',
totalAmount: 250.0,
finalAmount: 250.0,
paymentMethod: 'cash',
userId: 1,
shopId: 1,
createdAt: DateTime.now().subtract(const Duration(hours: 1)),
localId: '',
),
Sale(
saleId: 'SALE-${DateTime.now().millisecondsSinceEpoch + 1}',
totalAmount: 150.0,
finalAmount: 150.0,
paymentMethod: 'telebirr',
userId: 1,
shopId: 1,
createdAt: DateTime.now().subtract(const Duration(hours: 2)),
localId: '',
),
Sale(
saleId: 'SALE-${DateTime.now().millisecondsSinceEpoch + 2}',
totalAmount: 75.0,
finalAmount: 75.0,
paymentMethod: 'card',
userId: 1,
shopId: 1,
createdAt: DateTime.now().subtract(const Duration(days: 1)),
localId: '',
),
];

for (final sale in sampleSales) {
await createSale(sale, [
SaleItem(
saleId: '0', // Will be replaced with actual sale ID
productId: '1',
productName: 'Sample Product',
quantity: 2,
unitPrice: 25.0,
totalPrice: 50.0,
createdAt: sale.createdAt,
),
]);
}
}

Future<void> createSale(Sale sale, List<SaleItem> items) async {
final repository = SaleRepository();
await repository.createSale(sale, items);
}

##

// mobile/lib/src/data/repositories/settings_repository.dart
// Repository for managing application settings using SharedPreferences.

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../models/settings.dart';

final settingsRepositoryProvider = Provider<SettingsRepository>((ref) {
return SettingsRepository();
});

class SettingsRepository {
static const String \_settingsKey =
'app_settings_v2'; // Change key to force refresh

Future<AppSettings> getSettings() async {
final prefs = await SharedPreferences.getInstance();
final settingsJson = prefs.getString(\_settingsKey);

    if (settingsJson != null) {
      try {
        // In a real app, you'd parse JSON properly
        // For now, return from map with default values for new fields
        final Map<String, dynamic> settingsMap = {
          'shopName': 'Andalus Smart POS',
          'shopNameAm': '·ä†·äï·ã≥·àâ·àµ ·àõ·à≠·â≤·äï ·çñ·àµ',
          'address': 'Addis Ababa, Ethiopia',
          'phone': '+251 911 234 567',
          'tinNumber': 'TIN-123456789',
          'currency': 'ETB',
          'enableTax': false,
          'taxRate': 0.15,
          'enableDiscounts': true,
          'autoPrintReceipts': false,
          'defaultPaymentMethod': 'cash',
          'enableSync': true,
          'syncInterval': 5,
          'enableCreditSystem': true,
          'defaultCreditLimit': 1000.0,
          'defaultPaymentTerms': '30',
          'enableCustomerSelection': true,
          'lowStockNotifications': true,
          'lowStockThreshold': 10,
        };
        return AppSettings.fromMap(settingsMap);
      } catch (e) {
        print('Error parsing settings: $e');
        return _getDefaultSettings();
      }
    }

    return _getDefaultSettings();

}

Future<void> saveSettings(AppSettings settings) async {
final prefs = await SharedPreferences.getInstance();
// In a real app, you'd convert to JSON properly
await prefs.setString(\_settingsKey, 'settings_saved_v2');
await Future.delayed(const Duration(milliseconds: 500));
}

AppSettings \_getDefaultSettings() {
return AppSettings(
shopName: 'Andalus Smart POS',
shopNameAm: '·ä†·äï·ã≥·àâ·àµ ·àõ·à≠·â≤·äï ·çñ·àµ',
address: 'Addis Ababa, Ethiopia',
phone: '+251 911 234 567',
tinNumber: 'TIN-123456789',
currency: 'ETB',
enableTax: false,
taxRate: 0.15,
enableDiscounts: true,
autoPrintReceipts: false,
defaultPaymentMethod: 'cash',
enableSync: true,
syncInterval: 5,
enableCreditSystem: true,
defaultCreditLimit: 1000.0,
defaultPaymentTerms: '30',
enableCustomerSelection: true,
lowStockNotifications: true,
lowStockThreshold: 10,
);
}

Future<Map<String, String>> getShopInfo() async {
final settings = await getSettings();
return {
'name': settings.shopName,
'nameAm': settings.shopNameAm,
'address': settings.address,
'phone': settings.phone,
'tinNumber': settings.tinNumber,
};
}
}

##

// mobile/lib/src/data/repositories/subscription_repository.dart
// Repository for managing subscription data in the local database.
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:sqflite/sqflite.dart';
import '../local/database.dart';
import '../models/subscription.dart';

class SubscriptionRepository {
Future<Database> get \_db async => await AppDatabase.database;

Future<Subscription?> getCurrentSubscription() async {
final db = await \_db;

    try {
      final maps = await db.query(
        'subscriptions',
        where: 'is_active = 1',
        orderBy: 'created_at DESC',
        limit: 1,
      );

      if (maps.isNotEmpty) {
        return Subscription.fromMap(maps.first);
      }
      return null;
    } catch (e) {
      print('Error fetching current subscription: $e');
      return null;
    }

}

Future<List<Subscription>> getSubscriptionHistory() async {
final db = await \_db;

    try {
      final maps = await db.query(
        'subscriptions',
        orderBy: 'created_at DESC',
      );

      return maps.map((map) => Subscription.fromMap(map)).toList();
    } catch (e) {
      print('Error fetching subscription history: $e');
      return [];
    }

}

Future<void> createSubscription(Subscription subscription) async {
final db = await \_db;

    try {
      await db.insert(
        'subscriptions',
        subscription.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );
    } catch (e) {
      print('Error creating subscription: $e');
      rethrow;
    }

}

Future hasValidSubscription(String s) async {
final subscription = await getCurrentSubscription();
if (subscription == null) {
return false;
}
final now = DateTime.now();
return subscription.expiryDate.isAfter(now);
}
}

final subscriptionRepositoryProvider = Provider<SubscriptionRepository>((ref) {
return SubscriptionRepository();
});

##

// mobile/lib/src/data/repositories/user_repository.dart
// Repository for managing user data in the local database.
import 'package:andalus_smart_pos/src/data/local/database.dart';
import 'package:andalus_smart_pos/src/data/models/user.dart';

class UserRepository {
UserRepository();

Future<User?> getUserByPhone(String phone) async {
final db = await AppDatabase.database;

    try {
      final result = await db.query(
        'users',
        where: 'phone = ?',
        whereArgs: [phone],
      );

      print(
          'User query result: ${result.length} users found for phone: $phone');

      if (result.isEmpty) return null;

      final user = User.fromMap(result.first);
      print('User found: ${user.name} (${user.role})');

      return user;
    } catch (e) {
      print('Error getting user by phone: $e');
      return null;
    }

}

Future<User?> getUserById(String userId) async {
final db = await AppDatabase.database;
final result = await db.query(
'users',
where: 'user_id = ?',
whereArgs: [userId],
);

    if (result.isEmpty) return null;
    return User.fromMap(result.first);

}

Future<void> createUser(User user) async {
final db = await AppDatabase.database;
await db.insert('users', user.toMap());
}

Future<void> updateUser(User user) async {
final db = await AppDatabase.database;
await db.update(
'users',
user.toMap(),
where: 'user_id = ?',
whereArgs: [user.id],
);
}

Future<void> updateLastLogin(String userId) async {
final db = await AppDatabase.database;
await db.update(
'users',
{
'last_login_at': DateTime.now().millisecondsSinceEpoch,
'updated_at': DateTime.now().millisecondsSinceEpoch,
},
where: 'user_id = ?',
whereArgs: [userId],
);

    print('Last login updated for user: $userId');

}
}

Future<void> deleteUser(String userId) async {
final db = await AppDatabase.database;
await db.delete(
'users',
where: 'user_id = ?',
whereArgs: [userId],
);
}

##

//src/localization/app_localizations.dart
// Localization class for managing localized strings in the application.
//ensure to import necessary packages and add skipped terms from other files
import 'package:flutter/material.dart';
import 'package:flutter/foundation.dart';
import 'dart:async';

class AppLocalizations {
final Locale locale;

AppLocalizations(this.locale);

static AppLocalizations of(BuildContext context) {
final AppLocalizations? localizations =
Localizations.of<AppLocalizations>(context, AppLocalizations);
if (localizations == null) {
throw FlutterError(
'AppLocalizations.of() called with a context that does not contain AppLocalizations.\n'
'No AppLocalizations ancestor could be found starting from the context that was passed to AppLocalizations.of(). '
'This usually happens when the context provided is from the same StatefulWidget as that whose build '
'function actually creates the AppLocalizations widget.\n'
'The context used was: $context');
}
return localizations;
}

static const LocalizationsDelegate<AppLocalizations> delegate =
\_AppLocalizationsDelegate();

static final Map<String, Map<String, String>> \_localizedValues = {
'en': {
'appTitle': 'Andalus Smart POS',
'dashboard': 'Dashboard',
'pointOfSale': 'Point of Sale',
'salesHistory': 'Sales History',
'customers': 'Customers',
'products': 'Products',
'categories': 'Categories',
'settings': 'Settings',
'todayRevenue': 'Today\'s Revenue',
'todayOrders': 'Today\'s Orders',
'outstandingCredit': 'Outstanding Credit',
'overdue': 'Overdue',
'totalRevenue': 'Total Revenue',
'totalOrders': 'Total Orders',
'averageOrderValue': 'Average Order Value',
'salesPerformance': 'Sales Performance',
'creditOverview': 'Credit Overview',
'recentSales': 'Recent Sales',
'searchProducts': 'Search products...',
'shoppingCart': 'Shopping Cart',
'clearAll': 'Clear All',
'totalAmount': 'Total Amount',
'completeSale': 'Complete Sale',
'selectPaymentMethod': 'Select Payment Method',
'cash': 'Cash',
'telebirr': 'Telebirr',
// 'card': 'Card',
'bankTransfer': 'Bank Transfer',
'credit': 'Credit',
'confirm': 'Confirm',
'cancel': 'Cancel',
'businessInformation': 'Business Information',
'shopNameEnglish': 'Shop Name (English)',
'shopNameAmharic': 'Shop Name (Amharic)',
'address': 'Address',
'phone': 'Phone',
'tinNumber': 'TIN Number',
'appearanceLanguage': 'Appearance & Language',
'themeMode': 'Theme Mode',
'language': 'Language',
'light': 'Light',
'dark': 'Dark',
'systemDefault': 'System Default',
'english': 'English',
'amharic': 'Amharic',
'posSettings': 'POS Settings',
'autoPrintReceipts': 'Auto Print Receipts',
'enableCustomerSelection': 'Enable Customer Selection',
'defaultPaymentMethod': 'Default Payment Method',
'creditSettings': 'Credit Settings',
'enableCreditSystem': 'Enable Credit System',
'defaultCreditLimit': 'Default Credit Limit (ETB)',
'defaultPaymentTerms': 'Default Payment Terms (Days)',
'syncSettings': 'Sync Settings',
'enableDataSync': 'Enable Data Sync',
'syncInterval': 'Sync Interval (minutes)',
'advancedSettings': 'Advanced Settings',
'enableTax': 'Enable Tax',
'taxRate': 'Tax Rate (%)',
'enableDiscounts': 'Enable Discounts',
'lowStockNotifications': 'Low Stock Notifications',
'lowStockThreshold': 'Low Stock Threshold',
'dangerZone': 'Danger Zone',
'resetToDefaults': 'Reset to Default Settings',
'noSalesToday': 'No sales today',
'noProductsFound': 'No products found',
'yourCartEmpty': 'Your cart is empty',
'addProductsGetStarted': 'Add products to get started',
'saleCompleted': 'Sale completed successfully!',
'errorLoadingData': 'Error loading data',
'settingsSaved': 'Settings saved successfully!',
'settingsReset': 'Settings reset to defaults!',
'account': 'Account',
'accountSettings': 'Account Settings',
'security': 'Security',
'changePassword': 'Change Password',
'currentPassword': 'Current Password',
'newPassword': 'New Password',
'confirmNewPassword': 'Confirm New Password',
'Are you sure you want to logout?': 'Are you sure you want to logout?',
'weeklySales': 'Weekly Sales',
'orders': 'orders',
'refresh': 'Refresh',
'performanceOverview': 'Performance Overview',
'customersWithBalance': 'Customers with Balance',
'overdueAmount': 'Overdue Amount',
'databaseNeedsUpdate':
'Database schema needs update. Please try refreshing.',
'tryAgain': 'Try Again',
'up': 'Up',
'down': 'Down',
'sale': 'Sale',
'today': 'Today',
'completeFirstSale': 'Complete your first sale to see it here!',
'stockAlert': 'Stock Alert',
'quickActions': 'Quick Actions',
'newSale': 'New Sale',
'addProduct': 'Add Product',
'addCustomer': 'Add Customer',
'reports': 'Reports',
'salesAnalytics': 'Sales Analytics',
'chartsComingSoon': 'Charts Coming Soon',
'installFlChart': 'Install fl_chart for beautiful analytics',
'allProductsWellStocked': 'All products are well stocked',
'moreProducts': '+{count} more products',
'left': 'left',
'calendarSettings': 'Calendar Settings',
'calendarType': 'Calendar Type',
'calendarDescription':
'Choose between Gregorian and Ethiopian calendar systems',
'fontSize': 'Font Size',
'small': 'Small',
'large': 'Large',
'items sold': 'items sold',
'with balance': 'with balance',
'outstanding': 'Outstanding',
'thisMonth': 'This Month', // ... existing translations
'productsReport': 'Products Report',
'customersReport': 'Customers Report',
'financialReport': 'Financial Report',
'selectDateRange': 'Select Date Range',
'basicPlanFeatures': 'Basic Plan: Basic reports available',
'professionalPlanFeatures':
'Professional Plan: Advanced analytics available',
'enterprisePlanFeatures': 'Enterprise Plan: Complete analytics available',
'plan': 'Plan',
'basicReportsDescription': 'Basic sales reports and analytics',
'professionalReportsDescription':
'Advanced product and customer analytics',
'enterpriseReportsDescription':
'Complete financial and predictive analytics',
'upgradeForAdvancedReports': 'Upgrade for advanced reports',
'upgrade': 'Upgrade',
'professionalPlanRequired': 'Professional Plan Required',
'enterprisePlanRequired': 'Enterprise Plan Required',
'productsReportAvailableInPlan':
'Products Report is available in the {plan} plan',
'customersReportAvailableInPlan':
'Customers Report is available in the {plan} plan',
'financialReportAvailableInPlan':
'Financial Report is available in the {plan} plan',
'upgradeYourPlan': 'Upgrade Your Plan',
'upgradeForAdvancedAnalytics':
'Upgrade to access advanced analytics and reporting features.',
'viewPlans': 'View Plans',
'salesByPaymentMethod': 'Sales by Payment Method',
'revenueByDay': 'Revenue by Day',
'dailySalesTrend': 'Daily Sales Trend',
'topSellingHours': 'Top Selling Hours',
'customerRetention': 'Customer Retention',
'salesVelocity': 'Sales Velocity',
'profitMarginAnalysis': 'Profit Margin Analysis',
'inventoryTurnover': 'Inventory Turnover',
'abcAnalysis': 'ABC Analysis',
'stockOptimization': 'Stock Optimization',
'productsOverview': 'Products Overview',
'totalProducts': 'Total Products',
'lowStock': 'Low Stock',
'outOfStock': 'Out of Stock',
'topSellingProducts': 'Top Selling Products',
'sold': 'sold',
'customersOverview': 'Customers Overview',
'topCustomers': 'Top Customers',
'customerAcquisition': 'Customer Acquisition',
'averageCustomerValue': 'Average Customer Value',
'customerLifetimeValue': 'Customer Lifetime Value',
'churnRiskAnalysis': 'Churn Risk Analysis',
'financialOverview': 'Financial Overview',
'revenueTrend': 'Revenue Trend',
'profitMarginTrend': 'Profit Margin Trend',
'cashFlowAnalysis': 'Cash Flow Analysis',
'financialRatios': 'Financial Ratios',
'breakEvenAnalysis': 'Break-Even Analysis',
'advancedAnalyticsFeature':
'Advanced analytics feature available in higher plans',
'yesterday': 'Yesterday',
'thisWeek': 'This Week',
'lastWeek': 'Last Week',
'lastMonth': 'Last Month',
'last3Months': 'Last 3 Months',
'last6Months': 'Last 6 Months',
'thisYear': 'This Year',
'lastYear': 'Last Year',
'subscriptionPlans': 'Subscription Plans',
'choosePerfectPlan': 'Choose the perfect plan for your business',
'startWithFreeTrial':
'Start with 14 days free trial. No credit card required.',
'monthly': 'Monthly',
'yearly': 'Yearly',
'save20Percent': 'Save 20%',
'popular': 'Popular',
'selected': 'Selected',
'selectPlan': 'Select Plan',
'paymentMethod': 'Payment Method',
'card': 'Credit/Debit Card',
'orderSummary': 'Order Summary',
'price': 'Price',
'tax': 'Tax',
'total': 'Total',
'subscribeNow': 'Subscribe Now',
'salesOverview': 'Sales Overview',
'item': 'Item',
'qty': 'Qty',
'subtotal': 'Subtotal',
'discount': 'Discount',
'telebirrReference': 'Telebirr Reference',
'thankYou': 'Thank you for your business!',
'receipt': 'Receipt',
'time': 'Time',
'scanBarcode': 'Scan barcode',
'scan': 'Scan',
'selectCustomer': 'Select Customer',
'creditAvailable': 'Credit Available',
'connectedTo': 'Connected to',
'noPrinterConnected': 'No printer connected',
'testPrint': 'Test Print Receipt',
'tryAdjustingSearch': 'Try adjusting your search or add new products',
'registerBusiness': 'Register Business',
'adminAccount': 'Admin Account',
'subscriptionPlan': 'Subscription Plan',
'reviewRegistration': 'Review & Complete',
'verifyPhone': 'Verify Phone',
'businessNameEnglish': 'Business Name (English)',
'businessNameAmharic': 'Business Name (Amharic)',
'businessPhone': 'Business Phone',
'businessEmailOptional': 'Business Email (Optional)',
'businessAddress': 'Business Address',
'ownerName': 'Owner Name',
'ownerPhone': 'Owner Phone',
'ownerEmailOptional': 'Owner Email (Optional)',
'yourName': 'Your Name',
'yourPhone': 'Your Phone',
'yourEmailOptional': 'Your Email (Optional)',
'password': 'Password',
'confirmPassword': 'Confirm Password',
'chooseSubscriptionPlan': 'Choose your subscription plan',

      'recommended': 'Recommended',
      'premium': 'Premium',
      'standard': 'Standard',
      'reviewYourRegistration': 'Review Your Registration',
      'freeTrialNotice':
          'You will get 14 days free trial to test all features. After trial period, you need to make payment to continue using the service.',
      'verifyYourPhone': 'Verify Your Phone',
      'otpSentTo': 'We sent a 6-digit code to {phone}',
      'enterOTP': 'Enter OTP Code',
      'didNotReceiveOTP': "Didn't receive OTP?",
      'resendOTP': 'Resend OTP',
      'completeRegistration': 'Complete Registration',
      'verifyOTP': 'Verify OTP',
      'continue': 'Continue',
      'back': 'Back',
      'isRequired': 'is required',
      'phoneRequired': 'Phone number is required',
      'validEthiopianPhone':
          'Please enter a valid Ethiopian phone number (+251...)',
      'validEmail': 'Please enter a valid email address',
      'passwordRequired': 'Password is required',
      'passwordMinLength': 'Password must be at least 6 characters long',
      'tinRequired': 'TIN number is required',
      'tinMinLength': 'TIN number must be at least 9 characters',
      'otpRequired': 'OTP code is required',
      'otpLength': 'OTP code must be 6 digits',
      'passwordsDoNotMatch': 'Passwords do not match',
      'registrationSuccessful': 'Registration successful! Please login.',
      'otpSentToPhone': 'We sent a 6-digit verification code to {phone}',
      'enterOTPCode': 'Enter OTP Code',
      'verifyAndContinue': 'Verify & Continue',
      'didNotReceiveCode': "Didn't receive the code?",
      'resendAvailableIn': 'Resend available in {seconds} seconds',
      'forBusiness': 'For {business}',
      'otpMustBe6Digits': 'OTP must be 6 digits',
      'otpMustBeNumbers': 'OTP must contain only numbers',
      'otpResentSuccessfully': 'OTP resent successfully',
      'registrationComplete': 'Registration complete! Welcome to Andalus POS',
      'invalidOrExpiredOTP': 'Invalid or expired OTP code',
      'shopRegistration': 'Shop Registration',
      'ownerAccount': 'Owner Account',
      'payment': 'Payment',
      'setupYourShop': 'Setup Your Shop',
      'enterShopDetails': 'Enter your shop details to get started',
      'shopName': 'Shop Name',
      'shopCategory': 'Shop Category',
      'phoneNumber': 'Phone Number',
      'city': 'City',
      'country': 'Country',
      'shopCategoryRequired': 'Please select a shop category',
      'createOwnerAccount': 'Create Owner Account',
      'setupOwnerDetails': 'Setup your owner account details',
      'fullName': 'Full Name',
      'passwordRequirements': 'Password Requirements',
      'min6Characters': 'At least 6 characters',
      'recommendSpecialChars':
          '8+ characters with special characters recommended',
      'steps': 'Steps',
      'shop': 'Shop',
      'owner': 'Owner',
      'verify': 'Verify',

      // Subscription plans
      'basic': 'Basic',
      'professional': 'Professional',

      'cbeBirr': 'CBE Birr',
      'chapa': 'Chapa',
      'choosePaymentMethod': 'Choose Payment Method',
      'processPayment': 'Process Payment',
      'paymentSuccessful': 'Payment Successful',

      // Success
      'setupStaffAccounts': 'Setup Staff Accounts',
      'addAdminsCashiersManagers':
          'Add admins, cashiers, managers for your shop.',
      'getStarted': 'Get Started',
      'chooseYourPlan': 'Choose Your Plan',
      'billingCycle': 'Billing Cycle',
      'completePayment': 'Complete Payment',
      'paymentMethods': 'Payment Methods',
      'welcomeToAndalusPOS':
          'Welcome to Andalus POS! Your account is now active.',
      'loginToYourAccount': 'Login to your account',
      'loginWithPassword': 'Login with Password',
      'loginWithOTP': 'Login with OTP',
      'login': 'Login',
      'sendingOTP': 'Sending OTP...',
      'createNewBusiness': 'Create New Business',
      'otpSentSuccessfully': 'OTP sent successfully',
      'welcomeBack': 'Welcome Back',
      'enterCredentialsToContinue': 'Enter your credentials to continue',
      'featureComingSoon': 'This feature is coming soon',
      'forgotPassword': 'Forgot Password?',
      'or': 'OR',
      // 'forgotPassword': 'Forgot Password',
      'resetYourPassword': 'Reset Your Password',
      'enterPhoneToResetPassword':
          'Enter your phone number to reset your password',
      'verifyAndReset': 'Verify and Reset',
      'enterOTPAndNewPassword':
          'Enter the OTP sent to your phone and set a new password',
      // 'newPassword': 'New Password',
      // 'confirmNewPassword': 'Confirm New Password',
      'resetPassword': 'Reset Password',
      'passwordResetSuccessfully': 'Password Reset Successfully!',
      'youCanNowLoginWithNewPassword':
          'You can now login with your new password',
      'backToLogin': 'Back to Login',
      'resendingOTP': 'Resending OTP...',
      'otpVerifiedSuccessfully': 'OTP verified successfully!',
      'instantPayment': 'Instant payment',
      'mobileBanking': 'Mobile banking',
      'onlinePayment': 'Online payment',
      'securePayment': 'Secure payment',
    },
    'am': {
      'appTitle': '·ä†·äï·ã≥·àâ·àµ ·àõ·à≠·â≤·äï ·çñ·àµ',
      'dashboard': '·ã≥·àΩ·â¶·à≠·ãµ',
      'pointOfSale': '·ã®·àΩ·ã´·å≠ ·äê·å•·â•',
      'salesHistory': '·ã®·àΩ·ã´·å≠ ·â≥·à™·ä≠',
      'customers': '·ã∞·äï·â†·äû·âΩ',
      'products': '·àù·à≠·â∂·âΩ',
      'categories': '·àù·ãµ·â¶·âΩ',
      'settings': '·àõ·àµ·â∞·ä´·ä®·ã´·ãé·âΩ',
      'todayRevenue': '·ã®·ãõ·à¨ ·åà·â¢',
      'todayOrders': '·ã®·ãõ·à¨ ·âµ·ãï·ãõ·ãû·âΩ',
      'outstandingCredit': '·ã´·àç·â∞·ä®·çà·àà ·ä≠·à¨·ã≤·âµ',
      'overdue': '·â†·åä·ãú ·ã´·àç·â∞·ä®·çà·àà',
      'totalRevenue': '·å†·âÖ·àã·àã ·åà·â¢',
      'totalOrders': '·å†·âÖ·àã·àã ·âµ·ãï·ãõ·ãû·âΩ',
      'averageOrderValue': '·ä†·àõ·ä´·äù ·ã®·âµ·ãï·ãõ·ãù ·ãã·åã',
      'salesPerformance': '·ã®·àΩ·ã´·å≠ ·ä†·çà·çÉ·çÄ·àù',
      'creditOverview': '·ã®·ä≠·à¨·ã≤·âµ ·ä†·å†·âÉ·àã·ã≠ ·ä•·ã≠·â≥',
      'recentSales': '·ã®·âÖ·à≠·â• ·åä·ãú ·àΩ·ã´·åÆ·âΩ',
      'searchProducts': '·àù·à≠·â∂·âΩ·äï ·çà·àç·åç...',
      'shoppingCart': '·ã®·åç·ã¢ ·âã·àö',
      'clearAll': '·àÅ·àâ·äï·àù ·ä†·å•·çã',
      'totalAmount': '·å†·âÖ·àã·àã ·àò·å†·äï',
      'completeSale': '·àΩ·ã´·å≠ ·ä†·å†·äì·âÖ·âÖ',
      'selectPaymentMethod': '·ã®·ä≠·çç·ã´ ·ãò·ã¥ ·ã≠·àù·à®·å°',
      'cash': '·ä´·àΩ',
      'telebirr': '·â¥·àå·â•·à≠',
      // 'card': '·ä´·à≠·ãµ',
      'bankTransfer': '·â†·â£·äï·ä≠ ·àõ·àµ·â∞·àã·àà·çä·ã´',
      'credit': '·ä≠·à¨·ã≤·âµ',
      'confirm': '·ä†·à®·åã·åç·å•',
      'cancel': '·à∞·à≠·ãù',
      'businessInformation': '·ã®·äï·åç·ãµ ·àò·à®·åÉ',
      'shopNameEnglish': '·ã®·äï·åç·ãµ ·àµ·àù (·ä•·äï·åç·àä·ãù·äõ)',
      'shopNameAmharic': '·ã®·äï·åç·ãµ ·àµ·àù (·ä†·àõ·à≠·äõ)',
      'address': '·ä†·ãµ·à´·àª',
      'phone': '·àµ·àç·ä≠',
      'tinNumber': 'TIN ·âÅ·å•·à≠',
      'appearanceLanguage': '·åà·åΩ·â≥ ·ä•·äì ·âã·äï·âã',
      'themeMode': '·ã®·åà·åΩ·â≥ ·àÅ·äê·â≥',
      'language': '·âã·äï·âã',
      'light': '·â•·à≠·àÉ·äï',
      'dark': '·å®·àà·àõ',
      'systemDefault': '·ã®·àµ·à≠·ä†·âµ ·äê·â£·à™',
      'english': '·ä•·äï·åç·àä·ãù·äõ',
      'amharic': '·ä†·àõ·à≠·äõ',
      'posSettings': '·ã®·àΩ·ã´·å≠ ·äê·å•·â• ·àõ·àµ·â∞·ä´·ä®·ã´·ãé·âΩ',
      'autoPrintReceipts': '·à´·àµ-·à∞·à≠ ·ã∞·à®·à∞·äù ·ä†·âµ·àù',
      'enableCustomerSelection': '·ã∞·äï·â†·äõ ·àù·à≠·å´ ·ä†·äï·âÉ',
      'defaultPaymentMethod': '·äê·â£·à™ ·ã®·ä≠·çç·ã´ ·ãò·ã¥',
      'creditSettings': '·ã®·ä≠·à¨·ã≤·âµ ·àõ·àµ·â∞·ä´·ä®·ã´·ãé·âΩ',
      'enableCreditSystem': '·ã®·ä≠·à¨·ã≤·âµ ·àµ·à≠·ä†·âµ ·ä†·äï·âÉ',
      'defaultCreditLimit': '·äê·â£·à™ ·ã®·ä≠·à¨·ã≤·âµ ·åà·ã∞·â• (·â•·à≠)',
      'defaultPaymentTerms': '·äê·â£·à™ ·ã®·ä≠·çç·ã´ ·ãç·àé·âΩ (·âÄ·äì·âµ)',
      'syncSettings': '·ã®·àõ·àò·à≥·à∞·àç ·àõ·àµ·â∞·ä´·ä®·ã´·ãé·âΩ',
      'enableDataSync': '·ã®·ãç·àÇ·â• ·àõ·àò·à≥·à∞·àç ·ä†·äï·âÉ',
      'syncInterval': '·ã®·àõ·àò·à≥·à∞·àç ·ä≠·çç·â∞·âµ (·ã∞·âÇ·âÉ)',
      'advancedSettings': '·ã®·àã·âÄ ·àõ·àµ·â∞·ä´·ä®·ã´·ãé·âΩ',
      'enableTax': '·â≥·ä≠·àµ ·ä†·äï·âÉ',
      'taxRate': '·ã®·â≥·ä≠·àµ ·àò·å†·äï (%)',
      'enableDiscounts': '·âÖ·äì·àæ·âΩ ·ä†·äï·âÉ',
      'lowStockNotifications': '·ãù·âÖ·â∞·äõ ·ä≠·àù·âΩ·âµ ·àõ·à≥·ãà·âÇ·ã´·ãé·âΩ',
      'lowStockThreshold': '·ãù·âÖ·â∞·äõ ·ä≠·àù·âΩ·âµ ·ã∞·à®·åÉ',
      'dangerZone': '·ä†·ã∞·åã ·ãç·àµ·å• ·ã´·àà ·ä†·ä´·â£·â¢',
      'resetToDefaults': '·ãà·ã∞ ·äê·â£·à™ ·ä†·àµ·â∞·ä´·ä≠·àç',
      'noSalesToday': '·ãõ·à¨ ·àΩ·ã´·å≠ ·ã®·àà·àù',
      'noProductsFound': '·àù·äï·àù ·àù·à≠·âµ ·ä†·àç·â∞·åà·äò·àù',
      'yourCartEmpty': '·ã®·åç·ã¢ ·âã·àö·ãé ·â£·ã∂ ·äê·ãç',
      'addProductsGetStarted': '·àà·àò·åÄ·àò·à≠ ·àù·à≠·â∂·âΩ·äï ·ã´·ä≠·àâ',
      'saleCompleted': '·àΩ·ã´·å≠ ·â†·â∞·à≥·ä´ ·àÅ·äî·â≥ ·â∞·å†·äì·âÖ·âã·àç!',
      'errorLoadingData': '·ãç·àÇ·â• ·â†·àõ·àù·å£·âµ ·àã·ã≠ ·àµ·àÖ·â∞·âµ',
      'settingsSaved': '·àõ·àµ·â∞·ä´·ä®·ã´·ãé·âΩ ·â†·â∞·à≥·ä´ ·àÅ·äî·â≥ ·â∞·âÄ·àù·å†·ãã·àç!',
      'settingsReset': '·àõ·àµ·â∞·ä´·ä®·ã´·ãé·âΩ ·ãà·ã∞ ·äê·â£·à™ ·â∞·àò·àç·à∞·ãã·àç!',
      'account': '·àò·àà·ã´',
      'accountSettings': '·ã®·àò·àà·ã´ ·àõ·àµ·â∞·ä´·ä®·ã´·ãé·âΩ',
      'security': '·ã∞·àÖ·äï·äê·âµ',
      'changePassword': '·ã®·ã≠·àà·çç ·âÉ·àç ·ã≠·âÄ·ã≠·à©',
      'currentPassword': '·ä†·àÅ·äï ·ã´·àà·ãç ·ã®·ã≠·àà·çç ·âÉ·àç',
      'newPassword': '·ä†·ã≤·àµ ·ã®·ã≠·àà·çç ·âÉ·àç',
      'confirmNewPassword': '·ä†·ã≤·à±·äï ·ã®·ã≠·àà·çç ·âÉ·àç ·ã´·à®·åã·åç·å°',
      'Are you sure you want to logout?': '·ä•·à≠·åç·å†·äõ ·äê·àÖ ·àò·ãç·å£·âµ ·âµ·çà·àç·åã·àà·àÖ?',
      'weeklySales': '·ã®·à≥·àù·äï·âµ ·àΩ·ã´·å≠',
      'orders': '·âµ·ãï·ãõ·ãû·âΩ',
      'refresh': '·ä†·ãµ·àµ',
      'performanceOverview': '·ã®·ä†·çà·çÉ·çÄ·àù ·ä†·å†·âÉ·àã·ã≠ ·ä•·ã≠·â≥',
      'customersWithBalance': '·âÄ·à™ ·àÇ·à≥·â• ·ã´·àã·â∏·ãç ·ã∞·äï·â†·äû·âΩ',
      'overdueAmount': '·â†·åä·ãú ·ã´·àç·â∞·ä®·çà·àà ·àò·å†·äï',
      'databaseNeedsUpdate': '·ã®·ãç·àÇ·â• ·åé·â≥ ·àõ·ãò·àò·äï ·ã´·àµ·çà·àç·åã·àç·ç¢ ·ä•·â£·ä≠·ãé ·ä•·äï·ã∞·åà·äì ·ã≠·àû·ä≠·à©·ç¢',
      'tryAgain': '·ä•·äï·ã∞·åà·äì ·àû·ä≠·à≠',
      'up': '·àò·ãç·å£·âµ',
      'down': '·àò·ãç·à®·ãµ',
      'sale': '·àΩ·ã´·å≠',
      'today': '·ãõ·à¨',
      'completeFirstSale': '·àà·àõ·ã®·âµ ·ã®·àò·åÄ·àò·à™·ã´ ·àΩ·ã´·å≠·ãé·äï ·ã´·å†·äì·âÖ·âÅ!',
      'stockAlert': '·ã®·ä≠·àù·âΩ·âµ ·àõ·àµ·å†·äï·âÄ·âÇ·ã´',
      'quickActions': '·çà·å£·äï ·ä•·à≠·àù·åÉ·ãé·âΩ',
      'newSale': '·ä†·ã≤·àµ ·àΩ·ã´·å≠',
      'addProduct': '·àù·à≠·âµ ·å®·àù·à≠',
      'addCustomer': '·ã∞·äï·â†·äõ ·å®·àù·à≠',
      'reports': '·à™·çñ·à≠·â∂·âΩ',
      'salesAnalytics': '·ã®·àΩ·ã´·å≠ ·âµ·äï·â≥·äî',
      'chartsComingSoon': '·âª·à≠·â∂·âΩ ·â†·âÖ·à≠·â• ·ã≠·àò·å£·àâ',
      'installFlChart': '·àà·àö·ã´·àù·à© ·âµ·äï·â≥·äî·ãé·âΩ fl_chart ·å´·äï',
      'allProductsWellStocked': '·àÅ·àâ·àù ·àù·à≠·â∂·âΩ ·â†·ã∞·äï·â• ·â∞·âÄ·àù·å†·ãã·àç',
      'moreProducts': '+{count} ·â∞·å®·àõ·à™ ·àù·à≠·â∂·âΩ',
      'left': '·âÄ·à≠·â∑·àç',
      'calendarSettings': '·ã®·âÄ·äï ·àò·âÅ·å†·à™·ã´ ·àõ·àµ·â∞·ä´·ä®·ã´·ãé·âΩ',
      'calendarType': '·ã®·âÄ·äï ·àò·âÅ·å†·à™·ã´ ·ä†·ã≠·äê·âµ',
      'calendarDescription':
          '·â†·àò·â∞·åç·â†·à™·ã´·ãç ·ãç·àµ·å• ·àà·âÄ·äï ·àõ·à≥·ã´ ·åç·à™·åé·à≠·ã´·äï ·ä•·äì ·ä¢·âµ·ãÆ·åµ·ã´·ãä ·âÄ·äï ·àò·âÅ·å†·à™·ã´ ·àµ·à≠·ãì·â∂·âΩ·äï ·ã≠·àù·à®·å°',
      'fontSize': '·ã®·çä·ã∞·àç ·àò·å†·äï',
      'small': '·âµ·äï·àΩ',
      'large': '·âµ·àç·âÖ',
      'items sold': '·ã®·â∞·à∏·å° ·ä•·âÉ·ãé·âΩ',
      'with balance': '·âÄ·à™ ·àí·à≥·â• ·ã´·àã·â∏·ãç',
      'outstanding': '·ã´·àç·â∞·ä®·çà·àà',
      'thisMonth': '·â†·ãö·àÖ ·ãà·à≠',
      'productsReport': '·ã®·àù·à≠·â∂·âΩ ·à™·çñ·à≠·âµ',
      'customersReport': '·ã®·ã∞·äï·â†·äû·âΩ ·à™·çñ·à≠·âµ',
      'financialReport': '·ã®·çã·ã≠·äì·äï·àµ ·à™·çñ·à≠·âµ',
      'selectDateRange': '·ã®·âÄ·äï ·ä≠·àç·àç ·ã≠·àù·à®·å°',
      'basicPlanFeatures': '·àò·à∞·à®·â≥·ãä ·ä•·âÖ·ãµ: ·àò·à∞·à®·â≥·ãä ·à™·çñ·à≠·â∂·âΩ ·ã≠·åà·äõ·àâ',
      'professionalPlanFeatures': '·çï·àÆ·çå·àΩ·äì·àç ·ä•·âÖ·ãµ: ·ã®·àã·âÄ ·âµ·äï·â≥·äî ·ã≠·åà·äõ·àç',
      'enterprisePlanFeatures': '·ä¢·äï·â∞·à≠·çï·à´·ã≠·ãù ·ä•·âÖ·ãµ: ·àô·àâ ·âµ·äï·â≥·äî ·ã≠·åà·äõ·àç',
      'plan': '·ä•·âÖ·ãµ',
      'basicReportsDescription': '·àò·à∞·à®·â≥·ãä ·ã®·àΩ·ã´·å≠ ·à™·çñ·à≠·â∂·âΩ ·ä•·äì ·âµ·äï·â≥·äî',
      'professionalReportsDescription': '·ã®·àã·âÄ ·ã®·àù·à≠·âµ ·ä•·äì ·ã®·ã∞·äï·â†·äû·âΩ ·âµ·äï·â≥·äî',
      'enterpriseReportsDescription': '·àô·àâ ·ã®·çã·ã≠·äì·äï·àµ ·ä•·äì ·âµ·äï·â†·ã´ ·âµ·äï·â≥·äî',
      'upgradeForAdvancedReports': '·àà·àã·âÄ ·à™·çñ·à≠·â∂·âΩ ·ä†·àª·àΩ·àç',
      'upgrade': '·ä†·àª·àΩ·àç',
      'professionalPlanRequired': '·çï·àÆ·çå·àΩ·äì·àç ·ä•·âÖ·ãµ ·ã´·àµ·çà·àç·åã·àç',
      'enterprisePlanRequired': '·ä¢·äï·â∞·à≠·çï·à´·ã≠·ãù ·ä•·âÖ·ãµ ·ã´·àµ·çà·àç·åã·àç',
      'productsReportAvailableInPlan': '·ã®·àù·à≠·â∂·âΩ ·à™·çñ·à≠·âµ ·â†{plan} ·ä•·âÖ·ãµ ·ã≠·åà·äõ·àç',
      'customersReportAvailableInPlan': '·ã®·ã∞·äï·â†·äû·âΩ ·à™·çñ·à≠·âµ ·â†{plan} ·ä•·âÖ·ãµ ·ã≠·åà·äõ·àç',
      'financialReportAvailableInPlan': '·ã®·çã·ã≠·äì·äï·àµ ·à™·çñ·à≠·âµ ·â†{plan} ·ä•·âÖ·ãµ ·ã≠·åà·äõ·àç',
      'upgradeYourPlan': '·ä•·âÖ·ãµ·ãé·äï ·ä†·àª·àΩ·àç',
      'upgradeForAdvancedAnalytics': '·ã®·àã·âÄ ·âµ·äï·â≥·äî ·ä•·äì ·ã®·à™·çñ·à≠·âµ ·â£·àÖ·à™·ã´·âµ·äï ·àà·àõ·åç·äò·âµ ·ä†·àª·àΩ·àç·ç¢',
      'viewPlans': '·ä•·âÖ·ã∂·âΩ·äï ·ã≠·àò·àç·ä®·â±',
      'salesByPaymentMethod': '·â†·ä≠·çç·ã´ ·ãò·ã¥ ·àΩ·ã´·å≠',
      'revenueByDay': '·â†·âÄ·äï ·åà·â¢',
      'dailySalesTrend': '·ãï·àà·â≥·ãä ·ã®·àΩ·ã´·å≠ ·ä†·ãù·àõ·àö·ã´',
      'topSellingHours': '·ä®·çç·â∞·äõ ·ã®·àΩ·ã´·å≠ ·à∞·ãì·â≥·âµ',
      'customerRetention': '·ã®·ã∞·äï·â†·äû·âΩ ·àò·å†·â£·â†·âÇ·ã´',
      'salesVelocity': '·ã®·àΩ·ã´·å≠ ·çç·å•·äê·âµ',
      'profitMarginAnalysis': '·ã®·âµ·à≠·çç ·àÖ·ã≥·åç ·âµ·äï·â≥·äî',
      'inventoryTurnover': '·ã®·ä≠·àù·âΩ·âµ ·àõ·ãû·à™·ã´',
      'abcAnalysis': 'ABC ·âµ·äï·â≥·äî',
      'stockOptimization': '·ã®·ä≠·àù·âΩ·âµ ·àõ·àò·âª·â∏·âµ',
      'productsOverview': '·ã®·àù·à≠·â∂·âΩ ·ä†·å†·âÉ·àã·ã≠ ·ä•·ã≠·â≥',
      'totalProducts': '·å†·âÖ·àã·àã ·àù·à≠·â∂·âΩ',
      'lowStock': '·ãù·âÖ·â∞·äõ ·ä≠·àù·âΩ·âµ',
      'outOfStock': '·ã®·â∞·å†·äì·âÄ·âÄ',
      'topSellingProducts': '·ä®·çç·â∞·äõ ·ã®·àö·à∏·å° ·àù·à≠·â∂·âΩ',
      'sold': '·â∞·à∏·åß·àç',
      'customersOverview': '·ã®·ã∞·äï·â†·äû·âΩ ·ä†·å†·âÉ·àã·ã≠ ·ä•·ã≠·â≥',
      'topCustomers': '·ä®·çç·â∞·äõ ·ã∞·äï·â†·äû·âΩ',
      'customerAcquisition': '·ã®·ã∞·äï·â†·äû·âΩ ·àò·åç·ãõ·âµ',
      'averageCustomerValue': '·ä†·àõ·ä´·äù ·ã®·ã∞·äï·â†·äõ ·ãã·åã',
      'customerLifetimeValue': '·ã®·ã∞·äï·â†·äõ ·ã®·àÖ·ã≠·ãà·âµ ·ãò·àò·äï ·ãã·åã',
      'churnRiskAnalysis': '·ã®·ã∞·äï·â†·äõ ·àò·å•·çã·âµ ·ä†·ã∞·åã ·âµ·äï·â≥·äî',
      'financialOverview': '·ã®·çã·ã≠·äì·äï·àµ ·ä†·å†·âÉ·àã·ã≠ ·ä•·ã≠·â≥',
      'revenueTrend': '·ã®·åà·â¢ ·ä†·ãù·àõ·àö·ã´',
      'profitMarginTrend': '·ã®·âµ·à≠·çç ·àÖ·ã≥·åç ·ä†·ãù·àõ·àö·ã´',
      'cashFlowAnalysis': '·ã®·åà·äï·ãò·â• ·çç·à∞·âµ ·âµ·äï·â≥·äî',
      'financialRatios': '·ã®·çã·ã≠·äì·äï·àµ ·à¨·àæ·ãé·âΩ',
      'breakEvenAnalysis': '·ã®·âµ·à≠·çç-·ã®·ãà·å™ ·âµ·äï·â≥·äî',
      'advancedAnalyticsFeature': '·ã®·àã·âÄ ·âµ·äï·â≥·äî ·â£·àÖ·à™ ·â†·ä®·çç·â∞·äõ ·ä•·âÖ·ã∂·âΩ ·ã≠·åà·äõ·àç',
      'yesterday': '·âµ·àã·äï·âµ',
      'thisWeek': '·â†·ãö·àÖ ·à≥·àù·äï·âµ',
      'lastWeek': '·ã´·àà·çà·ãç ·à≥·àù·äï·âµ',
      'lastMonth': '·ã´·àà·çà·ãç ·ãà·à≠',
      'last3Months': '·ã´·àà·çâ·âµ 3 ·ãà·à´·âµ',
      'last6Months': '·ã´·àà·çâ·âµ 6 ·ãà·à´·âµ',
      'thisYear': '·â†·ãö·àÖ ·ãì·àò·âµ',
      'lastYear': '·ã´·àà·çà·ãç ·ãì·àò·âµ',
      'subscriptionPlans': '·ã®·ã∞·äï·â†·äù·äê·âµ ·ä•·âÖ·ã∂·âΩ',
      'choosePerfectPlan': '·àà·äï·åç·ãµ·ãé ·â∞·àµ·àõ·àö ·ä•·âÖ·ãµ ·ã≠·àù·à®·å°',
      'startWithFreeTrial': '·â†14 ·âÄ·äì·âµ ·äê·çÉ ·àô·ä®·à´ ·ã≠·åÄ·àù·à©·ç¢ ·ã®·ä≠·à¨·ã≤·âµ ·ä´·à≠·ãµ ·ä†·ã´·àµ·çà·àç·åç·àù·ç¢',
      'monthly': '·ãà·à≠·àÉ·ãä',
      'yearly': '·ãì·àò·â≥·ãä',
      'save20Percent': '20% ·ã≠·âÜ·å•·â°',
      'popular': '·â∞·ãà·ã≥·åÖ',
      'selected': '·â∞·àò·à≠·åß·àç',
      'selectPlan': '·ä•·âÖ·ãµ ·ã≠·àù·à®·å°',
      'paymentMethod': '·ã®·ä≠·çç·ã´ ·ãò·ã¥',
      'card': '·ä≠·à¨·ã≤·âµ/·ã≤·â¢·âµ ·ä´·à≠·ãµ',
      'orderSummary': '·ã®·âµ·ãï·ãõ·ãù ·àõ·å†·âÉ·àà·ã´',
      // 'plan': '·ä•·âÖ·ãµ',
      'price': '·ãã·åã',
      'tax': '·â≥·ä≠·àµ',
      'total': '·å†·âÖ·àã·àã',
      'subscribeNow': '·ä†·àÅ·äï ·ã≠·àò·ãù·åà·â°',
      'salesOverview': '·ã®·àΩ·ã´·å≠ ·ä†·å†·âÉ·àã·ã≠ ·ä•·ã≠·â≥',
      'item': '·ä•·âÉ',
      'qty': '·â•·ãõ·âµ',
      'subtotal': '·äï·ãë·àµ ·ãµ·àù·à≠',
      'discount': '·âÖ·äì·àΩ',
      'telebirrReference': '·â¥·àå·â•·à≠ ·àõ·å£·âÄ·àª',
      'thankYou': '·àà·äï·åç·ãµ·ãé ·ä•·äì·àò·à∞·åç·äì·àà·äï!',
      'receipt': '·ã∞·à®·à∞·äù',
      'time': '·à∞·ãì·âµ',
      'scanBarcode': '·â£·à≠·äÆ·ãµ ·ã≠·âÉ·äô',
      'scan': '·âÉ·äù',
      'selectCustomer': '·ã∞·äï·â†·äõ ·ã≠·àù·à®·å°',
      'creditAvailable': '·ã®·àö·åà·äù ·ä≠·à¨·ã≤·âµ',
      'connectedTo': '·â∞·åà·äì·äù·â∑·àç',
      'noPrinterConnected': '·àù·äï·àù ·çï·à™·äï·â∞·à≠ ·ä†·àç·â∞·åà·äì·äò·àù',
      'testPrint': '·ã∞·à®·à∞·äù ·ä†·âµ·àù',
      'tryAdjustingSearch': '·çç·àà·åã·ãé·äï ·ã´·àµ·â∞·ä´·ä≠·àâ ·ãà·ã≠·àù ·ä†·ã≤·àµ ·àù·à≠·â∂·âΩ·äï ·ã´·ä≠·àâ',
      'registerBusiness': '·ã®·äï·åç·ãµ ·à•·à´ ·àù·ãù·åà·â£',
      'adminAccount': '·ã®·ä†·àµ·â∞·ã≥·ã≥·à™ ·àò·àà·ã´',
      'subscriptionPlan': '·ã®·ã∞·äï·â†·äù·äê·âµ ·ä†·âÖ·àù',
      'reviewRegistration': '·åç·àù·åà·àõ ·ä•·äì ·àõ·å†·äì·âÄ·âÖ',
      'verifyPhone': '·àµ·àç·ä≠ ·àõ·à®·åã·åà·å´',
      'businessNameEnglish': '·ã®·äï·åç·ãµ ·à•·à´ ·àµ·àù (·ä•·äï·åç·àä·ãù·äõ)',
      'businessNameAmharic': '·ã®·äï·åç·ãµ ·à•·à´ ·àµ·àù (·ä†·àõ·à≠·äõ)',
      'businessPhone': '·ã®·äï·åç·ãµ ·à•·à´ ·àµ·àç·ä≠',
      'businessEmailOptional': '·ã®·äï·åç·ãµ ·à•·à´ ·ä¢·àú·ã≠·àç (·ä†·àõ·à´·å≠)',
      'businessAddress': '·ã®·äï·åç·ãµ ·à•·à´ ·ä†·ãµ·à´·àª',
      'ownerName': '·ã®·â£·àà·â§·âµ ·àµ·àù',
      'ownerPhone': '·ã®·â£·àà·â§·âµ ·àµ·àç·ä≠',
      'ownerEmailOptional': '·ã®·â£·àà·â§·âµ ·ä¢·àú·ã≠·àç (·ä†·àõ·à´·å≠)',
      'yourName': '·àµ·àù·ãé',
      'yourPhone': '·àµ·àç·ä≠·ãé',
      'yourEmailOptional': '·ä¢·àú·ã≠·àç·ãé (·ä†·àõ·à´·å≠)',
      'password': '·ã®·ã≠·àà·çç ·âÉ·àç',
      'confirmPassword': '·ã®·ã≠·àà·çç ·âÉ·àç ·ä†·à®·åã·åç·å•',
      'chooseSubscriptionPlan': '·ã®·ã∞·äï·â†·äù·äê·âµ ·ä†·âÖ·àù·ãé·äï ·ã≠·àù·à®·å°',
      'recommended': '·ã®·àö·àò·ä®·à≠',
      'premium': '·çï·à™·àö·ã®·àù',
      'standard': '·àò·ã∞·â†·äõ',
      'reviewYourRegistration': '·àù·ãù·åà·â£·ãé·äï ·ã≠·åà·àù·åç·àô',
      'freeTrialNotice':
          '·àÅ·àâ·äï·àù ·â£·àÖ·à™·ã´·âµ ·àà·àò·àû·ä®·à≠ 14 ·âÄ·äì·âµ ·äê·çÉ ·àô·ä®·à´ ·ã´·åà·äõ·àâ·ç¢ ·ä®·àô·ä®·à´ ·åä·ãú ·â†·äã·àã ·ä†·åà·àç·åç·àé·â±·äï ·àà·àò·å†·âÄ·àù ·ä≠·çç·ã´ ·àõ·ãµ·à®·åç ·ã´·àµ·çà·àç·åç·ãé·â≥·àç·ç¢',
      'verifyYourPhone': '·àµ·àç·ä≠·ãé·äï ·ã´·à®·åã·åç·å°',
      'otpSentTo': '6-·ä†·àÉ·ãù ·äÆ·ãµ ·ãà·ã∞ {phone} ·àç·ä®·äì·àç',
      'enterOTP': 'OTP ·äÆ·ãµ ·ã´·àµ·åà·â°',
      'didNotReceiveOTP': 'OTP ·ä†·àç·ã∞·à®·à∞·àù?',
      'resendOTP': 'OTP ·ä•·äï·ã∞·åà·äì ·àã·ä≠',
      'completeRegistration': '·àù·ãù·åà·â£·ãç·äï ·ã≠·å®·à≠·à±',
      'verifyOTP': 'OTP ·ä†·à®·åã·åç·å•',
      'continue': '·âÄ·å•·àç',
      'back': '·â∞·àò·àà·àµ',
      'isRequired': '·ã´·àµ·çà·àç·åã·àç',
      'phoneRequired': '·àµ·àç·ä≠ ·âÅ·å•·à≠ ·ã´·àµ·çà·àç·åã·àç',
      'validEthiopianPhone': '·ä•·â£·ä≠·ãé ·âµ·ä≠·ä≠·àà·äõ ·ã®·ä¢·âµ·ãÆ·åµ·ã´ ·àµ·àç·ä≠ ·âÅ·å•·à≠ ·ã´·àµ·åà·â° (+251...)',
      'validEmail': '·ä•·â£·ä≠·ãé ·âµ·ä≠·ä≠·àà·äõ ·ä¢·àú·ã≠·àç ·ä†·ãµ·à´·àª ·ã´·àµ·åà·â°',
      'passwordRequired': '·ã®·ã≠·àà·çç ·âÉ·àç ·ã´·àµ·çà·àç·åã·àç',
      'passwordMinLength': '·ã®·ã≠·àà·çç ·âÉ·àç ·â¢·ã´·äï·àµ 6 ·âÅ·àù·çä ·à≠·ãù·àò·âµ ·àä·äñ·à®·ãç ·ã≠·åà·â£·àç',
      'tinRequired': 'TIN ·âÅ·å•·à≠ ·ã´·àµ·çà·àç·åã·àç',
      'tinMinLength': 'TIN ·âÅ·å•·à≠ ·â¢·ã´·äï·àµ 9 ·âÅ·àù·çä ·à≠·ãù·àò·âµ ·àä·äñ·à®·ãç ·ã≠·åà·â£·àç',
      'otpRequired': 'OTP ·äÆ·ãµ ·ã´·àµ·çà·àç·åã·àç',
      'otpLength': 'OTP ·äÆ·ãµ 6 ·ä†·àÉ·ãù ·àä·äñ·à®·ãç ·ã≠·åà·â£·àç',
      'passwordsDoNotMatch': '·ã®·ã≠·àà·çç ·âÉ·àã·âµ ·ä†·ã≠·àò·à≥·à∞·àâ·àù',
      'registrationSuccessful': '·àù·ãù·åà·â£ ·â†·â∞·à≥·ä´ ·àÅ·äî·â≥ ·â∞·å†·äì·âã·àç! ·ä•·â£·ä≠·ãé ·ã≠·åç·â°·ç¢',
      'otpSentToPhone': '6-·ä†·àÉ·ãù ·àõ·à®·åã·åà·å´ ·äÆ·ãµ ·ãà·ã∞ {phone} ·àç·ä®·äì·àç',
      'enterOTPCode': 'OTP ·äÆ·ãµ ·ã´·àµ·åà·â°',
      'verifyAndContinue': '·ã´·à®·åã·åç·å° ·ä•·äì ·ã≠·âÄ·å•·àâ',
      'didNotReceiveCode': '·äÆ·ãµ ·ä†·àç·ã∞·à®·à∞·àù?',
      'resendAvailableIn': '·ä•·äï·ã∞·åà·äì ·àà·àò·àã·ä≠ ·â† {seconds} ·à∞·ä®·äï·ãµ ·ãç·àµ·å• ·ã≠·åà·äõ·àç',
      'forBusiness': '·àà {business}',
      'otpMustBe6Digits': 'OTP 6 ·ä†·àÉ·ãù ·àò·àÜ·äï ·ä†·àà·â†·âµ',
      'otpMustBeNumbers': 'OTP ·âÅ·å•·àÆ·âΩ ·â•·âª ·àä·äñ·à©·âµ ·ã≠·åà·â£·àç',
      'otpResentSuccessfully': 'OTP ·â†·â∞·à≥·ä´ ·àÅ·äî·â≥ ·ä•·äï·ã∞·åà·äì ·â∞·àç·â∑·àç',
      'registrationComplete': '·àù·ãù·åà·â£ ·â∞·å†·äì·âÖ·âã·àç! ·ãà·ã∞ ·ä†·äï·ã≥·àâ·àµ POS ·ä•·äï·ä≥·äï ·â†·ã∞·àÖ·äì ·àò·å°',
      'invalidOrExpiredOTP': '·àç·ä≠ ·ã´·àç·àÜ·äê ·ãà·ã≠·àù ·åä·ãú·ãç ·ã´·àà·çà ·ã®OTP ·äÆ·ãµ',
      'shopRegistration': '·ã®·à±·âÖ ·àù·ãù·åà·â£',
      'ownerAccount': '·ã®·â£·àà·â§·âµ ·àò·àà·ã´',
      'payment': '·ä≠·çç·ã´',
      'setupYourShop': '·à±·âÖ·ãé·äï ·ã´·ãò·åã·åÅ',
      'enterShopDetails': '·àà·àò·åÄ·àò·à≠ ·ã®·à±·âÖ·ãé·äï ·ãù·à≠·ãù·àÆ·âΩ ·ã´·àµ·åà·â°',
      'shopName': '·ã®·à±·âÖ ·àµ·àù',
      'shopCategory': '·ã®·à±·âÖ ·àù·ãµ·â•',
      'phoneNumber': '·àµ·àç·ä≠ ·âÅ·å•·à≠',
      'city': '·ä®·â∞·àõ',
      'country': '·ä†·åà·à≠',
      'shopCategoryRequired': '·ä•·â£·ä≠·ãé ·ã®·à±·âÖ ·àù·ãµ·â• ·ã≠·àù·à®·å°',
      'createOwnerAccount': '·ã®·â£·àà·â§·âµ ·àò·àà·ã´ ·ã≠·çç·å†·à©',
      'setupOwnerDetails': '·ã®·â£·àà·â§·âµ ·àò·àà·ã´ ·ãù·à≠·ãù·àÆ·âΩ·ãé·äï ·ã´·ãò·åã·åÅ',
      'fullName': '·àô·àâ ·àµ·àù',
      'passwordRequirements': '·ã®·ã≠·àà·çç ·âÉ·àç ·àò·àµ·çà·à≠·â∂·âΩ',
      'min6Characters': '·â¢·ã´·äï·àµ 6 ·çä·ã∞·àé·âΩ',
      'recommendSpecialChars': '8+ ·çä·ã∞·àé·âΩ ·ä®·àç·ã© ·àù·àç·ä≠·â∂·âΩ ·åã·à≠ ·ã≠·àò·ä®·à´·àç',
      'steps': '·ã∞·à®·åÉ·ãé·âΩ',
      'shop': '·à±·âÖ',
      'owner': '·â£·àà·â§·âµ',
      'verify': '·àõ·à®·åã·åà·å´',
      'basic': '·àò·à∞·à®·â≥·ãä',
      'professional': '·çï·àÆ·çå·àΩ·äì·àç',
      'cbeBirr': 'CBE ·â•·à≠',
      'chapa': '·âª·çì',
      'choosePaymentMethod': '·ã®·ä≠·çç·ã´ ·ãò·ã¥ ·ã≠·àù·à®·å°',
      'processPayment': '·ä≠·çç·ã´ ·ã´·àµ·åà·â°',
      'paymentSuccessful': '·ä≠·çç·ã´ ·â∞·à≥·ä≠·â∑·àç',
      'setupStaffAccounts': '·ã®·à∞·à´·â∞·äû·âΩ ·àò·àà·ã´·ãé·âΩ·äï ·ã´·ãò·åã·åÅ',
      'addAdminsCashiersManagers': '·àà·à±·âÖ·ãé ·ä†·àµ·â∞·ã≥·ã≥·à™·ãé·âΩ·ç£ ·ä´·à∫·ãé·âΩ·ç£ ·ä†·àµ·â∞·ã≥·ã≥·à™·ãé·âΩ ·ã´·ä≠·àâ',
      'getStarted': '·åÄ·àù·à≠',
      'chooseYourPlan': '·ä•·âÖ·ãµ·ãé·äï ·ã≠·àù·à®·å°',
      'billingCycle': '·ã®·ä≠·çç·ã´ ·ãë·ã∞·âµ',
      'completePayment': '·ä≠·çç·ã´·ãç·äï ·ã≠·å®·à≠·à±',
      'paymentMethods': '·ã®·ä≠·çç·ã´ ·ãò·ã¥·ãé·âΩ',
      'welcomeToAndalusPOS': '·ãà·ã∞ ·ä†·äï·ã≥·àâ·àµ POS ·ä•·äï·ä≥·äï ·â†·ã∞·àÖ·äì ·àò·å°! ·àò·àà·ã´·ãé ·ä†·àÅ·äï ·äê·âÖ·â∑·àç·ç¢',
      'loginToYourAccount': '·ãà·ã∞ ·àò·àà·ã´·ãé ·ã≠·åç·â°',
      'loginWithPassword': '·â†·ã≠·àà·çç ·âÉ·àç ·ã≠·åç·â°',
      'loginWithOTP': '·â†OTP ·ã≠·åç·â°',
      'login': '·åç·â£',
      'sendingOTP': 'OTP ·â†·àõ·àµ·â∞·àã·àà·çç ·àã·ã≠...',
      'createNewBusiness': '·ä†·ã≤·àµ ·äï·åç·ãµ ·ã≠·çç·å†·à©',
      'otpSentSuccessfully': 'OTP ·â†·â∞·à≥·ä´ ·àÅ·äî·â≥ ·â∞·àç·â∑·àç',
      'WelcomeBack': '·ä•·äï·ä≥·äï ·ã∞·åç·àû ·â†·ã∞·àÖ·äì ·àò·å°!',
      'enterCredentialsToContinue': '·ã®·åç·â£ ·ãù·à≠·ãù·àÆ·âΩ·ãé·äï ·ã´·àµ·åà·â°',
      'featureComingSoon': '·â†·âÖ·à≠·â• ·ã≠·å†·â•·âÅ·äï!',
      'forgotPassword': '·ã®·ã≠·àà·çç ·âÉ·àç·ãé·äï ·à®·àµ·â∞·ãã·àç?',
      'or': '·ãà·ã≠·àù',
      // 'forgotPassword': 'Forgot Password',
      'resetYourPassword': '·ã®·ã≠·àà·çç ·âÉ·àç·ãé·äï ·ã≠·âÄ·ã≠·à©',
      'enterPhoneToResetPassword': '·ã®·ã≠·àà·çç ·âÉ·àç ·àà·àò·âÄ·ã®·à≠ ·àµ·àç·ä≠ ·âÅ·å•·à≠·ãé·äï ·ã´·àµ·åà·â°',
      'verifyAndReset': '·ã´·à®·åã·åç·å° ·ä•·äì ·ã≠·âÄ·ã≠·à©',
      'enterOTPAndNewPassword':
          '·ãà·ã∞ ·àµ·àç·ä≠·ãé ·ã®·â∞·àã·ä®·ãç·äï OTP ·äÆ·ãµ ·ã´·àµ·åà·â° ·ä•·äì ·ä†·ã≤·àµ ·ã®·ã≠·àà·çç ·âÉ·àç ·ã´·àµ·âÄ·àù·å°',
      // 'newPassword': 'New Password',
      // 'confirmNewPassword': 'Confirm New Password',
      'resetPassword': '·ã®·ã≠·àà·çç ·âÉ·àç ·ã≠·âÄ·ã≠·à©',
      'passwordResetSuccessfully': '·ã®·ã≠·àà·çç ·âÉ·àç·ãé ·â†·â∞·à≥·ä´ ·àÅ·äî·â≥ ·â∞·âÄ·ã≠·àØ·àç!',
      'youCanNowLoginWithNewPassword': '·ä†·àÅ·äï ·â†·ä†·ã≤·à± ·ã®·ã≠·àà·çç ·âÉ·àç ·àò·åç·â£·âµ ·ã≠·âΩ·àã·àâ·ç¢',
      'backToLogin': '·ãà·ã∞ ·àò·åç·â¢·ã´·ãâ ·ã≠·àò·àà·à±',
      'resendingOTP': 'OTP ·ä•·äï·ã∞·åà·äì ·â†·àò·àã·ä≠ ·àã·ã≠...',
      'otpVerifiedSuccessfully': 'OTP ·â†·â∞·à≥·ä´ ·àÅ·äî·â≥ ·â∞·à®·åã·åç·åß·àç!',
      'instantPayment': '·ä†·åà·äì·äù ·ä≠·çç·ã´',
      'mobileBanking': '·àû·â£·ã≠·àç ·â£·äï·ä™·äï·åç',
      'onlinePayment': '·àò·àµ·àò·à≠ ·àã·ã≠ ·ä≠·çç·ã´',
      'securePayment': '·ã∞·àÖ·äï·äê·â≥·ãä ·ä≠·çç·ã´',
    }

};

String translate(String key, {Map<String, String>? params}) {
String translation = \_localizedValues[locale.languageCode]?[key] ?? key;

    if (params != null) {
      params.forEach((paramKey, paramValue) {
        translation = translation.replaceAll('{$paramKey}', paramValue);
      });
    }

    return translation;

}

// Convenience methods for common translations
String get appTitle => translate('appTitle');
String get dashboard => translate('dashboard');
String get pointOfSale => translate('pointOfSale');
String get salesHistory => translate('salesHistory');
String get customers => translate('customers');
String get products => translate('products');
String get categories => translate('categories');
String get settings => translate('settings');
String get todayRevenue => translate('todayRevenue');
String get todayOrders => translate('todayOrders');
String get searchProducts => translate('searchProducts');
String get shoppingCart => translate('shoppingCart');
String get totalAmount => translate('totalAmount');
String get completeSale => translate('completeSale');
String get light => translate('light');
String get dark => translate('dark');
String get systemDefault => translate('systemDefault');
String get english => translate('english');
String get amharic => translate('amharic');
String get themeMode => translate('themeMode');
String get language => translate('language');
String get appearanceLanguage => translate('appearanceLanguage');
String get businessInformation => translate('businessInformation');
String get shopNameEnglish => translate('shopNameEnglish');
String get shopNameAmharic => translate('shopNameAmharic');
String get address => translate('address');
String get phone => translate('phone');
String get tinNumber => translate('tinNumber');
String get account => translate('account');
String get accountSettings => translate('accountSettings');
String get security => translate('security');
String get changePassword => translate('changePassword');
String get currentPassword => translate('currentPassword');
String get newPassword => translate('newPassword');
String get confirmNewPassword => translate('confirmNewPassword');
String get weeklySales => translate('weeklySales');
String get orders => translate('orders');
String get refresh => translate('refresh');
String get performanceOverview => translate('performanceOverview');
String get customersWithBalance => translate('customersWithBalance');
String get overdueAmount => translate('overdueAmount');
String get today => translate('today');
String get completeFirstSale => translate('completeFirstSale');
String get stockAlert => translate('stockAlert');
String get quickActions => translate('quickActions');
String get newSale => translate('newSale');
String get addProduct => translate('addProduct');
String get addCustomer => translate('addCustomer');
String get reports => translate('reports');
String get salesAnalytics => translate('salesAnalytics');
String get chartsComingSoon => translate('chartsComingSoon');
String get installFlChart => translate('installFlChart');
String get cash => translate('cash');
String get telebirr => translate('telebirr');
String get card => translate('card');
String get credit => translate('credit');
String get bankTransfer => translate('bankTransfer');
String get errorLoadingData => translate('errorLoadingData');
String get settingsSaved => translate('settingsSaved');
String get settingsReset => translate('settingsReset');
String get databaseNeedsUpdate => translate('databaseNeedsUpdate');
String get tryAgain => translate('tryAgain');
String get up => translate('up');
String get down => translate('down');
String get sale => translate('sale');
String get recentSales => translate('recentSales');
String get noSalesToday => translate('noSalesToday');
String get noProductsFound => translate('noProductsFound');
String get yourCartEmpty => translate('yourCartEmpty');
String get addProductsGetStarted => translate('addProductsGetStarted');
String get saleCompleted => translate('saleCompleted');
String get areYouSureYouWantToLogout =>
translate('Are you sure you want to logout?');
String get clearAll => translate('clearAll');
String get selectPaymentMethod => translate('selectPaymentMethod');
String get confirm => translate('confirm');
String get cancel => translate('cancel');
String get defaultPaymentMethod => translate('defaultPaymentMethod');
String get posSettings => translate('posSettings');
String get autoPrintReceipts => translate('autoPrintReceipts');
String get enableCustomerSelection => translate('enableCustomerSelection');
String get creditSettings => translate('creditSettings');
String get enableCreditSystem => translate('enableCreditSystem');
String get defaultCreditLimit => translate('defaultCreditLimit');
String get defaultPaymentTerms => translate('defaultPaymentTerms');
String get syncSettings => translate('syncSettings');
String get enableDataSync => translate('enableDataSync');
String get syncInterval => translate('syncInterval');
String get advancedSettings => translate('advancedSettings');
String get enableTax => translate('enableTax');
String get taxRate => translate('taxRate');
String get enableDiscounts => translate('enableDiscounts');
String get lowStockNotifications => translate('lowStockNotifications');
String get lowStockThreshold => translate('lowStockThreshold');
String get dangerZone => translate('dangerZone');
String get resetToDefaults => translate('resetToDefaults');
String get tryAgainText => translate('tryAgain');
String get todayOrdersText => translate('todayOrders');
String get noOrdersToday => translate('noOrdersToday');
String get noOrdersTodayText => translate('noOrdersTodayText');
String get averageOrderValue => translate('averageOrderValue');
String get totalRevenue => translate('totalRevenue');
String get totalOrders => translate('totalOrders');
String get salesPerformance => translate('salesPerformance');
String get creditOverview => translate('creditOverview');
String get outstandingCredit => translate('outstandingCredit');
String get overdue => translate('overdue');
String get moreProducts => translate('moreProducts');
String get allProductsWellStocked => translate('allProductsWellStocked');
String get left => translate('left');
String get calendarSettings => translate('calendarSettings');
String get calendarType => translate('calendarType');
String get calendarDescription => translate('calendarDescription');
String get fontSize => translate('fontSize');
String get small => translate('small');
String get large => translate('large');
String get itemsSold => translate('items sold');
String get withBalance => translate('with balance');
String get outstanding => translate('outstanding');
String get thisMonth => translate('thisMonth');
String get productsReport => translate('productsReport');
String get customersReport => translate('customersReport');
String get financialReport => translate('financialReport');
String get selectDateRange => translate('selectDateRange');
String get basicPlanFeatures => translate('basicPlanFeatures');
String get professionalPlanFeatures => translate('professionalPlanFeatures');
String get enterprisePlanFeatures => translate('enterprisePlanFeatures');
String get plan => translate('plan');
String get basicReportsDescription => translate('basicReportsDescription');
String get professionalReportsDescription =>
translate('professionalReportsDescription');
String get enterpriseReportsDescription =>
translate('enterpriseReportsDescription');
String get upgradeForAdvancedReports =>
translate('upgradeForAdvancedReports');
String get upgrade => translate('upgrade');
String get professionalPlanRequired => translate('professionalPlanRequired');
String get enterprisePlanRequired => translate('enterprisePlanRequired');
String get productsReportAvailableInPlan =>
translate('productsReportAvailableInPlan');
String get customersReportAvailableInPlan =>
translate('customersReportAvailableInPlan');
String get financialReportAvailableInPlan =>
translate('financialReportAvailableInPlan');
String get upgradeYourPlan => translate('upgradeYourPlan');
String get upgradeForAdvancedAnalytics =>
translate('upgradeForAdvancedAnalytics');
String get viewPlans => translate('viewPlans');
String get salesByPaymentMethod => translate('salesByPaymentMethod');
String get revenueByDay => translate('revenueByDay');
String get dailySalesTrend => translate('dailySalesTrend');
String get topSellingHours => translate('topSellingHours');
String get customerRetention => translate('customerRetention');
String get salesVelocity => translate('salesVelocity');
String get profitMarginAnalysis => translate('profitMarginAnalysis');
String get inventoryTurnover => translate('inventoryTurnover');
String get abcAnalysis => translate('abcAnalysis');
String get stockOptimization => translate('stockOptimization');
String get productsOverview => translate('productsOverview');
String get totalProducts => translate('totalProducts');
String get lowStock => translate('lowStock');
String get outOfStock => translate('outOfStock');
String get topSellingProducts => translate('topSellingProducts');
String get sold => translate('sold');
String get customersOverview => translate('customersOverview');
String get topCustomers => translate('topCustomers');
String get customerAcquisition => translate('customerAcquisition');
String get averageCustomerValue => translate('averageCustomerValue');
String get customerLifetimeValue => translate('customerLifetimeValue');
String get churnRiskAnalysis => translate('churnRiskAnalysis');
String get financialOverview => translate('financialOverview');
String get revenueTrend => translate('revenueTrend');
String get profitMarginTrend => translate('profitMarginTrend');
String get cashFlowAnalysis => translate('cashFlowAnalysis');
String get financialRatios => translate('financialRatios');
String get breakEvenAnalysis => translate('breakEvenAnalysis');
String get advancedAnalyticsFeature => translate('advancedAnalyticsFeature');
String get subscriptionPlans => translate('subscriptionPlans');
String get choosePerfectPlan => translate('choosePerfectPlan');
String get startWithFreeTrial => translate('startWithFreeTrial');
String get monthly => translate('monthly');
String get yearly => translate('yearly');
String get save20Percent => translate('save20Percent');
String get popular => translate('popular');
String get selected => translate('selected');
String get selectPlan => translate('selectPlan');
String get paymentMethod => translate('paymentMethod');
String get orderSummary => translate('orderSummary');
String get price => translate('price');
String get tax => translate('tax');
String get total => translate('total');
String get subscribeNow => translate('subscribeNow');
String get salesOverview => translate('salesOverview');
String get item => translate('item');
String get qty => translate('qty');
String get subtotal => translate('subtotal');
String get discount => translate('discount');
String get telebirrReference => translate('telebirrReference');
String get thankYou => translate('thankYou');
String get receipt => translate('receipt');
String get time => translate('time');
String get scanBarcode => translate('scanBarcode');
String get scan => translate('scan');
String get selectCustomer => translate('selectCustomer');
String get creditAvailable => translate('creditAvailable');
String get connectedTo => translate('connectedTo');
String get noPrinterConnected => translate('noPrinterConnected');
String get testPrint => translate('testPrint');
String get tryAdjustingSearch => translate('tryAdjustingSearch');
String get yesterday => translate('yesterday');
String get thisWeek => translate('thisWeek');
String get lastWeek => translate('lastWeek');
String get lastMonth => translate('lastMonth');
String get last3Months => translate('last3Months');
String get last6Months => translate('last6Months');
String get thisYear => translate('thisYear');
String get lastYear => translate('lastYear');
String get cashInHand => translate('cashInHand');
String get registerBusiness => translate('registerBusiness');
String get adminAccount => translate('adminAccount');
String get subscriptionPlan => translate('subscriptionPlan');
String get reviewRegistration => translate('reviewRegistration');
String get verifyPhone => translate('verifyPhone');
String get businessNameEnglish => translate('businessNameEnglish');
String get businessNameAmharic => translate('businessNameAmharic');
String get businessPhone => translate('businessPhone');
String get businessEmailOptional => translate('businessEmailOptional');
String get businessAddress => translate('businessAddress');
String get ownerName => translate('ownerName');
String get ownerPhone => translate('ownerPhone');
String get ownerEmailOptional => translate('ownerEmailOptional');
String get yourName => translate('yourName');
String get yourPhone => translate('yourPhone');
String get yourEmailOptional => translate('yourEmailOptional');
String get password => translate('password');
String get confirmPassword => translate('confirmPassword');
String get chooseSubscriptionPlan => translate('chooseSubscriptionPlan');
String get recommended => translate('recommended');
String get premium => translate('premium');
String get standard => translate('standard');
String get reviewYourRegistration => translate('reviewYourRegistration');
String get freeTrialNotice => translate('freeTrialNotice');
String get verifyYourPhone => translate('verifyYourPhone');
String get otpSentTo => translate('otpSentTo');
String get enterOTP => translate('enterOTP');
String get didNotReceiveOTP => translate('didNotReceiveOTP');
String get resendOTP => translate('resendOTP');
String get completeRegistration => translate('completeRegistration');
String get verifyOTP => translate('verifyOTP');
String get back => translate('back');
String get isRequired => translate('isRequired');
String get phoneRequired => translate('phoneRequired');
String get validEthiopianPhone => translate('validEthiopianPhone');
String get validEmail => translate('validEmail');
String get passwordRequired => translate('passwordRequired');
String get passwordMinLength => translate('passwordMinLength');
String get tinRequired => translate('tinRequired');
String get tinMinLength => translate('tinMinLength');
String get otpRequired => translate('otpRequired');
String get otpLength => translate('otpLength');
String get passwordsDoNotMatch => translate('passwordsDoNotMatch');
String get registrationSuccessful => translate('registrationSuccessful');
String get otpSentToPhone => translate('otpSentToPhone');
String get enterOTPCode => translate('enterOTPCode');
String get verifyAndContinue => translate('verifyAndContinue');
String get didNotReceiveCode => translate('didNotReceiveCode');
String get resendAvailableIn => translate('resendAvailableIn');
String get forBusiness => translate('forBusiness');
String get otpMustBe6Digits => translate('otpMustBe6Digits');
String get otpMustBeNumbers => translate('otpMustBeNumbers');
String get otpResentSuccessfully => translate('otpResentSuccessfully');
String get registrationComplete => translate('registrationComplete');
String get invalidOrExpiredOTP => translate('invalidOrExpiredOTP');
// Add these getters to your translation service/class
String get shopRegistration => translate('shopRegistration');
String get ownerAccount => translate('ownerAccount');
String get payment => translate('payment');
String get setupYourShop => translate('setupYourShop');
String get enterShopDetails => translate('enterShopDetails');
String get shopName => translate('shopName');
String get shopCategory => translate('shopCategory');
String get phoneNumber => translate('phoneNumber');
String get city => translate('city');
String get country => translate('country');
String get shopCategoryRequired => translate('shopCategoryRequired');
String get createOwnerAccount => translate('createOwnerAccount');
String get setupOwnerDetails => translate('setupOwnerDetails');
String get fullName => translate('fullName');
String get passwordRequirements => translate('passwordRequirements');
String get min6Characters => translate('min6Characters');
String get recommendSpecialChars => translate('recommendSpecialChars');
String get steps => translate('steps');
String get shop => translate('shop');
String get owner => translate('owner');
String get verify => translate('verify');
String get basic => translate('basic');
String get professional => translate('professional');
String get cbeBirr => translate('cbeBirr');
String get chapa => translate('chapa');
String get choosePaymentMethod => translate('choosePaymentMethod');
String get processPayment => translate('processPayment');
String get paymentSuccessful => translate('paymentSuccessful');
String get setupStaffAccounts => translate('setupStaffAccounts');
String get addAdminsCashiersManagers =>
translate('addAdminsCashiersManagers');
String get getStarted => translate('getStarted');
String get chooseYourPlan => translate('chooseYourPlan');
String get billingCycle => translate('billingCycle');
String get completePayment => translate('completePayment');
String get paymentMethods => translate('paymentMethods');
String get welcomeToAndalusPOS => translate('welcomeToAndalusPOS');
String get loginToYourAccount => translate('loginToYourAccount');
String get loginWithPassword => translate('loginWithPassword');
String get loginWithOTP => translate('loginWithOTP');
String get login => translate('login');
String get sendingOTP => translate('sendingOTP');
String get createNewBusiness => translate('createNewBusiness');
String get otpSentSuccessfully => translate('otpSentSuccessfully');
String get welcomeBack => translate('welcomeBack');
String get enterCredentialsToContinue =>
translate('enterCredentialsToContinue');
String get featureComingSoon => translate('featureComingSoon');
String get forgotPassword => translate('forgotPassword');
String get or => translate('or');
String get resetYourPassword => translate('resetYourPassword');
String get enterPhoneToResetPassword =>
translate('enterPhoneToResetPassword');
String get verifyAndReset => translate('verifyAndReset');
String get enterOTPAndNewPassword => translate('enterOTPAndNewPassword');
String get resetPassword => translate('resetPassword');
String get passwordResetSuccessfully =>
translate('passwordResetSuccessfully');
String get youCanNowLoginWithNewPassword =>
translate('youCanNowLoginWithNewPassword');
String get backToLogin => translate('backToLogin');
String get resendingOTP => translate('resendingOTP');
String get otpVerifiedSuccessfully => translate('otpVerifiedSuccessfully');
String get instantPayment => translate('instantPayment');
String get mobileBanking => translate('mobileBanking');
String get onlinePayment => translate('onlinePayment');
String get securePayment => translate('securePayment');
}

class \_AppLocalizationsDelegate
extends LocalizationsDelegate<AppLocalizations> {
const \_AppLocalizationsDelegate();

@override
bool isSupported(Locale locale) {
return ['en', 'am'].contains(locale.languageCode);
}

@override
Future<AppLocalizations> load(Locale locale) {
return SynchronousFuture<AppLocalizations>(AppLocalizations(locale));
}

@override
bool shouldReload(\_AppLocalizationsDelegate old) => false;
}

##

// src/providers/auth_provider.dart
// Provider for managing authentication state and actions.
import 'package:andalus_smart_pos/src/data/local/database.dart';
import 'package:andalus_smart_pos/src/service/auth_service.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/data/models/user.dart';
import 'package:andalus_smart_pos/src/data/repositories/user_repository.dart';
import 'package:andalus_smart_pos/src/data/repositories/otp_repository.dart';
import 'package:andalus_smart_pos/src/data/repositories/subscription_repository.dart';

// Repository Providers
final userRepositoryProvider = Provider<UserRepository>((ref) {
return UserRepository();
});

final otpRepositoryProvider = Provider<OTPRepository>((ref) {
return OTPRepository();
});

final subscriptionRepositoryProvider = Provider<SubscriptionRepository>((ref) {
return SubscriptionRepository();
});

// Auth Service Provider
final authServiceProvider = Provider<AuthService>((ref) {
return AuthService(
userRepository: ref.read(userRepositoryProvider),
otpRepository: ref.read(otpRepositoryProvider),
subscriptionRepository: ref.read(subscriptionRepositoryProvider),
);
});

// Auth State
class AuthState {
final User? user;
final bool isLoading;
final String? error;
final bool isAuthenticated;
final AuthMethod authMethod;

const AuthState({
this.user,
this.isLoading = false,
this.error,
this.authMethod = AuthMethod.none,
}) : isAuthenticated = user != null;

AuthState copyWith({
User? user,
bool? isLoading,
String? error,
AuthMethod? authMethod,
}) {
return AuthState(
user: user ?? this.user,
isLoading: isLoading ?? this.isLoading,
error: error,
authMethod: authMethod ?? this.authMethod,
);
}
}

enum AuthMethod {
none,
password,
otp,
}

class AuthNotifier extends StateNotifier<AuthState> {
final Ref \_ref;

AuthNotifier(this.\_ref) : super(const AuthState());

Future<void> loginWithPassword(String phone, String password) async {
print('üîê Password login for: $phone');
state = state.copyWith(
isLoading: true, error: null, authMethod: AuthMethod.password);

    try {
      final authService = _ref.read(authServiceProvider);
      final user = await authService.loginWithPassword(phone, password);
      state = state.copyWith(user: user, isLoading: false);
      print('‚úÖ Password login successful for: ${user.name}');
    } catch (e) {
      print('‚ùå Password login error: $e');
      state = state.copyWith(isLoading: false, error: e.toString());
      rethrow;
    }

}

Future<void> sendOTP(String phone) async {
print('üì± Sending OTP for: $phone');
state = state.copyWith(isLoading: true, error: null);

    try {
      final authService = _ref.read(authServiceProvider);
      await authService.sendLoginOTP(phone);
      state = state.copyWith(isLoading: false, authMethod: AuthMethod.otp);
      print('‚úÖ OTP sent successfully');
    } catch (e) {
      print('‚ùå OTP send error: $e');
      state = state.copyWith(isLoading: false, error: e.toString());
      rethrow;
    }

}

Future<void> verifyOTPAndLogin(String phone, String code) async {
print('üîê Verifying OTP and logging in: $phone');
state = state.copyWith(
isLoading: true, error: null, authMethod: AuthMethod.otp);

    try {
      final authService = _ref.read(authServiceProvider);
      final user = await authService.loginWithOTP(phone, code);
      state = state.copyWith(user: user, isLoading: false);
      print('‚úÖ OTP login successful for: ${user.name}');
    } catch (e, stackTrace) {
      print('‚ùå OTP login error: $e');
      print('üìã FULL STACK TRACE: $stackTrace');
      state = state.copyWith(isLoading: false, error: e.toString());
      rethrow;
    }

}

void logout() {
print('üö™ Logging out user');
state = const AuthState();
}

void clearError() {
state = state.copyWith(error: null);
}

// Check if user exists (for navigation)
Future<bool> checkUserExists(String phone) async {
try {
final userRepository = \_ref.read(userRepositoryProvider);
final user = await userRepository.getUserByPhone(phone);
return user != null;
} catch (e) {
return false;
}
}
}

final authProvider = StateNotifierProvider<AuthNotifier, AuthState>((ref) {
return AuthNotifier(ref);
});

##

// providers/calendar_provider.dart
import 'dart:convert';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';

enum CalendarType {
gregorian,
ethiopian,
}

class CalendarSettings {
final CalendarType calendarType;
final double fontSizeScale;

const CalendarSettings({
this.calendarType = CalendarType.gregorian,
this.fontSizeScale = 1.0,
});

CalendarSettings copyWith({
CalendarType? calendarType,
double? fontSizeScale,
}) {
return CalendarSettings(
calendarType: calendarType ?? this.calendarType,
fontSizeScale: fontSizeScale ?? this.fontSizeScale,
);
}

Map<String, dynamic> toMap() {
return {
'calendar_type': calendarType.name,
'font_size_scale': fontSizeScale,
};
}

factory CalendarSettings.fromMap(Map<String, dynamic> map) {
return CalendarSettings(
calendarType: CalendarType.values.firstWhere(
(e) => e.name == map['calendar_type'],
orElse: () => CalendarType.gregorian,
),
fontSizeScale: map['font_size_scale']?.toDouble() ?? 1.0,
);
}
}

final calendarProvider =
StateNotifierProvider<CalendarNotifier, CalendarSettings>(
(ref) => CalendarNotifier(),
);

class CalendarNotifier extends StateNotifier<CalendarSettings> {
CalendarNotifier() : super(const CalendarSettings()) {
\_loadSettings();
}

static const String \_settingsKey = 'calendar_settings';

Future<void> \_loadSettings() async {
try {
final prefs = await SharedPreferences.getInstance();
final settingsString = prefs.getString(\_settingsKey);

      if (settingsString != null && settingsString.isNotEmpty) {
        try {
          final settingsMap =
              Map<String, dynamic>.from(json.decode(settingsString));
          state = CalendarSettings.fromMap(settingsMap);
        } catch (e) {
          print('Error parsing calendar settings: $e');
          // Fallback to default settings
          final calendarIndex = prefs.getInt('preferred_calendar') ?? 0;
          state = CalendarSettings(
            calendarType: CalendarType.values[calendarIndex],
            fontSizeScale: 1.0,
          );
        }
      } else {
        // Legacy support for old preference format
        final calendarIndex = prefs.getInt('preferred_calendar') ?? 0;
        state = CalendarSettings(
          calendarType: CalendarType.values[calendarIndex],
          fontSizeScale: 1.0,
        );
      }
    } catch (e) {
      print('Error loading calendar settings: $e');
      state = const CalendarSettings();
    }

}

Future<void> setCalendarType(CalendarType type) async {
state = state.copyWith(calendarType: type);
await \_saveSettings();
}

Future<void> setFontSizeScale(double scale) async {
state = state.copyWith(fontSizeScale: scale.clamp(0.8, 1.5));
await \_saveSettings();
}

Future<void> \_saveSettings() async {
try {
final prefs = await SharedPreferences.getInstance();
await prefs.setString(\_settingsKey, json.encode(state.toMap()));
// Also save legacy format for compatibility
await prefs.setInt('preferred_calendar', state.calendarType.index);
} catch (e) {
print('Error saving calendar settings: $e');
}
}
}

##

// mobile/lib/src/providers/cart_provider.dart
// Provider for managing the shopping cart state.
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/data/models/cart_item.dart';

final cartProvider = StateNotifierProvider<CartNotifier, List<CartItem>>((ref) {
return CartNotifier();
});

class CartNotifier extends StateNotifier<List<CartItem>> {
CartNotifier() : super([]);

// Getters for cart calculations
double get subtotalAmount {
return state.fold(0, (total, item) => total + item.totalPrice);
}

double get taxAmount {
// Assuming 15% tax rate - you can make this configurable
return subtotalAmount \* 0.15;
}

double get totalAmount {
return subtotalAmount + taxAmount;
}

int get totalItems {
return state.fold(0, (total, item) => total + item.quantity);
}

// Cart operations
void addProduct({
required int productId,
required String productName,
required double unitPrice,
int quantity = 1,
}) {
final existingIndex =
state.indexWhere((item) => item.productId == productId);

    if (existingIndex != -1) {
      // Update existing item
      final existingItem = state[existingIndex];
      final newQuantity = existingItem.quantity + quantity;
      final updatedItem = existingItem.copyWith(quantity: newQuantity);

      state = [
        ...state.sublist(0, existingIndex),
        updatedItem,
        ...state.sublist(existingIndex + 1),
      ];
    } else {
      // Add new item
      final newItem = CartItem(
        productId: productId,
        productName: productName,
        unitPrice: unitPrice,
        quantity: quantity,
      );
      state = [...state, newItem];
    }

}

void updateQuantity(int productId, int newQuantity) {
if (newQuantity <= 0) {
removeProduct(productId);
return;
}

    final index = state.indexWhere((item) => item.productId == productId);
    if (index != -1) {
      final updatedItem = state[index].copyWith(quantity: newQuantity);
      state = [
        ...state.sublist(0, index),
        updatedItem,
        ...state.sublist(index + 1),
      ];
    }

}

void removeProduct(int productId) {
state = state.where((item) => item.productId != productId).toList();
}

void clearCart() {
state = [];
}

// Helper methods
bool containsProduct(int productId) {
return state.any((item) => item.productId == productId);
}

int getProductQuantity(int productId) {
final item = state.firstWhere(
(item) => item.productId == productId,
orElse: () => CartItem(
productId: -1,
productName: '',
unitPrice: 0,
quantity: 0,
),
);
return item.productId == -1 ? 0 : item.quantity;
}

// Apply discount to entire cart (optional feature)
void applyDiscount(double discountPercentage) {
// This would modify the cart items with discounted prices
// Implementation depends on your discount strategy
}

// Apply tax (optional - you might want to handle this differently)
void setTaxRate(double taxRate) {
// Store tax rate and recalculate totals
}
}

##

// mobile/lib/src/providers/language_provider.dart
// Provider for managing application language settings.
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';

final languageProvider = StateNotifierProvider<LanguageNotifier, Locale>((ref) {
return LanguageNotifier();
});

class LanguageNotifier extends StateNotifier<Locale> {
LanguageNotifier() : super(const Locale('en', 'US')) {
\_loadLanguage();
}

static const String \_languageKey = 'app_language';

Future<void> \_loadLanguage() async {
try {
final prefs = await SharedPreferences.getInstance();
final languageCode = prefs.getString(\_languageKey) ?? 'en';
state = Locale(languageCode);
} catch (e) {
print('Error loading language: $e');
state = const Locale('en');
}
}

Future<void> setLanguage(String languageCode) async {
try {
state = Locale(languageCode);
final prefs = await SharedPreferences.getInstance();
await prefs.setString(\_languageKey, languageCode);
} catch (e) {
print('Error saving language: $e');
}
}

void toggleLanguage() {
final newLanguage = state.languageCode == 'en' ? 'am' : 'en';
setLanguage(newLanguage);
}

String get currentLanguage => state.languageCode;

bool get isEnglish => state.languageCode == 'en';
bool get isAmharic => state.languageCode == 'am';
}

##

// mobile/lib/src/providers/onboarding_provider.dart
// Provider for managing the onboarding and registration process.
import 'dart:async';

import 'package:andalus_smart_pos/src/providers/auth_provider.dart';
import 'package:andalus_smart_pos/src/providers/providers.dart'
hide authServiceProvider, otpRepositoryProvider;
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/data/models/shop_registration.dart';
import 'package:andalus_smart_pos/src/data/models/subscription.dart';
import 'package:andalus_smart_pos/src/service/registration_service.dart';
import 'package:andalus_smart_pos/src/service/auth_service.dart';

class OnboardingState {
final int currentStep;
final ShopRegistration? shop;
final OwnerRegistration? owner;
final SubscriptionPlan? selectedPlan;
final BillingCycle? billingCycle;
final bool isLoading;
final bool isSuccess;
final String? error;
final bool isVerifyingOTP;
final String? registeredPhone;
final String? tempBusinessId;
final String? tempUserId;
final int otpResendCooldown;

const OnboardingState({
this.currentStep = 0,
this.shop,
this.owner,
this.selectedPlan,
this.billingCycle,
this.isLoading = false,
this.isSuccess = false,
this.error,
this.isVerifyingOTP = false,
this.registeredPhone,
this.tempBusinessId,
this.tempUserId,
this.otpResendCooldown = 0,
});

OnboardingState copyWith({
int? currentStep,
ShopRegistration? shop,
OwnerRegistration? owner,
SubscriptionPlan? selectedPlan,
BillingCycle? billingCycle,
bool? isLoading,
bool? isSuccess,
String? error,
bool? isVerifyingOTP,
String? registeredPhone,
String? tempBusinessId,
String? tempUserId,
int? otpResendCooldown,
}) {
return OnboardingState(
currentStep: currentStep ?? this.currentStep,
shop: shop ?? this.shop,
owner: owner ?? this.owner,
selectedPlan: selectedPlan ?? this.selectedPlan,
billingCycle: billingCycle ?? this.billingCycle,
isLoading: isLoading ?? this.isLoading,
isSuccess: isSuccess ?? this.isSuccess,
error: error,
isVerifyingOTP: isVerifyingOTP ?? this.isVerifyingOTP,
registeredPhone: registeredPhone ?? this.registeredPhone,
tempBusinessId: tempBusinessId ?? this.tempBusinessId,
tempUserId: tempUserId ?? this.tempUserId,
otpResendCooldown: otpResendCooldown ?? this.otpResendCooldown,
);
}
}

class OnboardingNotifier extends StateNotifier<OnboardingState> {
final Ref \_ref;
final RegistrationService \_registrationService;
final AuthService \_authService;

OnboardingNotifier(this.\_ref)
: \_registrationService = \_ref.read(registrationServiceProvider),
\_authService = \_ref.read(authServiceProvider),
super(const OnboardingState());

void updateShopInfo(ShopRegistration shop) {
state = state.copyWith(shop: shop);
}

void updateOwnerInfo(OwnerRegistration owner) {
state = state.copyWith(owner: owner);
}

void selectPlan(SubscriptionPlan plan, BillingCycle billingCycle) {
state = state.copyWith(selectedPlan: plan, billingCycle: billingCycle);
}

void nextStep() {
if (state.currentStep < 4) {
state = state.copyWith(currentStep: state.currentStep + 1, error: null);
}
}

void previousStep() {
if (state.currentStep > 0) {
state = state.copyWith(currentStep: state.currentStep - 1, error: null);
}
}

Future<bool> \_verifyOTP(String phone, String code) async {
try {
// Use your existing OTP verification logic
if (code == '123456') return true; // Demo code

      final otp = await _ref
          .read(otpRepositoryProvider)
          .getValidOTP(phone, code, 'registration');
      if (otp != null) {
        await _ref.read(otpRepositoryProvider).markOTPAsUsed(otp.id);
        return true;
      }
      return false;
    } catch (e) {
      return false;
    }

}

Future<void> sendRegistrationOTP(String phone) async {
state = state.copyWith(isLoading: true, error: null);
try {
// Use the same type 'registration' for both sending and verifying
await \_authService.sendRegistrationOTP(phone);
\_startResendCooldown();
state = state.copyWith(
isLoading: false,
registeredPhone: phone,
);

      print('üì± Registration OTP sent to: $phone');
    } catch (e) {
      print('‚ùå Failed to send registration OTP: $e');
      state = state.copyWith(
        isLoading: false,
        error: 'Failed to send OTP: ${e.toString()}',
      );
    }

}

void \_startResendCooldown() {
const cooldownDuration = 60;
state = state.copyWith(otpResendCooldown: cooldownDuration);

    // 1. Declare the variable first (nullable)
    StreamSubscription? timer;

    // 2. Assign the subscription
    timer = Stream.periodic(const Duration(seconds: 1), (i) {
      final remaining = cooldownDuration - i - 1;

      if (remaining >= 0) {
        state = state.copyWith(otpResendCooldown: remaining);
      } else {
        state = state.copyWith(otpResendCooldown: 0);
        // 3. Now you can refer to 'timer' safely
        timer?.cancel();
      }
    }).listen((_) {});

}

Future<bool> verifyRegistrationOTP(String code) async {
print('üîÑ verifyRegistrationOTP called with code: $code');

    if (state.registeredPhone == null) {
      state = state.copyWith(error: 'Phone number not set');
      return false;
    }

    // Check if we're already verifying
    if (state.isVerifyingOTP) {
      print('‚ö†Ô∏è Already verifying OTP, ignoring duplicate call');
      return false;
    }

    state = state.copyWith(isVerifyingOTP: true, error: null);

    try {
      print('üîê Verifying OTP for: ${state.registeredPhone}');
      print('üîë OTP Code entered: $code');

      final otp = await _ref
          .read(otpRepositoryProvider)
          .getValidOTP(state.registeredPhone!, code, 'registration');

      if (otp == null) {
        print('‚ùå No valid OTP found for ${state.registeredPhone}');
        state = state.copyWith(
          isVerifyingOTP: false,
          error: 'Invalid or expired OTP code',
        );
        return false;
      }

      print('‚úÖ Valid OTP found, marking as used...');
      await _ref.read(otpRepositoryProvider).markOTPAsUsed(otp.id);

      // Create temporary registration after OTP verification
      if (state.shop != null &&
          state.owner != null &&
          state.selectedPlan != null &&
          state.billingCycle != null) {
        print('üè™ Creating temporary registration...');
        final result = await _registrationService.createTemporaryRegistration(
          shop: state.shop!,
          owner: state.owner!,
          plan: state.selectedPlan!,
          billingCycle: state.billingCycle!,
        );

        if (result.success) {
          print('‚úÖ Temporary registration created successfully');

          // Update state first
          state = state.copyWith(
            isVerifyingOTP: false,
            tempBusinessId: result.businessId,
            tempUserId: result.userId,
            error: null,
          );

          print('üöÄ Moving to next step...');
          // Then move to next step
          nextStep();

          return true;
        } else {
          print('‚ùå Temporary registration failed: ${result.error}');
          state = state.copyWith(
            isVerifyingOTP: false,
            error: result.error ?? 'Registration failed',
          );
          return false;
        }
      } else {
        print('‚ùå Incomplete registration data');
        state = state.copyWith(
          isVerifyingOTP: false,
          error: 'Registration data incomplete',
        );
        return false;
      }
    } catch (e, stackTrace) {
      print('‚ùå OTP verification error: $e');
      print('üìã Stack trace: $stackTrace');
      state = state.copyWith(
        isVerifyingOTP: false,
        error: 'OTP verification failed: ${e.toString()}',
      );
      return false;
    }

}

Future<bool> processPayment(
String paymentMethod, Map<String, dynamic> paymentDetails) async {
if (state.tempBusinessId == null || state.tempUserId == null) {
state = state.copyWith(error: 'Registration data missing');
return false;
}

    state = state.copyWith(isLoading: true, error: null);
    try {
      // Simulate payment processing
      await Future.delayed(const Duration(seconds: 2));

      // Generate payment reference
      final paymentReference = 'pay_${DateTime.now().millisecondsSinceEpoch}';
      final transactionId = 'txn_${DateTime.now().millisecondsSinceEpoch}';

      // Activate account after successful payment
      final result = await _registrationService.activateAccountAfterPayment(
        businessId: state.tempBusinessId!,
        userId: state.tempUserId!,
        paymentReference: paymentReference,
        transactionId: transactionId,
      );

      if (result.success) {
        state = state.copyWith(
          isLoading: false,
          isSuccess: true,
        );
        return true;
      } else {
        state = state.copyWith(
          isLoading: false,
          error: result.error,
        );
        return false;
      }
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: 'Payment processing failed: ${e.toString()}',
      );
      return false;
    }

}

void reset() {
state = const OnboardingState();
}

bool get canResendOTP => state.otpResendCooldown == 0;
}

final onboardingProvider =
StateNotifierProvider<OnboardingNotifier, OnboardingState>((ref) {
return OnboardingNotifier(ref);
});

##

// src/providers/providers.dart
// Provider definitions for repositories and services used in the application.
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/data/repositories/user_repository.dart';
import 'package:andalus_smart_pos/src/data/repositories/otp_repository.dart';
import 'package:andalus_smart_pos/src/data/repositories/subscription_repository.dart';
import 'package:andalus_smart_pos/src/service/auth_service.dart';
import 'package:andalus_smart_pos/src/service/registration_service.dart';

// Repository Providers
final userRepositoryProvider = Provider<UserRepository>((ref) {
return UserRepository();
});

final otpRepositoryProvider = Provider<OTPRepository>((ref) {
return OTPRepository();
});

final subscriptionRepositoryProvider = Provider<SubscriptionRepository>((ref) {
return SubscriptionRepository();
});

// Service Providers
final authServiceProvider = Provider<AuthService>((ref) {
return AuthService(
userRepository: ref.read(userRepositoryProvider),
otpRepository: ref.read(otpRepositoryProvider),
subscriptionRepository: ref.read(subscriptionRepositoryProvider),
);
});

final registrationServiceProvider = Provider<RegistrationService>((ref) {
return RegistrationService(
userRepository: ref.read(userRepositoryProvider),
subscriptionRepository: ref.read(subscriptionRepositoryProvider),
);
});

##

//src/providers/settings_provider.dart
// Provider for managing application settings.
import 'package:andalus_smart_pos/src/data/models/settings.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';
import "package:andalus_smart_pos/src/data/models/settings.dart";

final settingsProvider = AsyncNotifierProvider<SettingsNotifier, AppSettings>(
SettingsNotifier.new,
);

class SettingsNotifier extends AsyncNotifier<AppSettings> {
@override
Future<AppSettings> build() async {
try {
final repository = \_getRepository();
return await repository.getSettings();
} catch (e) {
print('Error building settings: $e');
// Return default settings as fallback
return \_getDefaultSettings();
}
}

SettingsRepository \_getRepository() {
return SettingsRepository(); // Your settings repository
}

AppSettings \_getDefaultSettings() {
return AppSettings(
shopName: 'Andalus Smart POS',
shopNameAm: '·ä†·äï·ã≥·àâ·àµ ·àõ·à≠·â≤·äï ·çñ·àµ',
address: 'Addis Ababa, Ethiopia',
phone: '+251 911 234 567',
tinNumber: 'TIN-123456789',
currency: 'ETB',
enableTax: false,
taxRate: 0.15,
enableDiscounts: true,
autoPrintReceipts: false,
defaultPaymentMethod: 'cash',
enableSync: true,
syncInterval: 5,
enableCreditSystem: true,
defaultCreditLimit: 1000.0,
defaultPaymentTerms: '30',
enableCustomerSelection: true,
lowStockNotifications: true,
lowStockThreshold: 10,
);
}

Future<void> updateSettings(AppSettings newSettings) async {
state = const AsyncValue.loading();
try {
final repository = \_getRepository();
await repository.saveSettings(newSettings);
state = AsyncValue.data(newSettings);
} catch (e, stackTrace) {
state = AsyncValue.error(e, stackTrace);
rethrow;
}
}

Future<void> resetToDefaults() async {
final defaultSettings = \_getDefaultSettings();
await updateSettings(defaultSettings);
}
}

// Simple Settings Repository for SharedPreferences
class SettingsRepository {
static const String \_settingsKey = 'app_settings';

Future<AppSettings> getSettings() async {
final prefs = await SharedPreferences.getInstance();
// In a real app, you'd parse JSON here
// For now, return default settings
return AppSettings(
shopName: 'Andalus Smart POS',
shopNameAm: '·ä†·äï·ã≥·àâ·àµ ·àõ·à≠·â≤·äï ·çñ·àµ',
address: 'Addis Ababa, Ethiopia',
phone: '+251 911 234 567',
tinNumber: 'TIN-123456789',
currency: 'ETB',
enableTax: false,
taxRate: 0.15,
enableDiscounts: true,
autoPrintReceipts: false,
defaultPaymentMethod: 'cash',
enableSync: true,
syncInterval: 5,
enableCreditSystem: true,
defaultCreditLimit: 1000.0,
defaultPaymentTerms: '30',
enableCustomerSelection: true,
lowStockNotifications: true,
lowStockThreshold: 10,
);
}

Future<void> saveSettings(AppSettings settings) async {
final prefs = await SharedPreferences.getInstance();
// In a real app, you'd convert to JSON here
await prefs.setString(\_settingsKey, 'settings_saved');
await Future.delayed(const Duration(milliseconds: 500)); // Simulate save
}
}

##

// providers/subscription_provider.dart
import 'package:andalus_smart_pos/src/data/models/subscription.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/data/repositories/subscription_repository.dart';

final subscriptionRepositoryProvider = Provider<SubscriptionRepository>((ref) {
return SubscriptionRepository();
});

final currentSubscriptionProvider = FutureProvider<Subscription?>((ref) async {
final repository = ref.read(subscriptionRepositoryProvider);
return await repository.getCurrentSubscription();
});

##

// mobile/lib/src/providers/theme_provider.dart
// Provider for managing application theme settings.
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';

final themeProvider = StateNotifierProvider<ThemeNotifier, ThemeMode>((ref) {
return ThemeNotifier();
});

class ThemeNotifier extends StateNotifier<ThemeMode> {
ThemeNotifier() : super(ThemeMode.light) {
\_loadTheme();
}

static const String \_themeKey = 'app_theme_mode';

Future<void> \_loadTheme() async {
try {
final prefs = await SharedPreferences.getInstance();
final themeIndex = prefs.getInt(\_themeKey) ?? 0;
state = ThemeMode.values[themeIndex];
} catch (e) {
print('Error loading theme: $e');
state = ThemeMode.light;
}
}

Future<void> setTheme(ThemeMode theme) async {
try {
state = theme;
final prefs = await SharedPreferences.getInstance();
await prefs.setInt(\_themeKey, theme.index);
} catch (e) {
print('Error saving theme: $e');
}
}

void toggleTheme() {
final newTheme =
state == ThemeMode.light ? ThemeMode.dark : ThemeMode.light;
setTheme(newTheme);
}
}

##

// src/service/auth_service.dart
// Service for handling authentication logic.
import 'package:crypto/crypto.dart';
import 'dart:convert';
import 'package:andalus_smart_pos/src/data/repositories/user_repository.dart';
import 'package:andalus_smart_pos/src/data/repositories/otp_repository.dart';
import 'package:andalus_smart_pos/src/data/repositories/subscription_repository.dart';
import 'package:andalus_smart_pos/src/data/models/user.dart';
import 'package:andalus_smart_pos/src/data/models/otp.dart';

class AuthService {
final UserRepository \_userRepository;
final OTPRepository \_otpRepository;
final SubscriptionRepository \_subscriptionRepository;

AuthService({
required UserRepository userRepository,
required OTPRepository otpRepository,
required SubscriptionRepository subscriptionRepository,
}) : \_userRepository = userRepository,
\_otpRepository = otpRepository,
\_subscriptionRepository = subscriptionRepository;

String \_hashPassword(String password) {
final bytes = utf8.encode(password);
final digest = sha256.convert(bytes);
return digest.toString();
}

Future<void> verifyOTPAndRegister(
String phone,
String code,
User user,
) async {
print('üîê OTP Registration for: $phone');

    try {
      // 1. Verify OTP
      final otp = await _otpRepository.getValidOTP(phone, code, 'registration');
      if (otp == null) {
        throw Exception('Invalid or expired OTP code. Please try again.');
      }

      // 2. Mark OTP as used
      await _otpRepository.markOTPAsUsed(otp.id);

      // 3. Check if user already exists
      final existingUser = await _userRepository.getUserByPhone(phone);
      if (existingUser != null) {
        throw Exception(
            'An account already exists with this phone number. Please login instead.');
      }

      // 4. Hash the password before saving
      final hashedPassword = _hashPassword(user.passwordHash ?? '');

      // 5. Create new user with verified status
      final newUser = user.copyWith(
        phone: phone,
        passwordHash: hashedPassword,
        isVerified: true,
        isActive: true,
      );
      await _userRepository.createUser(newUser);

      // 6. Update last login
      await _userRepository.updateLastLogin(newUser.id);

      print('‚úÖ Registration successful for: ${user.name}');
    } catch (e) {
      print('‚ùå OTP registration error: $e');
      rethrow;
    }

}

// Password-based login
Future<User> loginWithPassword(String phone, String password) async {
print('üîê Password login attempt for: $phone');

    try {
      // Get user by phone
      final user = await _userRepository.getUserByPhone(phone);
      if (user == null) {
        throw Exception(
            'No account found with this phone number. Please register first.');
      }

      if (!user.isActive) {
        throw Exception('Account is deactivated. Please contact support.');
      }

      // Verify password
      final hashedPassword = _hashPassword(password);
      if (user.passwordHash != hashedPassword) {
        throw Exception('Invalid password. Please try again.');
      }

      if (!user.isVerified) {
        throw Exception('Account not verified. Please complete verification.');
      }

      // Update last login
      await _userRepository.updateLastLogin(user.id);

      // Check subscription status
      final hasValidSubscription = await _subscriptionRepository
          .hasValidSubscription(user.businessId ?? '');
      if (!hasValidSubscription) {
        print('‚ö†Ô∏è No active subscription found for user: ${user.id}');
      }

      print('‚úÖ Password login successful for: ${user.name}');
      return user;
    } catch (e) {
      print('‚ùå Password login error: $e');
      rethrow;
    }

}

// Enhanced OTP-based login with better error handling
Future<User> loginWithOTP(String phone, String code) async {
print('üîê OTP login attempt for: $phone');

    // Validate inputs
    if (phone.isEmpty) {
      throw Exception('Phone number not set');
    }

    if (code.isEmpty || code.length != 6) {
      throw Exception('Please enter a valid 6-digit OTP code');
    }

    try {
      // Verify OTP
      final otp = await _otpRepository.getValidOTP(phone, code, 'login');
      if (otp == null) {
        throw Exception('Invalid or expired OTP code. Please try again.');
      }

      // Mark OTP as used
      await _otpRepository.markOTPAsUsed(otp.id);

      // Get user by phone
      final user = await _userRepository.getUserByPhone(phone);
      if (user == null) {
        throw Exception('User not found. Please complete registration.');
      }

      if (!user.isActive) {
        throw Exception('Account is deactivated. Please contact support.');
      }

      // Update last login
      await _userRepository.updateLastLogin(user.id);

      // Check subscription status
      final hasValidSubscription = await _subscriptionRepository
          .hasValidSubscription(user.businessId ?? '');
      if (!hasValidSubscription) {
        print('‚ö†Ô∏è No active subscription found for user: ${user.id}');
      }

      print('‚úÖ OTP login successful for: ${user.name}');
      return user;
    } catch (e) {
      print('‚ùå OTP login error: $e');
      rethrow;
    }

}

// Enhanced OTP sending with validation
Future<void> sendLoginOTP(String phone) async {
print('üì± Sending login OTP for: $phone');

    // Validate phone number
    if (phone.isEmpty || !RegExp(r'^\+251[0-9]{9}$').hasMatch(phone)) {
      throw Exception('Please enter a valid Ethiopian phone number (+251...)');
    }

    // Check if user exists
    final user = await _userRepository.getUserByPhone(phone);
    if (user == null) {
      throw Exception(
          'No account found with this phone number. Please register first.');
    }

    if (!user.isActive) {
      throw Exception('Account is deactivated. Please contact support.');
    }

    await _sendOTP(phone, 'login');

}

Future<void> sendRegistrationOTP(String phone) async {
print('üìù Sending registration OTP for: $phone');

    // Validate phone number
    if (phone.isEmpty || !RegExp(r'^\+251[0-9]{9}$').hasMatch(phone)) {
      throw Exception('Please enter a valid Ethiopian phone number (+251...)');
    }

    // Check if user already exists
    final existingUser = await _userRepository.getUserByPhone(phone);
    if (existingUser != null) {
      throw Exception(
          'An account already exists with this phone number. Please login instead.');
    }

    await _sendOTP(phone, 'registration');

}

// Generic OTP sending method for verification
Future<void> sendOTP(String phone) async {
print('üì± Sending OTP for: $phone');

    // Validate phone number
    if (phone.isEmpty || !RegExp(r'^\+251[0-9]{9}$').hasMatch(phone)) {
      throw Exception('Please enter a valid Ethiopian phone number (+251...)');
    }

    await _sendOTP(phone, 'verification');

}

// Enhanced OTP sending with better logging
Future<void> \_sendOTP(String phone, String type) async {
try {
// Generate OTP
final otp = OTP.create(phone: phone, type: type);

      // Store OTP
      await _otpRepository.createOTP(otp);

      // Simulate API call delay
      await Future.delayed(const Duration(seconds: 1));

      // Enhanced logging for demo purposes
      print('‚úÖ OTP sent successfully');
      print('üì± Phone: $phone');
      print('üîë OTP Code: ${otp.code}');
      print('üìù Type: $type');
      print('‚è∞ Expires: ${otp.expiresAt}');
      print('üéØ DEMO - Use this code: ${otp.code}');
    } catch (e) {
      print('‚ùå OTP send error: $e');
      throw Exception('Failed to send OTP. Please try again.');
    }

}

// Enhanced OTP verification for general use
Future<void> verifyOTP(String phone, String code,
{String type = 'verification'}) async {
print('üîê Verifying OTP for: $phone');

    if (phone.isEmpty) {
      throw Exception('Phone number not set');
    }

    if (code.isEmpty || code.length != 6) {
      throw Exception('Please enter a valid 6-digit OTP code');
    }

    try {
      final otp = await _otpRepository.getValidOTP(phone, code, type);
      if (otp == null) {
        throw Exception('Invalid or expired OTP code. Please try again.');
      }

      await _otpRepository.markOTPAsUsed(otp.id);
      print('‚úÖ OTP verified successfully for: $phone');
    } catch (e) {
      print('‚ùå OTP verification error: $e');
      rethrow;
    }

}

Future<void> logout() async {
// Clear any local authentication state
print('üö™ User logged out');
}

// Utility method to clean up expired OTPs
Future<void> cleanupExpiredOTPs() async {
await \_otpRepository.cleanExpiredOTPs();
}
}

##

// lib/src/services/receipt_service.dart
// Service for generating and printing sales receipt PDFs.
import 'dart:io';
import 'dart:typed_data';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:path_provider/path_provider.dart';
import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;
import 'package:printing/printing.dart';
import '../data/models/sale.dart';
import '../data/models/sale_item.dart';
import '../localization/app_localizations.dart';

class ReceiptService {
static const double \_receiptWidth = 80.0; // mm
static const double \_mmToPoint = 2.83465; // 1mm = 2.83465 points

Future<pw.Document> generateReceiptPDF({
required Sale sale,
required List<SaleItem> items,
required Map<String, dynamic> businessInfo,
required AppLocalizations localizations,
bool includeAmharic = true,
}) async {
final pdf = pw.Document();

    pdf.addPage(
      pw.Page(
        pageFormat: PdfPageFormat(
          _receiptWidth * _mmToPoint,
          double.infinity,
          marginAll: 4 * _mmToPoint,
        ),
        build: (pw.Context context) {
          return pw.Column(
            crossAxisAlignment: pw.CrossAxisAlignment.start,
            children: [
              // === HEADER ===
              _buildHeader(businessInfo, includeAmharic),

              pw.SizedBox(height: 8),
              pw.Divider(thickness: 1),
              pw.SizedBox(height: 8),

              // === SALE INFO ===
              _buildSaleInfo(sale, localizations),

              pw.SizedBox(height: 8),
              pw.Divider(thickness: 0.5),
              pw.SizedBox(height: 8),

              // === ITEMS TABLE ===
              _buildItemsTable(items, localizations),

              pw.SizedBox(height: 8),
              pw.Divider(thickness: 0.5),
              pw.SizedBox(height: 8),

              // === TOTALS ===
              _buildTotals(sale, localizations),

              pw.SizedBox(height: 8),
              pw.Divider(thickness: 1),
              pw.SizedBox(height: 8),

              // === PAYMENT INFO ===
              _buildPaymentInfo(sale, localizations),

              pw.SizedBox(height: 12),

              // === FOOTER ===
              _buildFooter(businessInfo, includeAmharic, localizations),
            ],
          );
        },
      ),
    );

    return pdf;

}

pw.Widget \_buildHeader(
Map<String, dynamic> businessInfo, bool includeAmharic) {
return pw.Column(
crossAxisAlignment: pw.CrossAxisAlignment.center,
children: [
pw.Text(
businessInfo['shopName'] ?? 'Andalus Smart POS',
style: pw.TextStyle(
fontSize: 14,
fontWeight: pw.FontWeight.bold,
),
textAlign: pw.TextAlign.center,
),
if (includeAmharic && businessInfo['shopNameAm'] != null)
pw.Text(
businessInfo['shopNameAm']!,
style: const pw.TextStyle(fontSize: 10),
textAlign: pw.TextAlign.center,
),
pw.SizedBox(height: 4),
if (businessInfo['address'] != null)
pw.Text(
businessInfo['address']!,
style: const pw.TextStyle(fontSize: 8),
textAlign: pw.TextAlign.center,
),
if (businessInfo['phone'] != null)
pw.Text(
'Tel: ${businessInfo['phone']!}',
style: const pw.TextStyle(fontSize: 8),
textAlign: pw.TextAlign.center,
),
if (businessInfo['tinNumber'] != null)
pw.Text(
'TIN: ${businessInfo['tinNumber']!}',
style: const pw.TextStyle(fontSize: 8),
textAlign: pw.TextAlign.center,
),
],
);
}

pw.Widget \_buildSaleInfo(Sale sale, AppLocalizations localizations) {
return pw.Column(
crossAxisAlignment: pw.CrossAxisAlignment.start,
children: [
pw.Row(
mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
children: [
pw.Text(
'${localizations.receipt}:',
style: pw.TextStyle(fontSize: 9, fontWeight: pw.FontWeight.bold),
),
pw.Text(
sale.saleId,
style: const pw.TextStyle(fontSize: 9),
),
],
),
pw.SizedBox(height: 4),
pw.Row(
mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
children: [
pw.Text(
'${localizations.time}:',
style: pw.TextStyle(fontSize: 9, fontWeight: pw.FontWeight.bold),
),
pw.Text(
sale.formattedDateTime,
style: const pw.TextStyle(fontSize: 9),
),
],
),
if (sale.customerName != null && sale.customerName!.isNotEmpty)
pw.Column(
children: [
pw.SizedBox(height: 4),
pw.Row(
mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
children: [
pw.Text(
'${localizations.translate("customer")}:',
style: pw.TextStyle(
fontSize: 9, fontWeight: pw.FontWeight.bold),
),
pw.Text(
sale.customerName!,
style: const pw.TextStyle(fontSize: 9),
),
],
),
],
),
if (sale.userName != null && sale.userName!.isNotEmpty)
pw.Column(
children: [
pw.SizedBox(height: 4),
pw.Row(
mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
children: [
pw.Text(
'${localizations.translate("cashier")}:',
style: pw.TextStyle(
fontSize: 9, fontWeight: pw.FontWeight.bold),
),
pw.Text(
sale.userName!,
style: const pw.TextStyle(fontSize: 9),
),
],
),
],
),
],
);
}

pw.Widget \_buildItemsTable(
List<SaleItem> items, AppLocalizations localizations) {
return pw.Table(
columnWidths: {
0: const pw.FlexColumnWidth(3),
1: const pw.FlexColumnWidth(1),
2: const pw.FlexColumnWidth(2),
3: const pw.FlexColumnWidth(2),
},
border: pw.TableBorder(
verticalInside: const pw.BorderSide(width: 0),
horizontalInside: const pw.BorderSide(width: 0),
),
children: [
// Header row
pw.TableRow(
children: [
pw.Text(
localizations.item,
style: pw.TextStyle(fontSize: 8, fontWeight: pw.FontWeight.bold),
),
pw.Text(
localizations.qty,
style: pw.TextStyle(fontSize: 8, fontWeight: pw.FontWeight.bold),
textAlign: pw.TextAlign.center,
),
pw.Text(
localizations.translate('price'),
style: pw.TextStyle(fontSize: 8, fontWeight: pw.FontWeight.bold),
textAlign: pw.TextAlign.right,
),
pw.Text(
localizations.total,
style: pw.TextStyle(fontSize: 8, fontWeight: pw.FontWeight.bold),
textAlign: pw.TextAlign.right,
),
],
),

        pw.TableRow(
          children: [
            pw.Divider(thickness: 0.5),
            pw.Divider(thickness: 0.5),
            pw.Divider(thickness: 0.5),
            pw.Divider(thickness: 0.5),
          ],
        ),

        // Item rows
        ...items
            .map((item) => pw.TableRow(
                  children: [
                    pw.Column(
                      crossAxisAlignment: pw.CrossAxisAlignment.start,
                      children: [
                        pw.Text(
                          _truncateText(item.productName, 18),
                          style: const pw.TextStyle(fontSize: 8),
                        ),
                        if (item.productNameAm != null &&
                            item.productNameAm!.isNotEmpty)
                          pw.Text(
                            _truncateText(item.productNameAm!, 18),
                            style: pw.TextStyle(
                                fontSize: 7, color: PdfColors.grey600),
                          ),
                      ],
                    ),
                    pw.Text(
                      item.quantity.toString(),
                      style: const pw.TextStyle(fontSize: 8),
                      textAlign: pw.TextAlign.center,
                    ),
                    pw.Text(
                      'ETB ${item.unitPrice.toStringAsFixed(2)}',
                      style: const pw.TextStyle(fontSize: 8),
                      textAlign: pw.TextAlign.right,
                    ),
                    pw.Text(
                      'ETB ${item.totalPrice.toStringAsFixed(2)}',
                      style: const pw.TextStyle(fontSize: 8),
                      textAlign: pw.TextAlign.right,
                    ),
                  ],
                ))
            .toList(),
      ],
    );

}

pw.Widget \_buildTotals(Sale sale, AppLocalizations localizations) {
return pw.Column(
children: [
// Use pw.Row instead of TableRow
_buildTotalRowWidget(
'${localizations.subtotal}:',
'ETB ${sale.subtotal.toStringAsFixed(2)}',
),
if (sale.taxAmount > 0)
_buildTotalRowWidget(
'${localizations.tax}:',
'ETB ${sale.taxAmount.toStringAsFixed(2)}',
),
if (sale.discountAmount > 0)
_buildTotalRowWidget(
'${localizations.discount}:',
'-ETB ${sale.discountAmount.toStringAsFixed(2)}',
),
pw.SizedBox(height: 4),
pw.Divider(thickness: 0.5),
pw.SizedBox(height: 4),
_buildTotalRowWidget(
'${localizations.total}:',
'ETB ${sale.finalAmount.toStringAsFixed(2)}',
isBold: true,
),
],
);
}

pw.Widget \_buildTotalRowWidget(String label, String value,
{bool isBold = false}) {
return pw.Row(
mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
children: [
pw.Text(
label,
style: pw.TextStyle(
fontSize: 9,
fontWeight: isBold ? pw.FontWeight.bold : pw.FontWeight.normal,
),
),
pw.Text(
value,
style: pw.TextStyle(
fontSize: 9,
fontWeight: isBold ? pw.FontWeight.bold : pw.FontWeight.normal,
),
),
],
);
}

pw.Widget \_buildPaymentInfo(Sale sale, AppLocalizations localizations) {
return pw.Column(
crossAxisAlignment: pw.CrossAxisAlignment.start,
children: [
pw.Row(
mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
children: [
pw.Text(
'${localizations.paymentMethod}:',
style: pw.TextStyle(fontSize: 9, fontWeight: pw.FontWeight.bold),
),
pw.Text(
_getPaymentMethodDisplay(sale.paymentMethod, localizations),
style: pw.TextStyle(fontSize: 9),
),
],
),
if (sale.paymentReference != null && sale.paymentReference!.isNotEmpty)
pw.Column(
children: [
pw.SizedBox(height: 4),
pw.Row(
mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
children: [
pw.Text(
'${localizations.telebirrReference}:',
style: pw.TextStyle(
fontSize: 9, fontWeight: pw.FontWeight.bold),
),
pw.Text(
sale.paymentReference!,
style: pw.TextStyle(fontSize: 9),
),
],
),
],
),
],
);
}

pw.Widget \_buildFooter(Map<String, dynamic> businessInfo, bool includeAmharic,
AppLocalizations localizations) {
return pw.Column(
crossAxisAlignment: pw.CrossAxisAlignment.center,
children: [
pw.Text(
localizations.thankYou,
style: pw.TextStyle(
fontSize: 10,
fontWeight: pw.FontWeight.bold,
),
textAlign: pw.TextAlign.center,
),
if (includeAmharic)
pw.Text(
'·ä•·äì·àò·à∞·åç·äì·àà·äï!',
style: const pw.TextStyle(fontSize: 9),
textAlign: pw.TextAlign.center,
),
pw.SizedBox(height: 8),
if (businessInfo['receiptFooter'] != null)
pw.Text(
businessInfo['receiptFooter']!,
style: const pw.TextStyle(fontSize: 7),
textAlign: pw.TextAlign.center,
),
pw.SizedBox(height: 4),
pw.Text(
'Powered by Andalus Smart POS',
style: pw.TextStyle(fontSize: 6, color: PdfColors.grey600),
textAlign: pw.TextAlign.center,
),
],
);
}

String \_truncateText(String text, int maxLength) {
if (text.length <= maxLength) return text;
return '${text.substring(0, maxLength - 3)}...';
}

String \_getPaymentMethodDisplay(
String method, AppLocalizations localizations) {
switch (method.toLowerCase()) {
case 'cash':
return localizations.cash;
case 'telebirr':
return localizations.telebirr;
case 'card':
return localizations.card;
case 'credit':
return localizations.credit;
case 'bank_transfer':
return localizations.bankTransfer;
default:
return method;
}
}

// === FILE MANAGEMENT ===
Future<File> saveReceiptToFile({
required Sale sale,
required pw.Document pdf,
String? customPath,
}) async {
final directory = await getApplicationDocumentsDirectory();
final receiptsDir = Directory('${directory.path}/receipts');

    if (!receiptsDir.existsSync()) {
      await receiptsDir.create(recursive: true);
    }

    final fileName =
        'receipt_${sale.saleId}_${DateTime.now().millisecondsSinceEpoch}.pdf';
    final filePath = customPath ?? '${receiptsDir.path}/$fileName';
    final file = File(filePath);

    final pdfBytes = await pdf.save();
    await file.writeAsBytes(pdfBytes);

    return file;

}

Future<List<File>> getSavedReceipts() async {
final directory = await getApplicationDocumentsDirectory();
final receiptsDir = Directory('${directory.path}/receipts');

    if (!receiptsDir.existsSync()) {
      return [];
    }

    final files = receiptsDir.listSync();
    return files
        .where((file) => file is File && file.path.endsWith('.pdf'))
        .map((file) => file as File)
        .toList();

}

Future<void> deleteOldReceipts({int daysToKeep = 30}) async {
final directory = await getApplicationDocumentsDirectory();
final receiptsDir = Directory('${directory.path}/receipts');

    if (!receiptsDir.existsSync()) {
      return;
    }

    final cutoffDate = DateTime.now().subtract(Duration(days: daysToKeep));
    final files = receiptsDir.listSync();

    for (final file in files) {
      if (file is File) {
        final stat = await file.stat();
        if (stat.modified.isBefore(cutoffDate)) {
          await file.delete();
        }
      }
    }

}

// === PRINTING ===
Future<void> printReceipt({
required Sale sale,
required List<SaleItem> items,
required Map<String, dynamic> businessInfo,
required AppLocalizations localizations,
}) async {
try {
final pdf = await generateReceiptPDF(
sale: sale,
items: items,
businessInfo: businessInfo,
localizations: localizations,
);

      await Printing.layoutPdf(
        onLayout: (PdfPageFormat format) async => pdf.save(),
      );

      // Save copy for records
      await saveReceiptToFile(sale: sale, pdf: pdf);
    } catch (e) {
      print('PDF printing error: $e');
      rethrow;
    }

}
}

// Provider
final receiptServiceProvider = Provider<ReceiptService>((ref) {
return ReceiptService();
});

##

// src/service/registration_service.dart
// Service for handling user and shop registration logic.
import 'package:andalus_smart_pos/src/data/models/registration.dart';
import 'package:andalus_smart_pos/src/data/repositories/subscription_repository.dart';
import 'package:andalus_smart_pos/src/data/repositories/user_repository.dart';
import 'package:crypto/crypto.dart';
import 'dart:convert';
import 'package:andalus_smart_pos/src/data/local/database.dart';
import 'package:andalus_smart_pos/src/data/models/user.dart';
import 'package:andalus_smart_pos/src/data/models/subscription.dart';
import 'package:andalus_smart_pos/src/data/models/shop_registration.dart';

class RegistrationService {
final UserRepository \_userRepository;
final SubscriptionRepository \_subscriptionRepository;

RegistrationService({
required UserRepository userRepository,
required SubscriptionRepository subscriptionRepository,
}) : \_userRepository = userRepository,
\_subscriptionRepository = subscriptionRepository;
// Convenience method to create a temporary registration using ShopRegistration directly.
Future<RegistrationResult> createTemporaryRegistrationFromShop({
required ShopRegistration shop,
required UserRegistration user,
required SubscriptionPlan plan,
required BillingCycle billingCycle,
required OwnerRegistration owner,
BusinessRegistration? business, // <--- Add '?' here
}) async {
final db = await AppDatabase.database;

    try {
      // Check if phone numbers already exist
      // ShopRegistration does not expose a `phone` getter, so read it from toMap().
      final shopPhone = shop.toMap()['phone']?.toString() ?? '';
      final shopPhoneExists = await checkShopPhoneExists(shopPhone);
      if (shopPhoneExists) {
        return RegistrationResult.failure(
            'Shop phone number already registered');
      }

      final userPhoneExists = await checkUserPhoneExists(user.phone);
      if (userPhoneExists) {
        return RegistrationResult.failure(
            'User phone number already registered');
      }

      String? tempShopId;
      String? tempOwnerId;

      await db.transaction((txn) async {
        // 1. Create temporary shop profile
        tempShopId = 'temp_shop_${DateTime.now().millisecondsSinceEpoch}';
        final now = DateTime.now().millisecondsSinceEpoch;

        await txn.insert('business_profile', {
          'business_id': tempShopId,
          ...shop.toMap(),
          'currency': 'ETB',
          'is_active': 0, // Not active until payment
          'created_at': now,
          'updated_at': now,
        });

        // 2. Create temporary owner account
        tempOwnerId = 'temp_user_${DateTime.now().millisecondsSinceEpoch}';

        // Handle email properly
        final userEmail =
            user.email?.trim().isEmpty == true ? '' : user.email?.trim() ?? '';

        final userModel = User(
          id: tempOwnerId!,
          name: user.name,
          phone: user.phone,
          email: userEmail,
          role: user.role,
          createdAt: DateTime.now(),
          isActive: false, // Not active until payment
          isVerified: false,
          businessId: tempShopId,
          passwordHash: _hashPassword(user.password),
        );

        await txn.insert('users', userModel.toMap());

        // 3. Create pending subscription
        final subscription = Subscription(
          id: 'pending_sub_${DateTime.now().millisecondsSinceEpoch}',
          businessId: tempShopId!,
          userId: tempOwnerId!,
          plan: plan,
          billingCycle: billingCycle,
          status: SubscriptionStatus.pending,
          startDate: DateTime.now(),
          endDate: DateTime.now().add(const Duration(days: 14)),
          amount: plan.getPrice(billingCycle),
          currency: 'ETB',
          isActive: false,
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        );

        await txn.insert('subscriptions', subscription.toMap());
      });

      return RegistrationResult.success(
        businessId: tempShopId,
        userId: tempOwnerId,
      );
    } catch (e) {
      print('Registration error: $e');
      return RegistrationResult.failure('Registration failed: ${e.toString()}');
    }

}

String \_hashPassword(String password) {
final bytes = utf8.encode(password);
final digest = sha256.convert(bytes);
return digest.toString();
}

Future<RegistrationResult> createTemporaryRegistration({
BusinessRegistration? business,
UserRegistration? user,
ShopRegistration? shop,
OwnerRegistration? owner,
required SubscriptionPlan plan,
required BillingCycle billingCycle,
}) async {
final db = await AppDatabase.database;

    try {
      String? phoneToCheck;

      // Determine which phone to check based on provided data
      if (shop != null) {
        final shopPhone = shop.phoneNumber;
        phoneToCheck = shopPhone;
      } else if (business != null) {
        phoneToCheck = business.phone;
      }

      if (phoneToCheck != null) {
        final shopPhoneExists = await checkShopPhoneExists(phoneToCheck);
        if (shopPhoneExists) {
          return RegistrationResult.failure('Phone number already registered');
        }
      }

      String? userPhoneToCheck;
      if (owner != null) {
        userPhoneToCheck = owner.phone;
      } else if (user != null) {
        userPhoneToCheck = user.phone;
      }

      if (userPhoneToCheck != null) {
        final userPhoneExists = await checkUserPhoneExists(userPhoneToCheck);
        if (userPhoneExists) {
          return RegistrationResult.failure(
              'User phone number already registered');
        }
      }

      String? tempShopId;
      String? tempOwnerId;

      await db.transaction((txn) async {
        // 1. Create temporary business profile
        tempShopId = 'temp_shop_${DateTime.now().millisecondsSinceEpoch}';
        final now = DateTime.now().millisecondsSinceEpoch;

        if (shop != null) {
          // Map ShopRegistration to business_profile table schema
          final shopMap = shop.toMap();
          await txn.insert('business_profile', {
            'business_id': tempShopId,
            'name': shopMap['shop_name'], // Map to 'name' column
            'name_am': shopMap[
                'shop_name'], // Use same name for Amharic or get from somewhere
            'business_type': shopMap['shop_category'], // Map to 'business_type'
            'phone': shopMap['phone_number'], // Map to 'phone'
            'email': '', // Optional field
            'address': shopMap['business_address'], // Map to 'address'
            'city': shopMap['city'],
            'region':
                shopMap['country'], // Map country to region or adjust as needed
            'tin_number':
                'TEMP_${DateTime.now().millisecondsSinceEpoch}', // Generate temp TIN
            'vat_number': null,
            'business_license': null,
            'owner_name': '', // Will be set from owner registration
            'owner_phone': '', // Will be set from owner registration
            'owner_email': null,
            'currency': 'ETB',
            'logo_path': shopMap['shop_logo'],
            'receipt_header': null,
            'receipt_footer': null,
            'is_active': 0,
            'created_at': now,
            'updated_at': now,
          });
        } else if (business != null) {
          // Use BusinessRegistration data (existing logic)
          await txn.insert('business_profile', {
            'business_id': tempShopId,
            ...business.toMap(),
            'currency': 'ETB',
            'is_active': 0,
            'created_at': now,
            'updated_at': now,
          });
        }

        // 2. Create temporary owner account
        tempOwnerId = 'temp_user_${DateTime.now().millisecondsSinceEpoch}';

        // In registration_service.dart - fix the user creation
        User userModel;
        if (owner != null) {
          // Handle email properly - use null if empty
          final userEmail =
              owner.email?.trim().isEmpty == true ? null : owner.email?.trim();

          userModel = User(
            id: tempOwnerId!,
            name: owner.fullName,
            phone: owner.phone,
            email: userEmail, // Can be null now
            role: UserRole.owner,
            createdAt: DateTime.now(),
            isActive: false,
            isVerified: false,
            businessId: tempShopId,
            passwordHash: _hashPassword(owner.password),
          );
        } else if (user != null) {
          // Use UserRegistration data - ensure email is unique
          final uniqueEmail = user.email?.isNotEmpty == true
              ? user.email
              : 'user_${DateTime.now().millisecondsSinceEpoch}@temp.com';

          userModel = User(
            id: tempOwnerId!,
            name: user.name,
            phone: user.phone,
            email: uniqueEmail!, // Ensure unique email
            role: user.role,
            createdAt: DateTime.now(),
            isActive: false,
            isVerified: false,
            businessId: tempShopId,
            passwordHash: _hashPassword(user.password),
          );
        } else {
          throw Exception('No user data provided');
        }

        await txn.insert('users', userModel.toMap());

        // 3. Update business profile with owner information
        if (owner != null && shop != null) {
          await txn.update(
            'business_profile',
            {
              'owner_name': owner.fullName,
              'owner_phone': owner.phone,
              'owner_email': owner.email,
              'updated_at': DateTime.now().millisecondsSinceEpoch,
            },
            where: 'business_id = ?',
            whereArgs: [tempShopId],
          );
        }

        // 4. Create pending subscription
        final subscription = Subscription(
          id: 'pending_sub_${DateTime.now().millisecondsSinceEpoch}',
          businessId: tempShopId!,
          userId: tempOwnerId!,
          plan: plan,
          billingCycle: billingCycle,
          status: SubscriptionStatus.pending,
          startDate: DateTime.now(),
          endDate: DateTime.now().add(const Duration(days: 14)),
          amount: plan.getPrice(billingCycle),
          currency: 'ETB',
          isActive: false,
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        );

        await txn.insert('subscriptions', subscription.toMap());
      });

      return RegistrationResult.success(
        businessId: tempShopId,
        userId: tempOwnerId,
      );
    } catch (e) {
      print('Registration error: $e');
      return RegistrationResult.failure('Registration failed: ${e.toString()}');
    }

}

Future<PaymentResult> activateAccountAfterPayment({
required String businessId,
required String userId,
required String paymentReference,
required String transactionId,
}) async {
final db = await AppDatabase.database;

    try {
      await db.transaction((txn) async {
        // 1. Activate business
        await txn.update(
          'business_profile',
          {
            'is_active': 1,
            'updated_at': DateTime.now().millisecondsSinceEpoch,
          },
          where: 'business_id = ?',
          whereArgs: [businessId],
        );

        // 2. Activate user
        await txn.update(
          'users',
          {
            'is_active': 1,
            'is_verified': 1,
            'updated_at': DateTime.now().millisecondsSinceEpoch,
          },
          where: 'user_id = ?',
          whereArgs: [userId],
        );

        // 3. Activate subscription and update payment info
        await txn.update(
          'subscriptions',
          {
            'is_active': 1,
            'status': 'active',
            'payment_reference': paymentReference,
            'updated_at': DateTime.now().millisecondsSinceEpoch,
          },
          where: 'business_id = ? AND user_id = ?',
          whereArgs: [businessId, userId],
        );
      });

      return PaymentResult.success(
        paymentReference: paymentReference,
        transactionId: transactionId,
      );
    } catch (e) {
      return PaymentResult.failure('Account activation failed: $e');
    }

}

Future<bool> checkShopPhoneExists(String phone) async {
final db = await AppDatabase.database;
final result = await db.query(
'business_profile',
where: 'phone = ?',
whereArgs: [phone],
);
return result.isNotEmpty;
}

Future<bool> checkUserPhoneExists(String phone) async {
final user = await \_userRepository.getUserByPhone(phone);
return user != null;
}
}

// Add these result classes at the bottom of the file
class RegistrationResult {
final bool success;
final String? error;
final String? businessId;
final String? userId;

const RegistrationResult({
required this.success,
this.error,
this.businessId,
this.userId,
});

factory RegistrationResult.success({String? businessId, String? userId}) {
return RegistrationResult(
success: true,
businessId: businessId,
userId: userId,
);
}

factory RegistrationResult.failure(String error) {
return RegistrationResult(success: false, error: error);
}
}

class PaymentResult {
final bool success;
final String? error;
final String? paymentReference;
final String? transactionId;

const PaymentResult({
required this.success,
this.error,
this.paymentReference,
this.transactionId,
});

factory PaymentResult.success({
required String paymentReference,
required String transactionId,
}) {
return PaymentResult(
success: true,
paymentReference: paymentReference,
transactionId: transactionId,
);
}

factory PaymentResult.failure(String error) {
return PaymentResult(success: false, error: error);
}
}

##

// lib/src/services/sync_service.dart
// Service for synchronizing local data with the remote server.
import 'dart:async';
import 'dart:convert';
import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:workmanager/workmanager.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../data/local/database.dart';
import '../data/models/sale.dart';
import '../data/models/product.dart';
import '../data/models/customer.dart';

@pragma('vm:entry-point')
void callbackDispatcher() {
Workmanager().executeTask((task, inputData) async {
try {
final service = SyncService();
await service.syncAllData();
return Future.value(true);
} catch (e) {
print('Background sync error: $e');
return Future.value(false);
}
});
}

class SyncService {
static const String \_lastSyncKey = 'last_sync_timestamp';
static const String \_syncStatusKey = 'sync_status';
static const Duration \_syncInterval = Duration(minutes: 15);
static const int \_maxRetries = 3;

Future<void> initialize() async {
await Workmanager().initialize(
callbackDispatcher,
isInDebugMode: false,
);

    // Register periodic sync
    await Workmanager().registerPeriodicTask(
      'pos_sync',
      'pos_sync_task',
      frequency: _syncInterval,
      constraints: Constraints(
        networkType: NetworkType.connected,
        requiresBatteryNotLow: false,
        requiresStorageNotLow: false,
      ),
      initialDelay: const Duration(seconds: 10),
    );

}

Future<SyncResult> syncAllData() async {
final connectivity = await Connectivity().checkConnectivity();
if (connectivity == ConnectivityResult.none) {
print('No internet connection for sync');
return SyncResult.noConnection();
}

    final prefs = await SharedPreferences.getInstance();
    final lastSync = prefs.getInt(_lastSyncKey) ?? 0;
    final now = DateTime.now().millisecondsSinceEpoch;

    // Skip if synced recently
    if (now - lastSync < _syncInterval.inMilliseconds ~/ 2) {
      return SyncResult.skipped();
    }

    try {
      await prefs.setString(_syncStatusKey, 'syncing');

      // Sync in order of importance
      final salesResult = await _syncSales();
      final productsResult = await _syncProducts();
      final customersResult = await _syncCustomers();

      await prefs.setInt(_lastSyncKey, now);
      await prefs.setString(_syncStatusKey, 'success');

      return SyncResult.success(
        syncedSales: salesResult.syncedCount,
        syncedProducts: productsResult.syncedCount,
        syncedCustomers: customersResult.syncedCount,
      );
    } catch (e, stackTrace) {
      await prefs.setString(_syncStatusKey, 'failed');

      // Log error
      print('Sync error: $e');
      print('Stack trace: $stackTrace');

      return SyncResult.failed(e.toString());
    }

}

Future<SyncBatchResult> \_syncSales() async {
final db = await AppDatabase.database;
final unsyncedSales = await db.query(
'sales',
where: 'is_synced = 0 AND sync_attempts < ?',
whereArgs: [_maxRetries],
);

    int syncedCount = 0;
    int failedCount = 0;

    for (final saleData in unsyncedSales) {
      try {
        final sale = Sale.fromMap(saleData);

        // Validate sale before syncing
        if (!sale.isValid() || !sale.isTotalValid) {
          await _markSaleAsInvalid(saleData['id'] as int);
          failedCount++;
          continue;
        }

        // Get sale items
        final items = await db.query(
          'sale_items',
          where: 'sale_id = ?',
          whereArgs: [saleData['sale_id']],
        );

        // Upload to server (simulate API call)
        // await _api.uploadSale(sale, items);
        await Future.delayed(const Duration(milliseconds: 100)); // Simulate API

        // Mark as synced
        await db.update(
          'sales',
          {
            'is_synced': 1,
            'synced_at': DateTime.now().millisecondsSinceEpoch,
            'updated_at': DateTime.now().millisecondsSinceEpoch,
          },
          where: 'id = ?',
          whereArgs: [saleData['id']],
        );

        // Mark items as synced
        for (final item in items) {
          await db.update(
            'sale_items',
            {'is_synced': 1},
            where: 'id = ?',
            whereArgs: [item['id']],
          );
        }

        syncedCount++;
      } catch (e) {
        failedCount++;

        // Increment sync attempts
        await db.update(
          'sales',
          {
            'sync_attempts': (saleData['sync_attempts'] as int? ?? 0) + 1,
            'updated_at': DateTime.now().millisecondsSinceEpoch,
          },
          where: 'id = ?',
          whereArgs: [saleData['id']],
        );

        // If max retries reached, move to failed queue
        if ((saleData['sync_attempts'] as int? ?? 0) + 1 >= _maxRetries) {
          await _moveToFailedQueue('sales', saleData);
        }
      }
    }

    return SyncBatchResult(
      type: 'sales',
      syncedCount: syncedCount,
      failedCount: failedCount,
    );

}

Future<SyncBatchResult> \_syncProducts() async {
final db = await AppDatabase.database;
final unsyncedProducts = await db.query(
'products',
where: 'is_synced = 0 AND sync_attempts < ?',
whereArgs: [_maxRetries],
);

    int syncedCount = 0;
    int failedCount = 0;

    for (final productData in unsyncedProducts) {
      try {
        final product = Product.fromMap(productData);

        // Validate product
        if (!product.verifyChecksum()) {
          await _markProductAsInvalid(productData['id'] as int);
          failedCount++;
          continue;
        }

        // Upload to server
        // await _api.uploadProduct(product);
        await Future.delayed(const Duration(milliseconds: 50));

        // Mark as synced
        await db.update(
          'products',
          {
            'is_synced': 1,
            'synced_at': DateTime.now().millisecondsSinceEpoch,
            'updated_at': DateTime.now().millisecondsSinceEpoch,
          },
          where: 'id = ?',
          whereArgs: [productData['id']],
        );

        syncedCount++;
      } catch (e) {
        failedCount++;

        await db.update(
          'products',
          {
            'sync_attempts': (productData['sync_attempts'] as int? ?? 0) + 1,
            'updated_at': DateTime.now().millisecondsSinceEpoch,
          },
          where: 'id = ?',
          whereArgs: [productData['id']],
        );
      }
    }

    return SyncBatchResult(
      type: 'products',
      syncedCount: syncedCount,
      failedCount: failedCount,
    );

}

Future<SyncBatchResult> \_syncCustomers() async {
final db = await AppDatabase.database;
final unsyncedCustomers = await db.query(
'customers',
where: 'is_synced = 0 AND sync_attempts < ?',
whereArgs: [_maxRetries],
);

    int syncedCount = 0;
    int failedCount = 0;

    for (final customerData in unsyncedCustomers) {
      try {
        // Upload to server
        // await _api.uploadCustomer(customerData);
        await Future.delayed(const Duration(milliseconds: 50));

        // Mark as synced
        await db.update(
          'customers',
          {
            'is_synced': 1,
            'synced_at': DateTime.now().millisecondsSinceEpoch,
            'updated_at': DateTime.now().millisecondsSinceEpoch,
          },
          where: 'id = ?',
          whereArgs: [customerData['id']],
        );

        syncedCount++;
      } catch (e) {
        failedCount++;

        await db.update(
          'customers',
          {
            'sync_attempts': (customerData['sync_attempts'] as int? ?? 0) + 1,
            'updated_at': DateTime.now().millisecondsSinceEpoch,
          },
          where: 'id = ?',
          whereArgs: [customerData['id']],
        );
      }
    }

    return SyncBatchResult(
      type: 'customers',
      syncedCount: syncedCount,
      failedCount: failedCount,
    );

}

Future<void> \_markSaleAsInvalid(int saleId) async {
final db = await AppDatabase.database;
await db.update(
'sales',
{
'is_synced': 2, // 2 = invalid
'updated_at': DateTime.now().millisecondsSinceEpoch,
},
where: 'id = ?',
whereArgs: [saleId],
);
}

Future<void> \_markProductAsInvalid(int productId) async {
final db = await AppDatabase.database;
await db.update(
'products',
{
'is_synced': 2, // 2 = invalid
'updated_at': DateTime.now().millisecondsSinceEpoch,
},
where: 'id = ?',
whereArgs: [productId],
);
}

Future<void> \_moveToFailedQueue(
String type, Map<String, dynamic> data) async {
final db = await AppDatabase.database;
await db.insert('failed_syncs', {
'type': type,
'data': jsonEncode(data),
'error': 'Max retries reached',
'created_at': DateTime.now().millisecondsSinceEpoch,
});
}

// === SYNC STATUS ===
Future<SyncStatus> getSyncStatus() async {
final prefs = await SharedPreferences.getInstance();
final status = prefs.getString(\_syncStatusKey) ?? 'idle';
final lastSync = prefs.getInt(\_lastSyncKey) ?? 0;

    return SyncStatus(
      status: status,
      lastSync:
          lastSync == 0 ? null : DateTime.fromMillisecondsSinceEpoch(lastSync),
    );

}

Future<void> forceSync() async {
await syncAllData();
}

Future<List<Map<String, dynamic>>> getFailedSyncs() async {
final db = await AppDatabase.database;
return await db.query('failed_syncs', orderBy: 'created_at DESC');
}

Future<void> retryFailedSync(int id) async {
final db = await AppDatabase.database;
final failed =
await db.query('failed_syncs', where: 'id = ?', whereArgs: [id]);

    if (failed.isNotEmpty) {
      final data = jsonDecode(failed.first['data'] as String);
      final type = failed.first['type'] as String;

      // Retry logic based on type
      // ...

      // Remove from failed queue
      await db.delete('failed_syncs', where: 'id = ?', whereArgs: [id]);
    }

}
}

// === DATA CLASSES ===
class SyncResult {
final bool success;
final String? error;
final int syncedSales;
final int syncedProducts;
final int syncedCustomers;
final bool hasConnection;
final bool wasSkipped;

const SyncResult({
required this.success,
this.error,
this.syncedSales = 0,
this.syncedProducts = 0,
this.syncedCustomers = 0,
this.hasConnection = true,
this.wasSkipped = false,
});

factory SyncResult.success({
int syncedSales = 0,
int syncedProducts = 0,
int syncedCustomers = 0,
}) {
return SyncResult(
success: true,
syncedSales: syncedSales,
syncedProducts: syncedProducts,
syncedCustomers: syncedCustomers,
);
}

factory SyncResult.failed(String error) {
return SyncResult(success: false, error: error);
}

factory SyncResult.noConnection() {
return SyncResult(success: false, hasConnection: false);
}

factory SyncResult.skipped() {
return SyncResult(success: true, wasSkipped: true);
}
}

class SyncBatchResult {
final String type;
final int syncedCount;
final int failedCount;

const SyncBatchResult({
required this.type,
required this.syncedCount,
required this.failedCount,
});
}

class SyncStatus {
final String status; // 'idle', 'syncing', 'success', 'failed'
final DateTime? lastSync;

const SyncStatus({
required this.status,
this.lastSync,
});

bool get isSyncing => status == 'syncing';
bool get hasSynced => lastSync != null;
}

// Provider
final syncServiceProvider = Provider<SyncService>((ref) {
return SyncService();
});

##

//src/ui/screens/account/account_management_screen.dart
// Screen for managing user account settings.
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
import 'package:andalus_smart_pos/src/providers/auth_provider.dart';
import 'package:andalus_smart_pos/src/providers/theme_provider.dart';
import 'package:andalus_smart_pos/src/providers/language_provider.dart';
import 'package:andalus_smart_pos/src/data/models/user.dart';
import 'package:andalus_smart_pos/src/ui/screens/auth/phone_login_screen.dart';

class AccountManagementScreen extends ConsumerStatefulWidget {
const AccountManagementScreen({super.key});

@override
ConsumerState<AccountManagementScreen> createState() =>
\_AccountManagementScreenState();
}

class \_AccountManagementScreenState
extends ConsumerState<AccountManagementScreen> {
final \_nameController = TextEditingController();
final \_phoneController = TextEditingController();
final \_emailController = TextEditingController();
final \_currentPasswordController = TextEditingController();
final \_newPasswordController = TextEditingController();
final \_confirmPasswordController = TextEditingController();

bool \_isEditing = false;
bool \_isChangingPassword = false;

@override
void initState() {
super.initState();
\_loadUserData();
}

void \_loadUserData() {
final authState = ref.read(authProvider);
final user = authState.user;

    if (user != null) {
      _nameController.text = user.name;
      _phoneController.text = user.phone;
      _emailController.text = user.email ?? '';
    }

}

@override
void dispose() {
\_nameController.dispose();
\_phoneController.dispose();
\_emailController.dispose();
\_currentPasswordController.dispose();
\_newPasswordController.dispose();
\_confirmPasswordController.dispose();
super.dispose();
}

void \_toggleEdit() {
setState(() {
\_isEditing = !\_isEditing;
if (!\_isEditing) {
\_loadUserData(); // Reset changes
}
});
}

void \_togglePasswordChange() {
setState(() {
\_isChangingPassword = !\_isChangingPassword;
if (!\_isChangingPassword) {
\_currentPasswordController.clear();
\_newPasswordController.clear();
\_confirmPasswordController.clear();
}
});
}

Future<void> \_updateProfile() async {
final authState = ref.read(authProvider);
final user = authState.user;

    if (user == null) return;

    // TODO: Implement profile update logic
    final updatedUser = user.copyWith(
      name: _nameController.text,
      phone: _phoneController.text,
      email: _emailController.text.isEmpty ? null : _emailController.text,
    );

    // Update user in provider/database
    // await ref.read(authProvider.notifier).updateProfile(updatedUser);

    setState(() => _isEditing = false);

    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content:
              Text(AppLocalizations.of(context).translate('settingsSaved')),
          backgroundColor: Colors.green,
        ),
      );
    }

}

Future<void> \_changePassword() async {
if (\_newPasswordController.text != \_confirmPasswordController.text) {
if (mounted) {
ScaffoldMessenger.of(context).showSnackBar(
const SnackBar(
content: Text('New passwords do not match'),
backgroundColor: Colors.red,
),
);
}
return;
}

    // TODO: Implement password change logic
    // await ref.read(authServiceProvider).changePassword(
    //   userId,
    //   _newPasswordController.text,
    // );

    _togglePasswordChange();

    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Password changed successfully'),
          backgroundColor: Colors.green,
        ),
      );
    }

}

void \_logout() {
showDialog(
context: context,
builder: (context) => AlertDialog(
title: Text(AppLocalizations.of(context).translate('confirm')),
content: Text(AppLocalizations.of(context)
.translate('Are you sure you want to logout?')),
actions: [
TextButton(
onPressed: () => Navigator.pop(context),
child: Text(AppLocalizations.of(context).translate('cancel')),
),
TextButton(
onPressed: () {
Navigator.pop(context);
_performLogout();
},
style: TextButton.styleFrom(foregroundColor: Colors.red),
child: Text(AppLocalizations.of(context).translate('confirm')),
),
],
),
);
}

void \_performLogout() {
ref.read(authProvider.notifier).logout();
Navigator.pushAndRemoveUntil(
context,
MaterialPageRoute(builder: (context) => const PhoneLoginScreen()),
(route) => false,
);
}

@override
Widget build(BuildContext context) {
final authState = ref.watch(authProvider);
final themeMode = ref.watch(themeProvider);
final locale = ref.watch(languageProvider);
final localizations = AppLocalizations.of(context);
final user = authState.user;

    return Scaffold(
      appBar: AppBar(
        title: Text(localizations.translate('Account Settings')),
        actions: [
          if (_isEditing) ...[
            IconButton(
              icon: const Icon(Icons.save),
              onPressed: _updateProfile,
              tooltip: 'Save Changes',
            ),
            IconButton(
              icon: const Icon(Icons.cancel),
              onPressed: _toggleEdit,
              tooltip: 'Cancel',
            ),
          ] else if (!_isChangingPassword) ...[
            IconButton(
              icon: const Icon(Icons.edit),
              onPressed: _toggleEdit,
              tooltip: 'Edit Profile',
            ),
          ],
        ],
      ),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          // User Profile Section
          Card(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      const CircleAvatar(
                        radius: 30,
                        backgroundColor: Colors.blue,
                        child:
                            Icon(Icons.person, color: Colors.white, size: 30),
                      ),
                      const SizedBox(width: 16),
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              user?.name ?? 'No Name',
                              style: const TextStyle(
                                fontSize: 18,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                            const SizedBox(height: 4),
                            Text(
                              user?.role.displayName ?? 'User',
                              style: TextStyle(
                                color: Colors.grey.shade600,
                              ),
                            ),
                            const SizedBox(height: 4),
                            Text(
                              user?.phone ?? 'No Phone',
                              style: TextStyle(
                                color: Colors.grey.shade600,
                              ),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 16),

                  // Profile Form
                  if (_isEditing) _buildProfileForm(),
                ],
              ),
            ),
          ),
          const SizedBox(height: 16),

          // Appearance & Language Section
          Card(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    localizations.appearanceLanguage,
                    style: const TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 16),

                  // Theme Mode
                  ListTile(
                    leading: const Icon(Icons.dark_mode),
                    title: Text(localizations.themeMode),
                    subtitle: Text(_getThemeModeText(themeMode, localizations)),
                    trailing: DropdownButton<ThemeMode>(
                      value: themeMode,
                      onChanged: (newMode) {
                        if (newMode != null) {
                          ref.read(themeProvider.notifier).setTheme(newMode);
                        }
                      },
                      items: ThemeMode.values.map((mode) {
                        return DropdownMenuItem(
                          value: mode,
                          child: Text(_getThemeModeText(mode, localizations)),
                        );
                      }).toList(),
                    ),
                  ),
                  const Divider(),

                  // Language
                  ListTile(
                    leading: const Icon(Icons.language),
                    title: Text(localizations.language),
                    subtitle: Text(_getLanguageText(locale, localizations)),
                    trailing: DropdownButton<Locale>(
                      value: locale,
                      onChanged: (newLocale) {
                        if (newLocale != null) {
                          ref
                              .read(languageProvider.notifier)
                              .setLanguage(newLocale.languageCode);
                        }
                      },
                      items: const [
                        DropdownMenuItem(
                          value: Locale('en'),
                          child: Text('English'),
                        ),
                        DropdownMenuItem(
                          value: Locale('am'),
                          child: Text('·ä†·àõ·à≠·äõ'),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ),
          ),
          const SizedBox(height: 16),

          // Security Section
          Card(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Security',
                    style: const TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 16),
                  if (_isChangingPassword) ...[
                    _buildPasswordChangeForm(),
                    const SizedBox(height: 16),
                  ],
                  SizedBox(
                    width: double.infinity,
                    child: OutlinedButton(
                      onPressed: _isChangingPassword
                          ? _changePassword
                          : _togglePasswordChange,
                      child: Text(_isChangingPassword
                          ? 'Change Password'
                          : 'Change Password'),
                    ),
                  ),
                ],
              ),
            ),
          ),
          const SizedBox(height: 16),

          // Logout Section
          Card(
            color: Colors.red.shade50,
            child: ListTile(
              leading: Icon(Icons.logout, color: Colors.red.shade600),
              title: Text(
                'Logout',
                style: TextStyle(
                  color: Colors.red.shade700,
                  fontWeight: FontWeight.bold,
                ),
              ),
              trailing: Icon(Icons.arrow_forward, color: Colors.red.shade600),
              onTap: _logout,
            ),
          ),
        ],
      ),
    );

}

Widget \_buildProfileForm() {
return Column(
children: [
TextFormField(
controller: _nameController,
decoration: const InputDecoration(
labelText: 'Full Name',
border: OutlineInputBorder(),
),
),
const SizedBox(height: 12),
TextFormField(
controller: _phoneController,
decoration: const InputDecoration(
labelText: 'Phone Number',
border: OutlineInputBorder(),
),
keyboardType: TextInputType.phone,
),
const SizedBox(height: 12),
TextFormField(
controller: _emailController,
decoration: const InputDecoration(
labelText: 'Email (Optional)',
border: OutlineInputBorder(),
),
keyboardType: TextInputType.emailAddress,
),
],
);
}

Widget \_buildPasswordChangeForm() {
return Column(
children: [
TextFormField(
controller: _currentPasswordController,
decoration: const InputDecoration(
labelText: 'Current Password',
border: OutlineInputBorder(),
),
obscureText: true,
),
const SizedBox(height: 12),
TextFormField(
controller: _newPasswordController,
decoration: const InputDecoration(
labelText: 'New Password',
border: OutlineInputBorder(),
),
obscureText: true,
),
const SizedBox(height: 12),
TextFormField(
controller: _confirmPasswordController,
decoration: const InputDecoration(
labelText: 'Confirm New Password',
border: OutlineInputBorder(),
),
obscureText: true,
),
],
);
}

String \_getThemeModeText(ThemeMode mode, AppLocalizations localizations) {
switch (mode) {
case ThemeMode.light:
return localizations.light;
case ThemeMode.dark:
return localizations.dark;
case ThemeMode.system:
return localizations.systemDefault;
}
}

String \_getLanguageText(Locale locale, AppLocalizations localizations) {
return locale.languageCode == 'en'
? localizations.english
: localizations.amharic;
}
}

##

// lib/src/ui/screens/auth/forgot_password_screen.dart
// Screen for handling the "Forgot Password" functionality.
import 'package:andalus_smart_pos/src/widgets/common/app_button.dart';
import 'package:andalus_smart_pos/src/widgets/common/app_text_field.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';

class ForgotPasswordScreen extends ConsumerStatefulWidget {
const ForgotPasswordScreen({super.key});

@override
ConsumerState<ForgotPasswordScreen> createState() =>
\_ForgotPasswordScreenState();
}

class \_ForgotPasswordScreenState extends ConsumerState<ForgotPasswordScreen> {
final \_phoneController = TextEditingController();
final \_otpController = TextEditingController();
final \_newPasswordController = TextEditingController();
final \_confirmPasswordController = TextEditingController();

final \_formKey = GlobalKey<FormState>();
final \_step2FormKey = GlobalKey<FormState>();

int \_currentStep = 0;
bool \_isLoading = false;
bool \_isResendingOTP = false;
String? \_errorMessage;

@override
void dispose() {
\_phoneController.dispose();
\_otpController.dispose();
\_newPasswordController.dispose();
\_confirmPasswordController.dispose();
super.dispose();
}

Future<void> \_sendOTP() async {
if (!\_formKey.currentState!.validate()) return;

    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      // Simulate API call
      await Future.delayed(const Duration(seconds: 2));

      // TODO: Implement actual OTP sending logic
      // await ref.read(authProvider.notifier).sendPasswordResetOTP(_phoneController.text.trim());

      setState(() {
        _currentStep = 1;
        _isLoading = false;
      });

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
              AppLocalizations.of(context).translate('otpSentSuccessfully')),
          backgroundColor: Colors.green,
        ),
      );
    } catch (e) {
      setState(() {
        _isLoading = false;
        _errorMessage = e.toString();
      });
    }

}

Future<void> \_resendOTP() async {
setState(() => \_isResendingOTP = true);

    try {
      // Simulate API call
      await Future.delayed(const Duration(seconds: 2));

      // TODO: Implement actual OTP resend logic

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
              AppLocalizations.of(context).translate('otpResentSuccessfully')),
          backgroundColor: Colors.green,
        ),
      );
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(e.toString()),
          backgroundColor: Colors.red,
        ),
      );
    } finally {
      setState(() => _isResendingOTP = false);
    }

}

Future<void> \_verifyOTPAndResetPassword() async {
if (!\_step2FormKey.currentState!.validate()) return;

    if (_newPasswordController.text != _confirmPasswordController.text) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
              AppLocalizations.of(context).translate('passwordsDoNotMatch')),
          backgroundColor: Colors.red,
        ),
      );
      return;
    }

    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      // Simulate API call
      await Future.delayed(const Duration(seconds: 2));

      // TODO: Implement actual password reset logic
      // await ref.read(authProvider.notifier).resetPassword(
      //   _phoneController.text.trim(),
      //   _otpController.text.trim(),
      //   _newPasswordController.text,
      // );

      setState(() {
        _currentStep = 2;
        _isLoading = false;
      });

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(AppLocalizations.of(context)
              .translate('passwordResetSuccessfully')),
          backgroundColor: Colors.green,
        ),
      );
    } catch (e) {
      setState(() {
        _isLoading = false;
        _errorMessage = e.toString();
      });
    }

}

void \_navigateToLogin() {
Navigator.of(context).pop();
}

String? \_validatePhone(String? value) {
if (value == null || value.trim().isEmpty) {
return AppLocalizations.of(context).translate('phoneRequired');
}
if (!RegExp(r'^\+251[0-9]{9}$').hasMatch(value.trim())) {
return AppLocalizations.of(context).translate('validEthiopianPhone');
}
return null;
}

String? \_validateOTP(String? value) {
if (value == null || value.trim().isEmpty) {
return AppLocalizations.of(context).translate('otpRequired');
}
if (value.trim().length != 6) {
return AppLocalizations.of(context).translate('otpMustBe6Digits');
}
return null;
}

String? \_validatePassword(String? value) {
if (value == null || value.isEmpty) {
return AppLocalizations.of(context).translate('passwordRequired');
}
if (value.length < 6) {
return AppLocalizations.of(context).translate('passwordMinLength');
}
return null;
}

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);
final loc = AppLocalizations.of(context);

    return Scaffold(
      appBar: AppBar(
        title: Text(loc.translate('forgotPassword')),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: _navigateToLogin,
        ),
      ),
      body: Padding(
        padding: const EdgeInsets.all(24),
        child: _buildStepContent(theme, loc),
      ),
    );

}

Widget \_buildStepContent(ThemeData theme, AppLocalizations loc) {
switch (\_currentStep) {
case 0:
return \_buildStep1(theme, loc);
case 1:
return \_buildStep2(theme, loc);
case 2:
return \_buildSuccessStep(theme, loc);
default:
return \_buildStep1(theme, loc);
}
}

Widget \_buildStep1(ThemeData theme, AppLocalizations loc) {
return Form(
key: \_formKey,
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
// Header
Icon(
Icons.lock_reset_rounded,
size: 80,
color: theme.colorScheme.primary,
),
const SizedBox(height: 24),
Text(
loc.translate('resetYourPassword'),
style: theme.textTheme.headlineSmall?.copyWith(
fontWeight: FontWeight.w700,
),
),
const SizedBox(height: 8),
Text(
loc.translate('enterPhoneToResetPassword'),
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.6),
),
),
const SizedBox(height: 32),

          // Phone Input
          AppTextField(
            controller: _phoneController,
            label: loc.translate('phoneNumber'),
            prefixText: '+251 ',
            prefixIcon: Icon(
              Icons.phone_rounded,
              color: theme.colorScheme.primary,
            ),
            keyboardType: TextInputType.phone,
            enabled: !_isLoading,
            validator: _validatePhone,
            textInputAction: TextInputAction.done,
          ),
          const SizedBox(height: 16),

          // Error Message
          if (_errorMessage != null) ...[
            Container(
              width: double.infinity,
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: theme.colorScheme.errorContainer,
                borderRadius: BorderRadius.circular(8),
              ),
              child: Row(
                children: [
                  Icon(
                    Icons.error_outline_rounded,
                    color: theme.colorScheme.onErrorContainer,
                    size: 16,
                  ),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      _errorMessage!,
                      style: theme.textTheme.bodySmall?.copyWith(
                        color: theme.colorScheme.onErrorContainer,
                      ),
                    ),
                  ),
                ],
              ),
            ),
            const SizedBox(height: 16),
          ],

          const Spacer(),

          // Send OTP Button
          AppButton.primary(
            onPressed: _isLoading ? null : _sendOTP,
            isLoading: _isLoading,
            child: Text(loc.translate('sendOTP')),
          ),
        ],
      ),
    );

}

Widget \_buildStep2(ThemeData theme, AppLocalizations loc) {
return Form(
key: \_step2FormKey,
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
// Header
Icon(
Icons.verified_user_rounded,
size: 80,
color: theme.colorScheme.primary,
),
const SizedBox(height: 24),
Text(
loc.translate('verifyAndReset'),
style: theme.textTheme.headlineSmall?.copyWith(
fontWeight: FontWeight.w700,
),
),
const SizedBox(height: 8),
Text(
loc.translate('enterOTPAndNewPassword'),
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.6),
),
),
const SizedBox(height: 32),

          // OTP Input
          AppTextField(
            controller: _otpController,
            label: loc.translate('enterOTPCode'),
            prefixIcon: Icon(
              Icons.sms_rounded,
              color: theme.colorScheme.primary,
            ),
            keyboardType: TextInputType.number,
            maxLength: 6,
            enabled: !_isLoading,
            validator: _validateOTP,
          ),
          const SizedBox(height: 16),

          // New Password
          AppTextField(
            controller: _newPasswordController,
            label: loc.translate('newPassword'),
            prefixIcon: Icon(
              Icons.lock_rounded,
              color: theme.colorScheme.primary,
            ),
            obscureText: true,
            enabled: !_isLoading,
            validator: _validatePassword,
          ),
          const SizedBox(height: 16),

          // Confirm Password
          AppTextField(
            controller: _confirmPasswordController,
            label: loc.translate('confirmNewPassword'),
            prefixIcon: Icon(
              Icons.lock_outline_rounded,
              color: theme.colorScheme.primary,
            ),
            obscureText: true,
            enabled: !_isLoading,
            validator: (value) {
              if (value != _newPasswordController.text) {
                return loc.translate('passwordsDoNotMatch');
              }
              return null;
            },
          ),
          const SizedBox(height: 16),

          // Resend OTP
          Center(
            child: TextButton(
              onPressed: _isResendingOTP ? null : _resendOTP,
              child: _isResendingOTP
                  ? Text(loc.translate('resendingOTP'))
                  : Text(loc.translate('resendOTP')),
            ),
          ),

          const Spacer(),

          // Reset Password Button
          AppButton.primary(
            onPressed: _isLoading ? null : _verifyOTPAndResetPassword,
            isLoading: _isLoading,
            child: Text(loc.translate('resetPassword')),
          ),
        ],
      ),
    );

}

Widget \_buildSuccessStep(ThemeData theme, AppLocalizations loc) {
return Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
Icon(
Icons.check_circle_rounded,
size: 100,
color: Colors.green,
),
const SizedBox(height: 32),
Text(
loc.translate('passwordResetSuccessfully'),
style: theme.textTheme.headlineSmall?.copyWith(
fontWeight: FontWeight.w700,
color: Colors.green,
),
textAlign: TextAlign.center,
),
const SizedBox(height: 16),
Text(
loc.translate('youCanNowLoginWithNewPassword'),
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.6),
),
textAlign: TextAlign.center,
),
const SizedBox(height: 40),
AppButton.primary(
onPressed: _navigateToLogin,
child: Text(loc.translate('backToLogin')),
),
],
);
}
}

##

// src/ui/screens/auth/otp_verification_screen.dart
// Screen for OTP verification during registration or login.
import 'dart:async';

import 'package:andalus_smart_pos/src/widgets/common/app_button.dart';
import 'package:andalus_smart_pos/src/widgets/common/app_text_field.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
import 'package:andalus_smart_pos/src/providers/auth_provider.dart';

class OTPVerificationScreen extends ConsumerStatefulWidget {
final String phone;
final VerificationType type;
final String? businessName;

const OTPVerificationScreen({
super.key,
required this.phone,
required this.type,
this.businessName,
});

@override
ConsumerState<OTPVerificationScreen> createState() =>
\_OTPVerificationScreenState();
}

class \_OTPVerificationScreenState extends ConsumerState<OTPVerificationScreen> {
final \_otpController = TextEditingController();
final \_formKey = GlobalKey<FormState>();
final \_focusNode = FocusNode();

bool \_isLoading = false;
bool \_isResending = false;
int \_resendCooldown = 0;
Timer? \_cooldownTimer;

@override
void initState() {
super.initState();
\_sendOTP();
\_focusNode.requestFocus();
}

@override
void dispose() {
\_otpController.dispose();
\_focusNode.dispose();
\_cooldownTimer?.cancel();
super.dispose();
}

Future<void> \_sendOTP() async {
if (widget.phone.isEmpty) {
\_showError('Phone number not set');
return;
}

    try {
      setState(() => _isResending = true);

      // Use the generic sendOTP method from your AuthService
      await ref.read(authProvider.notifier).sendOTP(widget.phone);

      // Start cooldown timer (60 seconds)
      _startCooldownTimer();

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              AppLocalizations.of(context).translate('otpSentSuccessfully'),
            ),
            backgroundColor: Colors.green,
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
    } catch (e) {
      _showError(e.toString());
    } finally {
      if (mounted) {
        setState(() => _isResending = false);
      }
    }

}

void \_startCooldownTimer() {
setState(() => \_resendCooldown = 60);

    _cooldownTimer?.cancel();
    _cooldownTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (_resendCooldown > 0) {
        setState(() => _resendCooldown--);
      } else {
        timer.cancel();
      }
    });

}

Future<void> \_verifyOTP() async {
if (!\_formKey.currentState!.validate()) return;
if (\_isLoading) return;

    setState(() => _isLoading = true);

    try {
      // Use the appropriate method based on verification type
      if (widget.type == VerificationType.registration) {
        // For registration, you'll need to handle this differently
        // This would typically be called from your registration flow
        _showError(
            'Registration OTP verification should be handled in registration flow');
      } else {
        // For login, use the existing loginWithOTP method
        await ref.read(authProvider.notifier).verifyOTPAndLogin(
              widget.phone,
              _otpController.text.trim(),
            );
      }

      // Success handling is done via auth state listener
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              widget.type == VerificationType.registration
                  ? AppLocalizations.of(context)
                      .translate('registrationSuccessful')
                  : AppLocalizations.of(context).translate('loginSuccessful'),
            ),
            backgroundColor: Colors.green,
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
    } catch (e) {
      _showError(e.toString());
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }

}

void \_showError(String message) {
if (mounted) {
ScaffoldMessenger.of(context).showSnackBar(
SnackBar(
content: Text(message),
backgroundColor: Colors.red,
behavior: SnackBarBehavior.floating,
duration: const Duration(seconds: 4),
),
);
}
}

String? \_validateOTP(String? value) {
if (value == null || value.trim().isEmpty) {
return AppLocalizations.of(context).translate('otpRequired');
}
if (value.trim().length != 6) {
return AppLocalizations.of(context).translate('otpMustBe6Digits');
}
if (!RegExp(r'^[0-9]{6}$').hasMatch(value.trim())) {
return AppLocalizations.of(context).translate('otpMustBeNumbers');
}
return null;
}

String \_formatPhone(String phone) {
if (phone.startsWith('+251')) {
return '+251 ${phone.substring(4, 6)} ${phone.substring(6, 9)} ${phone.substring(9)}';
}
return phone;
}

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);
final loc = AppLocalizations.of(context);

    return Scaffold(
      appBar: AppBar(
        title: Text(loc.translate('verifyPhone')),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: _isLoading ? null : () => Navigator.of(context).pop(),
        ),
      ),
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Form(
            key: _formKey,
            child: Column(
              children: [
                // Header Section
                _buildHeaderSection(theme, loc),
                const SizedBox(height: 32),

                // OTP Input Section
                _buildOTPInputSection(theme, loc),
                const SizedBox(height: 24),

                // Action Buttons
                _buildActionButtons(theme, loc),

                // Spacer to prevent overflow
                const Expanded(child: SizedBox()),

                // Demo Hint (Remove in production)
                _buildDemoHint(theme),
              ],
            ),
          ),
        ),
      ),
    );

}

Widget \_buildHeaderSection(ThemeData theme, AppLocalizations loc) {
return Column(
children: [
Icon(
Icons.verified_user_rounded,
size: 80,
color: theme.colorScheme.primary,
),
const SizedBox(height: 24),
Text(
loc.translate('verifyYourPhone'),
style: theme.textTheme.headlineSmall?.copyWith(
fontWeight: FontWeight.w700,
),
textAlign: TextAlign.center,
),
const SizedBox(height: 12),
Text(
loc.translate('otpSentToPhone',
params: {'phone': \_formatPhone(widget.phone)}),
style: theme.textTheme.bodyLarge?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.7),
),
textAlign: TextAlign.center,
),
if (widget.businessName != null) ...[
const SizedBox(height: 8),
Text(
loc.translate('forBusiness',
params: {'business': widget.businessName!}),
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.primary,
fontWeight: FontWeight.w600,
),
textAlign: TextAlign.center,
),
],
],
);
}

Widget _buildOTPInputSection(ThemeData theme, AppLocalizations loc) {
return Column(
children: [
AppTextField(
controller: \_otpController,
label: loc.translate('enterOTPCode'),
hintText: '123456',
keyboardType: TextInputType.number,
maxLength: 6,
validator: \_validateOTP,
focusNode: \_focusNode,
textInputAction: TextInputAction.done,
onSubmitted: (_) => _verifyOTP(),
onChanged: (value) {
if (value.length == 6) {
\_focusNode.unfocus();
// Auto-submit when 6 digits are entered
WidgetsBinding.instance.addPostFrameCallback((_) {
\_verifyOTP();
});
}
},
),
const SizedBox(height: 8),
Text(
loc.translate('enter6DigitCode'),
style: theme.textTheme.bodySmall?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.6),
),
),
],
);
}

Widget \_buildActionButtons(ThemeData theme, AppLocalizations loc) {
return Column(
children: [
AppButton.primary(
onPressed: \_isLoading ? null : \_verifyOTP,
isLoading: \_isLoading,
child: Text(
loc.translate('verifyAndContinue'),
style: const TextStyle(fontWeight: FontWeight.w600),
),
),
const SizedBox(height: 20),
Row(
mainAxisAlignment: MainAxisAlignment.center,
children: [
Text(
loc.translate('didNotReceiveCode'),
style: theme.textTheme.bodyMedium,
),
const SizedBox(width: 8),
if (_resendCooldown > 0)
Text(
'(${_resendCooldown}s)',
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.primary,
fontWeight: FontWeight.w600,
),
)
else
TextButton(
onPressed: (_isResending || _isLoading) ? null : _sendOTP,
child: _isResending
? SizedBox(
height: 16,
width: 16,
child: CircularProgressIndicator(
strokeWidth: 2,
color: theme.colorScheme.primary,
),
)
: Text(
loc.translate('resendOTP'),
style: TextStyle(
color: theme.colorScheme.primary,
fontWeight: FontWeight.w600,
),
),
),
],
),
],
);
}

Widget \_buildDemoHint(ThemeData theme) {
return Column(
children: [
const Divider(),
const SizedBox(height: 16),
Container(
padding: const EdgeInsets.all(16),
decoration: BoxDecoration(
color: theme.colorScheme.surfaceVariant,
borderRadius: BorderRadius.circular(12),
),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Row(
children: [
Icon(
Icons.info_outline_rounded,
size: 16,
color: theme.colorScheme.primary,
),
const SizedBox(width: 8),
Text(
'Demo Mode',
style: theme.textTheme.bodySmall?.copyWith(
fontWeight: FontWeight.w600,
color: theme.colorScheme.primary,
),
),
],
),
const SizedBox(height: 8),
Text(
'‚Ä¢ Use "123456" for instant verification\n‚Ä¢ OTPs expire after 10 minutes\n‚Ä¢ Remove this hint in production',
style: theme.textTheme.bodySmall?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.6),
),
),
],
),
),
],
);
}
}

enum VerificationType {
registration,
login,
}

##

// lib/src/ui/screens/auth/phone_login_screen.dart
// Screen for phone number and password login.
import 'package:andalus_smart_pos/src/widgets/common/app_button.dart';
import 'package:andalus_smart_pos/src/widgets/common/app_text_field.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
import 'package:andalus_smart_pos/src/providers/auth_provider.dart';
import 'package:andalus_smart_pos/src/ui/screens/onboarding/onboarding_screen.dart';
import 'package:andalus_smart_pos/src/ui/screens/main_navigation.dart';

class PhoneLoginScreen extends ConsumerStatefulWidget {
const PhoneLoginScreen({super.key});

@override
ConsumerState<PhoneLoginScreen> createState() => \_PhoneLoginScreenState();
}

class \_PhoneLoginScreenState extends ConsumerState<PhoneLoginScreen> {
final \_phoneController = TextEditingController();
final \_passwordController = TextEditingController();
final \_formKey = GlobalKey<FormState>();
final \_passwordFocusNode = FocusNode();

bool \_isLoggingIn = false;
String? \_loginError;

@override
void dispose() {
\_phoneController.dispose();
\_passwordController.dispose();
\_passwordFocusNode.dispose();
super.dispose();
}

Future<void> \_loginWithPassword() async {
if (!(\_formKey.currentState?.validate() ?? false)) return;

    if (_isLoggingIn) return;

    setState(() {
      _isLoggingIn = true;
      _loginError = null;
    });

    try {
      await ref.read(authProvider.notifier).loginWithPassword(
            _phoneController.text.trim(),
            _passwordController.text,
          );

      // Success handling is done in the auth state listener
    } catch (e) {
      setState(() {
        _isLoggingIn = false;
        _loginError = e.toString();
      });

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(e.toString()),
          backgroundColor: Theme.of(context).colorScheme.error,
          duration: const Duration(seconds: 3),
        ),
      );
    }

}

String? \_validatePhone(String? value) {
if (value == null || value.trim().isEmpty) {
return AppLocalizations.of(context).translate('phoneRequired');
}
if (!RegExp(r'^\+251[0-9]{9}$').hasMatch(value.trim())) {
return AppLocalizations.of(context).translate('validEthiopianPhone');
}
return null;
}

String? \_validatePassword(String? value) {
if (value == null || value.isEmpty) {
return AppLocalizations.of(context).translate('passwordRequired');
}
if (value.length < 6) {
return AppLocalizations.of(context).translate('passwordMinLength');
}
return null;
}

void \_navigateToOnboarding() {
Navigator.push(
context,
MaterialPageRoute(builder: (context) => const OnboardingScreen()),
);
}

@override
Widget build(BuildContext context) {
final authState = ref.watch(authProvider);
final theme = Theme.of(context);
final loc = AppLocalizations.of(context);

    // Handle successful login
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (authState.isAuthenticated) {
        Navigator.of(context).pushReplacement(
          MaterialPageRoute(builder: (context) => const MainNavigation()),
        );
      }
    });

    return Scaffold(
      backgroundColor: theme.colorScheme.primary,
      body: SafeArea(
        child: Center(
          child: SingleChildScrollView(
            padding: const EdgeInsets.all(24),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                // Logo and Welcome Section
                _buildWelcomeSection(theme, loc),
                const SizedBox(height: 40),

                // Login Card
                _buildLoginCard(theme, loc),
              ],
            ),
          ),
        ),
      ),
    );

}

Widget \_buildWelcomeSection(ThemeData theme, AppLocalizations loc) {
return Column(
children: [
// App Icon
Container(
width: 100,
height: 100,
decoration: BoxDecoration(
color: theme.colorScheme.onPrimary.withOpacity(0.1),
shape: BoxShape.circle,
border: Border.all(
color: theme.colorScheme.onPrimary.withOpacity(0.2),
width: 2,
),
),
child: Icon(
Icons.point_of_sale_rounded,
size: 50,
color: theme.colorScheme.onPrimary,
),
),
const SizedBox(height: 24),

        // App Name
        Text(
          'Andalus Smart POS',
          style: TextStyle(
            fontSize: 28,
            fontWeight: FontWeight.bold,
            color: theme.colorScheme.onPrimary,
            letterSpacing: -0.5,
          ),
        ),
        const SizedBox(height: 8),

        // Subtitle
        Text(
          loc.translate('loginToYourAccount'),
          style: TextStyle(
            fontSize: 16,
            color: theme.colorScheme.onPrimary.withOpacity(0.8),
          ),
          textAlign: TextAlign.center,
        ),
      ],
    );

}

Widget \_buildLoginCard(ThemeData theme, AppLocalizations loc) {
return Card(
elevation: 8,
shape: RoundedRectangleBorder(
borderRadius: BorderRadius.circular(20),
),
child: Padding(
padding: const EdgeInsets.all(32),
child: Form(
key: \_formKey,
child: Column(
children: [
// Header
Text(
loc.translate('welcomeBack'),
style: theme.textTheme.headlineSmall?.copyWith(
fontWeight: FontWeight.w700,
color: theme.colorScheme.onSurface,
),
),
const SizedBox(height: 8),
Text(
loc.translate('enterCredentialsToContinue'),
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.6),
),
textAlign: TextAlign.center,
),
const SizedBox(height: 32),

              // Phone Input
              AppTextField(
                controller: _phoneController,
                label: loc.translate('phoneNumber'),
                prefixText: '+251 ',
                prefixIcon: Icon(
                  Icons.phone_rounded,
                  color: theme.colorScheme.primary,
                ),
                keyboardType: TextInputType.phone,
                enabled: !_isLoggingIn,
                validator: _validatePhone,
                textInputAction: TextInputAction.next,
                onSubmitted: (_) {
                  // Move focus to password field when phone field is submitted
                  FocusScope.of(context).requestFocus(_passwordFocusNode);
                },
              ),
              const SizedBox(height: 20),

              // Password Input - FIXED: using onSubmitted instead of onFieldSubmitted
              AppTextField(
                controller: _passwordController,
                label: loc.translate('password'),
                prefixIcon: Icon(
                  Icons.lock_rounded,
                  color: theme.colorScheme.primary,
                ),
                obscureText: true,
                enabled: !_isLoggingIn,
                validator: _validatePassword,
                textInputAction: TextInputAction.done,
                focusNode: _passwordFocusNode,
                onSubmitted: (_) =>
                    _loginWithPassword(), // FIXED: Changed to onSubmitted
              ),
              const SizedBox(height: 8),

              // Forgot Password
              Align(
                alignment: Alignment.centerRight,
                child: TextButton(
                  onPressed: _isLoggingIn
                      ? null
                      : () {
                          // TODO: Implement forgot password
                          ScaffoldMessenger.of(context).showSnackBar(
                            SnackBar(
                              content: Text(loc.translate('featureComingSoon')),
                            ),
                          );
                        },
                  child: Text(
                    loc.translate('forgotPassword'),
                    style: TextStyle(
                      color: theme.colorScheme.primary,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ),
              ),
              const SizedBox(height: 24),

              // Error Message
              if (_loginError != null) ...[
                Container(
                  width: double.infinity,
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    color: theme.colorScheme.errorContainer,
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Row(
                    children: [
                      Icon(
                        Icons.error_outline_rounded,
                        color: theme.colorScheme.onErrorContainer,
                        size: 16,
                      ),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Text(
                          _loginError!,
                          style: theme.textTheme.bodySmall?.copyWith(
                            color: theme.colorScheme.onErrorContainer,
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
                const SizedBox(height: 16),
              ],

              // Login Button
              AppButton.primary(
                onPressed: _isLoggingIn ? null : _loginWithPassword,
                isLoading: _isLoggingIn,
                child: Text(
                  loc.translate('login'),
                  style: const TextStyle(
                    fontWeight: FontWeight.w600,
                    fontSize: 16,
                  ),
                ),
              ),
              const SizedBox(height: 24),

              // Divider
              Row(
                children: [
                  Expanded(
                    child: Divider(
                      color: theme.colorScheme.outline.withOpacity(0.3),
                    ),
                  ),
                  Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 16),
                    child: Text(
                      loc.translate('or'),
                      style: theme.textTheme.bodySmall?.copyWith(
                        color: theme.colorScheme.onSurface.withOpacity(0.5),
                      ),
                    ),
                  ),
                  Expanded(
                    child: Divider(
                      color: theme.colorScheme.outline.withOpacity(0.3),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 24),

              // Register Button
              AppButton.outlined(
                onPressed: _isLoggingIn ? null : _navigateToOnboarding,
                child: Text(
                  loc.translate('createNewBusiness'),
                  style: TextStyle(
                    fontWeight: FontWeight.w600,
                    color: theme.colorScheme.primary,
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );

}
}

##

// src/ui/screens/onboarding/onboarding_otp_verification_screen.dart
// Screen for OTP verification during the onboarding process.
import 'dart:async';

import 'package:andalus_smart_pos/src/widgets/common/app_button.dart';
import 'package:andalus_smart_pos/src/widgets/common/app_text_field.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
import 'package:andalus_smart_pos/src/providers/onboarding_provider.dart';

class OnboardingOTPVerificationScreen extends ConsumerStatefulWidget {
const OnboardingOTPVerificationScreen({super.key});

@override
ConsumerState<OnboardingOTPVerificationScreen> createState() =>
\_OnboardingOTPVerificationScreenState();
}

class \_OnboardingOTPVerificationScreenState
extends ConsumerState<OnboardingOTPVerificationScreen> {
final \_otpController = TextEditingController();
final \_formKey = GlobalKey<FormState>();
final \_focusNode = FocusNode();

bool \_isLoading = false;
bool \_isResending = false;
bool \_isVerifying = false; // Add this flag
int \_resendCooldown = 0;
Timer? \_cooldownTimer;
bool \_otpSent = false;
Timer? \_debounceTimer;

@override
void initState() {
super.initState();
WidgetsBinding.instance.addPostFrameCallback((\_) {
\_sendOTP();
});
\_focusNode.requestFocus();
}

@override
void dispose() {
\_otpController.dispose();
\_focusNode.dispose();
\_cooldownTimer?.cancel();
super.dispose();
}

String? get \_phone {
final state = ref.read(onboardingProvider);
return state.owner?.phone;
}

String? get \_businessName {
final state = ref.read(onboardingProvider);
return state.shop?.shopName;
}

Future<void> \_sendOTP() async {
final phone = \_phone;
if (phone == null) {
\_showError('Phone number not set. Please complete owner registration.');
return;
}

    try {
      setState(() => _isResending = true);

      await ref.read(onboardingProvider.notifier).sendRegistrationOTP(phone);

      _startCooldownTimer();
      setState(() => _otpSent = true);

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              AppLocalizations.of(context).translate('otpSentSuccessfully'),
            ),
            backgroundColor: Colors.green,
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
    } catch (e) {
      _showError(e.toString());
    } finally {
      if (mounted) {
        setState(() => _isResending = false);
      }
    }

}

void \_startCooldownTimer() {
setState(() => \_resendCooldown = 60);

    _cooldownTimer?.cancel();
    _cooldownTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (_resendCooldown > 0) {
        setState(() => _resendCooldown--);
      } else {
        timer.cancel();
      }
    });

}

Future<void> \_verifyOTP() async {
if (!\_formKey.currentState!.validate()) return;
if (\_isLoading || \_isVerifying) return; // Prevent multiple calls

    setState(() {
      _isLoading = true;
      _isVerifying = true;
    });

    try {
      final success =
          await ref.read(onboardingProvider.notifier).verifyRegistrationOTP(
                _otpController.text.trim(),
              );

      if (success && mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              AppLocalizations.of(context).translate('otpVerifiedSuccessfully'),
            ),
            backgroundColor: Colors.green,
            behavior: SnackBarBehavior.floating,
            duration: const Duration(seconds: 2),
          ),
        );

        // Wait a bit for the state to update and navigation to happen
        await Future.delayed(const Duration(milliseconds: 500));

        // Check if we're still on the same screen (navigation didn't happen)
        final currentState = ref.read(onboardingProvider);
        if (currentState.currentStep == 3 && mounted) {
          // Still on OTP screen - show manual continue option
          _showManualContinueOption();
        }
      }
    } catch (e) {
      _showError(e.toString());
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
          _isVerifying = false;
        });
      }
    }

}

void \_showManualContinueOption() {
showDialog(
context: context,
barrierDismissible: false,
builder: (context) => AlertDialog(
title: const Text('Verification Successful'),
content: const Text(
'OTP verified successfully! Please continue to payment.'),
actions: [
TextButton(
onPressed: () {
Navigator.pop(context);
// Manually trigger next step
ref.read(onboardingProvider.notifier).nextStep();
},
child: const Text('Continue to Payment'),
),
],
),
);
}

void \_showError(String message) {
if (mounted) {
ScaffoldMessenger.of(context).showSnackBar(
SnackBar(
content: Text(message),
backgroundColor: Colors.red,
behavior: SnackBarBehavior.floating,
duration: const Duration(seconds: 4),
),
);
}
}

String? \_validateOTP(String? value) {
if (value == null || value.trim().isEmpty) {
return AppLocalizations.of(context).translate('otpRequired');
}
if (value.trim().length != 6) {
return AppLocalizations.of(context).translate('otpMustBe6Digits');
}
if (!RegExp(r'^[0-9]{6}$').hasMatch(value.trim())) {
return AppLocalizations.of(context).translate('otpMustBeNumbers');
}
return null;
}

String \_formatPhone(String phone) {
if (phone.startsWith('+251')) {
return '+251 ${phone.substring(4, 6)} ${phone.substring(6, 9)} ${phone.substring(9)}';
}
return phone;
}

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);
final loc = AppLocalizations.of(context);

    final phone = _phone;
    final businessName = _businessName;

    if (phone == null) {
      return _buildErrorScreen('Please complete owner registration first.');
    }

    return Scaffold(
      appBar: AppBar(
        title: Text(loc.translate('verifyPhone')),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: _isLoading
              ? null
              : () => ref.read(onboardingProvider.notifier).previousStep(),
        ),
      ),
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Form(
            key: _formKey,
            child: Column(
              children: [
                // Header Section
                _buildHeaderSection(theme, loc, phone, businessName),
                const SizedBox(height: 32),

                // OTP Input Section
                _buildOTPInputSection(theme, loc),
                const SizedBox(height: 24),

                // Action Buttons
                _buildActionButtons(theme, loc),

                // Spacer to prevent overflow
                const Expanded(child: SizedBox()),

                // Demo Hint (Remove in production)
                if (_otpSent) _buildDemoHint(theme),
              ],
            ),
          ),
        ),
      ),
    );

}

Widget \_buildHeaderSection(ThemeData theme, AppLocalizations loc,
String phone, String? businessName) {
return Column(
children: [
Icon(
Icons.verified_user_rounded,
size: 80,
color: theme.colorScheme.primary,
),
const SizedBox(height: 24),
Text(
loc.translate('verifyYourPhone'),
style: theme.textTheme.headlineSmall?.copyWith(
fontWeight: FontWeight.w700,
),
textAlign: TextAlign.center,
),
const SizedBox(height: 12),
Text(
loc.translate('otpSentToPhone',
params: {'phone': \_formatPhone(phone)}),
style: theme.textTheme.bodyLarge?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.7),
),
textAlign: TextAlign.center,
),
if (businessName != null) ...[
const SizedBox(height: 8),
Text(
loc.translate('forBusiness', params: {'business': businessName}),
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.primary,
fontWeight: FontWeight.w600,
),
textAlign: TextAlign.center,
),
],
],
);
}

Widget _buildOTPInputSection(ThemeData theme, AppLocalizations loc) {
return Column(
children: [
AppTextField(
controller: \_otpController,
label: loc.translate('enterOTPCode'),
hintText: '123456',
keyboardType: TextInputType.number,
maxLength: 6,
validator: \_validateOTP,
focusNode: \_focusNode,
textInputAction: TextInputAction.done,
onSubmitted: (_) => _verifyOTP(),
onChanged: (value) {
if (value.length == 6 && !\_isLoading) {
\_focusNode.unfocus();
// Use a flag to prevent multiple calls
if (!\_isVerifying) {
\_isVerifying = true;
// Add a small delay to ensure the field is updated
Future.delayed(const Duration(milliseconds: 100), () {
if (mounted) {
\_verifyOTP().then((_) {
\_isVerifying = false;
});
}
});
}
}
},
),
const SizedBox(height: 8),
Text(
loc.translate('enter6DigitCode'),
style: theme.textTheme.bodySmall?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.6),
),
),
],
);
}

Widget \_buildActionButtons(ThemeData theme, AppLocalizations loc) {
return Column(
children: [
AppButton.primary(
onPressed: \_isLoading ? null : \_verifyOTP,
isLoading: \_isLoading,
child: Text(
loc.translate('verifyAndContinue'),
style: const TextStyle(fontWeight: FontWeight.w600),
),
),
const SizedBox(height: 20),
Row(
mainAxisAlignment: MainAxisAlignment.center,
children: [
Text(
loc.translate('didNotReceiveCode'),
style: theme.textTheme.bodyMedium,
),
const SizedBox(width: 8),
if (_resendCooldown > 0)
Text(
'(${_resendCooldown}s)',
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.primary,
fontWeight: FontWeight.w600,
),
)
else
TextButton(
onPressed: (_isResending || _isLoading) ? null : _sendOTP,
child: _isResending
? SizedBox(
height: 16,
width: 16,
child: CircularProgressIndicator(
strokeWidth: 2,
color: theme.colorScheme.primary,
),
)
: Text(
loc.translate('resendOTP'),
style: TextStyle(
color: theme.colorScheme.primary,
fontWeight: FontWeight.w600,
),
),
),
],
),
],
);
}

Widget \_buildDemoHint(ThemeData theme) {
return Column(
children: [
const Divider(),
const SizedBox(height: 16),
Container(
padding: const EdgeInsets.all(16),
decoration: BoxDecoration(
color: theme.colorScheme.surfaceVariant,
borderRadius: BorderRadius.circular(12),
),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Row(
children: [
Icon(
Icons.info_outline_rounded,
size: 16,
color: theme.colorScheme.primary,
),
const SizedBox(width: 8),
Text(
'Demo Mode',
style: theme.textTheme.bodySmall?.copyWith(
fontWeight: FontWeight.w600,
color: theme.colorScheme.primary,
),
),
],
),
const SizedBox(height: 8),
Text(
'‚Ä¢ Use "123456" for instant verification\n‚Ä¢ OTPs expire after 10 minutes\n‚Ä¢ Remove this hint in production',
style: theme.textTheme.bodySmall?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.6),
),
),
],
),
),
],
);
}

Widget \_buildErrorScreen(String message) {
return Center(
child: Padding(
padding: const EdgeInsets.all(24.0),
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
const Icon(
Icons.error_outline_rounded,
size: 64,
color: Colors.red,
),
const SizedBox(height: 24),
Text(
'Registration Error',
style: TextStyle(
fontSize: 20,
fontWeight: FontWeight.bold,
color: Colors.grey[800],
),
),
const SizedBox(height: 16),
Text(
message,
textAlign: TextAlign.center,
style: TextStyle(
fontSize: 16,
color: Colors.grey[600],
),
),
const SizedBox(height: 32),
ElevatedButton(
onPressed: () {
ref.read(onboardingProvider.notifier).previousStep();
},
child: const Text('Go Back to Owner Registration'),
),
],
),
),
);
}
}

##

// src/ui/screens/onboarding/onboarding_screen.dart
// Onboarding screen that manages the multi-step onboarding process.
import 'package:andalus_smart_pos/src/ui/screens/onboarding/onboarding_otp_verification_screen.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/providers/onboarding_provider.dart';
import 'package:andalus_smart_pos/src/ui/screens/onboarding/shop_registration_screen.dart';
import 'package:andalus_smart_pos/src/ui/screens/onboarding/owner_registration_screen.dart';
import 'package:andalus_smart_pos/src/ui/screens/onboarding/subscription_selection_screen.dart';
import 'package:andalus_smart_pos/src/ui/screens/onboarding/otp_verification_screen.dart';
import 'package:andalus_smart_pos/src/ui/screens/onboarding/payment_screen.dart';

class OnboardingScreen extends ConsumerWidget {
const OnboardingScreen({super.key});

@override
Widget build(BuildContext context, WidgetRef ref) {
final state = ref.watch(onboardingProvider);

    return Scaffold(
      backgroundColor: Theme.of(context).colorScheme.background,
      body: _buildStepContent(state.currentStep),
    );

}

// In onboarding_screen.dart - update the \_buildStepContent method
Widget \_buildStepContent(int currentStep) {
switch (currentStep) {
case 0:
return const ShopRegistrationScreen();
case 1:
return const OwnerRegistrationScreen();
case 2:
return const SubscriptionSelectionScreen();
case 3:
return const OnboardingOTPVerificationScreen(); // Use the new dedicated screen
case 4:
return const PaymentScreen();
default:
return const ShopRegistrationScreen();
}
}
}

##

// src/ui/screens/auth/otp_verification_screen.dart
// Screen for OTP verification during registration or login.
import 'dart:async';

import 'package:andalus_smart_pos/src/widgets/common/app_button.dart';
import 'package:andalus_smart_pos/src/widgets/common/app_text_field.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
import 'package:andalus_smart_pos/src/providers/auth_provider.dart';

class OTPVerificationScreen extends ConsumerStatefulWidget {
final String phone;
final VerificationType type;
final String? businessName;

const OTPVerificationScreen({
super.key,
required this.phone,
required this.type,
this.businessName,
});

@override
ConsumerState<OTPVerificationScreen> createState() =>
\_OTPVerificationScreenState();
}

class \_OTPVerificationScreenState extends ConsumerState<OTPVerificationScreen> {
final \_otpController = TextEditingController();
final \_formKey = GlobalKey<FormState>();
final \_focusNode = FocusNode();

bool \_isLoading = false;
bool \_isResending = false;
int \_resendCooldown = 0;
Timer? \_cooldownTimer;

@override
void initState() {
super.initState();
\_sendOTP();
\_focusNode.requestFocus();
}

@override
void dispose() {
\_otpController.dispose();
\_focusNode.dispose();
\_cooldownTimer?.cancel();
super.dispose();
}

Future<void> \_sendOTP() async {
if (widget.phone.isEmpty) {
\_showError('Phone number not set');
return;
}

    try {
      setState(() => _isResending = true);

      // Use the generic sendOTP method from your AuthService
      await ref.read(authProvider.notifier).sendOTP(widget.phone);

      // Start cooldown timer (60 seconds)
      _startCooldownTimer();

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              AppLocalizations.of(context).translate('otpSentSuccessfully'),
            ),
            backgroundColor: Colors.green,
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
    } catch (e) {
      _showError(e.toString());
    } finally {
      if (mounted) {
        setState(() => _isResending = false);
      }
    }

}

void \_startCooldownTimer() {
setState(() => \_resendCooldown = 60);

    _cooldownTimer?.cancel();
    _cooldownTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (_resendCooldown > 0) {
        setState(() => _resendCooldown--);
      } else {
        timer.cancel();
      }
    });

}

Future<void> \_verifyOTP() async {
if (!\_formKey.currentState!.validate()) return;
if (\_isLoading) return;

    setState(() => _isLoading = true);

    try {
      // Use the appropriate method based on verification type
      if (widget.type == VerificationType.registration) {
        // For registration, you'll need to handle this differently
        // This would typically be called from your registration flow
        _showError(
            'Registration OTP verification should be handled in registration flow');
      } else {
        // For login, use the existing loginWithOTP method
        await ref.read(authProvider.notifier).verifyOTPAndLogin(
              widget.phone,
              _otpController.text.trim(),
            );
      }

      // Success handling is done via auth state listener
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              widget.type == VerificationType.registration
                  ? AppLocalizations.of(context)
                      .translate('registrationSuccessful')
                  : AppLocalizations.of(context).translate('loginSuccessful'),
            ),
            backgroundColor: Colors.green,
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
    } catch (e) {
      _showError(e.toString());
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }

}

void \_showError(String message) {
if (mounted) {
ScaffoldMessenger.of(context).showSnackBar(
SnackBar(
content: Text(message),
backgroundColor: Colors.red,
behavior: SnackBarBehavior.floating,
duration: const Duration(seconds: 4),
),
);
}
}

String? \_validateOTP(String? value) {
if (value == null || value.trim().isEmpty) {
return AppLocalizations.of(context).translate('otpRequired');
}
if (value.trim().length != 6) {
return AppLocalizations.of(context).translate('otpMustBe6Digits');
}
if (!RegExp(r'^[0-9]{6}$').hasMatch(value.trim())) {
return AppLocalizations.of(context).translate('otpMustBeNumbers');
}
return null;
}

String \_formatPhone(String phone) {
if (phone.startsWith('+251')) {
return '+251 ${phone.substring(4, 6)} ${phone.substring(6, 9)} ${phone.substring(9)}';
}
return phone;
}

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);
final loc = AppLocalizations.of(context);

    return Scaffold(
      appBar: AppBar(
        title: Text(loc.translate('verifyPhone')),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: _isLoading ? null : () => Navigator.of(context).pop(),
        ),
      ),
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Form(
            key: _formKey,
            child: Column(
              children: [
                // Header Section
                _buildHeaderSection(theme, loc),
                const SizedBox(height: 32),

                // OTP Input Section
                _buildOTPInputSection(theme, loc),
                const SizedBox(height: 24),

                // Action Buttons
                _buildActionButtons(theme, loc),

                // Spacer to prevent overflow
                const Expanded(child: SizedBox()),

                // Demo Hint (Remove in production)
                _buildDemoHint(theme),
              ],
            ),
          ),
        ),
      ),
    );

}

Widget \_buildHeaderSection(ThemeData theme, AppLocalizations loc) {
return Column(
children: [
Icon(
Icons.verified_user_rounded,
size: 80,
color: theme.colorScheme.primary,
),
const SizedBox(height: 24),
Text(
loc.translate('verifyYourPhone'),
style: theme.textTheme.headlineSmall?.copyWith(
fontWeight: FontWeight.w700,
),
textAlign: TextAlign.center,
),
const SizedBox(height: 12),
Text(
loc.translate('otpSentToPhone',
params: {'phone': \_formatPhone(widget.phone)}),
style: theme.textTheme.bodyLarge?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.7),
),
textAlign: TextAlign.center,
),
if (widget.businessName != null) ...[
const SizedBox(height: 8),
Text(
loc.translate('forBusiness',
params: {'business': widget.businessName!}),
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.primary,
fontWeight: FontWeight.w600,
),
textAlign: TextAlign.center,
),
],
],
);
}

Widget _buildOTPInputSection(ThemeData theme, AppLocalizations loc) {
return Column(
children: [
AppTextField(
controller: \_otpController,
label: loc.translate('enterOTPCode'),
hintText: '123456',
keyboardType: TextInputType.number,
maxLength: 6,
validator: \_validateOTP,
focusNode: \_focusNode,
textInputAction: TextInputAction.done,
onSubmitted: (_) => _verifyOTP(),
onChanged: (value) {
if (value.length == 6) {
\_focusNode.unfocus();
// Auto-submit when 6 digits are entered
WidgetsBinding.instance.addPostFrameCallback((_) {
\_verifyOTP();
});
}
},
),
const SizedBox(height: 8),
Text(
loc.translate('enter6DigitCode'),
style: theme.textTheme.bodySmall?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.6),
),
),
],
);
}

Widget \_buildActionButtons(ThemeData theme, AppLocalizations loc) {
return Column(
children: [
AppButton.primary(
onPressed: \_isLoading ? null : \_verifyOTP,
isLoading: \_isLoading,
child: Text(
loc.translate('verifyAndContinue'),
style: const TextStyle(fontWeight: FontWeight.w600),
),
),
const SizedBox(height: 20),
Row(
mainAxisAlignment: MainAxisAlignment.center,
children: [
Text(
loc.translate('didNotReceiveCode'),
style: theme.textTheme.bodyMedium,
),
const SizedBox(width: 8),
if (_resendCooldown > 0)
Text(
'(${_resendCooldown}s)',
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.primary,
fontWeight: FontWeight.w600,
),
)
else
TextButton(
onPressed: (_isResending || _isLoading) ? null : _sendOTP,
child: _isResending
? SizedBox(
height: 16,
width: 16,
child: CircularProgressIndicator(
strokeWidth: 2,
color: theme.colorScheme.primary,
),
)
: Text(
loc.translate('resendOTP'),
style: TextStyle(
color: theme.colorScheme.primary,
fontWeight: FontWeight.w600,
),
),
),
],
),
],
);
}

Widget \_buildDemoHint(ThemeData theme) {
return Column(
children: [
const Divider(),
const SizedBox(height: 16),
Container(
padding: const EdgeInsets.all(16),
decoration: BoxDecoration(
color: theme.colorScheme.surfaceVariant,
borderRadius: BorderRadius.circular(12),
),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Row(
children: [
Icon(
Icons.info_outline_rounded,
size: 16,
color: theme.colorScheme.primary,
),
const SizedBox(width: 8),
Text(
'Demo Mode',
style: theme.textTheme.bodySmall?.copyWith(
fontWeight: FontWeight.w600,
color: theme.colorScheme.primary,
),
),
],
),
const SizedBox(height: 8),
Text(
'‚Ä¢ Use "123456" for instant verification\n‚Ä¢ OTPs expire after 10 minutes\n‚Ä¢ Remove this hint in production',
style: theme.textTheme.bodySmall?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.6),
),
),
],
),
),
],
);
}
}

enum VerificationType {
registration,
login,
}

##

// src/ui/screens/onboarding/owner_registration_screen.dart
// Screen for registering the owner during the onboarding process.
import 'package:andalus_smart_pos/src/widgets/common/app_button.dart';
import 'package:andalus_smart_pos/src/widgets/common/app_text_field.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
import 'package:andalus_smart_pos/src/providers/onboarding_provider.dart';
import 'package:andalus_smart_pos/src/data/models/shop_registration.dart';

class OwnerRegistrationScreen extends ConsumerStatefulWidget {
const OwnerRegistrationScreen({super.key});

@override
ConsumerState<OwnerRegistrationScreen> createState() =>
\_OwnerRegistrationScreenState();
}

class \_OwnerRegistrationScreenState
extends ConsumerState<OwnerRegistrationScreen> {
final \_fullNameController = TextEditingController();
final \_phoneController = TextEditingController();
final \_emailController = TextEditingController();
final \_passwordController = TextEditingController();
final \_confirmPasswordController = TextEditingController();

final \_formKey = GlobalKey<FormState>();
bool \_obscurePassword = true;
bool \_obscureConfirmPassword = true;

@override
void dispose() {
\_fullNameController.dispose();
\_phoneController.dispose();
\_emailController.dispose();
\_passwordController.dispose();
\_confirmPasswordController.dispose();
super.dispose();
}

bool \_validateForm() {
if (\_formKey.currentState?.validate() ?? false) {
if (\_passwordController.text != \_confirmPasswordController.text) {
ScaffoldMessenger.of(context).showSnackBar(
SnackBar(
content: Text(
AppLocalizations.of(context).translate('passwordsDoNotMatch')),
backgroundColor: Theme.of(context).colorScheme.error,
),
);
return false;
}

      final owner = OwnerRegistration(
        fullName: _fullNameController.text.trim(),
        phone: _phoneController.text.trim(),
        password: _passwordController.text,
        email: _emailController.text.trim().isEmpty
            ? null
            : _emailController.text.trim(),
      );

      ref.read(onboardingProvider.notifier).updateOwnerInfo(owner);
      return true;
    }
    return false;

}

void \_proceedToNextStep() {
if (\_validateForm()) {
ref.read(onboardingProvider.notifier).nextStep();
}
}

String? \_validateRequired(String? value, String fieldName) {
if (value == null || value.trim().isEmpty) {
return '$fieldName ${AppLocalizations.of(context).translate('isRequired')}';
}
return null;
}

String? \_validatePhone(String? value) {
if (value == null || value.trim().isEmpty) {
return AppLocalizations.of(context).translate('phoneRequired');
}
if (!RegExp(r'^\+251[0-9]{9}$').hasMatch(value.trim())) {
return AppLocalizations.of(context).translate('validEthiopianPhone');
}
return null;
}

String? \_validateEmail(String? value) {
if (value != null && value.trim().isNotEmpty) {
if (!RegExp(r'^[^@]+@[^@]+\.[^@]+').hasMatch(value.trim())) {
return AppLocalizations.of(context).translate('validEmail');
}
}
return null;
}

String? \_validatePassword(String? value) {
if (value == null || value.isEmpty) {
return AppLocalizations.of(context).translate('passwordRequired');
}
if (value.length < 6) {
return AppLocalizations.of(context).translate('passwordMinLength');
}
return null;
}

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);
final loc = AppLocalizations.of(context);

    return Scaffold(
      appBar: AppBar(
        title: Text(loc.translate('ownerAccount')),
        backgroundColor: Colors.transparent,
        elevation: 0,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => ref.read(onboardingProvider.notifier).previousStep(),
        ),
      ),
      body: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const SizedBox(height: 20),
              _buildProgressIndicator(1, loc),
              const SizedBox(height: 32),
              Text(
                loc.translate('createOwnerAccount'),
                style: theme.textTheme.headlineSmall?.copyWith(
                  fontWeight: FontWeight.w700,
                ),
              ),
              const SizedBox(height: 8),
              Text(
                loc.translate('setupOwnerDetails'),
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: theme.colorScheme.onSurface.withOpacity(0.6),
                ),
              ),
              const SizedBox(height: 32),
              Expanded(
                child: SingleChildScrollView(
                  child: Column(
                    children: [
                      AppTextField(
                        controller: _fullNameController,
                        label: loc.translate('fullName'),
                        validator: (value) =>
                            _validateRequired(value, loc.translate('fullName')),
                      ),
                      const SizedBox(height: 16),
                      AppTextField(
                        controller: _phoneController,
                        label: loc.translate('phoneNumber'),
                        prefixText: '+251 ',
                        keyboardType: TextInputType.phone,
                        validator: _validatePhone,
                      ),
                      const SizedBox(height: 16),
                      AppTextField(
                        controller: _emailController,
                        label:
                            '${loc.translate('email')} (${loc.translate('optional')})',
                        keyboardType: TextInputType.emailAddress,
                        validator: _validateEmail,
                      ),
                      const SizedBox(height: 16),
                      AppTextField(
                        controller: _passwordController,
                        label: loc.translate('password'),
                        obscureText: _obscurePassword,
                        suffixIcon: IconButton(
                          icon: Icon(
                            _obscurePassword
                                ? Icons.visibility
                                : Icons.visibility_off,
                          ),
                          onPressed: () {
                            setState(() {
                              _obscurePassword = !_obscurePassword;
                            });
                          },
                        ),
                        validator: _validatePassword,
                      ),
                      const SizedBox(height: 16),
                      AppTextField(
                        controller: _confirmPasswordController,
                        label: loc.translate('confirmPassword'),
                        obscureText: _obscureConfirmPassword,
                        suffixIcon: IconButton(
                          icon: Icon(
                            _obscureConfirmPassword
                                ? Icons.visibility
                                : Icons.visibility_off,
                          ),
                          onPressed: () {
                            setState(() {
                              _obscureConfirmPassword =
                                  !_obscureConfirmPassword;
                            });
                          },
                        ),
                        validator: (value) {
                          if (value != _passwordController.text) {
                            return loc.translate('passwordsDoNotMatch');
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 24),
                      // Password requirements
                      _buildPasswordRequirements(loc),
                      const SizedBox(height: 40),
                    ],
                  ),
                ),
              ),
              AppButton.primary(
                onPressed: _proceedToNextStep,
                child: Text(loc.translate('continue')),
              ),
            ],
          ),
        ),
      ),
    );

}

Widget \_buildPasswordRequirements(AppLocalizations loc) {
final password = \_passwordController.text;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          loc.translate('passwordRequirements'),
          style: Theme.of(context).textTheme.bodySmall?.copyWith(
                fontWeight: FontWeight.w600,
              ),
        ),
        const SizedBox(height: 8),
        _buildRequirementItem(
          loc.translate('min6Characters'),
          password.length >= 6,
        ),
        _buildRequirementItem(
          loc.translate('recommendSpecialChars'),
          password.length >= 8,
        ),
      ],
    );

}

Widget \_buildRequirementItem(String text, bool isMet) {
return Padding(
padding: const EdgeInsets.symmetric(vertical: 2),
child: Row(
children: [
Icon(
isMet ? Icons.check_circle : Icons.radio_button_unchecked,
size: 16,
color: isMet ? Colors.green : Theme.of(context).colorScheme.outline,
),
const SizedBox(width: 8),
Text(
text,
style: Theme.of(context).textTheme.bodySmall?.copyWith(
color: isMet
? Colors.green
: Theme.of(context).colorScheme.outline,
),
),
],
),
);
}

Widget \_buildProgressIndicator(int currentStep, AppLocalizations loc) {
// Same as previous screen
return Column(
children: [
Row(
mainAxisAlignment: MainAxisAlignment.spaceBetween,
children: [
_buildStep(1, 'üè™', loc.translate('shop'), currentStep >= 0),
_buildStep(2, 'üë§', loc.translate('owner'), currentStep >= 1),
_buildStep(3, 'üì¶', loc.translate('plan'), currentStep >= 2),
_buildStep(4, 'üîê', loc.translate('verify'), currentStep >= 3),
_buildStep(5, 'üí≥', loc.translate('payment'), currentStep >= 4),
],
),
const SizedBox(height: 8),
Text(
'${currentStep + 1}/5 ${loc.translate('steps')}',
style: Theme.of(context).textTheme.bodySmall?.copyWith(
color: Theme.of(context).colorScheme.onSurface.withOpacity(0.6),
),
),
],
);
}

Widget \_buildStep(int stepNumber, String emoji, String label, bool isActive) {
return Column(
children: [
Container(
width: 36,
height: 36,
decoration: BoxDecoration(
color: isActive
? Theme.of(context).colorScheme.primary
: Theme.of(context).colorScheme.surfaceVariant,
shape: BoxShape.circle,
),
child: Center(
child: Text(
emoji,
style: const TextStyle(fontSize: 16),
),
),
),
const SizedBox(height: 4),
Text(
label,
style: Theme.of(context).textTheme.labelSmall?.copyWith(
fontWeight: isActive ? FontWeight.w600 : FontWeight.normal,
color: isActive
? Theme.of(context).colorScheme.primary
: Theme.of(context).colorScheme.onSurface.withOpacity(0.5),
),
),
],
);
}
}

##

// src/ui/screens/onboarding/payment_screen.dart
// Screen for handling payment during the onboarding process.
import 'package:andalus_smart_pos/src/ui/screens/main_navigation.dart';
import 'package:andalus_smart_pos/src/widgets/common/app_button.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
import 'package:andalus_smart_pos/src/providers/onboarding_provider.dart';
import 'package:andalus_smart_pos/src/data/models/subscription.dart';
import 'package:andalus_smart_pos/src/ui/screens/dashboard_screen.dart';

class PaymentScreen extends ConsumerStatefulWidget {
const PaymentScreen({super.key});

@override
ConsumerState<PaymentScreen> createState() => \_PaymentScreenState();
}

class \_PaymentScreenState extends ConsumerState<PaymentScreen> {
String? \_selectedPaymentMethod;

final List<Map<String, dynamic>> \_paymentMethods = [
{
'id': 'telebirr',
'name': 'Telebirr',
'icon': Icons.phone_android_rounded,
'color': Colors.blue,
'description': 'Instant payment via Telebirr mobile money',
},
{
'id': 'cbe_birr',
'name': 'CBE Birr',
'icon': Icons.account_balance_rounded,
'color': Colors.green,
'description': 'Mobile banking with Commercial Bank of Ethiopia',
},
{
'id': 'chapa',
'name': 'Chapa',
'icon': Icons.payment_rounded,
'color': Colors.orange,
'description': 'Secure online payment gateway',
},
{
'id': 'bank_transfer',
'name': 'Bank Transfer',
'icon': Icons.account_balance_wallet_rounded,
'color': Colors.purple,
'description': 'Direct bank transfer to our account',
},
];

final ScrollController \_scrollController = ScrollController();

@override
void dispose() {
\_scrollController.dispose();
super.dispose();
}

Future<void> \_processPayment() async {
if (\_selectedPaymentMethod == null) {
ScaffoldMessenger.of(context).showSnackBar(
SnackBar(
content: const Text('Please select a payment method'),
backgroundColor: Theme.of(context).colorScheme.error,
behavior: SnackBarBehavior.floating,
),
);
return;
}

    final success = await ref.read(onboardingProvider.notifier).processPayment(
      _selectedPaymentMethod!,
      {
        'method': _selectedPaymentMethod,
        'timestamp': DateTime.now().millisecondsSinceEpoch,
      },
    );

    if (success && mounted) {
      _showSuccessDialog();
    }

}

void \_showSuccessDialog() {
showDialog(
context: context,
barrierDismissible: false,
builder: (context) => \_buildSuccessDialog(),
);
}

void \_navigateToMain() {
Navigator.pushAndRemoveUntil(
context,
MaterialPageRoute(builder: (context) => const MainNavigation()),
(route) => false,
);
}

@override
Widget build(BuildContext context) {
final state = ref.watch(onboardingProvider);
final theme = Theme.of(context);
final loc = AppLocalizations.of(context);

    return Scaffold(
      appBar: AppBar(
        title: Text(loc.translate('payment')),
        backgroundColor: Colors.transparent,
        elevation: 0,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => ref.read(onboardingProvider.notifier).previousStep(),
        ),
      ),
      body: Column(
        children: [
          // Fixed Header Section
          Container(
            padding: const EdgeInsets.all(24),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                _buildProgressIndicator(4, loc),
                const SizedBox(height: 32),
                Text(
                  loc.translate('completePayment'),
                  style: theme.textTheme.headlineSmall?.copyWith(
                    fontWeight: FontWeight.w700,
                  ),
                ),
                const SizedBox(height: 8),
                Text(
                  loc.translate('choosePaymentMethod'),
                  style: theme.textTheme.bodyMedium?.copyWith(
                    color: theme.colorScheme.onSurface.withOpacity(0.6),
                  ),
                ),
              ],
            ),
          ),

          // Scrollable Content Section
          Expanded(
            child: CustomScrollView(
              controller: _scrollController,
              slivers: [
                // Order Summary
                SliverToBoxAdapter(
                  child: Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 24),
                    child: _buildOrderSummary(state, theme, loc),
                  ),
                ),

                // Payment Methods Header
                SliverToBoxAdapter(
                  child: Padding(
                    padding: const EdgeInsets.fromLTRB(24, 32, 24, 16),
                    child: Row(
                      children: [
                        Text(
                          loc.translate('paymentMethods'),
                          style: theme.textTheme.titleMedium?.copyWith(
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                        const SizedBox(width: 8),
                        Container(
                          padding: const EdgeInsets.symmetric(
                              horizontal: 8, vertical: 4),
                          decoration: BoxDecoration(
                            color: theme.colorScheme.primary.withOpacity(0.1),
                            borderRadius: BorderRadius.circular(12),
                          ),
                          child: Text(
                            _paymentMethods.length.toString(),
                            style: theme.textTheme.bodySmall?.copyWith(
                              color: theme.colorScheme.primary,
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                ),

                // Payment Methods List
                SliverList(
                  delegate: SliverChildBuilderDelegate(
                    (context, index) {
                      final method = _paymentMethods[index];
                      return Padding(
                        padding: EdgeInsets.fromLTRB(
                          24,
                          0,
                          24,
                          index == _paymentMethods.length - 1 ? 24 : 12,
                        ),
                        child: _buildPaymentMethodCard(method, theme, loc),
                      );
                    },
                    childCount: _paymentMethods.length,
                  ),
                ),

                // Demo Notice
                SliverToBoxAdapter(
                  child: Padding(
                    padding: const EdgeInsets.fromLTRB(24, 8, 24, 24),
                    child: _buildDemoNotice(theme),
                  ),
                ),
              ],
            ),
          ),

          // Fixed Footer with Process Payment Button
          Container(
            padding: const EdgeInsets.all(24),
            decoration: BoxDecoration(
              color: theme.colorScheme.background,
              border: Border(
                top: BorderSide(
                  color: theme.colorScheme.outline.withOpacity(0.1),
                ),
              ),
            ),
            child: Column(
              children: [
                AppButton.primary(
                  onPressed: state.isLoading ? null : _processPayment,
                  isLoading: state.isLoading,
                  child: Text(
                    loc.translate('processPayment'),
                    style: const TextStyle(
                      fontWeight: FontWeight.w600,
                      fontSize: 16,
                    ),
                  ),
                ),
                const SizedBox(height: 8),
                Text(
                  'No payment required during 14-day free trial',
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: theme.colorScheme.onSurface.withOpacity(0.6),
                  ),
                  textAlign: TextAlign.center,
                ),
              ],
            ),
          ),
        ],
      ),
    );

}

Widget \_buildPaymentMethodCard(
Map<String, dynamic> method, ThemeData theme, AppLocalizations loc) {
final isSelected = \_selectedPaymentMethod == method['id'];

    return AnimatedContainer(
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeInOut,
      child: Card(
        elevation: isSelected ? 4 : 1,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
          side: BorderSide(
            color: isSelected
                ? theme.colorScheme.primary
                : theme.colorScheme.outline.withOpacity(0.1),
            width: isSelected ? 2 : 1,
          ),
        ),
        child: InkWell(
          onTap: () {
            setState(() {
              _selectedPaymentMethod = method['id'];
            });
          },
          borderRadius: BorderRadius.circular(16),
          child: Padding(
            padding: const EdgeInsets.all(20),
            child: Row(
              children: [
                // Icon
                Container(
                  width: 48,
                  height: 48,
                  decoration: BoxDecoration(
                    color: isSelected
                        ? method['color']
                        : method['color'].withOpacity(0.1),
                    shape: BoxShape.circle,
                  ),
                  child: Icon(
                    method['icon'],
                    color: isSelected ? Colors.white : method['color'],
                    size: 24,
                  ),
                ),
                const SizedBox(width: 16),

                // Content
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        method['name'],
                        style: theme.textTheme.titleMedium?.copyWith(
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                      const SizedBox(height: 4),
                      Text(
                        method['description'],
                        style: theme.textTheme.bodyMedium?.copyWith(
                          color: theme.colorScheme.onSurface.withOpacity(0.6),
                        ),
                      ),
                    ],
                  ),
                ),

                // Selection Indicator
                AnimatedContainer(
                  duration: const Duration(milliseconds: 300),
                  width: 24,
                  height: 24,
                  decoration: BoxDecoration(
                    shape: BoxShape.circle,
                    border: Border.all(
                      color: isSelected
                          ? theme.colorScheme.primary
                          : theme.colorScheme.outline.withOpacity(0.3),
                      width: 2,
                    ),
                    color: isSelected
                        ? theme.colorScheme.primary
                        : Colors.transparent,
                  ),
                  child: isSelected
                      ? Icon(
                          Icons.check_rounded,
                          size: 16,
                          color: Colors.white,
                        )
                      : null,
                ),
              ],
            ),
          ),
        ),
      ),
    );

}

Widget \_buildDemoNotice(ThemeData theme) {
return Container(
width: double.infinity,
padding: const EdgeInsets.all(16),
decoration: BoxDecoration(
color: theme.colorScheme.primary.withOpacity(0.05),
borderRadius: BorderRadius.circular(12),
border: Border.all(
color: theme.colorScheme.primary.withOpacity(0.1),
),
),
child: Row(
children: [
Icon(
Icons.info_outline_rounded,
size: 20,
color: theme.colorScheme.primary,
),
const SizedBox(width: 12),
Expanded(
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
'Demo Mode',
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.primary,
fontWeight: FontWeight.w600,
),
),
const SizedBox(height: 2),
Text(
'Select any payment method to continue. No actual payment will be processed during the 14-day free trial.',
style: theme.textTheme.bodySmall?.copyWith(
color: theme.colorScheme.primary.withOpacity(0.8),
),
),
],
),
),
],
),
);
}

Widget \_buildOrderSummary(
OnboardingState state, ThemeData theme, AppLocalizations loc) {
final plan = state.selectedPlan;
final billingCycle = state.billingCycle;

    if (plan == null || billingCycle == null) return const SizedBox();

    return Card(
      elevation: 2,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(20),
      ),
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Header
            Row(
              children: [
                Icon(
                  Icons.receipt_long_rounded,
                  color: theme.colorScheme.primary,
                  size: 20,
                ),
                const SizedBox(width: 8),
                Text(
                  loc.translate('orderSummary'),
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 20),

            // Plan Details
            _buildSummaryRow('Subscription Plan', plan.name, theme),
            _buildSummaryRow(
              'Billing Cycle',
              billingCycle == BillingCycle.monthly ? 'Monthly' : 'Yearly',
              theme,
            ),
            const SizedBox(height: 8),

            // Divider
            Divider(
              color: theme.colorScheme.outline.withOpacity(0.1),
              height: 1,
            ),
            const SizedBox(height: 16),

            // Total Amount
            _buildSummaryRow(
              'Total Amount',
              plan.getFormattedPrice(billingCycle),
              theme,
              isTotal: true,
            ),
            const SizedBox(height: 16),

            // Free Trial Notice
            Container(
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: Colors.green.withOpacity(0.08),
                borderRadius: BorderRadius.circular(12),
                border: Border.all(
                  color: Colors.green.withOpacity(0.2),
                ),
              ),
              child: Row(
                children: [
                  Icon(
                    Icons.celebration_rounded,
                    size: 20,
                    color: Colors.green,
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          '14-Day Free Trial',
                          style: theme.textTheme.bodyMedium?.copyWith(
                            color: Colors.green,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                        const SizedBox(height: 2),
                        Text(
                          'No payment required now. Your trial starts immediately after registration.',
                          style: theme.textTheme.bodySmall?.copyWith(
                            color: Colors.green.withOpacity(0.8),
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );

}

Widget \_buildSummaryRow(String label, String value, ThemeData theme,
{bool isTotal = false}) {
return Padding(
padding: const EdgeInsets.symmetric(vertical: 6),
child: Row(
mainAxisAlignment: MainAxisAlignment.spaceBetween,
children: [
Text(
label,
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.7),
),
),
Text(
value,
style: theme.textTheme.bodyMedium?.copyWith(
fontWeight: isTotal ? FontWeight.w700 : FontWeight.w500,
color: isTotal
? theme.colorScheme.primary
: theme.colorScheme.onSurface,
fontSize: isTotal ? 16 : 14,
),
),
],
),
);
}

Widget \_buildSuccessDialog() {
final theme = Theme.of(context);
final loc = AppLocalizations.of(context);

    return Dialog(
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(24),
      ),
      child: Container(
        padding: const EdgeInsets.all(32),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Success Icon
            Container(
              width: 80,
              height: 80,
              decoration: BoxDecoration(
                color: Colors.green.withOpacity(0.1),
                shape: BoxShape.circle,
              ),
              child: Icon(
                Icons.check_rounded,
                size: 40,
                color: Colors.green,
              ),
            ),
            const SizedBox(height: 24),

            // Title
            Text(
              'Welcome to Andalus POS! üéâ',
              style: theme.textTheme.headlineSmall?.copyWith(
                fontWeight: FontWeight.w700,
                // textAlign: TextAlign.center,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 12),

            // Description
            Text(
              'Your account has been successfully created and your 14-day free trial has started.',
              style: theme.textTheme.bodyLarge?.copyWith(
                color: theme.colorScheme.onSurface.withOpacity(0.7),
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),

            // Features List
            _buildFeatureItem('14-day full access to all features'),
            _buildFeatureItem('No credit card required'),
            _buildFeatureItem('Setup your products and start selling'),
            const SizedBox(height: 32),

            // Get Started Button
            AppButton.primary(
              onPressed: _navigateToMain,
              child: Text(
                'Get Started',
                style: const TextStyle(
                  fontWeight: FontWeight.w600,
                  fontSize: 16,
                ),
              ),
            ),
          ],
        ),
      ),
    );

}

Widget \_buildFeatureItem(String text) {
return Padding(
padding: const EdgeInsets.symmetric(vertical: 4),
child: Row(
children: [
Icon(
Icons.check_circle_rounded,
size: 16,
color: Colors.green,
),
const SizedBox(width: 8),
Expanded(
child: Text(
text,
style: Theme.of(context).textTheme.bodyMedium?.copyWith(
color: Theme.of(context)
.colorScheme
.onSurface
.withOpacity(0.7),
),
),
),
],
),
);
}

Widget \_buildProgressIndicator(int currentStep, AppLocalizations loc) {
return Column(
children: [
Row(
mainAxisAlignment: MainAxisAlignment.spaceBetween,
children: [
_buildStep(1, 'üè™', loc.translate('shop'), currentStep >= 0),
_buildStep(2, 'üë§', loc.translate('owner'), currentStep >= 1),
_buildStep(3, 'üì¶', loc.translate('plan'), currentStep >= 2),
_buildStep(4, 'üîê', loc.translate('verify'), currentStep >= 3),
_buildStep(5, 'üí≥', loc.translate('payment'), currentStep >= 4),
],
),
const SizedBox(height: 8),
Text(
'${currentStep + 1}/5 ${loc.translate('steps')}',
style: Theme.of(context).textTheme.bodySmall?.copyWith(
color: Theme.of(context).colorScheme.onSurface.withOpacity(0.6),
),
),
],
);
}

Widget \_buildStep(int stepNumber, String emoji, String label, bool isActive) {
final theme = Theme.of(context);

    return Column(
      children: [
        Container(
          width: 44,
          height: 44,
          decoration: BoxDecoration(
            color: isActive
                ? theme.colorScheme.primary
                : theme.colorScheme.surfaceVariant,
            shape: BoxShape.circle,
            boxShadow: isActive
                ? [
                    BoxShadow(
                      color: theme.colorScheme.primary.withOpacity(0.3),
                      blurRadius: 8,
                      offset: const Offset(0, 2),
                    ),
                  ]
                : null,
          ),
          child: Center(
            child: Text(
              emoji,
              style: const TextStyle(fontSize: 18),
            ),
          ),
        ),
        const SizedBox(height: 6),
        Text(
          label,
          style: theme.textTheme.labelSmall?.copyWith(
            fontWeight: isActive ? FontWeight.w700 : FontWeight.normal,
            color: isActive
                ? theme.colorScheme.primary
                : theme.colorScheme.onSurface.withOpacity(0.5),
          ),
        ),
      ],
    );

}
}

##

// src/ui/screens/onboarding/shop_registration_screen.dart
// Screen for registering the shop during the onboarding process.
import 'package:andalus_smart_pos/src/data/models/business.dart';
import 'package:andalus_smart_pos/src/widgets/common/app_button.dart';
import 'package:andalus_smart_pos/src/widgets/common/app_text_field.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
import 'package:andalus_smart_pos/src/providers/onboarding_provider.dart';
import 'package:andalus_smart_pos/src/data/models/shop_registration.dart';

class ShopRegistrationScreen extends ConsumerStatefulWidget {
const ShopRegistrationScreen({super.key});

@override
ConsumerState<ShopRegistrationScreen> createState() =>
\_ShopRegistrationScreenState();
}

class \_ShopRegistrationScreenState
extends ConsumerState<ShopRegistrationScreen> {
final \_shopNameController = TextEditingController();
final \_phoneController = TextEditingController();
final \_cityController = TextEditingController();
final \_countryController = TextEditingController();
final \_addressController = TextEditingController();

final \_formKey = GlobalKey<FormState>();
String? \_selectedCategory;

@override
void dispose() {
\_shopNameController.dispose();
\_phoneController.dispose();
\_cityController.dispose();
\_countryController.dispose();
\_addressController.dispose();
super.dispose();
}

bool \_validateForm() {
if (\_formKey.currentState?.validate() ?? false) {
final shop = ShopRegistration(
shopName: \_shopNameController.text.trim(),
shopCategory: \_selectedCategory ?? 'retail',
phoneNumber: \_phoneController.text.trim(),
city: \_cityController.text.trim(),
country: \_countryController.text.trim(),
businessAddress: \_addressController.text.trim(),
);

      ref.read(onboardingProvider.notifier).updateShopInfo(shop);
      return true;
    }
    return false;

}

void \_proceedToNextStep() {
if (\_validateForm()) {
ref.read(onboardingProvider.notifier).nextStep();
}
}

String? \_validateRequired(String? value, String fieldName) {
if (value == null || value.trim().isEmpty) {
return '$fieldName ${AppLocalizations.of(context).translate('isRequired')}';
}
return null;
}

String? \_validatePhone(String? value) {
if (value == null || value.trim().isEmpty) {
return AppLocalizations.of(context).translate('phoneRequired');
}
if (!RegExp(r'^\+251[0-9]{9}$').hasMatch(value.trim())) {
return AppLocalizations.of(context).translate('validEthiopianPhone');
}
return null;
}

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);
final loc = AppLocalizations.of(context);

    return Scaffold(
      appBar: AppBar(
        title: Text(loc.translate('shopRegistration')),
        backgroundColor: Colors.transparent,
        elevation: 0,
      ),
      body: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const SizedBox(height: 20),
              // Progress indicator
              _buildProgressIndicator(0, loc),
              const SizedBox(height: 32),
              Text(
                loc.translate('setupYourShop'),
                style: theme.textTheme.headlineSmall?.copyWith(
                  fontWeight: FontWeight.w700,
                ),
              ),
              const SizedBox(height: 8),
              Text(
                loc.translate('enterShopDetails'),
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: theme.colorScheme.onSurface.withOpacity(0.6),
                ),
              ),
              const SizedBox(height: 32),
              Expanded(
                child: SingleChildScrollView(
                  child: Column(
                    children: [
                      AppTextField(
                        controller: _shopNameController,
                        label: loc.translate('shopName'),
                        validator: (value) =>
                            _validateRequired(value, loc.translate('shopName')),
                      ),
                      const SizedBox(height: 16),
                      // Shop Category Dropdown
                      DropdownButtonFormField<String>(
                        value: _selectedCategory,
                        decoration: InputDecoration(
                          labelText: loc.translate('shopCategory'),
                          border: const OutlineInputBorder(),
                          contentPadding: const EdgeInsets.symmetric(
                              horizontal: 16, vertical: 12),
                        ),
                        items: BusinessType.allTypes.map((type) {
                          return DropdownMenuItem<String>(
                            value: type.id,
                            child: Text(loc.locale.languageCode == 'am'
                                ? type.nameAm
                                : type.name),
                          );
                        }).toList(),
                        onChanged: (value) {
                          setState(() {
                            _selectedCategory = value;
                          });
                        },
                        validator: (value) {
                          if (value == null) {
                            return loc.translate('shopCategoryRequired');
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 16),
                      AppTextField(
                        controller: _phoneController,
                        label: loc.translate('phoneNumber'),
                        prefixText: '+251 ',
                        keyboardType: TextInputType.phone,
                        validator: _validatePhone,
                      ),
                      const SizedBox(height: 16),
                      Row(
                        children: [
                          Expanded(
                            child: AppTextField(
                              controller: _cityController,
                              label: loc.translate('city'),
                              validator: (value) => _validateRequired(
                                  value, loc.translate('city')),
                            ),
                          ),
                          const SizedBox(width: 16),
                          Expanded(
                            child: AppTextField(
                              controller: _countryController,
                              label: loc.translate('country'),
                              readOnly: true,
                              enabled:
                                  false, // This makes it look disabled but without the initialValue conflict
                            ),
                          )
                        ],
                      ),
                      const SizedBox(height: 16),
                      AppTextField(
                        controller: _addressController,
                        label: loc.translate('businessAddress'),
                        maxLines: 2,
                        validator: (value) => _validateRequired(
                            value, loc.translate('businessAddress')),
                      ),
                      const SizedBox(height: 40),
                    ],
                  ),
                ),
              ),
              AppButton.primary(
                onPressed: _proceedToNextStep,
                child: Text(loc.translate('continue')),
              ),
            ],
          ),
        ),
      ),
    );

}

Widget \_buildProgressIndicator(int currentStep, AppLocalizations loc) {
return Column(
children: [
Row(
mainAxisAlignment: MainAxisAlignment.spaceBetween,
children: [
_buildStep(1, 'üè™', loc.translate('shop'), currentStep >= 0),
_buildStep(2, 'üë§', loc.translate('owner'), currentStep >= 1),
_buildStep(3, 'üì¶', loc.translate('plan'), currentStep >= 2),
_buildStep(4, 'üîê', loc.translate('verify'), currentStep >= 3),
_buildStep(5, 'üí≥', loc.translate('payment'), currentStep >= 4),
],
),
const SizedBox(height: 8),
Text(
'${currentStep + 1}/5 ${loc.translate('steps')}',
style: Theme.of(context).textTheme.bodySmall?.copyWith(
color: Theme.of(context).colorScheme.onSurface.withOpacity(0.6),
),
),
],
);
}

Widget \_buildStep(int stepNumber, String emoji, String label, bool isActive) {
return Column(
children: [
Container(
width: 36,
height: 36,
decoration: BoxDecoration(
color: isActive
? Theme.of(context).colorScheme.primary
: Theme.of(context).colorScheme.surfaceVariant,
shape: BoxShape.circle,
),
child: Center(
child: Text(
emoji,
style: const TextStyle(fontSize: 16),
),
),
),
const SizedBox(height: 4),
Text(
label,
style: Theme.of(context).textTheme.labelSmall?.copyWith(
fontWeight: isActive ? FontWeight.w600 : FontWeight.normal,
color: isActive
? Theme.of(context).colorScheme.primary
: Theme.of(context).colorScheme.onSurface.withOpacity(0.5),
),
),
],
);
}
}

##

// src/ui/screens/onboarding/subscription_selection_screen.dart
// Screen for selecting a subscription plan during the onboarding process.
import 'package:andalus_smart_pos/src/widgets/common/app_button.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
import 'package:andalus_smart_pos/src/providers/onboarding_provider.dart';
import 'package:andalus_smart_pos/src/data/models/subscription.dart';

class SubscriptionSelectionScreen extends ConsumerStatefulWidget {
const SubscriptionSelectionScreen({super.key});

@override
ConsumerState<SubscriptionSelectionScreen> createState() =>
\_SubscriptionSelectionScreenState();
}

class \_SubscriptionSelectionScreenState
extends ConsumerState<SubscriptionSelectionScreen> {
bool \_isYearlyBilling = false;
SubscriptionPlan? \_selectedPlan;

@override
void initState() {
super.initState();
// Set Professional as default selected plan
\_selectedPlan = SubscriptionPlan.professional;
}

void \_selectPlan(SubscriptionPlan plan) {
setState(() {
\_selectedPlan = plan;
});
}

void \_toggleBillingCycle() {
setState(() {
\_isYearlyBilling = !\_isYearlyBilling;
});
}

void \_proceedToNextStep() {
if (\_selectedPlan != null) {
ref.read(onboardingProvider.notifier).selectPlan(
\_selectedPlan!,
\_isYearlyBilling ? BillingCycle.yearly : BillingCycle.monthly,
);
ref.read(onboardingProvider.notifier).nextStep();
}
}

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);
final loc = AppLocalizations.of(context);

    return Scaffold(
      appBar: AppBar(
        title: Text(loc.translate('subscriptionPlan')),
        backgroundColor: Colors.transparent,
        elevation: 0,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => ref.read(onboardingProvider.notifier).previousStep(),
        ),
      ),
      body: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const SizedBox(height: 20),
            _buildProgressIndicator(2, loc),
            const SizedBox(height: 32),
            Text(
              loc.translate('chooseYourPlan'),
              style: theme.textTheme.headlineSmall?.copyWith(
                fontWeight: FontWeight.w700,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              loc.translate('startWithFreeTrial'),
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.onSurface.withOpacity(0.6),
              ),
            ),
            const SizedBox(height: 24),

            // Billing Cycle Toggle
            _buildBillingCycleToggle(theme, loc),
            const SizedBox(height: 32),

            // Subscription Plans
            Expanded(
              child: SingleChildScrollView(
                child: Column(
                  children: [
                    _buildPlanCard(SubscriptionPlan.basic, theme, loc),
                    const SizedBox(height: 16),
                    _buildPlanCard(SubscriptionPlan.professional, theme, loc),
                    const SizedBox(height: 16),
                    _buildPlanCard(SubscriptionPlan.premium, theme, loc),
                    const SizedBox(height: 40),
                  ],
                ),
              ),
            ),

            AppButton.primary(
              onPressed: _selectedPlan != null ? _proceedToNextStep : null,
              child: Text(loc.translate('continue')),
            ),
          ],
        ),
      ),
    );

}

Widget \_buildBillingCycleToggle(ThemeData theme, AppLocalizations loc) {
return Container(
padding: const EdgeInsets.all(4),
decoration: BoxDecoration(
color: theme.colorScheme.surfaceVariant,
borderRadius: BorderRadius.circular(12),
),
child: Row(
mainAxisAlignment: MainAxisAlignment.center,
children: [
Expanded(
child: GestureDetector(
onTap: () => setState(() => \_isYearlyBilling = false),
child: Container(
padding:
const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
decoration: BoxDecoration(
color: !\_isYearlyBilling
? theme.colorScheme.primary
: Colors.transparent,
borderRadius: BorderRadius.circular(8),
),
child: Center(
child: Text(
loc.translate('monthly'),
style: theme.textTheme.bodyMedium?.copyWith(
fontWeight: FontWeight.w600,
color: !\_isYearlyBilling
? theme.colorScheme.onPrimary
: theme.colorScheme.onSurfaceVariant,
),
),
),
),
),
),
Expanded(
child: GestureDetector(
onTap: () => setState(() => \_isYearlyBilling = true),
child: Container(
padding:
const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
decoration: BoxDecoration(
color: \_isYearlyBilling
? theme.colorScheme.primary
: Colors.transparent,
borderRadius: BorderRadius.circular(8),
),
child: Center(
child: Column(
children: [
Text(
loc.translate('yearly'),
style: theme.textTheme.bodyMedium?.copyWith(
fontWeight: FontWeight.w600,
color: _isYearlyBilling
? theme.colorScheme.onPrimary
: theme.colorScheme.onSurfaceVariant,
),
),
Text(
loc.translate('save20Percent'),
style: theme.textTheme.labelSmall?.copyWith(
color: _isYearlyBilling
? theme.colorScheme.onPrimary.withOpacity(0.8)
: theme.colorScheme.primary,
),
),
],
),
),
),
),
),
],
),
);
}

Widget \_buildPlanCard(
SubscriptionPlan plan, ThemeData theme, AppLocalizations loc) {
final isSelected = \_selectedPlan?.id == plan.id;
final isRecommended = plan.id == 'professional';

    return Card(
      margin: EdgeInsets.zero,
      elevation: isSelected ? 4 : 1,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
        side: BorderSide(
          color: isSelected
              ? theme.colorScheme.primary
              : theme.colorScheme.outline.withOpacity(0.1),
          width: isSelected ? 2 : 1,
        ),
      ),
      child: InkWell(
        onTap: () => _selectPlan(plan),
        borderRadius: BorderRadius.circular(16),
        child: Padding(
          padding: const EdgeInsets.all(20),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(
                    plan.name,
                    style: theme.textTheme.titleLarge?.copyWith(
                      fontWeight: FontWeight.w700,
                    ),
                  ),
                  if (isRecommended) ...[
                    Container(
                      padding: const EdgeInsets.symmetric(
                          horizontal: 12, vertical: 4),
                      decoration: BoxDecoration(
                        color: theme.colorScheme.primary.withOpacity(0.1),
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Text(
                        loc.translate('recommended'),
                        style: theme.textTheme.labelSmall?.copyWith(
                          color: theme.colorScheme.primary,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ),
                  ],
                ],
              ),
              const SizedBox(height: 8),

              // Description
              Text(
                plan.description,
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: theme.colorScheme.onSurface.withOpacity(0.6),
                ),
              ),
              const SizedBox(height: 16),

              // Price
              Text(
                _isYearlyBilling
                    ? plan.getFormattedPrice(BillingCycle.yearly)
                    : plan.getFormattedPrice(BillingCycle.monthly),
                style: theme.textTheme.headlineSmall?.copyWith(
                  fontWeight: FontWeight.w700,
                  color: theme.colorScheme.primary,
                ),
              ),
              if (_isYearlyBilling) ...[
                const SizedBox(height: 4),
                Text(
                  plan.savingsInfo,
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: theme.colorScheme.primary,
                  ),
                ),
              ],
              const SizedBox(height: 16),

              // Features
              ...plan.features.take(4).map((feature) => Padding(
                    padding: const EdgeInsets.symmetric(vertical: 4),
                    child: Row(
                      children: [
                        Icon(
                          Icons.check_circle_rounded,
                          size: 16,
                          color: theme.colorScheme.primary,
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Text(
                            feature,
                            style: theme.textTheme.bodyMedium,
                          ),
                        ),
                      ],
                    ),
                  )),

              // Selection indicator
              const SizedBox(height: 16),
              Container(
                width: double.infinity,
                padding: const EdgeInsets.symmetric(vertical: 12),
                decoration: BoxDecoration(
                  color: isSelected
                      ? theme.colorScheme.primary
                      : Colors.transparent,
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(
                    color: isSelected
                        ? theme.colorScheme.primary
                        : theme.colorScheme.outline,
                  ),
                ),
                child: Center(
                  child: Text(
                    isSelected
                        ? loc.translate('selected')
                        : loc.translate('selectPlan'),
                    style: theme.textTheme.bodyMedium?.copyWith(
                      fontWeight: FontWeight.w600,
                      color: isSelected
                          ? theme.colorScheme.onPrimary
                          : theme.colorScheme.primary,
                    ),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );

}

Widget \_buildProgressIndicator(int currentStep, AppLocalizations loc) {
return Column(
children: [
Row(
mainAxisAlignment: MainAxisAlignment.spaceBetween,
children: [
_buildStep(1, 'üè™', loc.translate('shop'), currentStep >= 0),
_buildStep(2, 'üë§', loc.translate('owner'), currentStep >= 1),
_buildStep(3, 'üì¶', loc.translate('plan'), currentStep >= 2),
_buildStep(4, 'üîê', loc.translate('verify'), currentStep >= 3),
_buildStep(5, 'üí≥', loc.translate('payment'), currentStep >= 4),
],
),
const SizedBox(height: 8),
Text(
'${currentStep + 1}/5 ${loc.translate('steps')}',
style: Theme.of(context).textTheme.bodySmall?.copyWith(
color: Theme.of(context).colorScheme.onSurface.withOpacity(0.6),
),
),
],
);
}

Widget \_buildStep(int stepNumber, String emoji, String label, bool isActive) {
return Column(
children: [
Container(
width: 36,
height: 36,
decoration: BoxDecoration(
color: isActive
? Theme.of(context).colorScheme.primary
: Theme.of(context).colorScheme.surfaceVariant,
shape: BoxShape.circle,
),
child: Center(
child: Text(
emoji,
style: const TextStyle(fontSize: 16),
),
),
),
const SizedBox(height: 4),
Text(
label,
style: Theme.of(context).textTheme.labelSmall?.copyWith(
fontWeight: isActive ? FontWeight.w600 : FontWeight.normal,
color: isActive
? Theme.of(context).colorScheme.primary
: Theme.of(context).colorScheme.onSurface.withOpacity(0.5),
),
),
],
);
}
}

##

// src/ui/screens/account_setting_screen.dart
// Account settings screen for viewing and updating user profile, preferences, and security settings.
import 'package:andalus_smart_pos/src/config/app_theme.dart';
import 'package:andalus_smart_pos/src/config/font_theme.dart';
import 'package:andalus_smart_pos/src/utils/date_utils.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
import 'package:andalus_smart_pos/src/providers/auth_provider.dart';
import 'package:andalus_smart_pos/src/providers/theme_provider.dart';
import 'package:andalus_smart_pos/src/providers/language_provider.dart';
// import 'package:andalus_smart_pos/src/config/theme/font_theme.dart';

import 'package:andalus_smart_pos/src/utils/calendar_utils.dart';
import 'package:andalus_smart_pos/src/data/models/user.dart';
import 'package:andalus_smart_pos/src/ui/screens/auth/phone_login_screen.dart';
import 'package:andalus_smart_pos/src/widgets/common/custom_card.dart';

class AccountSettingsScreen extends ConsumerStatefulWidget {
const AccountSettingsScreen({super.key});

@override
ConsumerState<AccountSettingsScreen> createState() =>
\_AccountSettingsScreenState();
}

class \_AccountSettingsScreenState extends ConsumerState<AccountSettingsScreen> {
final \_nameController = TextEditingController();
final \_phoneController = TextEditingController();
final \_emailController = TextEditingController();
final \_currentPasswordController = TextEditingController();
final \_newPasswordController = TextEditingController();
final \_confirmPasswordController = TextEditingController();

bool \_isEditing = false;
bool \_isChangingPassword = false;

@override
void initState() {
super.initState();
\_loadUserData();
}

void \_loadUserData() {
final authState = ref.read(authProvider);
final user = authState.user;

    if (user != null) {
      _nameController.text = user.name;
      _phoneController.text = user.phone;
      _emailController.text = user.email ?? '';
    }

}

@override
void dispose() {
\_nameController.dispose();
\_phoneController.dispose();
\_emailController.dispose();
\_currentPasswordController.dispose();
\_newPasswordController.dispose();
\_confirmPasswordController.dispose();
super.dispose();
}

void \_toggleEdit() {
setState(() {
\_isEditing = !\_isEditing;
if (!\_isEditing) {
\_loadUserData();
}
});
}

void \_togglePasswordChange() {
setState(() {
\_isChangingPassword = !\_isChangingPassword;
if (!\_isChangingPassword) {
\_currentPasswordController.clear();
\_newPasswordController.clear();
\_confirmPasswordController.clear();
}
});
}

Future<void> \_updateProfile() async {
final authState = ref.read(authProvider);
final user = authState.user;

    if (user == null) return;

    // TODO: Implement profile update logic
    final updatedUser = user.copyWith(
      name: _nameController.text,
      phone: _phoneController.text,
      email: _emailController.text.isEmpty ? null : _emailController.text,
    );

    setState(() => _isEditing = false);

    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content:
              Text(AppLocalizations.of(context).translate('settingsSaved')),
          backgroundColor: Colors.green,
        ),
      );
    }

}

Future<void> \_changePassword() async {
if (\_newPasswordController.text != \_confirmPasswordController.text) {
if (mounted) {
ScaffoldMessenger.of(context).showSnackBar(
const SnackBar(
content: Text('New passwords do not match'),
backgroundColor: Colors.red,
),
);
}
return;
}

    // TODO: Implement password change logic
    _togglePasswordChange();

    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Password changed successfully'),
          backgroundColor: Colors.green,
        ),
      );
    }

}

void \_logout() {
showDialog(
context: context,
builder: (context) => AlertDialog(
title: Text(AppLocalizations.of(context).translate('confirm')),
content: Text(AppLocalizations.of(context)
.translate('Are you sure you want to logout?')),
actions: [
TextButton(
onPressed: () => Navigator.pop(context),
child: Text(AppLocalizations.of(context).translate('cancel')),
),
TextButton(
onPressed: () {
Navigator.pop(context);
_performLogout();
},
style: TextButton.styleFrom(foregroundColor: Colors.red),
child: Text(AppLocalizations.of(context).translate('confirm')),
),
],
),
);
}

void \_performLogout() {
ref.read(authProvider.notifier).logout();
Navigator.pushAndRemoveUntil(
context,
MaterialPageRoute(builder: (context) => const PhoneLoginScreen()),
(route) => false,
);
}

@override
Widget build(BuildContext context) {
final authState = ref.watch(authProvider);
final themeMode = ref.watch(themeProvider);
final locale = ref.watch(languageProvider);
final fontTheme = ref.watch(fontThemeProvider);
final localizations = AppLocalizations.of(context);
final user = authState.user;

    return Scaffold(
      appBar: AppBar(
        title: Text(localizations.translate('Account Settings')),
        actions: [
          if (_isEditing) ...[
            IconButton(
              icon: const Icon(Icons.save),
              onPressed: _updateProfile,
              tooltip: 'Save Changes',
            ),
            IconButton(
              icon: const Icon(Icons.cancel),
              onPressed: _toggleEdit,
              tooltip: 'Cancel',
            ),
          ],
        ],
      ),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          // User Profile Section
          _buildProfileSection(user, localizations),
          const SizedBox(height: 16),

          // Calendar Settings
          _buildCalendarSection(localizations),
          const SizedBox(height: 16),

          // Language Settings
          _buildLanguageSection(locale, localizations),
          const SizedBox(height: 16),

          // Font Settings
          _buildFontSettingsSection(fontTheme, localizations),
          const SizedBox(height: 16),

          // Theme Settings
          _buildThemeSection(themeMode, localizations),
          const SizedBox(height: 16),

          // Security Section
          _buildSecuritySection(localizations),
          const SizedBox(height: 16),

          // Logout Section
          _buildLogoutSection(localizations),
        ],
      ),
    );

}

Widget \_buildProfileSection(User? user, AppLocalizations localizations) {
return CustomCard(
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Row(
children: [
const CircleAvatar(
radius: 30,
backgroundColor: Colors.blue,
child: Icon(Icons.person, color: Colors.white, size: 30),
),
const SizedBox(width: 16),
Expanded(
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
user?.name ?? 'No Name',
style: const TextStyle(
fontSize: 18,
fontWeight: FontWeight.bold,
),
),
const SizedBox(height: 4),
Text(
user?.role.displayName ?? 'User',
style: TextStyle(
color: Colors.grey.shade600,
),
),
const SizedBox(height: 4),
Text(
user?.phone ?? 'No Phone',
style: TextStyle(
color: Colors.grey.shade600,
),
),
],
),
),
if (!\_isEditing && !\_isChangingPassword)
IconButton(
icon: const Icon(Icons.edit),
onPressed: \_toggleEdit,
tooltip: 'Edit Profile',
),
],
),
const SizedBox(height: 16),
if (\_isEditing) \_buildProfileForm(),
],
),
),
);
}

Widget \_buildCalendarSection(AppLocalizations localizations) {
final currentCalendar = CalendarUtils.currentCalendar;

    return CustomCard(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                const Icon(Icons.calendar_today, color: Color(0xFF10B981)),
                const SizedBox(width: 12),
                Text(
                  'Calendar System',
                  style: Theme.of(context).textTheme.titleLarge?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                ),
              ],
            ),
            const SizedBox(height: 16),
            Text(
              'Choose your preferred calendar system for date displays throughout the app.',
              style: TextStyle(color: Colors.grey.shade600),
            ),
            const SizedBox(height: 16),
            Wrap(
              spacing: 12,
              runSpacing: 12,
              children: [
                _buildCalendarOption(
                  'Gregorian',
                  CalendarType.gregorian,
                  currentCalendar,
                  Icons.calendar_today,
                ),
                _buildCalendarOption(
                  'Ethiopian',
                  CalendarType.ethiopian,
                  currentCalendar,
                  Icons.language,
                ),
              ],
            ),
            const SizedBox(height: 8),
            Text(
              'Current date: ${AppDateUtils.formatFullDate(DateTime.now())}',
              style: const TextStyle(
                fontWeight: FontWeight.w500,
                color: Color(0xFF10B981),
              ),
            ),
          ],
        ),
      ),
    );

}

Widget \_buildCalendarOption(
String label,
CalendarType type,
CalendarType currentType,
IconData icon,
) {
final isSelected = currentType == type;

    return FilterChip(
      label: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 16),
          const SizedBox(width: 6),
          Text(label),
        ],
      ),
      selected: isSelected,
      onSelected: (selected) {
        CalendarUtils.setCalendarType(type);
        setState(() {});
      },
      backgroundColor: Colors.grey.shade100,
      selectedColor: const Color(0xFF10B981).withOpacity(0.2),
      checkmarkColor: const Color(0xFF10B981),
      labelStyle: TextStyle(
        color: isSelected ? const Color(0xFF10B981) : Colors.grey.shade700,
        fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
      ),
    );

}

Widget \_buildLanguageSection(Locale locale, AppLocalizations localizations) {
return CustomCard(
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Row(
children: [
const Icon(Icons.language, color: Color(0xFF10B981)),
const SizedBox(width: 12),
Text(
localizations.translate('language'),
style: Theme.of(context).textTheme.titleLarge?.copyWith(
fontWeight: FontWeight.bold,
),
),
],
),
const SizedBox(height: 16),
DropdownButtonFormField<Locale>(
value: locale,
decoration: InputDecoration(
labelText: 'App Language',
border: OutlineInputBorder(
borderRadius: BorderRadius.circular(12),
),
),
items: const [
DropdownMenuItem(
value: Locale('en'),
child: Text('English'),
),
DropdownMenuItem(
value: Locale('am'),
child: Text('·ä†·àõ·à≠·äõ'),
),
],
onChanged: (newLocale) {
if (newLocale != null) {
ref
.read(languageProvider.notifier)
.setLanguage(newLocale.languageCode);
}
},
),
],
),
),
);
}

Widget \_buildFontSettingsSection(
FontTheme fontTheme, AppLocalizations localizations) {
return CustomCard(
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Row(
children: [
const Icon(Icons.font_download, color: Color(0xFF10B981)),
const SizedBox(width: 12),
Text(
'Font Settings',
style: Theme.of(context).textTheme.titleLarge?.copyWith(
fontWeight: FontWeight.bold,
),
),
],
),
const SizedBox(height: 16),

            // English Font
            _buildFontSelector(
              'English Font',
              fontTheme.englishFont,
              AppFontFamily.values,
              (font) =>
                  ref.read(fontThemeProvider.notifier).updateEnglishFont(font),
            ),
            const SizedBox(height: 16),

            // Amharic Font
            _buildFontSelector(
              'Amharic Font',
              fontTheme.amharicFont,
              [AppFontFamily.notoSansEthiopic, AppFontFamily.AbyssinicaSIL],
              (font) =>
                  ref.read(fontThemeProvider.notifier).updateAmharicFont(font),
            ),
            const SizedBox(height: 16),

            // Font Size Scaling
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(
                      'Font Size Scale',
                      style: Theme.of(context).textTheme.titleMedium,
                    ),
                    Text(
                      '${(fontTheme.fontSizeScale * 100).toInt()}%',
                      style: const TextStyle(
                        fontWeight: FontWeight.bold,
                        color: Color(0xFF10B981),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 8),
                Slider(
                  value: fontTheme.fontSizeScale,
                  min: 0.8,
                  max: 1.5,
                  divisions: 7,
                  onChanged: (value) {
                    ref.read(fontThemeProvider.notifier).updateFontScale(value);
                  },
                  activeColor: const Color(0xFF10B981),
                ),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: const [
                    Text('Smaller', style: TextStyle(fontSize: 12)),
                    Text('Larger', style: TextStyle(fontSize: 12)),
                  ],
                ),
              ],
            ),
          ],
        ),
      ),
    );

}

Widget \_buildFontSelector(
String label,
AppFontFamily currentFont,
List<AppFontFamily> options,
Function(AppFontFamily) onChanged,
) {
return Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
label,
style: Theme.of(context).textTheme.titleMedium,
),
const SizedBox(height: 8),
Wrap(
spacing: 8,
runSpacing: 8,
children: options.map((font) {
final isSelected = currentFont == font;
return FilterChip(
label: Text(font.name),
selected: isSelected,
onSelected: (selected) => onChanged(font),
backgroundColor: Colors.grey.shade100,
selectedColor: const Color(0xFF10B981).withOpacity(0.2),
checkmarkColor: const Color(0xFF10B981),
labelStyle: TextStyle(
color:
isSelected ? const Color(0xFF10B981) : Colors.grey.shade700,
fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
),
);
}).toList(),
),
],
);
}

Widget \_buildThemeSection(
ThemeMode themeMode, AppLocalizations localizations) {
return CustomCard(
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Row(
children: [
const Icon(Icons.palette, color: Color(0xFF10B981)),
const SizedBox(width: 12),
Text(
localizations.translate('themeMode'),
style: Theme.of(context).textTheme.titleLarge?.copyWith(
fontWeight: FontWeight.bold,
),
),
],
),
const SizedBox(height: 16),
DropdownButtonFormField<ThemeMode>(
value: themeMode,
decoration: InputDecoration(
labelText: 'Theme Mode',
border: OutlineInputBorder(
borderRadius: BorderRadius.circular(12),
),
),
items: [
DropdownMenuItem(
value: ThemeMode.light,
child: Text(localizations.translate('light')),
),
DropdownMenuItem(
value: ThemeMode.dark,
child: Text(localizations.translate('dark')),
),
DropdownMenuItem(
value: ThemeMode.system,
child: Text(localizations.translate('systemDefault')),
),
],
onChanged: (newMode) {
if (newMode != null) {
ref.read(themeProvider.notifier).setTheme(newMode);
}
},
),
],
),
),
);
}

Widget \_buildSecuritySection(AppLocalizations localizations) {
return CustomCard(
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
'Security',
style: Theme.of(context).textTheme.titleLarge?.copyWith(
fontWeight: FontWeight.bold,
),
),
const SizedBox(height: 16),
if (\_isChangingPassword) ...[
_buildPasswordChangeForm(),
const SizedBox(height: 16),
],
SizedBox(
width: double.infinity,
child: OutlinedButton(
onPressed: \_isChangingPassword
? \_changePassword
: \_togglePasswordChange,
child: Text(\_isChangingPassword
? 'Change Password'
: 'Change Password'),
),
),
],
),
),
);
}

Widget \_buildLogoutSection(AppLocalizations localizations) {
return CustomCard(
backgroundColor: Colors.red.shade50,
child: ListTile(
leading: Icon(Icons.logout, color: Colors.red.shade600),
title: Text(
'Logout',
style: TextStyle(
color: Colors.red.shade700,
fontWeight: FontWeight.bold,
),
),
trailing: Icon(Icons.arrow_forward, color: Colors.red.shade600),
onTap: \_logout,
),
);
}

Widget \_buildProfileForm() {
return Column(
children: [
TextFormField(
controller: _nameController,
decoration: const InputDecoration(
labelText: 'Full Name',
border: OutlineInputBorder(),
),
),
const SizedBox(height: 12),
TextFormField(
controller: _phoneController,
decoration: const InputDecoration(
labelText: 'Phone Number',
border: OutlineInputBorder(),
),
keyboardType: TextInputType.phone,
),
const SizedBox(height: 12),
TextFormField(
controller: _emailController,
decoration: const InputDecoration(
labelText: 'Email (Optional)',
border: OutlineInputBorder(),
),
keyboardType: TextInputType.emailAddress,
),
],
);
}

Widget \_buildPasswordChangeForm() {
return Column(
children: [
TextFormField(
controller: _currentPasswordController,
decoration: const InputDecoration(
labelText: 'Current Password',
border: OutlineInputBorder(),
),
obscureText: true,
),
const SizedBox(height: 12),
TextFormField(
controller: _newPasswordController,
decoration: const InputDecoration(
labelText: 'New Password',
border: OutlineInputBorder(),
),
obscureText: true,
),
const SizedBox(height: 12),
TextFormField(
controller: _confirmPasswordController,
decoration: const InputDecoration(
labelText: 'Confirm New Password',
border: OutlineInputBorder(),
),
obscureText: true,
),
],
);
}
}

##

// src/ui/screens/business_registration_screen.dart
// Screen for registering a business during the onboarding process.
import 'package:andalus_smart_pos/src/data/models/category.dart';
import 'package:andalus_smart_pos/src/data/repositories/category_repository.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/data/models/business.dart';
import 'package:andalus_smart_pos/src/data/repositories/business_repository.dart';
import 'package:andalus_smart_pos/src/widgets/common/custom_card.dart';
import 'package:andalus_smart_pos/src/widgets/common/loading_shimmer.dart';

class BusinessRegistrationScreen extends ConsumerStatefulWidget {
const BusinessRegistrationScreen({super.key});

@override
ConsumerState<BusinessRegistrationScreen> createState() =>
\_BusinessRegistrationScreenState();
}

class \_BusinessRegistrationScreenState
extends ConsumerState<BusinessRegistrationScreen> {
final \_formKey = GlobalKey<FormState>();
final \_businessNameController = TextEditingController();
final \_businessNameAmController = TextEditingController();
final \_phoneController = TextEditingController();
final \_emailController = TextEditingController();
final \_addressController = TextEditingController();
final \_cityController = TextEditingController();
final \_regionController = TextEditingController();
final \_tinController = TextEditingController();
final \_vatController = TextEditingController();
final \_licenseController = TextEditingController();
final \_ownerNameController = TextEditingController();
final \_ownerPhoneController = TextEditingController();
final \_ownerEmailController = TextEditingController();

String \_selectedBusinessType = 'retail';
bool \_isLoading = false;

@override
void dispose() {
\_businessNameController.dispose();
\_businessNameAmController.dispose();
\_phoneController.dispose();
\_emailController.dispose();
\_addressController.dispose();
\_cityController.dispose();
\_regionController.dispose();
\_tinController.dispose();
\_vatController.dispose();
\_licenseController.dispose();
\_ownerNameController.dispose();
\_ownerPhoneController.dispose();
\_ownerEmailController.dispose();
super.dispose();
}

Future<void> \_registerBusiness() async {
if (!\_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);

    try {
      final businessRepo = ref.read(businessRepositoryProvider);
      final business = BusinessProfile(
        businessId: 'biz_${DateTime.now().millisecondsSinceEpoch}',
        name: _businessNameController.text.trim(),
        nameAm: _businessNameAmController.text.trim(),
        businessType: _selectedBusinessType,
        phone: _phoneController.text.trim(),
        email: _emailController.text.trim().isEmpty
            ? null
            : _emailController.text.trim(),
        address: _addressController.text.trim(),
        city: _cityController.text.trim().isEmpty
            ? null
            : _cityController.text.trim(),
        region: _regionController.text.trim().isEmpty
            ? null
            : _regionController.text.trim(),
        tinNumber: _tinController.text.trim(),
        vatNumber: _vatController.text.trim().isEmpty
            ? null
            : _vatController.text.trim(),
        businessLicense: _licenseController.text.trim().isEmpty
            ? null
            : _licenseController.text.trim(),
        ownerName: _ownerNameController.text.trim().isEmpty
            ? null
            : _ownerNameController.text.trim(),
        ownerPhone: _ownerPhoneController.text.trim().isEmpty
            ? null
            : _ownerPhoneController.text.trim(),
        ownerEmail: _ownerEmailController.text.trim().isEmpty
            ? null
            : _ownerEmailController.text.trim(),
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      await businessRepo.saveBusinessProfile(business);

      // Create default categories for the business type
      final categoryRepo = ref.read(categoryRepositoryProvider);
      final defaultCategories =
          DefaultCategories.forBusinessType(_selectedBusinessType);
      for (final category in defaultCategories) {
        await categoryRepo.createCategory(category);
      }

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Business registered successfully!'),
            backgroundColor: Colors.green,
          ),
        );
        Navigator.pushReplacementNamed(context, '/main');
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error registering business: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }

}

@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: const Text('Business Registration'),
backgroundColor: const Color(0xFF10B981),
foregroundColor: Colors.white,
),
body: \_isLoading
? \_buildLoadingState()
: SingleChildScrollView(
padding: const EdgeInsets.all(16),
child: Form(
key: \_formKey,
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
_buildBusinessTypeSection(),
const SizedBox(height: 24),
_buildBusinessInfoSection(),
const SizedBox(height: 24),
_buildOwnerInfoSection(),
const SizedBox(height: 32),
_buildSubmitButton(),
],
),
),
),
);
}

Widget \_buildLoadingState() {
return const Padding(
padding: EdgeInsets.all(16),
child: Column(
children: [
LoadingShimmer(height: 60, borderRadius: 12),
SizedBox(height: 16),
LoadingShimmer(height: 200, borderRadius: 12),
SizedBox(height: 16),
LoadingShimmer(height: 150, borderRadius: 12),
],
),
);
}

Widget \_buildBusinessTypeSection() {
return CustomCard(
margin: EdgeInsets.zero,
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
'Business Type',
style: Theme.of(context).textTheme.titleLarge?.copyWith(
fontWeight: FontWeight.bold,
),
),
const SizedBox(height: 16),
Wrap(
spacing: 8,
runSpacing: 8,
children: BusinessType.allTypes.map((type) {
final isSelected = \_selectedBusinessType == type.id;
return FilterChip(
label: Text(type.name),
selected: isSelected,
onSelected: (selected) {
setState(() => \_selectedBusinessType = type.id);
},
backgroundColor: Colors.grey.shade100,
selectedColor: const Color(0xFF10B981).withOpacity(0.2),
checkmarkColor: const Color(0xFF10B981),
labelStyle: TextStyle(
color: isSelected
? const Color(0xFF10B981)
: Colors.grey.shade700,
fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
),
);
}).toList(),
),
if (\_selectedBusinessType.isNotEmpty) ...[
const SizedBox(height: 12),
Text(
BusinessType.allTypes
.firstWhere((type) => type.id == _selectedBusinessType)
.description,
style: Theme.of(context).textTheme.bodySmall?.copyWith(
color: Colors.grey.shade600,
fontStyle: FontStyle.italic,
),
),
],
],
),
);
}

Widget \_buildBusinessInfoSection() {
return CustomCard(
margin: EdgeInsets.zero,
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
'Business Information',
style: Theme.of(context).textTheme.titleLarge?.copyWith(
fontWeight: FontWeight.bold,
),
),
const SizedBox(height: 16),
\_buildTextField(
controller: \_businessNameController,
label: 'Business Name (English) _',
hintText: 'Enter business name in English',
validator: (value) {
if (value == null || value.trim().isEmpty) {
return 'Business name is required';
}
return null;
},
),
const SizedBox(height: 12),
\_buildTextField(
controller: \_businessNameAmController,
label: 'Business Name (Amharic) _',
hintText: '·ã®·äï·åç·ãµ ·àµ·àù ·â†·ä†·àõ·à≠·äõ',
validator: (value) {
if (value == null || value.trim().isEmpty) {
return 'Business name in Amharic is required';
}
return null;
},
),
const SizedBox(height: 12),
\_buildTextField(
controller: \_phoneController,
label: 'Business Phone _',
hintText: '+251 XXX XXX XXX',
keyboardType: TextInputType.phone,
validator: (value) {
if (value == null || value.trim().isEmpty) {
return 'Phone number is required';
}
if (!RegExp(r'^(\+251|251|0)\d{9}$').hasMatch(value.trim())) {
return 'Please enter a valid Ethiopian phone number';
}
return null;
},
),
const SizedBox(height: 12),
\_buildTextField(
controller: \_emailController,
label: 'Business Email',
hintText: 'business@example.com',
keyboardType: TextInputType.emailAddress,
),
const SizedBox(height: 12),
\_buildTextField(
controller: \_addressController,
label: 'Address _',
hintText: 'Full business address',
maxLines: 2,
validator: (value) {
if (value == null || value.trim().isEmpty) {
return 'Address is required';
}
return null;
},
),
const SizedBox(height: 12),
Row(
children: [
Expanded(
child: _buildTextField(
controller: _cityController,
label: 'City',
hintText: 'City',
),
),
const SizedBox(width: 12),
Expanded(
child: _buildTextField(
controller: _regionController,
label: 'Region',
hintText: 'Region/State',
),
),
],
),
const SizedBox(height: 12),
\_buildTextField(
controller: \_tinController,
label: 'TIN Number \*',
hintText: 'Tax Identification Number',
validator: (value) {
if (value == null || value.trim().isEmpty) {
return 'TIN number is required';
}
return null;
},
),
const SizedBox(height: 12),
Row(
children: [
Expanded(
child: _buildTextField(
controller: _vatController,
label: 'VAT Number',
hintText: 'VAT Registration Number',
),
),
const SizedBox(width: 12),
Expanded(
child: _buildTextField(
controller: _licenseController,
label: 'Business License',
hintText: 'License Number',
),
),
],
),
],
),
);
}

Widget \_buildOwnerInfoSection() {
return CustomCard(
margin: EdgeInsets.zero,
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
'Owner Information (Optional)',
style: Theme.of(context).textTheme.titleLarge?.copyWith(
fontWeight: FontWeight.bold,
),
),
const SizedBox(height: 8),
Text(
'Provide owner details for business records',
style: Theme.of(context).textTheme.bodySmall?.copyWith(
color: Colors.grey.shade600,
),
),
const SizedBox(height: 16),
_buildTextField(
controller: _ownerNameController,
label: 'Owner Name',
hintText: 'Full name of business owner',
),
const SizedBox(height: 12),
_buildTextField(
controller: _ownerPhoneController,
label: 'Owner Phone',
hintText: 'Owner phone number',
keyboardType: TextInputType.phone,
),
const SizedBox(height: 12),
_buildTextField(
controller: _ownerEmailController,
label: 'Owner Email',
hintText: 'Owner email address',
keyboardType: TextInputType.emailAddress,
),
],
),
);
}

Widget \_buildTextField({
required TextEditingController controller,
required String label,
required String hintText,
TextInputType keyboardType = TextInputType.text,
int maxLines = 1,
String? Function(String?)? validator,
}) {
return TextFormField(
controller: controller,
decoration: InputDecoration(
labelText: label,
hintText: hintText,
border: const OutlineInputBorder(),
contentPadding:
const EdgeInsets.symmetric(horizontal: 12, vertical: 16),
),
keyboardType: keyboardType,
maxLines: maxLines,
validator: validator,
);
}

Widget \_buildSubmitButton() {
return SizedBox(
width: double.infinity,
child: ElevatedButton(
onPressed: \_isLoading ? null : \_registerBusiness,
style: ElevatedButton.styleFrom(
backgroundColor: const Color(0xFF10B981),
foregroundColor: Colors.white,
padding: const EdgeInsets.symmetric(vertical: 16),
shape: RoundedRectangleBorder(
borderRadius: BorderRadius.circular(12),
),
),
child: \_isLoading
? const SizedBox(
height: 20,
width: 20,
child: CircularProgressIndicator(
strokeWidth: 2,
valueColor: AlwaysStoppedAnimation(Colors.white),
),
)
: const Text(
'Register Business',
style: TextStyle(
fontSize: 16,
fontWeight: FontWeight.bold,
),
),
),
);
}
}

##

// src/ui/screens/category_management_screen.dart
// Screen for managing product categories including viewing, searching, adding, editing, and toggling active
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/data/models/category.dart';
import 'package:andalus_smart_pos/src/data/repositories/category_repository.dart';
import 'package:andalus_smart_pos/src/widgets/common/custom_card.dart';
import 'package:andalus_smart_pos/src/widgets/common/loading_shimmer.dart';

class CategoryManagementScreen extends ConsumerStatefulWidget {
const CategoryManagementScreen({super.key});

@override
ConsumerState<CategoryManagementScreen> createState() =>
\_CategoryManagementScreenState();
}

class \_CategoryManagementScreenState
extends ConsumerState<CategoryManagementScreen> {
final \_searchController = TextEditingController();
List<ProductCategory> \_categories = [];
List<ProductCategory> \_filteredCategories = [];
bool \_isLoading = true;
String \_searchQuery = '';

@override
void initState() {
super.initState();
\_loadCategories();
\_searchController.addListener(\_onSearchChanged);
}

@override
void dispose() {
\_searchController.dispose();
super.dispose();
}

Future<void> \_loadCategories() async {
setState(() => \_isLoading = true);
try {
final categoryRepo = ref.read(categoryRepositoryProvider);
final categories = await categoryRepo.getAllCategories();
setState(() {
\_categories = categories;
\_filteredCategories = categories;
});
} catch (e) {
if (mounted) {
ScaffoldMessenger.of(context).showSnackBar(
SnackBar(
content: Text('Error loading categories: $e'),
backgroundColor: Colors.red,
),
);
}
} finally {
setState(() => \_isLoading = false);
}
}

void \_onSearchChanged() {
setState(() {
\_searchQuery = \_searchController.text.toLowerCase();
\_filteredCategories = \_categories.where((category) {
return category.name.toLowerCase().contains(\_searchQuery) ||
category.nameAm.toLowerCase().contains(\_searchQuery) ||
(category.description?.toLowerCase().contains(\_searchQuery) ??
false);
}).toList();
});
}

void \_showAddCategoryDialog({ProductCategory? existingCategory}) {
final isEdit = existingCategory != null;
final nameController =
TextEditingController(text: existingCategory?.name ?? '');
final nameAmController =
TextEditingController(text: existingCategory?.nameAm ?? '');
final descriptionController =
TextEditingController(text: existingCategory?.description ?? '');
final colorController =
TextEditingController(text: existingCategory?.color ?? '#4CAF50');
final iconController =
TextEditingController(text: existingCategory?.icon ?? 'category');

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(isEdit ? 'Edit Category' : 'Add New Category'),
        content: SingleChildScrollView(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              _buildDialogTextField(
                controller: nameController,
                label: 'Category Name (English) *',
                hintText: 'e.g., Beverages',
              ),
              const SizedBox(height: 12),
              _buildDialogTextField(
                controller: nameAmController,
                label: 'Category Name (Amharic) *',
                hintText: 'e.g., ·àò·å†·å¶·âΩ',
              ),
              const SizedBox(height: 12),
              _buildDialogTextField(
                controller: descriptionController,
                label: 'Description',
                hintText: 'Category description',
                maxLines: 2,
              ),
              const SizedBox(height: 12),
              Row(
                children: [
                  Expanded(
                    child: _buildDialogTextField(
                      controller: colorController,
                      label: 'Color',
                      hintText: '#4CAF50',
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: _buildDialogTextField(
                      controller: iconController,
                      label: 'Icon',
                      hintText: 'local_cafe',
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () async {
              if (nameController.text.trim().isEmpty ||
                  nameAmController.text.trim().isEmpty) {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('Category name is required')),
                );
                return;
              }

              try {
                final categoryRepo = ref.read(categoryRepositoryProvider);
                final category = ProductCategory(
                  id: existingCategory?.id,
                  categoryId: existingCategory?.categoryId ??
                      'cat_${DateTime.now().millisecondsSinceEpoch}',
                  name: nameController.text.trim(),
                  nameAm: nameAmController.text.trim(),
                  description: descriptionController.text.trim().isEmpty
                      ? null
                      : descriptionController.text.trim(),
                  color: colorController.text.trim().isEmpty
                      ? null
                      : colorController.text.trim(),
                  icon: iconController.text.trim().isEmpty
                      ? null
                      : iconController.text.trim(),
                  sortOrder: existingCategory?.sortOrder ?? _categories.length,
                  isActive: existingCategory?.isActive ?? true,
                  createdAt: existingCategory?.createdAt ?? DateTime.now(),
                  updatedAt: DateTime.now(),
                );

                if (isEdit) {
                  await categoryRepo.updateCategory(category);
                } else {
                  await categoryRepo.createCategory(category);
                }

                if (mounted) {
                  Navigator.pop(context);
                  _loadCategories();
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(
                      content: Text(
                          'Category ${isEdit ? 'updated' : 'created'} successfully!'),
                      backgroundColor: Colors.green,
                    ),
                  );
                }
              } catch (e) {
                if (mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(
                      content: Text('Error saving category: $e'),
                      backgroundColor: Colors.red,
                    ),
                  );
                }
              }
            },
            child: Text(isEdit ? 'Update' : 'Create'),
          ),
        ],
      ),
    );

}

Widget \_buildDialogTextField({
required TextEditingController controller,
required String label,
required String hintText,
int maxLines = 1,
}) {
return TextFormField(
controller: controller,
decoration: InputDecoration(
labelText: label,
hintText: hintText,
border: const OutlineInputBorder(),
),
maxLines: maxLines,
);
}

Future<void> \_toggleCategoryStatus(ProductCategory category) async {
try {
final categoryRepo = ref.read(categoryRepositoryProvider);
await categoryRepo
.updateCategory(category.copyWith(isActive: !category.isActive));
\_loadCategories();
} catch (e) {
if (mounted) {
ScaffoldMessenger.of(context).showSnackBar(
SnackBar(
content: Text('Error updating category: $e'),
backgroundColor: Colors.red,
),
);
}
}
}

@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: const Text('Product Categories'),
backgroundColor: const Color(0xFF10B981),
foregroundColor: Colors.white,
actions: [
IconButton(
icon: const Icon(Icons.add),
onPressed: () => _showAddCategoryDialog(),
tooltip: 'Add Category',
),
],
),
body: Column(
children: [
// Search Bar
Padding(
padding: const EdgeInsets.all(16),
child: TextField(
controller: _searchController,
decoration: InputDecoration(
hintText: 'Search categories...',
prefixIcon: const Icon(Icons.search),
border: OutlineInputBorder(
borderRadius: BorderRadius.circular(12),
),
),
),
),
// Categories List
Expanded(
child: _isLoading
? _buildLoadingState()
: _filteredCategories.isEmpty
? _buildEmptyState()
: _buildCategoriesList(),
),
],
),
);
}

Widget \_buildLoadingState() {
return ListView.builder(
padding: const EdgeInsets.all(16),
itemCount: 6,
itemBuilder: (context, index) => const Padding(
padding: EdgeInsets.only(bottom: 12),
child: ListItemShimmer(hasLeading: true, hasTrailing: true),
),
);
}

Widget \_buildEmptyState() {
return Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
Icon(Icons.category_outlined, size: 64, color: Colors.grey.shade400),
const SizedBox(height: 16),
Text(
_searchQuery.isEmpty ? 'No categories yet' : 'No categories found',
style: const TextStyle(
fontSize: 18,
fontWeight: FontWeight.bold,
color: Colors.grey,
),
),
const SizedBox(height: 8),
Text(
_searchQuery.isEmpty
? 'Add your first product category to get started'
: 'Try adjusting your search terms',
style: TextStyle(color: Colors.grey.shade600),
textAlign: TextAlign.center,
),
const SizedBox(height: 24),
if (_searchQuery.isEmpty)
ElevatedButton(
onPressed: () => _showAddCategoryDialog(),
style: ElevatedButton.styleFrom(
backgroundColor: const Color(0xFF10B981),
foregroundColor: Colors.white,
),
child: const Text('Add First Category'),
),
],
),
);
}

Widget \_buildCategoriesList() {
return ListView.builder(
padding: const EdgeInsets.all(16),
itemCount: \_filteredCategories.length,
itemBuilder: (context, index) {
final category = \_filteredCategories[index];
return \_buildCategoryCard(category);
},
);
}

Widget \_buildCategoryCard(ProductCategory category) {
return CustomCard(
margin: const EdgeInsets.only(bottom: 12),
onTap: () => \_showAddCategoryDialog(existingCategory: category),
child: Row(
children: [
// Category Icon/Color
Container(
width: 48,
height: 48,
decoration: BoxDecoration(
color: \_parseColor(category.color ?? '#4CAF50').withOpacity(0.2),
borderRadius: BorderRadius.circular(12),
),
child: Icon(
\_getIcon(category.icon ?? 'category'),
color: \_parseColor(category.color ?? '#4CAF50'),
size: 24,
),
),
const SizedBox(width: 16),
// Category Info
Expanded(
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
category.name,
style: const TextStyle(
fontWeight: FontWeight.bold,
fontSize: 16,
),
),
const SizedBox(height: 4),
Text(
category.nameAm,
style: TextStyle(
color: Colors.grey.shade600,
fontSize: 14,
),
),
if (category.description != null) ...[
const SizedBox(height: 4),
Text(
category.description!,
style: TextStyle(
color: Colors.grey.shade500,
fontSize: 12,
),
maxLines: 1,
overflow: TextOverflow.ellipsis,
),
],
],
),
),
// Status and Actions
Row(
mainAxisSize: MainAxisSize.min,
children: [
// Active/Inactive Badge
Container(
padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
decoration: BoxDecoration(
color: category.isActive
? Colors.green.shade50
: Colors.grey.shade100,
borderRadius: BorderRadius.circular(6),
border: Border.all(
color: category.isActive
? Colors.green.shade200
: Colors.grey.shade300,
),
),
child: Text(
category.isActive ? 'Active' : 'Inactive',
style: TextStyle(
color: category.isActive
? Colors.green.shade700
: Colors.grey.shade600,
fontSize: 12,
fontWeight: FontWeight.w500,
),
),
),
const SizedBox(width: 12),
// Toggle Button
IconButton(
icon: Icon(
category.isActive ? Icons.toggle_on : Icons.toggle_off,
color:
category.isActive ? const Color(0xFF10B981) : Colors.grey,
size: 30,
),
onPressed: () => _toggleCategoryStatus(category),
),
],
),
],
),
);
}

Color \_parseColor(String colorString) {
try {
return Color(int.parse(colorString.replaceAll('#', '0xFF')));
} catch (e) {
return const Color(0xFF4CAF50);
}
}

IconData \_getIcon(String iconName) {
switch (iconName) {
case 'local_grocery_store':
return Icons.local_grocery_store;
case 'restaurant':
return Icons.restaurant;
case 'local_cafe':
return Icons.local_cafe;
case 'medical_services':
return Icons.medical_services;
case 'local_pharmacy':
return Icons.local_pharmacy;
case 'spa':
return Icons.spa;
case 'home':
return Icons.home;
case 'cake':
return Icons.cake;
default:
return Icons.category;
}
}
}

##

// src/ui/screens/customer_detail_screen.dart
// Screen for viewing and managing detailed information about a specific customer, including credit sales and payments.
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/data/models/customer.dart';
import 'package:andalus_smart_pos/src/data/models/credit_transaction.dart';
import 'package:andalus_smart_pos/src/data/repositories/customer_repository.dart';

class CustomerDetailScreen extends ConsumerStatefulWidget {
final Customer customer;

const CustomerDetailScreen({super.key, required this.customer});

@override
ConsumerState<CustomerDetailScreen> createState() =>
\_CustomerDetailScreenState();
}

class \_CustomerDetailScreenState extends ConsumerState<CustomerDetailScreen> {
List<CreditTransaction> \_transactions = [];
bool \_isLoading = true;
Customer? \_currentCustomer;

@override
void initState() {
super.initState();
\_currentCustomer = widget.customer;
\_loadData();
}

Future<void> \_loadData() async {
await \_loadCustomer();
await \_loadTransactions();
}

Future<void> \_loadCustomer() async {
try {
final repository = ref.read(customerRepositoryProvider);
final customer = await repository.getCustomerById(widget.customer.id!);
if (customer != null && mounted) {
setState(() {
\_currentCustomer = customer;
});
}
} catch (e) {
print('Error loading customer: $e');
}
}

Future<void> \_loadTransactions() async {
try {
final repository = ref.read(customerRepositoryProvider);
final transactions =
await repository.getCustomerTransactions(widget.customer.id!);

      if (mounted) {
        setState(() {
          _transactions = transactions;
          _isLoading = false;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error loading transactions: $e'),
          backgroundColor: Colors.red,
        ),
      );
    }

}

void \_showAddCreditSaleDialog() {
showDialog(
context: context,
builder: (context) => AddCreditSaleDialog(
customer: \_currentCustomer!,
onSaleCompleted: \_loadData,
),
);
}

void \_showRecordPaymentDialog() {
showDialog(
context: context,
builder: (context) => RecordPaymentDialog(
customer: \_currentCustomer!,
onPaymentRecorded: \_loadData,
),
);
}

void \_showEditCreditLimitDialog() {
showDialog(
context: context,
builder: (context) => EditCreditLimitDialog(
customer: \_currentCustomer!,
onCreditLimitUpdated: \_loadData,
),
);
}

@override
Widget build(BuildContext context) {
if (\_currentCustomer == null) {
return const Scaffold(
body: Center(
child: CircularProgressIndicator(),
),
);
}

    final customer = _currentCustomer!;
    final screenSize = MediaQuery.of(context).size;
    final isSmallScreen = screenSize.width < 600;

    return Scaffold(
      appBar: AppBar(
        title: Text(customer.name),
        backgroundColor: const Color(0xFF10B981),
        foregroundColor: Colors.white,
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: _loadData,
            tooltip: 'Refresh',
          ),
        ],
      ),
      body: SingleChildScrollView(
        padding: EdgeInsets.all(isSmallScreen ? 16 : 24),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Customer Info Card
            _buildCustomerInfoCard(customer, isSmallScreen),
            const SizedBox(height: 24),

            // Credit Control Actions
            _buildCreditActionsCard(customer, isSmallScreen),
            const SizedBox(height: 24),

            // Transaction History
            _buildTransactionHistory(),
          ],
        ),
      ),
    );

}

// In customer_detail_screen.dart, update the customer info card
Widget \_buildCustomerInfoCard(Customer customer, bool isSmallScreen) {
return Card(
elevation: 2,
child: Padding(
padding: const EdgeInsets.all(20),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
// Header with business name if available
Row(
children: [
Container(
width: 50,
height: 50,
decoration: BoxDecoration(
color: const Color(0xFF10B981).withOpacity(0.1),
borderRadius: BorderRadius.circular(25),
),
child: const Icon(
Icons.person,
color: Color(0xFF10B981),
size: 24,
),
),
const SizedBox(width: 16),
Expanded(
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
customer.name,
style: const TextStyle(
fontSize: 20,
fontWeight: FontWeight.bold,
),
),
if (customer.businessName != null) ...[
const SizedBox(height: 4),
Text(
customer.businessName!,
style: const TextStyle(
color: Colors.grey,
fontStyle: FontStyle.italic,
),
),
],
if (customer.phone != null) ...[
const SizedBox(height: 4),
Text(
customer.phone!,
style: const TextStyle(
color: Colors.grey,
),
),
],
],
),
),
// Status Badge
Container(
padding:
const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
decoration: BoxDecoration(
color: customer.isOverdue
? Colors.red.withOpacity(0.1)
: customer.currentBalance > 0
? Colors.orange.withOpacity(0.1)
: Colors.green.withOpacity(0.1),
borderRadius: BorderRadius.circular(20),
border: Border.all(
color: customer.isOverdue
? Colors.red
: customer.currentBalance > 0
? Colors.orange
: Colors.green,
),
),
child: Text(
customer.isOverdue
? 'OVERDUE'
: customer.currentBalance > 0
? 'PENDING'
: 'PAID',
style: TextStyle(
fontSize: 12,
fontWeight: FontWeight.bold,
color: customer.isOverdue
? Colors.red
: customer.currentBalance > 0
? Colors.orange
: Colors.green,
),
),
),
],
),
const SizedBox(height: 20),

            // Additional customer info
            if (customer.tinNumber != null ||
                customer.whatsappNumber != null ||
                customer.email != null) ...[
              _buildAdditionalInfo(customer),
              const SizedBox(height: 16),
            ],

            // Rest of the existing credit information grid...
            // ... [keep the existing credit info grid code]
          ],
        ),
      ),
    );

}

Widget \_buildAdditionalInfo(Customer customer) {
return Container(
padding: const EdgeInsets.all(16),
decoration: BoxDecoration(
color: Colors.grey.shade50,
borderRadius: BorderRadius.circular(12),
border: Border.all(color: Colors.grey.shade200),
),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
const Text(
'Additional Information',
style: TextStyle(
fontWeight: FontWeight.w600,
fontSize: 14,
),
),
const SizedBox(height: 8),
if (customer.tinNumber != null)
_buildInfoRow('TIN/VAT:', customer.tinNumber!),
if (customer.whatsappNumber != null)
_buildInfoRow('WhatsApp:', customer.whatsappNumber!),
if (customer.email != null) _buildInfoRow('Email:', customer.email!),
if (customer.notes != null) _buildInfoRow('Notes:', customer.notes!),
],
),
);
}

Widget \_buildInfoRow(String label, String value) {
return Padding(
padding: const EdgeInsets.symmetric(vertical: 4),
child: Row(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
SizedBox(
width: 80,
child: Text(
label,
style: const TextStyle(
fontWeight: FontWeight.w500,
color: Colors.grey,
fontSize: 12,
),
),
),
Expanded(
child: Text(
value,
style: const TextStyle(
fontSize: 12,
),
),
),
],
),
);
}

Widget \_buildInfoItem(
String title, String value, IconData icon, Color color) {
return Container(
decoration: BoxDecoration(
color: Colors.white,
borderRadius: BorderRadius.circular(12),
border: Border.all(color: Colors.grey.shade200),
),
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
mainAxisAlignment: MainAxisAlignment.spaceBetween,
children: [
Row(
children: [
Container(
padding: const EdgeInsets.all(4),
decoration: BoxDecoration(
color: color.withOpacity(0.1),
borderRadius: BorderRadius.circular(6),
),
child: Icon(icon, color: color, size: 16),
),
const SizedBox(width: 8),
Expanded(
child: Text(
title,
style: const TextStyle(
fontSize: 12,
color: Colors.grey,
fontWeight: FontWeight.w500,
),
),
),
],
),
const SizedBox(height: 8),
Text(
value,
style: TextStyle(
fontSize: 16,
fontWeight: FontWeight.bold,
color: color,
),
),
],
),
),
);
}

Widget \_buildCreditActionsCard(Customer customer, bool isSmallScreen) {
return Card(
elevation: 2,
child: Padding(
padding: const EdgeInsets.all(20),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
const Text(
'Credit Actions',
style: TextStyle(
fontSize: 18,
fontWeight: FontWeight.bold,
),
),
const SizedBox(height: 16),
Wrap(
spacing: 12,
runSpacing: 12,
children: [
ElevatedButton.icon(
onPressed: customer.canMakeCreditSale
? _showAddCreditSaleDialog
: null,
style: ElevatedButton.styleFrom(
backgroundColor: const Color(0xFF10B981),
foregroundColor: Colors.white,
padding: const EdgeInsets.symmetric(
horizontal: 20, vertical: 12),
),
icon: const Icon(Icons.add_shopping_cart, size: 18),
label: const Text('Add Credit Sale'),
),
ElevatedButton.icon(
onPressed: customer.currentBalance > 0
? _showRecordPaymentDialog
: null,
style: ElevatedButton.styleFrom(
backgroundColor: const Color(0xFF059669),
foregroundColor: Colors.white,
padding: const EdgeInsets.symmetric(
horizontal: 20, vertical: 12),
),
icon: const Icon(Icons.payment, size: 18),
label: const Text('Record Payment'),
),
OutlinedButton.icon(
onPressed: _showEditCreditLimitDialog,
style: OutlinedButton.styleFrom(
foregroundColor: const Color(0xFF10B981),
side: const BorderSide(color: Color(0xFF10B981)),
padding: const EdgeInsets.symmetric(
horizontal: 20, vertical: 12),
),
icon: const Icon(Icons.credit_card, size: 18),
label: const Text('Edit Credit Limit'),
),
],
),
],
),
),
);
}

Widget \_buildTransactionHistory() {
return Card(
elevation: 2,
child: Padding(
padding: const EdgeInsets.all(20),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
const Text(
'Transaction History',
style: TextStyle(
fontSize: 18,
fontWeight: FontWeight.bold,
),
),
const SizedBox(height: 16),
\_isLoading
? const Center(
child: Padding(
padding: EdgeInsets.all(32),
child:
CircularProgressIndicator(color: Color(0xFF10B981)),
),
)
: \_transactions.isEmpty
? const Padding(
padding: EdgeInsets.all(32),
child: Column(
children: [
Icon(Icons.receipt_long,
size: 64, color: Colors.grey),
SizedBox(height: 16),
Text(
'No transactions yet',
style: TextStyle(
color: Colors.grey,
fontSize: 16,
),
),
],
),
)
: ListView.separated(
shrinkWrap: true,
physics: const NeverScrollableScrollPhysics(),
itemCount: \_transactions.length,
separatorBuilder: (context, index) =>
const Divider(height: 1),
itemBuilder: (context, index) {
final transaction = \_transactions[index];
return \_buildTransactionItem(transaction);
},
),
],
),
),
);
}

Widget \_buildTransactionItem(CreditTransaction transaction) {
return ListTile(
leading: Container(
width: 40,
height: 40,
decoration: BoxDecoration(
color: transaction.amountColor.withOpacity(0.1),
borderRadius: BorderRadius.circular(20),
),
child: Icon(transaction.icon, color: transaction.amountColor, size: 20),
),
title: Text(transaction.description),
subtitle: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
if (transaction.reference != null)
Text('Reference: ${transaction.reference}'),
if (transaction.notes != null) Text(transaction.notes!),
Text(
'${_formatDateTime(transaction.createdAt)} ‚Ä¢ Balance: ETB ${transaction.balanceAfter.toStringAsFixed(2)}',
style: const TextStyle(fontSize: 12, color: Colors.grey),
),
],
),
trailing: Text(
transaction.formattedAmount,
style: TextStyle(
fontWeight: FontWeight.bold,
color: transaction.amountColor,
fontSize: 16,
),
),
);
}

String \_formatDate(DateTime date) {
return '${date.day}/${date.month}/${date.year}';
}

String \_formatDateTime(DateTime date) {
return '${_formatDate(date)} ${date.hour.toString().padLeft(2, '0')}:${date.minute.toString().padLeft(2, '0')}';
}

int \_daysOverdue(DateTime dueDate) {
return DateTime.now().difference(dueDate).inDays;
}
}

// Add these dialog classes to your customer_detail_screen.dart file

// Add Credit Sale Dialog
class AddCreditSaleDialog extends ConsumerStatefulWidget {
final Customer customer;
final VoidCallback onSaleCompleted;

const AddCreditSaleDialog({
super.key,
required this.customer,
required this.onSaleCompleted,
});

@override
ConsumerState<AddCreditSaleDialog> createState() =>
\_AddCreditSaleDialogState();
}

class \_AddCreditSaleDialogState extends ConsumerState<AddCreditSaleDialog> {
final \_formKey = GlobalKey<FormState>();
final \_amountController = TextEditingController();
final \_referenceController = TextEditingController();
final \_notesController = TextEditingController();
final \_dueDaysController = TextEditingController(text: '30');

bool \_isSubmitting = false;

@override
void dispose() {
\_amountController.dispose();
\_referenceController.dispose();
\_notesController.dispose();
\_dueDaysController.dispose();
super.dispose();
}

Future<void> \_addCreditSale() async {
if (!\_formKey.currentState!.validate()) return;

    final amount = double.tryParse(_amountController.text) ?? 0;
    final dueDays = int.tryParse(_dueDaysController.text) ?? 30;

    if (amount <= 0) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Sale amount must be greater than zero'),
          backgroundColor: Colors.orange,
        ),
      );
      return;
    }

    setState(() {
      _isSubmitting = true;
    });

    try {
      final repository = ref.read(customerRepositoryProvider);
      final result = await repository.createCreditSale(
        customerId: widget.customer.id!,
        amount: amount,
        saleReference: _referenceController.text.isNotEmpty
            ? _referenceController.text
            : 'SALE-${DateTime.now().millisecondsSinceEpoch}',
        dueDays: dueDays,
        notes: _notesController.text.isNotEmpty ? _notesController.text : null,
      );

      if (result.success) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
                'Credit sale of ETB ${amount.toStringAsFixed(2)} added successfully!'),
            backgroundColor: const Color(0xFF10B981),
          ),
        );
        Navigator.pop(context);
        widget.onSaleCompleted();
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(result.error!),
            backgroundColor: Colors.red,
          ),
        );
      }
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error adding credit sale: $e'),
          backgroundColor: Colors.red,
        ),
      );
    } finally {
      if (mounted) {
        setState(() {
          _isSubmitting = false;
        });
      }
    }

}

@override
Widget build(BuildContext context) {
return Dialog(
insetPadding: const EdgeInsets.all(20),
shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
child: SingleChildScrollView(
padding: const EdgeInsets.all(24),
child: Form(
key: \_formKey,
child: Column(
mainAxisSize: MainAxisSize.min,
crossAxisAlignment: CrossAxisAlignment.start,
children: [
// Header
Row(
children: [
Container(
padding: const EdgeInsets.all(8),
decoration: BoxDecoration(
color: const Color(0xFF10B981).withOpacity(0.1),
borderRadius: BorderRadius.circular(8),
),
child: const Icon(Icons.add_shopping_cart,
color: Color(0xFF10B981), size: 24),
),
const SizedBox(width: 12),
const Expanded(
child: Text(
'Add Credit Sale',
style: TextStyle(
fontSize: 18,
fontWeight: FontWeight.bold,
),
),
),
IconButton(
icon: const Icon(Icons.close),
onPressed: () => Navigator.pop(context),
),
],
),
const SizedBox(height: 8),
Text(
'Customer: ${widget.customer.name}',
style: const TextStyle(color: Colors.grey),
),
const SizedBox(height: 4),
Text(
'Available Credit: ETB ${widget.customer.availableCredit.toStringAsFixed(2)}',
style: TextStyle(
color: widget.customer.availableCredit > 0
? Colors.green
: Colors.red,
fontWeight: FontWeight.w500,
),
),
const SizedBox(height: 24),

              // Form Fields
              TextFormField(
                controller: _amountController,
                decoration: const InputDecoration(
                  labelText: 'Sale Amount (ETB) *',
                  border: OutlineInputBorder(),
                  prefixText: 'ETB ',
                ),
                keyboardType: TextInputType.number,
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Please enter sale amount';
                  }
                  final amount = double.tryParse(value);
                  if (amount == null || amount <= 0) {
                    return 'Please enter a valid amount';
                  }
                  if (amount > widget.customer.availableCredit) {
                    return 'Amount exceeds available credit';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _referenceController,
                decoration: const InputDecoration(
                  labelText: 'Sale Reference',
                  border: OutlineInputBorder(),
                  hintText: 'Optional reference number',
                ),
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _dueDaysController,
                decoration: const InputDecoration(
                  labelText: 'Due Days',
                  border: OutlineInputBorder(),
                  hintText: '30',
                  suffixText: 'days',
                ),
                keyboardType: TextInputType.number,
                validator: (value) {
                  if (value != null && value.isNotEmpty) {
                    final days = int.tryParse(value);
                    if (days == null || days <= 0) {
                      return 'Please enter valid number of days';
                    }
                  }
                  return null;
                },
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _notesController,
                decoration: const InputDecoration(
                  labelText: 'Notes',
                  border: OutlineInputBorder(),
                  hintText: 'Optional notes about this sale',
                ),
                maxLines: 2,
              ),
              const SizedBox(height: 32),

              // Actions
              Row(
                children: [
                  Expanded(
                    child: OutlinedButton(
                      onPressed:
                          _isSubmitting ? null : () => Navigator.pop(context),
                      child: const Text('Cancel'),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: ElevatedButton(
                      onPressed: _isSubmitting ? null : _addCreditSale,
                      style: ElevatedButton.styleFrom(
                        backgroundColor: const Color(0xFF10B981),
                        foregroundColor: Colors.white,
                      ),
                      child: _isSubmitting
                          ? const SizedBox(
                              width: 20,
                              height: 20,
                              child: CircularProgressIndicator(
                                strokeWidth: 2,
                                color: Colors.white,
                              ),
                            )
                          : const Text('Add Sale'),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );

}
}

// Record Payment Dialog
class RecordPaymentDialog extends ConsumerStatefulWidget {
final Customer customer;
final VoidCallback onPaymentRecorded;

const RecordPaymentDialog({
super.key,
required this.customer,
required this.onPaymentRecorded,
});

@override
ConsumerState<RecordPaymentDialog> createState() =>
\_RecordPaymentDialogState();
}

class \_RecordPaymentDialogState extends ConsumerState<RecordPaymentDialog> {
final \_formKey = GlobalKey<FormState>();
final \_amountController = TextEditingController();
final \_referenceController = TextEditingController();
final \_notesController = TextEditingController();

bool \_isSubmitting = false;

@override
void initState() {
super.initState();
\_amountController.text = widget.customer.currentBalance.toStringAsFixed(2);
}

@override
void dispose() {
\_amountController.dispose();
\_referenceController.dispose();
\_notesController.dispose();
super.dispose();
}

Future<void> \_recordPayment() async {
if (!\_formKey.currentState!.validate()) return;

    final amount = double.tryParse(_amountController.text) ?? 0;

    if (amount <= 0) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Please enter a valid payment amount'),
          backgroundColor: Colors.orange,
        ),
      );
      return;
    }

    if (amount > widget.customer.currentBalance) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Payment amount cannot exceed outstanding balance'),
          backgroundColor: Colors.orange,
        ),
      );
      return;
    }

    setState(() {
      _isSubmitting = true;
    });

    try {
      final repository = ref.read(customerRepositoryProvider);
      final result = await repository.recordPayment(
        customerId: widget.customer.id!,
        amount: amount,
        paymentReference: _referenceController.text.isNotEmpty
            ? _referenceController.text
            : 'PAY-${DateTime.now().millisecondsSinceEpoch}',
        notes: _notesController.text.isNotEmpty ? _notesController.text : null,
      );

      if (result.success) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
                'Payment of ETB ${amount.toStringAsFixed(2)} recorded successfully!'),
            backgroundColor: const Color(0xFF10B981),
          ),
        );
        Navigator.pop(context);
        widget.onPaymentRecorded();
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(result.error!),
            backgroundColor: Colors.red,
          ),
        );
      }
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error recording payment: $e'),
          backgroundColor: Colors.red,
        ),
      );
    } finally {
      if (mounted) {
        setState(() {
          _isSubmitting = false;
        });
      }
    }

}

@override
Widget build(BuildContext context) {
return Dialog(
insetPadding: const EdgeInsets.all(20),
shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
child: SingleChildScrollView(
padding: const EdgeInsets.all(24),
child: Form(
key: \_formKey,
child: Column(
mainAxisSize: MainAxisSize.min,
crossAxisAlignment: CrossAxisAlignment.start,
children: [
// Header
Row(
children: [
Container(
padding: const EdgeInsets.all(8),
decoration: BoxDecoration(
color: const Color(0xFF10B981).withOpacity(0.1),
borderRadius: BorderRadius.circular(8),
),
child: const Icon(Icons.payment,
color: Color(0xFF10B981), size: 24),
),
const SizedBox(width: 12),
const Expanded(
child: Text(
'Record Payment',
style: TextStyle(
fontSize: 18,
fontWeight: FontWeight.bold,
),
),
),
IconButton(
icon: const Icon(Icons.close),
onPressed: () => Navigator.pop(context),
),
],
),
const SizedBox(height: 8),
Text(
'Customer: ${widget.customer.name}',
style: const TextStyle(color: Colors.grey),
),
const SizedBox(height: 4),
Text(
'Current Balance: ETB ${widget.customer.currentBalance.toStringAsFixed(2)}',
style: TextStyle(
color: widget.customer.currentBalance > 0
? Colors.orange
: Colors.green,
fontWeight: FontWeight.w500,
),
),
const SizedBox(height: 24),

              // Form Fields
              TextFormField(
                controller: _amountController,
                decoration: const InputDecoration(
                  labelText: 'Payment Amount (ETB) *',
                  border: OutlineInputBorder(),
                  prefixText: 'ETB ',
                ),
                keyboardType: TextInputType.number,
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Please enter payment amount';
                  }
                  final amount = double.tryParse(value);
                  if (amount == null || amount <= 0) {
                    return 'Please enter a valid amount';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _referenceController,
                decoration: const InputDecoration(
                  labelText: 'Payment Reference',
                  border: OutlineInputBorder(),
                  hintText: 'Optional reference number',
                ),
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _notesController,
                decoration: const InputDecoration(
                  labelText: 'Notes',
                  border: OutlineInputBorder(),
                  hintText: 'Optional notes about this payment',
                ),
                maxLines: 2,
              ),
              const SizedBox(height: 32),

              // Actions
              Row(
                children: [
                  Expanded(
                    child: OutlinedButton(
                      onPressed:
                          _isSubmitting ? null : () => Navigator.pop(context),
                      child: const Text('Cancel'),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: ElevatedButton(
                      onPressed: _isSubmitting ? null : _recordPayment,
                      style: ElevatedButton.styleFrom(
                        backgroundColor: const Color(0xFF10B981),
                        foregroundColor: Colors.white,
                      ),
                      child: _isSubmitting
                          ? const SizedBox(
                              width: 20,
                              height: 20,
                              child: CircularProgressIndicator(
                                strokeWidth: 2,
                                color: Colors.white,
                              ),
                            )
                          : const Text('Record Payment'),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );

}
}

// Edit Credit Limit Dialog
class EditCreditLimitDialog extends ConsumerStatefulWidget {
final Customer customer;
final VoidCallback onCreditLimitUpdated;

const EditCreditLimitDialog({
super.key,
required this.customer,
required this.onCreditLimitUpdated,
});

@override
ConsumerState<EditCreditLimitDialog> createState() =>
\_EditCreditLimitDialogState();
}

class \_EditCreditLimitDialogState extends ConsumerState<EditCreditLimitDialog> {
final \_formKey = GlobalKey<FormState>();
final \_creditLimitController = TextEditingController();

bool \_isSubmitting = false;

@override
void initState() {
super.initState();
\_creditLimitController.text =
widget.customer.creditLimit.toStringAsFixed(2);
}

@override
void dispose() {
\_creditLimitController.dispose();
super.dispose();
}

Future<void> \_updateCreditLimit() async {
if (!\_formKey.currentState!.validate()) return;

    final newLimit = double.tryParse(_creditLimitController.text) ?? 0;

    if (newLimit < 0) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Credit limit cannot be negative'),
          backgroundColor: Colors.orange,
        ),
      );
      return;
    }

    setState(() {
      _isSubmitting = true;
    });

    try {
      final repository = ref.read(customerRepositoryProvider);
      final result = await repository.updateCreditLimit(
        customerId: widget.customer.id!,
        newCreditLimit: newLimit,
      );

      if (result.success) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
                'Credit limit updated to ETB ${newLimit.toStringAsFixed(2)}'),
            backgroundColor: const Color(0xFF10B981),
          ),
        );
        Navigator.pop(context);
        widget.onCreditLimitUpdated();
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(result.error!),
            backgroundColor: Colors.red,
          ),
        );
      }
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error updating credit limit: $e'),
          backgroundColor: Colors.red,
        ),
      );
    } finally {
      if (mounted) {
        setState(() {
          _isSubmitting = false;
        });
      }
    }

}

@override
Widget build(BuildContext context) {
return Dialog(
insetPadding: const EdgeInsets.all(20),
shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
child: SingleChildScrollView(
padding: const EdgeInsets.all(24),
child: Form(
key: \_formKey,
child: Column(
mainAxisSize: MainAxisSize.min,
crossAxisAlignment: CrossAxisAlignment.start,
children: [
// Header
Row(
children: [
Container(
padding: const EdgeInsets.all(8),
decoration: BoxDecoration(
color: const Color(0xFF10B981).withOpacity(0.1),
borderRadius: BorderRadius.circular(8),
),
child: const Icon(Icons.credit_card,
color: Color(0xFF10B981), size: 24),
),
const SizedBox(width: 12),
const Expanded(
child: Text(
'Edit Credit Limit',
style: TextStyle(
fontSize: 18,
fontWeight: FontWeight.bold,
),
),
),
IconButton(
icon: const Icon(Icons.close),
onPressed: () => Navigator.pop(context),
),
],
),
const SizedBox(height: 8),
Text(
'Customer: ${widget.customer.name}',
style: const TextStyle(color: Colors.grey),
),
const SizedBox(height: 4),
Text(
'Current Balance: ETB ${widget.customer.currentBalance.toStringAsFixed(2)}',
style: const TextStyle(
color: Colors.orange,
fontWeight: FontWeight.w500,
),
),
const SizedBox(height: 24),

              // Form Field
              TextFormField(
                controller: _creditLimitController,
                decoration: const InputDecoration(
                  labelText: 'New Credit Limit (ETB) *',
                  border: OutlineInputBorder(),
                  prefixText: 'ETB ',
                ),
                keyboardType: TextInputType.number,
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Please enter credit limit';
                  }
                  final limit = double.tryParse(value);
                  if (limit == null) {
                    return 'Please enter a valid amount';
                  }
                  if (limit < widget.customer.currentBalance) {
                    return 'Credit limit cannot be less than current balance';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 32),

              // Actions
              Row(
                children: [
                  Expanded(
                    child: OutlinedButton(
                      onPressed:
                          _isSubmitting ? null : () => Navigator.pop(context),
                      child: const Text('Cancel'),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: ElevatedButton(
                      onPressed: _isSubmitting ? null : _updateCreditLimit,
                      style: ElevatedButton.styleFrom(
                        backgroundColor: const Color(0xFF10B981),
                        foregroundColor: Colors.white,
                      ),
                      child: _isSubmitting
                          ? const SizedBox(
                              width: 20,
                              height: 20,
                              child: CircularProgressIndicator(
                                strokeWidth: 2,
                                color: Colors.white,
                              ),
                            )
                          : const Text('Update Limit'),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );

}
}

##

// src/ui/screens/customer_detail_screen.dart
//
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/data/models/customer.dart';
import 'package:andalus_smart_pos/src/data/models/credit_transaction.dart';
import 'package:andalus_smart_pos/src/data/repositories/customer_repository.dart';
import 'package:andalus_smart_pos/src/data/local/database.dart';
// import 'package:andalus_smart_pos/src/ui/screens/customer_detail_screen.dart';

class CustomerManagementScreen extends ConsumerStatefulWidget {
const CustomerManagementScreen({super.key});

@override
ConsumerState<CustomerManagementScreen> createState() =>
\_CustomerManagementScreenState();
}

class \_CustomerManagementScreenState
extends ConsumerState<CustomerManagementScreen> {
final TextEditingController \_searchController = TextEditingController();
final ScrollController \_scrollController = ScrollController();

List<Customer> \_filteredCustomers = [];
List<Customer> \_allCustomers = [];
bool \_isLoading = true;
String \_filter = 'all';
String \_searchQuery = '';

@override
void initState() {
super.initState();
\_initializeData();
\_searchController.addListener(\_onSearchChanged);
}

@override
void dispose() {
\_searchController.dispose();
\_scrollController.dispose();
super.dispose();
}

Future<void> \_initializeData() async {
// Attempt to access the customers via the repository to ensure DB is initialized,
// and reset the database if accessing customers fails.
try {
final repository = ref.read(customerRepositoryProvider);
final customers = await repository.getAllCustomers();
print('Loaded ${customers.length} customers from database');
} catch (e) {
print('Database access error: $e');
try {
print('Resetting database...');
await AppDatabase.resetDatabase();
} catch (resetError) {
print('Failed to reset database: $resetError');
}
}

    await _loadCustomers();

}

Future<void> \_loadCustomers() async {
if (mounted) {
setState(() {
\_isLoading = true;
});
}

    try {
      final repository = ref.read(customerRepositoryProvider);
      List<Customer> customers;

      switch (_filter) {
        case 'with_balance':
          customers = await repository.getCustomersWithBalance();
          break;
        case 'overdue':
          customers = await repository.getOverdueCustomers();
          break;
        case 'all':
        default:
          customers = await repository.getAllCustomers();
      }

      if (mounted) {
        setState(() {
          _allCustomers = customers;
          _filteredCustomers = _applySearchFilter(customers, _searchQuery);
          _isLoading = false;
        });
      }
    } catch (e, stackTrace) {
      print('Error loading customers: $e');
      print('Stack trace: $stackTrace');

      if (mounted) {
        setState(() {
          _isLoading = false;
        });

        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error loading customers: $e'),
            backgroundColor: Colors.red,
            duration: const Duration(seconds: 5),
            action: SnackBarAction(
              label: 'Retry',
              onPressed: _loadCustomers,
            ),
          ),
        );
      }
    }

}

List<Customer> \_applySearchFilter(List<Customer> customers, String query) {
if (query.isEmpty) return customers;

    return customers.where((customer) {
      return customer.name.toLowerCase().contains(query.toLowerCase()) ||
          (customer.phone?.toLowerCase().contains(query.toLowerCase()) ??
              false) ||
          (customer.email?.toLowerCase().contains(query.toLowerCase()) ??
              false);
    }).toList();

}

void \_onSearchChanged() {
final query = \_searchController.text;
setState(() {
\_searchQuery = query;
\_filteredCustomers = \_applySearchFilter(\_allCustomers, query);
});
}

void \_changeFilter(String newFilter) {
setState(() {
\_filter = newFilter;
});
\_loadCustomers();
}

void _showAddCustomerDialog() {
showDialog(
context: context,
builder: (context) => AddCustomerDialog(
onCustomerAdded: \_loadCustomers,
),
).then((_) {
// This ensures the screen resizes properly after dialog closes
if (mounted) {
setState(() {});
}
});
}

void \_showCustomerDetails(Customer customer) {
Navigator.push(
context,
MaterialPageRoute(
builder: (context) => CustomerDetailScreen(customer: customer),
),
);
}

void \_showRecordPaymentDialog(Customer customer) {
showDialog(
context: context,
builder: (context) => RecordPaymentDialog(
customer: customer,
onPaymentRecorded: \_loadCustomers,
),
);
}

// Statistics
int get \_totalCustomers => \_allCustomers.length;
int get \_customersWithBalance =>
\_allCustomers.where((c) => c.currentBalance != 0).length;
int get \_overdueCustomers => \_allCustomers.where((c) => c.isOverdue).length;
double get \_totalOutstanding =>
\_allCustomers.fold(0, (sum, c) => sum + c.currentBalance);

@override
Widget build(BuildContext context) {
final screenSize = MediaQuery.of(context).size;
final isSmallScreen = screenSize.width < 600;
final isVerySmallScreen = screenSize.width < 400;

    return Scaffold(
      backgroundColor: const Color(0xFFF8FAFC),
      appBar: AppBar(
        title: const Text(
          'Customer Management',
          style: TextStyle(
            fontWeight: FontWeight.w600,
            fontSize: 18,
          ),
        ),
        backgroundColor: Colors.white,
        foregroundColor: const Color(0xFF1E293B),
        elevation: 1,
        shadowColor: Colors.black12,
        actions: [
          IconButton(
            icon: const Icon(Icons.add, size: 22),
            onPressed: _showAddCustomerDialog,
            tooltip: 'Add Customer',
          ),
          IconButton(
            icon: const Icon(Icons.refresh, size: 22),
            onPressed: _loadCustomers,
            tooltip: 'Refresh',
          ),
          const SizedBox(width: 8),
        ],
      ),
      body: Column(
        children: [
          // Header Section with Search
          _buildHeaderSection(isSmallScreen, isVerySmallScreen),

          // Statistics Cards
          if (_allCustomers.isNotEmpty)
            _buildStatisticsSection(isSmallScreen, isVerySmallScreen),

          // Content
          Expanded(
            child: _isLoading
                ? _buildLoadingState()
                : _filteredCustomers.isEmpty
                    ? _buildEmptyState(isSmallScreen)
                    : _buildCustomersList(isSmallScreen),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _showAddCustomerDialog,
        backgroundColor: const Color(0xFF10B981),
        foregroundColor: Colors.white,
        elevation: 4,
        child: const Icon(Icons.person_add_alt_1, size: 24),
      ),
    );

}

Widget \_buildHeaderSection(bool isSmallScreen, bool isVerySmallScreen) {
return Container(
padding: EdgeInsets.fromLTRB(
isVerySmallScreen ? 16 : 20,
16,
isVerySmallScreen ? 16 : 20,
12,
),
decoration: BoxDecoration(
color: Colors.white,
boxShadow: [
BoxShadow(
color: Colors.black.withOpacity(0.05),
blurRadius: 8,
offset: const Offset(0, 2),
),
],
),
child: Column(
children: [
// Search Bar
Container(
decoration: BoxDecoration(
borderRadius: BorderRadius.circular(12),
boxShadow: [
BoxShadow(
color: const Color(0xFF10B981).withOpacity(0.1),
blurRadius: 8,
offset: const Offset(0, 2),
),
],
),
child: TextField(
controller: \_searchController,
decoration: InputDecoration(
hintText: 'Search customers by name, phone, or email...',
prefixIcon: const Icon(Icons.search, color: Color(0xFF64748B)),
filled: true,
fillColor: Colors.white,
border: OutlineInputBorder(
borderRadius: BorderRadius.circular(12),
borderSide: BorderSide.none,
),
enabledBorder: OutlineInputBorder(
borderRadius: BorderRadius.circular(12),
borderSide: BorderSide.none,
),
focusedBorder: OutlineInputBorder(
borderRadius: BorderRadius.circular(12),
borderSide: const BorderSide(
color: Color(0xFF10B981),
width: 2,
),
),
contentPadding: const EdgeInsets.symmetric(
horizontal: 16,
vertical: 16,
),
),
),
),
const SizedBox(height: 16),

          // Filter Chips
          SizedBox(
            height: isVerySmallScreen ? 36 : 40,
            child: ListView(
              scrollDirection: Axis.horizontal,
              children: [
                _buildFilterChip('All Customers', 'all', isVerySmallScreen),
                SizedBox(width: isVerySmallScreen ? 8 : 12),
                _buildFilterChip(
                    'With Balance', 'with_balance', isVerySmallScreen),
                SizedBox(width: isVerySmallScreen ? 8 : 12),
                _buildFilterChip('Overdue', 'overdue', isVerySmallScreen),
              ],
            ),
          ),
        ],
      ),
    );

}

Widget \_buildFilterChip(String label, String value, bool isVerySmallScreen) {
final isSelected = \_filter == value;

    return FilterChip(
      label: Text(
        label,
        style: TextStyle(
          fontSize: isVerySmallScreen ? 12 : 13,
          fontWeight: FontWeight.w500,
          color: isSelected ? Colors.white : const Color(0xFF475569),
        ),
      ),
      selected: isSelected,
      onSelected: (selected) => _changeFilter(value),
      backgroundColor: Colors.white,
      selectedColor: const Color(0xFF10B981),
      side: BorderSide(
        color: isSelected ? const Color(0xFF10B981) : const Color(0xFFE2E8F0),
        width: 1,
      ),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(20),
      ),
      checkmarkColor: Colors.white,
      padding: EdgeInsets.symmetric(
        horizontal: isVerySmallScreen ? 12 : 16,
        vertical: isVerySmallScreen ? 4 : 6,
      ),
    );

}

Widget \_buildStatisticsSection(bool isSmallScreen, bool isVerySmallScreen) {
final stats = [
_StatItem('Total Customers', _totalCustomers.toString(), Icons.people_alt,
const Color(0xFF10B981)),
_StatItem('With Balance', _customersWithBalance.toString(),
Icons.account_balance_wallet, const Color(0xFFF59E0B)),
_StatItem('Overdue', _overdueCustomers.toString(), Icons.warning_amber,
const Color(0xFFEF4444)),
_StatItem('Outstanding', 'ETB ${_totalOutstanding.toStringAsFixed(0)}',
Icons.attach_money, const Color(0xFF8B5CF6)),
];

    return Container(
      padding: EdgeInsets.symmetric(
        horizontal: isVerySmallScreen ? 16 : 20,
        vertical: 16,
      ),
      child: GridView.builder(
        shrinkWrap: true,
        physics: const NeverScrollableScrollPhysics(),
        gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: isVerySmallScreen ? 2 : (isSmallScreen ? 2 : 4),
          crossAxisSpacing: isVerySmallScreen ? 12 : 16,
          mainAxisSpacing: isVerySmallScreen ? 12 : 16,
          childAspectRatio: isVerySmallScreen ? 1.2 : 1.4,
        ),
        itemCount: stats.length,
        itemBuilder: (context, index) {
          return _buildStatCard(stats[index], isVerySmallScreen);
        },
      ),
    );

}

Widget \_buildStatCard(\_StatItem stat, bool isVerySmallScreen) {
return Container(
decoration: BoxDecoration(
color: Colors.white,
borderRadius: BorderRadius.circular(12),
boxShadow: [
BoxShadow(
color: Colors.black.withOpacity(0.05),
blurRadius: 8,
offset: const Offset(0, 2),
),
],
),
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
mainAxisAlignment: MainAxisAlignment.spaceBetween,
children: [
Container(
padding: const EdgeInsets.all(8),
decoration: BoxDecoration(
color: stat.color.withOpacity(0.1),
borderRadius: BorderRadius.circular(8),
),
child: Icon(stat.icon, color: stat.color, size: 20),
),
Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
stat.value,
style: TextStyle(
fontSize: isVerySmallScreen ? 16 : 18,
fontWeight: FontWeight.bold,
color: const Color(0xFF1E293B),
),
),
const SizedBox(height: 4),
Text(
stat.label,
style: TextStyle(
fontSize: isVerySmallScreen ? 11 : 12,
color: const Color(0xFF64748B),
fontWeight: FontWeight.w500,
),
),
],
),
],
),
),
);
}

Widget \_buildLoadingState() {
return const Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
SizedBox(
width: 40,
height: 40,
child: CircularProgressIndicator(
strokeWidth: 3,
color: Color(0xFF10B981),
),
),
SizedBox(height: 16),
Text(
'Loading customers...',
style: TextStyle(
color: Color(0xFF64748B),
fontSize: 14,
),
),
],
),
);
}

Widget \_buildEmptyState(bool isSmallScreen) {
return Center(
child: Padding(
padding: EdgeInsets.all(isSmallScreen ? 32 : 48),
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
Container(
width: isSmallScreen ? 120 : 150,
height: isSmallScreen ? 120 : 150,
decoration: BoxDecoration(
color: const Color(0xFFF1F5F9),
borderRadius: BorderRadius.circular(75),
),
child: Icon(
Icons.people_outline,
size: isSmallScreen ? 50 : 60,
color: const Color(0xFF94A3B8),
),
),
const SizedBox(height: 24),
Text(
_getEmptyStateTitle(),
style: const TextStyle(
fontSize: 20,
fontWeight: FontWeight.bold,
color: Color(0xFF1E293B),
),
textAlign: TextAlign.center,
),
const SizedBox(height: 8),
Text(
_getEmptyStateMessage(),
style: const TextStyle(
fontSize: 14,
color: Color(0xFF64748B),
height: 1.5,
),
textAlign: TextAlign.center,
),
const SizedBox(height: 32),
ElevatedButton(
onPressed: _showAddCustomerDialog,
style: ElevatedButton.styleFrom(
backgroundColor: const Color(0xFF10B981),
foregroundColor: Colors.white,
padding:
const EdgeInsets.symmetric(horizontal: 32, vertical: 16),
shape: RoundedRectangleBorder(
borderRadius: BorderRadius.circular(12),
),
elevation: 2,
),
child: const Text(
'Add First Customer',
style: TextStyle(
fontWeight: FontWeight.w600,
fontSize: 14,
),
),
),
],
),
),
);
}

String \_getEmptyStateTitle() {
switch (\_filter) {
case 'with_balance':
return 'No Customers with Balance';
case 'overdue':
return 'No Overdue Customers';
default:
return 'No Customers Yet';
}
}

String \_getEmptyStateMessage() {
switch (\_filter) {
case 'with_balance':
return 'All customers are paid up! Great job managing credit.';
case 'overdue':
return 'No customers have exceeded their credit limits. Excellent credit control!';
default:
return 'Start building your customer database to track sales, credit, and customer relationships.';
}
}

Widget \_buildCustomersList(bool isSmallScreen) {
return RefreshIndicator(
onRefresh: \_loadCustomers,
color: const Color(0xFF10B981),
backgroundColor: Colors.white,
child: ListView.builder(
controller: \_scrollController,
padding: EdgeInsets.fromLTRB(
isSmallScreen ? 16 : 20,
8,
isSmallScreen ? 16 : 20,
20,
),
itemCount: \_filteredCustomers.length,
itemBuilder: (context, index) {
final customer = \_filteredCustomers[index];
return \_buildCustomerCard(customer, isSmallScreen);
},
),
);
}

Widget \_buildCustomerCard(Customer customer, bool isSmallScreen) {
return Card(
elevation: 1,
margin: const EdgeInsets.only(bottom: 12),
shape: RoundedRectangleBorder(
borderRadius: BorderRadius.circular(12),
),
child: InkWell(
onTap: () => \_showCustomerDetails(customer),
borderRadius: BorderRadius.circular(12),
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
// Header Row
Row(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
// Customer Avatar
Container(
width: 44,
height: 44,
decoration: BoxDecoration(
color: const Color(0xFF10B981).withOpacity(0.1),
borderRadius: BorderRadius.circular(10),
),
child: Icon(
Icons.person,
color: const Color(0xFF10B981),
size: 20,
),
),
const SizedBox(width: 12),

                  // Customer Info
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Row(
                          children: [
                            Expanded(
                              child: Text(
                                customer.name,
                                style: const TextStyle(
                                  fontSize: 16,
                                  fontWeight: FontWeight.w600,
                                  color: Color(0xFF1E293B),
                                ),
                                maxLines: 1,
                                overflow: TextOverflow.ellipsis,
                              ),
                            ),
                            // Status Badges
                            if (customer.isOverdue)
                              _buildStatusBadge('OVERDUE', Colors.red),
                            if (customer.currentBalance > 0 &&
                                !customer.isOverdue)
                              _buildStatusBadge('BALANCE', Colors.blue),
                          ],
                        ),
                        const SizedBox(height: 4),

                        // Contact Info
                        if (customer.phone != null) ...[
                          Row(
                            children: [
                              Icon(Icons.phone,
                                  size: 14, color: const Color(0xFF64748B)),
                              const SizedBox(width: 4),
                              Text(
                                customer.phone!,
                                style: const TextStyle(
                                  fontSize: 13,
                                  color: Color(0xFF64748B),
                                ),
                              ),
                            ],
                          ),
                          const SizedBox(height: 2),
                        ],

                        if (customer.email != null) ...[
                          Row(
                            children: [
                              Icon(Icons.email,
                                  size: 14, color: const Color(0xFF64748B)),
                              const SizedBox(width: 4),
                              Expanded(
                                child: Text(
                                  customer.email!,
                                  style: const TextStyle(
                                    fontSize: 13,
                                    color: Color(0xFF64748B),
                                  ),
                                  maxLines: 1,
                                  overflow: TextOverflow.ellipsis,
                                ),
                              ),
                            ],
                          ),
                        ],
                      ],
                    ),
                  ),
                ],
              ),

              const SizedBox(height: 12),

              // Balance and Actions
              Row(
                children: [
                  // Balance Info
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          customer.balanceStatus,
                          style: TextStyle(
                            fontSize: 14,
                            fontWeight: FontWeight.w600,
                            color: customer.currentBalance > 0
                                ? (customer.isOverdue
                                    ? Colors.red
                                    : const Color(0xFF2563EB))
                                : const Color(0xFF10B981),
                          ),
                        ),
                        if (customer.hasCredit)
                          Text(
                            'Credit Limit: ETB ${customer.creditLimit.toStringAsFixed(2)}',
                            style: const TextStyle(
                              fontSize: 12,
                              color: Color(0xFF64748B),
                            ),
                          ),
                      ],
                    ),
                  ),

                  // Action Buttons
                  if (customer.currentBalance > 0)
                    ElevatedButton(
                      onPressed: () => _showRecordPaymentDialog(customer),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: const Color(0xFF10B981),
                        foregroundColor: Colors.white,
                        padding: const EdgeInsets.symmetric(
                            horizontal: 16, vertical: 8),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(8),
                        ),
                        elevation: 0,
                      ),
                      child: const Text(
                        'Receive Payment',
                        style: TextStyle(
                          fontSize: 12,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ),
                ],
              ),
            ],
          ),
        ),
      ),
    );

}

Widget \_buildStatusBadge(String text, Color color) {
return Container(
padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
margin: const EdgeInsets.only(left: 8),
decoration: BoxDecoration(
color: color.withOpacity(0.1),
borderRadius: BorderRadius.circular(6),
border: Border.all(color: color.withOpacity(0.3)),
),
child: Text(
text,
style: TextStyle(
fontSize: 10,
fontWeight: FontWeight.bold,
color: color,
),
),
);
}
}

// Stat Item Helper Class
class \_StatItem {
final String label;
final String value;
final IconData icon;
final Color color;

\_StatItem(this.label, this.value, this.icon, this.color);
}

// Enhanced Add Customer Dialog
// Enhanced AddCustomerDialog in customer_management_screen.dart
class AddCustomerDialog extends ConsumerStatefulWidget {
final VoidCallback onCustomerAdded;

const AddCustomerDialog({super.key, required this.onCustomerAdded});

@override
ConsumerState<AddCustomerDialog> createState() => \_AddCustomerDialogState();
}

class \_AddCustomerDialogState extends ConsumerState<AddCustomerDialog> {
final \_formKey = GlobalKey<FormState>();
final \_nameController = TextEditingController();
final \_businessNameController = TextEditingController();
final \_phoneController = TextEditingController();
final \_whatsappController = TextEditingController();
final \_emailController = TextEditingController();
final \_tinController = TextEditingController();
final \_addressController = TextEditingController();
final \_creditLimitController = TextEditingController(text: '0.00');
final \_notesController = TextEditingController();

bool \_isSubmitting = false;
bool \_allowCredit = false;
String \_paymentTerms = '30'; // Default to 30 days
DateTime? \_customDueDate;

@override
void dispose() {
\_nameController.dispose();
\_businessNameController.dispose();
\_phoneController.dispose();
\_whatsappController.dispose();
\_emailController.dispose();
\_tinController.dispose();
\_addressController.dispose();
\_creditLimitController.dispose();
\_notesController.dispose();
super.dispose();
}

// Validation methods
String? \_validateRequired(String? value, String fieldName) {
if (value == null || value.trim().isEmpty) {
return '$fieldName is required';
}
return null;
}

String? \_validatePhone(String? value) {
if (value == null || value.trim().isEmpty) {
return 'Phone number is required';
}

    // Ethiopian phone format validation (starts with +251 or 09)
    final phoneRegex = RegExp(r'^(\+251|0)(9|7)\d{8}$');
    final digitsOnly = value.replaceAll(RegExp(r'[\s\-]'), '');

    if (!phoneRegex.hasMatch(digitsOnly)) {
      return 'Please enter a valid Ethiopian phone number';
    }
    return null;

}

String? _validateEmail(String? value) {
if (value != null && value.trim().isNotEmpty) {
final emailRegex =
RegExp(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$');
if (!emailRegex.hasMatch(value)) {
return 'Please enter a valid email address';
}
}
return null;
}

String? \_validateCreditLimit(String? value) {
if (\_allowCredit) {
if (value == null || value.trim().isEmpty) {
return 'Credit limit is required when credit is allowed';
}
final amount = double.tryParse(value);
if (amount == null || amount < 0) {
return 'Please enter a valid credit limit';
}
}
return null;
}

String? \_validateTIN(String? value) {
if (value != null && value.trim().isNotEmpty) {
// Basic TIN validation (Ethiopian TIN is typically 10 digits)
final tinRegex = RegExp(r'^\d{10}$');
final digitsOnly = value.replaceAll(RegExp(r'[^\d]'), '');

      if (digitsOnly.length != 10) {
        return 'TIN should be 10 digits';
      }
    }
    return null;

}

Future<void> \_addCustomer() async {
if (!\_formKey.currentState!.validate()) return;

    setState(() {
      _isSubmitting = true;
    });

    try {
      final repository = ref.read(customerRepositoryProvider);

      // Calculate due date based on payment terms
      DateTime? dueDate;
      if (_paymentTerms == 'custom' && _customDueDate != null) {
        dueDate = _customDueDate;
      } else if (_paymentTerms != 'none' && _paymentTerms != 'custom') {
        final days = int.tryParse(_paymentTerms) ?? 30;
        dueDate = DateTime.now().add(Duration(days: days));
      }

      final customer = Customer(
        localId: 'cust_${DateTime.now().millisecondsSinceEpoch}',
        name: _nameController.text.trim(),
        businessName: _businessNameController.text.trim().isNotEmpty
            ? _businessNameController.text.trim()
            : null,
        phone: _phoneController.text.trim(),
        whatsappNumber: _whatsappController.text.trim().isNotEmpty
            ? _whatsappController.text.trim()
            : null,
        email: _emailController.text.trim().isNotEmpty
            ? _emailController.text.trim()
            : null,
        address: _addressController.text.trim().isNotEmpty
            ? _addressController.text.trim()
            : null,
        tinNumber: _tinController.text.trim().isNotEmpty
            ? _tinController.text.trim()
            : null,
        creditLimit: _allowCredit
            ? (double.tryParse(_creditLimitController.text) ?? 0)
            : 0,
        currentBalance: 0, // Always start with zero balance
        dueDate: dueDate,
        allowCredit: _allowCredit,
        paymentTerms: _allowCredit ? _paymentTerms : null,
        notes: _notesController.text.trim().isNotEmpty
            ? _notesController.text.trim()
            : null,
        isActive: true,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      await repository.createCustomer(customer);

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: const Text('Customer added successfully!'),
            backgroundColor: const Color(0xFF10B981),
            behavior: SnackBarBehavior.floating,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(8),
            ),
          ),
        );

        Navigator.pop(context);
        widget.onCustomerAdded();
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error adding customer: $e'),
            backgroundColor: Colors.red,
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isSubmitting = false;
        });
      }
    }

}

Future<void> \_selectCustomDueDate() async {
final DateTime? picked = await showDatePicker(
context: context,
initialDate: DateTime.now().add(const Duration(days: 30)),
firstDate: DateTime.now(),
lastDate: DateTime(2100),
builder: (context, child) {
return Theme(
data: Theme.of(context).copyWith(
colorScheme: const ColorScheme.light(
primary: Color(0xFF10B981),
onPrimary: Colors.white,
surface: Colors.white,
onSurface: Colors.black,
),
),
child: child!,
);
},
);

    if (picked != null && mounted) {
      setState(() {
        _customDueDate = picked;
        _paymentTerms = 'custom';
      });
    }

}

@override
Widget build(BuildContext context) {
final screenSize = MediaQuery.of(context).size;
final isSmallScreen = screenSize.width < 600;

    return Dialog(
      insetPadding: EdgeInsets.all(isSmallScreen ? 8 : 20),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
      ),
      child: Container(
        constraints: BoxConstraints(
          maxHeight: screenSize.height * 0.9,
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Header that stays fixed
            Container(
              padding: EdgeInsets.all(isSmallScreen ? 16 : 20),
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius: const BorderRadius.only(
                  topLeft: Radius.circular(16),
                  topRight: Radius.circular(16),
                ),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.1),
                    blurRadius: 4,
                    offset: const Offset(0, 2),
                  ),
                ],
              ),
              child: Row(
                children: [
                  Container(
                    padding: const EdgeInsets.all(8),
                    decoration: BoxDecoration(
                      color: const Color(0xFF10B981).withOpacity(0.1),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: const Icon(
                      Icons.person_add_alt_1,
                      color: Color(0xFF10B981),
                      size: 24,
                    ),
                  ),
                  const SizedBox(width: 12),
                  const Expanded(
                    child: Text(
                      'Add New Customer',
                      style: TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                        color: Color(0xFF1E293B),
                      ),
                    ),
                  ),
                  IconButton(
                    icon: const Icon(Icons.close, size: 20),
                    onPressed: () => Navigator.pop(context),
                    color: const Color(0xFF64748B),
                  ),
                ],
              ),
            ),

            // Scrollable content area
            Expanded(
              child: SingleChildScrollView(
                padding: EdgeInsets.all(isSmallScreen ? 16 : 20),
                child: Form(
                  key: _formKey,
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const Text(
                        'Enter customer details for your POS system',
                        style: TextStyle(
                          color: Color(0xFF64748B),
                          fontSize: 14,
                        ),
                      ),
                      const SizedBox(height: 20),

                      // Your form fields here (same as before)
                      // Personal Information Section
                      _buildSectionHeader('Personal Information'),
                      _buildFormField(
                        label: 'Full Name *',
                        controller: _nameController,
                        validator: (value) =>
                            _validateRequired(value, 'Full name'),
                        icon: Icons.person_outline,
                        textCapitalization: TextCapitalization.words,
                      ),
                      const SizedBox(height: 12), // Reduced spacing

                      _buildFormField(
                        label: 'Business/Company Name',
                        controller: _businessNameController,
                        icon: Icons.business_outlined,
                        textCapitalization: TextCapitalization.words,
                      ),
                      const SizedBox(height: 16),

                      // Contact Information Section
                      _buildSectionHeader('Contact Information'),
                      _buildFormField(
                        label: 'Phone Number *',
                        controller: _phoneController,
                        validator: _validatePhone,
                        icon: Icons.phone_outlined,
                        keyboardType: TextInputType.phone,
                      ),
                      const SizedBox(height: 12),

                      _buildFormField(
                        label: 'WhatsApp Number',
                        controller: _whatsappController,
                        validator: (value) {
                          if (value != null && value.isNotEmpty) {
                            return _validatePhone(value);
                          }
                          return null;
                        },
                        icon: Icons.chat,
                        keyboardType: TextInputType.phone,
                      ),
                      const SizedBox(height: 12),

                      _buildFormField(
                        label: 'Email Address',
                        controller: _emailController,
                        validator: _validateEmail,
                        icon: Icons.email_outlined,
                        keyboardType: TextInputType.emailAddress,
                      ),
                      const SizedBox(height: 16),

                      // Business Information Section
                      _buildSectionHeader('Business Information'),
                      _buildFormField(
                        label: 'TIN/VAT Number',
                        controller: _tinController,
                        validator: _validateTIN,
                        icon: Icons.assignment_outlined,
                        keyboardType: TextInputType.number,
                      ),
                      const SizedBox(height: 12),

                      _buildFormField(
                        label: 'Address',
                        controller: _addressController,
                        icon: Icons.location_on_outlined,
                        maxLines: 2,
                        textCapitalization: TextCapitalization.sentences,
                      ),
                      const SizedBox(height: 16),

                      // Credit Control Section
                      _buildSectionHeader('Credit Control'),
                      _buildCreditControlSection(),
                      const SizedBox(height: 16),

                      // Additional Information Section
                      _buildSectionHeader('Additional Information'),
                      _buildFormField(
                        label: 'Notes',
                        controller: _notesController,
                        icon: Icons.notes_outlined,
                        maxLines: 3,
                        textCapitalization: TextCapitalization.sentences,
                      ),
                      const SizedBox(height: 24),

                      // Actions
                      _buildActionButtons(),
                    ],
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );

}

Widget \_buildCreditControlSection() {
return Container(
decoration: BoxDecoration(
color: Colors.grey.shade50,
borderRadius: BorderRadius.circular(12),
border: Border.all(color: Colors.grey.shade200),
),
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
// Allow Credit Switch
Row(
children: [
Container(
padding: const EdgeInsets.all(6),
decoration: BoxDecoration(
color: const Color(0xFF10B981).withOpacity(0.1),
borderRadius: BorderRadius.circular(6),
),
child: const Icon(
Icons.credit_card_outlined,
color: Color(0xFF10B981),
size: 20,
),
),
const SizedBox(width: 12),
const Expanded(
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
'Allow Credit',
style: TextStyle(
fontWeight: FontWeight.w500,
color: Color(0xFF1E293B),
),
),
SizedBox(height: 2),
Text(
'Enable credit facility for this customer',
style: TextStyle(
fontSize: 12,
color: Color(0xFF64748B),
),
),
],
),
),
Switch(
value: \_allowCredit,
onChanged: (value) {
setState(() {
\_allowCredit = value;
if (!value) {
\_paymentTerms = 'none';
\_customDueDate = null;
}
});
},
activeColor: const Color(0xFF10B981),
),
],
),

            // Credit Limit (only show if credit is allowed)
            if (_allowCredit) ...[
              const SizedBox(height: 16),
              _buildFormField(
                label: 'Credit Limit (ETB) *',
                controller: _creditLimitController,
                validator: _validateCreditLimit,
                icon: Icons.attach_money_outlined,
                keyboardType: TextInputType.number,
              ),
              const SizedBox(height: 16),

              // Payment Terms
              Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Container(
                        padding: const EdgeInsets.all(6),
                        decoration: BoxDecoration(
                          color: const Color(0xFF10B981).withOpacity(0.1),
                          borderRadius: BorderRadius.circular(6),
                        ),
                        child: const Icon(
                          Icons.calendar_today_outlined,
                          color: Color(0xFF10B981),
                          size: 20,
                        ),
                      ),
                      const SizedBox(width: 12),
                      const Expanded(
                        child: Text(
                          'Payment Terms',
                          style: TextStyle(
                            fontWeight: FontWeight.w500,
                            color: Color(0xFF1E293B),
                          ),
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 12),
                  DropdownButtonFormField<String>(
                    value: _paymentTerms,
                    decoration: const InputDecoration(
                      labelText: 'Select Payment Terms',
                      border: OutlineInputBorder(),
                      contentPadding: EdgeInsets.symmetric(
                        horizontal: 12,
                        vertical: 16,
                      ),
                    ),
                    items: const [
                      DropdownMenuItem(
                        value: 'none',
                        child: Text('No Credit Terms'),
                      ),
                      DropdownMenuItem(
                        value: '7',
                        child: Text('7 Days'),
                      ),
                      DropdownMenuItem(
                        value: '15',
                        child: Text('15 Days'),
                      ),
                      DropdownMenuItem(
                        value: '30',
                        child: Text('30 Days'),
                      ),
                      DropdownMenuItem(
                        value: 'custom',
                        child: Text('Custom Date'),
                      ),
                    ],
                    onChanged: (value) {
                      setState(() {
                        _paymentTerms = value ?? '30';
                        if (value != 'custom') {
                          _customDueDate = null;
                        }
                      });
                    },
                  ),
                  if (_paymentTerms == 'custom') ...[
                    const SizedBox(height: 12),
                    OutlinedButton.icon(
                      onPressed: _selectCustomDueDate,
                      icon: const Icon(Icons.calendar_today, size: 16),
                      label: Text(
                        _customDueDate != null
                            ? 'Due Date: ${_formatDate(_customDueDate!)}'
                            : 'Select Custom Due Date',
                      ),
                      style: OutlinedButton.styleFrom(
                        foregroundColor: const Color(0xFF10B981),
                        side: const BorderSide(color: Color(0xFF10B981)),
                        minimumSize: const Size(double.infinity, 48),
                      ),
                    ),
                  ],
                ],
              ),
            ],
          ],
        ),
      ),
    );

}

Widget \_buildActionButtons() {
return Row(
children: [
Expanded(
child: OutlinedButton(
onPressed: _isSubmitting ? null : () => Navigator.pop(context),
style: OutlinedButton.styleFrom(
foregroundColor: const Color(0xFF64748B),
side: const BorderSide(color: Color(0xFFE2E8F0)),
padding: const EdgeInsets.symmetric(vertical: 16),
shape: RoundedRectangleBorder(
borderRadius: BorderRadius.circular(12),
),
),
child: const Text(
'Cancel',
style: TextStyle(
fontWeight: FontWeight.w600,
),
),
),
),
const SizedBox(width: 12),
Expanded(
child: ElevatedButton(
onPressed: _isSubmitting ? null : _addCustomer,
style: ElevatedButton.styleFrom(
backgroundColor: const Color(0xFF10B981),
foregroundColor: Colors.white,
padding: const EdgeInsets.symmetric(vertical: 16),
shape: RoundedRectangleBorder(
borderRadius: BorderRadius.circular(12),
),
elevation: 0,
),
child: _isSubmitting
? const SizedBox(
width: 20,
height: 20,
child: CircularProgressIndicator(
strokeWidth: 2,
color: Colors.white,
),
)
: const Text(
'Add Customer',
style: TextStyle(
fontWeight: FontWeight.w600,
),
),
),
),
],
);
}

Widget \_buildSectionHeader(String title) {
return Padding(
padding: const EdgeInsets.only(bottom: 16, top: 8),
child: Text(
title,
style: const TextStyle(
fontSize: 16,
fontWeight: FontWeight.w600,
color: Color(0xFF1E293B),
),
),
);
}

Widget \_buildFormField({
required String label,
required TextEditingController controller,
String? Function(String?)? validator,
required IconData icon,
TextInputType? keyboardType,
int maxLines = 1,
TextCapitalization textCapitalization = TextCapitalization.none,
}) {
return TextFormField(
controller: controller,
keyboardType: keyboardType,
maxLines: maxLines,
validator: validator,
textCapitalization: textCapitalization,
decoration: InputDecoration(
labelText: label,
prefixIcon: Icon(icon, color: const Color(0xFF64748B)),
filled: true,
fillColor: const Color(0xFFF8FAFC),
border: OutlineInputBorder(
borderRadius: BorderRadius.circular(12),
borderSide: BorderSide.none,
),
enabledBorder: OutlineInputBorder(
borderRadius: BorderRadius.circular(12),
borderSide: const BorderSide(color: Color(0xFFE2E8F0)),
),
focusedBorder: OutlineInputBorder(
borderRadius: BorderRadius.circular(12),
borderSide: const BorderSide(
color: Color(0xFF10B981),
width: 2,
),
),
errorBorder: OutlineInputBorder(
borderRadius: BorderRadius.circular(12),
borderSide: const BorderSide(color: Colors.red),
),
focusedErrorBorder: OutlineInputBorder(
borderRadius: BorderRadius.circular(12),
borderSide: const BorderSide(
color: Colors.red,
width: 2,
),
),
contentPadding: EdgeInsets.symmetric(
horizontal: 16,
vertical: maxLines > 1 ? 16 : 18,
),
alignLabelWithHint: maxLines > 1,
),
);
}

String \_formatDate(DateTime date) {
return '${date.day}/${date.month}/${date.year}';
}
}
// Keep the existing RecordPaymentDialog and CustomerDetailScreen as they are
// but ensure they also use ref.read(customerRepositoryProvider)

class RecordPaymentDialog extends ConsumerStatefulWidget {
final Customer customer;
final VoidCallback onPaymentRecorded;

const RecordPaymentDialog({
super.key,
required this.customer,
required this.onPaymentRecorded,
});

@override
ConsumerState<RecordPaymentDialog> createState() =>
\_RecordPaymentDialogState();
}

class \_RecordPaymentDialogState extends ConsumerState<RecordPaymentDialog> {
final \_formKey = GlobalKey<FormState>();
final \_amountController = TextEditingController();
final \_notesController = TextEditingController();
bool \_isSubmitting = false;

@override
void initState() {
super.initState();
\_amountController.text = widget.customer.currentBalance.toStringAsFixed(2);
}

@override
void dispose() {
\_amountController.dispose();
\_notesController.dispose();
super.dispose();
}

void \_recordPayment() async {
if (\_formKey.currentState!.validate()) {
final amount = double.tryParse(\_amountController.text) ?? 0;

      if (amount <= 0) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Please enter a valid payment amount'),
            backgroundColor: Colors.orange,
          ),
        );
        return;
      }

      if (amount > widget.customer.currentBalance) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Payment amount cannot exceed outstanding balance'),
            backgroundColor: Colors.orange,
          ),
        );
        return;
      }

      setState(() {
        _isSubmitting = true;
      });

      try {
        final repository = ref.read(customerRepositoryProvider);
        final transaction = CreditTransaction(
          localId: 'payment_${DateTime.now().millisecondsSinceEpoch}',
          customerId: widget.customer.id!,
          customerName: widget.customer.name,
          type: 'payment',
          amount: amount,
          balanceBefore: widget.customer.currentBalance,
          balanceAfter: widget.customer.currentBalance - amount,
          notes:
              _notesController.text.isNotEmpty ? _notesController.text : null,
          createdAt: DateTime.now(),
        );

        await repository.addCreditTransaction(transaction);

        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content:
                Text('Payment of ETB ${amount.toStringAsFixed(2)} recorded!'),
            backgroundColor: const Color(0xFF10B981),
          ),
        );

        Navigator.pop(context);
        widget.onPaymentRecorded();
      } catch (e) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error recording payment: $e'),
            backgroundColor: Colors.red,
          ),
        );
      } finally {
        if (mounted) {
          setState(() {
            _isSubmitting = false;
          });
        }
      }
    }

}

@override
Widget build(BuildContext context) {
final isSmallScreen = MediaQuery.of(context).size.width < 600;

    return Dialog(
      insetPadding: EdgeInsets.all(isSmallScreen ? 16 : 24),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
      ),
      child: SingleChildScrollView(
        padding: EdgeInsets.all(isSmallScreen ? 20 : 24),
        child: Form(
          key: _formKey,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Container(
                    padding: const EdgeInsets.all(8),
                    decoration: BoxDecoration(
                      color: const Color(0xFF10B981).withOpacity(0.1),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: const Icon(Icons.payment,
                        color: Color(0xFF10B981), size: 24),
                  ),
                  const SizedBox(width: 12),
                  const Expanded(
                    child: Text(
                      'Record Payment',
                      style: TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                        color: Color(0xFF1E293B),
                      ),
                    ),
                  ),
                  IconButton(
                    icon: const Icon(Icons.close, size: 20),
                    onPressed: () => Navigator.pop(context),
                    color: const Color(0xFF64748B),
                  ),
                ],
              ),
              const SizedBox(height: 16),
              Text(
                'Customer: ${widget.customer.name}',
                style: const TextStyle(
                  fontWeight: FontWeight.w600,
                  fontSize: 16,
                ),
              ),
              const SizedBox(height: 8),
              Text(
                'Outstanding Balance: ETB ${widget.customer.currentBalance.toStringAsFixed(2)}',
                style: TextStyle(
                  color: widget.customer.isOverdue ? Colors.red : Colors.blue,
                  fontWeight: FontWeight.w600,
                ),
              ),
              const SizedBox(height: 24),
              TextFormField(
                controller: _amountController,
                decoration: const InputDecoration(
                  labelText: 'Payment Amount (ETB) *',
                  border: OutlineInputBorder(),
                  filled: true,
                ),
                keyboardType: TextInputType.number,
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Please enter payment amount';
                  }
                  if (double.tryParse(value) == null) {
                    return 'Please enter a valid amount';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _notesController,
                decoration: const InputDecoration(
                  labelText: 'Notes (Optional)',
                  border: OutlineInputBorder(),
                  filled: true,
                ),
                maxLines: 2,
              ),
              const SizedBox(height: 32),
              Row(
                children: [
                  Expanded(
                    child: OutlinedButton(
                      onPressed:
                          _isSubmitting ? null : () => Navigator.pop(context),
                      child: const Text('Cancel'),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: ElevatedButton(
                      onPressed: _isSubmitting ? null : _recordPayment,
                      style: ElevatedButton.styleFrom(
                        backgroundColor: const Color(0xFF10B981),
                        foregroundColor: Colors.white,
                      ),
                      child: _isSubmitting
                          ? const SizedBox(
                              width: 20,
                              height: 20,
                              child: CircularProgressIndicator(
                                strokeWidth: 2,
                                color: Colors.white,
                              ),
                            )
                          : const Text('Record Payment'),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );

}
}

// Add this to your customer_management_screen.dart or create separate files

// Add Credit Sale Dialog
class AddCreditSaleDialog extends ConsumerStatefulWidget {
final Customer customer;
final VoidCallback onSaleCompleted;

const AddCreditSaleDialog({
super.key,
required this.customer,
required this.onSaleCompleted,
});

@override
ConsumerState<AddCreditSaleDialog> createState() =>
\_AddCreditSaleDialogState();
}

class \_AddCreditSaleDialogState extends ConsumerState<AddCreditSaleDialog> {
final \_formKey = GlobalKey<FormState>();
final \_amountController = TextEditingController();
final \_referenceController = TextEditingController();
final \_notesController = TextEditingController();
final \_dueDaysController = TextEditingController(text: '30');

bool \_isSubmitting = false;

@override
void dispose() {
\_amountController.dispose();
\_referenceController.dispose();
\_notesController.dispose();
\_dueDaysController.dispose();
super.dispose();
}

Future<void> \_addCreditSale() async {
if (!\_formKey.currentState!.validate()) return;

    final amount = double.tryParse(_amountController.text) ?? 0;
    final dueDays = int.tryParse(_dueDaysController.text) ?? 30;

    if (amount <= 0) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Sale amount must be greater than zero'),
          backgroundColor: Colors.orange,
        ),
      );
      return;
    }

    setState(() {
      _isSubmitting = true;
    });

    try {
      final repository = ref.read(customerRepositoryProvider);
      final result = await repository.createCreditSale(
        customerId: widget.customer.id!,
        amount: amount,
        saleReference: _referenceController.text.isNotEmpty
            ? _referenceController.text
            : 'SALE-${DateTime.now().millisecondsSinceEpoch}',
        dueDays: dueDays,
        notes: _notesController.text.isNotEmpty ? _notesController.text : null,
      );

      if (result.success) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
                'Credit sale of ETB ${amount.toStringAsFixed(2)} added successfully!'),
            backgroundColor: const Color(0xFF10B981),
          ),
        );
        Navigator.pop(context);
        widget.onSaleCompleted();
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(result.error!),
            backgroundColor: Colors.red,
          ),
        );
      }
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error adding credit sale: $e'),
          backgroundColor: Colors.red,
        ),
      );
    } finally {
      if (mounted) {
        setState(() {
          _isSubmitting = false;
        });
      }
    }

}

@override
Widget build(BuildContext context) {
return Dialog(
insetPadding: const EdgeInsets.all(20),
shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
child: SingleChildScrollView(
padding: const EdgeInsets.all(24),
child: Form(
key: \_formKey,
child: Column(
mainAxisSize: MainAxisSize.min,
crossAxisAlignment: CrossAxisAlignment.start,
children: [
// Header
Row(
children: [
Container(
padding: const EdgeInsets.all(8),
decoration: BoxDecoration(
color: const Color(0xFF10B981).withOpacity(0.1),
borderRadius: BorderRadius.circular(8),
),
child: const Icon(Icons.add_shopping_cart,
color: Color(0xFF10B981), size: 24),
),
const SizedBox(width: 12),
const Expanded(
child: Text(
'Add Credit Sale',
style: TextStyle(
fontSize: 18,
fontWeight: FontWeight.bold,
),
),
),
IconButton(
icon: const Icon(Icons.close),
onPressed: () => Navigator.pop(context),
),
],
),
const SizedBox(height: 8),
Text(
'Customer: ${widget.customer.name}',
style: const TextStyle(color: Colors.grey),
),
const SizedBox(height: 4),
Text(
'Available Credit: ETB ${widget.customer.availableCredit.toStringAsFixed(2)}',
style: TextStyle(
color: widget.customer.availableCredit > 0
? Colors.green
: Colors.red,
fontWeight: FontWeight.w500,
),
),
const SizedBox(height: 24),

              // Form Fields
              TextFormField(
                controller: _amountController,
                decoration: const InputDecoration(
                  labelText: 'Sale Amount (ETB) *',
                  border: OutlineInputBorder(),
                  prefixText: 'ETB ',
                ),
                keyboardType: TextInputType.number,
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Please enter sale amount';
                  }
                  final amount = double.tryParse(value);
                  if (amount == null || amount <= 0) {
                    return 'Please enter a valid amount';
                  }
                  if (amount > widget.customer.availableCredit) {
                    return 'Amount exceeds available credit';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _referenceController,
                decoration: const InputDecoration(
                  labelText: 'Sale Reference',
                  border: OutlineInputBorder(),
                  hintText: 'Optional reference number',
                ),
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _dueDaysController,
                decoration: const InputDecoration(
                  labelText: 'Due Days',
                  border: OutlineInputBorder(),
                  hintText: '30',
                  suffixText: 'days',
                ),
                keyboardType: TextInputType.number,
                validator: (value) {
                  if (value != null && value.isNotEmpty) {
                    final days = int.tryParse(value);
                    if (days == null || days <= 0) {
                      return 'Please enter valid number of days';
                    }
                  }
                  return null;
                },
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _notesController,
                decoration: const InputDecoration(
                  labelText: 'Notes',
                  border: OutlineInputBorder(),
                  hintText: 'Optional notes about this sale',
                ),
                maxLines: 2,
              ),
              const SizedBox(height: 32),

              // Actions
              Row(
                children: [
                  Expanded(
                    child: OutlinedButton(
                      onPressed:
                          _isSubmitting ? null : () => Navigator.pop(context),
                      child: const Text('Cancel'),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: ElevatedButton(
                      onPressed: _isSubmitting ? null : _addCreditSale,
                      style: ElevatedButton.styleFrom(
                        backgroundColor: const Color(0xFF10B981),
                        foregroundColor: Colors.white,
                      ),
                      child: _isSubmitting
                          ? const SizedBox(
                              width: 20,
                              height: 20,
                              child: CircularProgressIndicator(
                                strokeWidth: 2,
                                color: Colors.white,
                              ),
                            )
                          : const Text('Add Sale'),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );

}
}

// Edit Credit Limit Dialog
class EditCreditLimitDialog extends ConsumerStatefulWidget {
final Customer customer;
final VoidCallback onCreditLimitUpdated;

const EditCreditLimitDialog({
super.key,
required this.customer,
required this.onCreditLimitUpdated,
});

@override
ConsumerState<EditCreditLimitDialog> createState() =>
\_EditCreditLimitDialogState();
}

class \_EditCreditLimitDialogState extends ConsumerState<EditCreditLimitDialog> {
final \_formKey = GlobalKey<FormState>();
final \_creditLimitController = TextEditingController();

bool \_isSubmitting = false;

@override
void initState() {
super.initState();
\_creditLimitController.text =
widget.customer.creditLimit.toStringAsFixed(2);
}

@override
void dispose() {
\_creditLimitController.dispose();
super.dispose();
}

Future<void> \_updateCreditLimit() async {
if (!\_formKey.currentState!.validate()) return;

    final newLimit = double.tryParse(_creditLimitController.text) ?? 0;

    if (newLimit < 0) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Credit limit cannot be negative'),
          backgroundColor: Colors.orange,
        ),
      );
      return;
    }

    setState(() {
      _isSubmitting = true;
    });

    try {
      final repository = ref.read(customerRepositoryProvider);
      final result = await repository.updateCreditLimit(
        customerId: widget.customer.id!,
        newCreditLimit: newLimit,
      );

      if (result.success) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
                'Credit limit updated to ETB ${newLimit.toStringAsFixed(2)}'),
            backgroundColor: const Color(0xFF10B981),
          ),
        );
        Navigator.pop(context);
        widget.onCreditLimitUpdated();
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(result.error!),
            backgroundColor: Colors.red,
          ),
        );
      }
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error updating credit limit: $e'),
          backgroundColor: Colors.red,
        ),
      );
    } finally {
      if (mounted) {
        setState(() {
          _isSubmitting = false;
        });
      }
    }

}

@override
Widget build(BuildContext context) {
return Dialog(
insetPadding: const EdgeInsets.all(20),
shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
child: SingleChildScrollView(
padding: const EdgeInsets.all(24),
child: Form(
key: \_formKey,
child: Column(
mainAxisSize: MainAxisSize.min,
crossAxisAlignment: CrossAxisAlignment.start,
children: [
// Header
Row(
children: [
Container(
padding: const EdgeInsets.all(8),
decoration: BoxDecoration(
color: const Color(0xFF10B981).withOpacity(0.1),
borderRadius: BorderRadius.circular(8),
),
child: const Icon(Icons.credit_card,
color: Color(0xFF10B981), size: 24),
),
const SizedBox(width: 12),
const Expanded(
child: Text(
'Edit Credit Limit',
style: TextStyle(
fontSize: 18,
fontWeight: FontWeight.bold,
),
),
),
IconButton(
icon: const Icon(Icons.close),
onPressed: () => Navigator.pop(context),
),
],
),
const SizedBox(height: 8),
Text(
'Customer: ${widget.customer.name}',
style: const TextStyle(color: Colors.grey),
),
const SizedBox(height: 4),
Text(
'Current Balance: ETB ${widget.customer.currentBalance.toStringAsFixed(2)}',
style: const TextStyle(
color: Colors.orange,
fontWeight: FontWeight.w500,
),
),
const SizedBox(height: 24),

              // Form Field
              TextFormField(
                controller: _creditLimitController,
                decoration: const InputDecoration(
                  labelText: 'New Credit Limit (ETB) *',
                  border: OutlineInputBorder(),
                  prefixText: 'ETB ',
                ),
                keyboardType: TextInputType.number,
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Please enter credit limit';
                  }
                  final limit = double.tryParse(value);
                  if (limit == null) {
                    return 'Please enter a valid amount';
                  }
                  if (limit < widget.customer.currentBalance) {
                    return 'Credit limit cannot be less than current balance';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 32),

              // Actions
              Row(
                children: [
                  Expanded(
                    child: OutlinedButton(
                      onPressed:
                          _isSubmitting ? null : () => Navigator.pop(context),
                      child: const Text('Cancel'),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: ElevatedButton(
                      onPressed: _isSubmitting ? null : _updateCreditLimit,
                      style: ElevatedButton.styleFrom(
                        backgroundColor: const Color(0xFF10B981),
                        foregroundColor: Colors.white,
                      ),
                      child: _isSubmitting
                          ? const SizedBox(
                              width: 20,
                              height: 20,
                              child: CircularProgressIndicator(
                                strokeWidth: 2,
                                color: Colors.white,
                              ),
                            )
                          : const Text('Update Limit'),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );

}
}

// CustomerDetailScreen remains the same but ensure it uses ref.read
class CustomerDetailScreen extends ConsumerStatefulWidget {
final Customer customer;

const CustomerDetailScreen({super.key, required this.customer});

@override
ConsumerState<CustomerDetailScreen> createState() =>
\_CustomerDetailScreenState();
}

class \_CustomerDetailScreenState extends ConsumerState<CustomerDetailScreen> {
List<CreditTransaction> \_transactions = [];
bool \_isLoading = true;

@override
void initState() {
super.initState();
\_loadTransactions();
}

Future<void> \_loadTransactions() async {
try {
final repository = ref.read(customerRepositoryProvider);
final transactions =
await repository.getCustomerTransactions(widget.customer.id!);

      setState(() {
        _transactions = transactions;
        _isLoading = false;
      });
    } catch (e) {
      setState(() {
        _isLoading = false;
      });
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error loading transactions: $e'),
          backgroundColor: Colors.red,
        ),
      );
    }

}

@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: Text(widget.customer.name),
backgroundColor: const Color(0xFF10B981),
foregroundColor: Colors.white,
),
body: SingleChildScrollView(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Card(
elevation: 2,
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
widget.customer.name,
style: const TextStyle(
fontSize: 20,
fontWeight: FontWeight.bold,
),
),
if (widget.customer.phone != null) ...[
const SizedBox(height: 8),
Text('Phone: ${widget.customer.phone}'),
],
if (widget.customer.email != null) ...[
const SizedBox(height: 4),
Text('Email: ${widget.customer.email}'),
],
if (widget.customer.address != null) ...[
const SizedBox(height: 4),
Text('Address: ${widget.customer.address}'),
],
const SizedBox(height: 16),
Row(
mainAxisAlignment: MainAxisAlignment.spaceBetween,
children: [
Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
const Text('Current Balance:'),
Text(
widget.customer.formattedBalance,
style: TextStyle(
fontSize: 18,
fontWeight: FontWeight.bold,
color: widget.customer.currentBalance > 0
? (widget.customer.isOverdue
? Colors.red
: Colors.blue)
: Colors.green,
),
),
],
),
if (widget.customer.hasCredit)
Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
const Text('Credit Limit:'),
Text(
'ETB ${widget.customer.creditLimit.toStringAsFixed(2)}',
style: const TextStyle(
fontSize: 16,
fontWeight: FontWeight.w600,
),
),
],
),
],
),
],
),
),
),
const SizedBox(height: 24),
const Text(
'Transaction History',
style: TextStyle(
fontSize: 18,
fontWeight: FontWeight.bold,
),
),
const SizedBox(height: 16),
\_isLoading
? const Center(
child: CircularProgressIndicator(color: Color(0xFF10B981)))
: \_transactions.isEmpty
? const Center(
child: Text(
'No transactions yet',
style: TextStyle(color: Colors.grey),
),
)
: Column(
children: \_transactions
.map((transaction) =>
\_buildTransactionCard(transaction))
.toList(),
),
],
),
),
);
}

Widget \_buildTransactionCard(CreditTransaction transaction) {
return Card(
margin: const EdgeInsets.only(bottom: 8),
child: Padding(
padding: const EdgeInsets.all(12),
child: Row(
mainAxisAlignment: MainAxisAlignment.spaceBetween,
children: [
Expanded(
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
transaction.description,
style: const TextStyle(
fontWeight: FontWeight.w500,
),
),
if (transaction.notes != null) ...[
const SizedBox(height: 4),
Text(
transaction.notes!,
style: const TextStyle(
fontSize: 12,
color: Colors.grey,
),
),
],
const SizedBox(height: 4),
Text(
'${transaction.createdAt.day}/${transaction.createdAt.month}/${transaction.createdAt.year} ${transaction.createdAt.hour}:${transaction.createdAt.minute.toString().padLeft(2, '0')}',
style: const TextStyle(
fontSize: 12,
color: Colors.grey,
),
),
],
),
),
Column(
crossAxisAlignment: CrossAxisAlignment.end,
children: [
Text(
transaction.formattedAmount,
style: TextStyle(
fontWeight: FontWeight.bold,
color: transaction.amountColor,
),
),
Text(
'Balance: ETB ${transaction.balanceAfter.toStringAsFixed(2)}',
style: const TextStyle(
fontSize: 12,
color: Colors.grey,
),
),
],
),
],
),
),
);
}
}

##

//lib/src/ui/screens/dashboard_screen.dart
// Dashboard screen displaying key metrics, charts, and recent activity.
// i need professionnal modern content rich dashboard screen code secure responsive and optimized for performance code here as per best practices and expert guidelines.
import 'package:andalus_smart_pos/src/data/models/customer.dart';
import 'package:andalus_smart_pos/src/providers/language_provider.dart';
import 'package:andalus_smart_pos/src/ui/screens/customer_management_screen.dart';
import 'package:andalus_smart_pos/src/ui/screens/product_management_screen.dart';
import 'package:andalus_smart_pos/src/utils/calendar_utils.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/data/repositories/sale_repository.dart';
import 'package:andalus_smart_pos/src/data/repositories/customer_repository.dart';
import 'package:andalus_smart_pos/src/data/repositories/product_repository.dart';
import 'package:andalus_smart_pos/src/data/models/sale.dart';
import 'package:andalus_smart_pos/src/data/models/product.dart';
import 'package:andalus_smart_pos/src/utils/date_utils.dart';
import 'package:andalus_smart_pos/src/utils/formatters.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
// import 'package:andalus_smart_pos/src/widgets/dashboard/stat_card.dart';
import 'package:andalus_smart_pos/src/widgets/dashboard/metric_card.dart';
import 'package:andalus_smart_pos/src/widgets/dashboard/recent_sales_list.dart';
import 'package:andalus_smart_pos/src/widgets/dashboard/stock_alert_widget.dart';
import 'package:andalus_smart_pos/src/widgets/dashboard/quick_actions_widget.dart';
// import 'package:andalus_smart_pos/src/widgets/dashboard/sales_charts.dart';
import 'package:andalus_smart_pos/src/widgets/common/loading_shimmer.dart';
// import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
import 'package:intl/intl.dart';
import 'package:andalus_smart_pos/src/widgets/dashboard/dashboard_cards.dart';
import 'package:andalus_smart_pos/src/widgets/dashboard/sales_analytics.dart';

class DashboardScreen extends ConsumerStatefulWidget {
const DashboardScreen({super.key});

@override
ConsumerState<DashboardScreen> createState() => \_DashboardScreenState();
}

class \_DashboardScreenState extends ConsumerState<DashboardScreen> {
late Future<DashboardData> \_dashboardData;
bool \_isRefreshing = false;

@override
void initState() {
super.initState();
\_dashboardData = \_loadDashboardData();
}

Future<DashboardData> \_loadDashboardData() async {
try {
final saleRepository = ref.read(saleRepositoryProvider);
final customerRepository = ref.read(customerRepositoryProvider);
final productRepository = ref.read(productRepositoryProvider);

      // Load all data
      final salesSummary = await saleRepository.getSalesSummary();
      final creditSummary = await customerRepository.getCreditSummary();
      final todaysSales = await saleRepository.getTodaysSales();
      final lowStockProducts = await productRepository.getLowStockProducts();
      final totalProducts = await productRepository.getAllProducts();

      // Get customers for total count
      List<Customer> allCustomers = [];
      try {
        allCustomers = await customerRepository.getAllCustomers();
      } catch (e) {
        print('Error loading customers: $e');
        allCustomers = [];
      }

      // Calculate metrics
      final totalRevenue = salesSummary.totalSales;
      final averageOrderValue = salesSummary.totalOrders > 0
          ? (totalRevenue / salesSummary.totalOrders).toDouble()
          : 0.0;

      final dailyGrowth = salesSummary.weeklySales > 0
          ? ((salesSummary.todaysSales / salesSummary.weeklySales * 100) - 100)
              .toDouble()
          : 0.0;

      return DashboardData(
        salesSummary: salesSummary,
        creditSummary: creditSummary,
        todaysSales: todaysSales,
        lowStockProducts: lowStockProducts,
        totalProducts: totalProducts,
        allCustomers: allCustomers,
        totalRevenue: totalRevenue,
        averageOrderValue: averageOrderValue,
        dailyGrowth: dailyGrowth,
        timestamp: DateTime.now(),
      );
    } catch (e) {
      print('Error loading dashboard data: $e');
      // Return fallback data without using createSample methods
      return _createFallbackDashboardData();
    }

}

// Add this fallback method
DashboardData \_createFallbackDashboardData() {
return DashboardData(
salesSummary: SalesSummary(
todaysSales: 1250.0,
todaysOrders: 8,
totalSales: 12500.0,
totalOrders: 45,
weeklySales: 3250.0,
weeklyOrders: 22,
),
creditSummary: {
'totalOutstanding': 2500.0,
'overdueAmount': 750.0,
'customersWithBalance': 3,
'overdueCustomers': 1,
'totalCustomers': 15,
},
todaysSales: [],
lowStockProducts: [],
totalProducts: [],
allCustomers: [],
totalRevenue: 12500.0,
averageOrderValue: 277.78,
dailyGrowth: 15.2,
timestamp: DateTime.now(),
);
}

Future<void> \_refreshData() async {
setState(() => \_isRefreshing = true);
await Future.delayed(const Duration(milliseconds: 800));
setState(() {
\_dashboardData = \_loadDashboardData();
\_isRefreshing = false;
});
}

// Add navigation methods:
void \_navigateToSalesDetails(BuildContext context) {
// Navigate to sales details screen
showDialog(
context: context,
builder: (context) => \_buildSalesDetailsDialog(context),
);
}

void \_navigateToProducts(BuildContext context) {
Navigator.push(
context,
MaterialPageRoute(builder: (context) => const ProductManagementScreen()),
);
}

void \_navigateToCustomers(BuildContext context) {
Navigator.push(
context,
MaterialPageRoute(builder: (context) => const CustomerManagementScreen()),
);
}

void \_navigateToRevenueAnalytics(BuildContext context) {
// Navigate to detailed revenue analytics
showDialog(
context: context,
builder: (context) => \_buildRevenueAnalyticsDialog(context),
);
}

// Helper methods

// Helper methods for dashboard
int \_getTotalItems(List<Product> products) {
if (products.isEmpty) return 0;
return products.fold(0, (sum, product) => sum + (product.stockQuantity));
}

int \_getTotalCategories(List<Product> products) {
if (products.isEmpty) return 0;
final categoryIds =
// ignore: unnecessary_null_comparison
products.map((p) => p.categoryId).where((id) => id != null).toSet();
return categoryIds.length;
}

int \_getTotalCustomers(DashboardData data) {
// Try to get from credit summary first, then fallback to actual list
final fromSummary = data.creditSummary['totalCustomers'] as int?;
if (fromSummary != null) return fromSummary;
return data.allCustomers.length;
}

int \_getCustomersWithBalance(DashboardData data) {
return data.creditSummary['customersWithBalance'] as int? ?? 0;
}

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);

    return Scaffold(
      backgroundColor: Theme.of(context).colorScheme.background,
      appBar: _buildAppBar(localizations),
      body: FutureBuilder<DashboardData>(
        future: _dashboardData,
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return DashboardShimmer(localizations: localizations);
          }

          if (snapshot.hasError) {
            return DashboardErrorWidget(
              error: snapshot.error.toString(),
              onRetry: _refreshData,
              localizations: localizations,
            );
          }

          final data = snapshot.data!;

          return RefreshIndicator.adaptive(
            onRefresh: _refreshData,
            color: Theme.of(context).colorScheme.primary,
            child: CustomScrollView(
              slivers: [
                SliverToBoxAdapter(
                  child: _buildLiveDateTimeWidget(context),
                ),
                // Header Stats Section
                _buildStatsSection(data, localizations),

                // Charts Section
                _buildChartsSection(data, localizations),

                // Content Section
                _buildContentSection(data, localizations),
              ],
            ),
          );
        },
      ),
    );

}

AppBar \_buildAppBar(AppLocalizations localizations) {
return AppBar(
title: Text(
localizations.dashboard,
style: TextStyle(
fontWeight: FontWeight.w700,
fontSize: 24,
color: Theme.of(context).colorScheme.onBackground,
),
),
backgroundColor: Colors.transparent,
foregroundColor: Theme.of(context).colorScheme.onBackground,
elevation: 0,
actions: [
IconButton(
icon: Icon(
_isRefreshing ? Icons.refresh : Icons.refresh_rounded,
color: _isRefreshing
? Theme.of(context).colorScheme.outline
: Theme.of(context).colorScheme.primary,
),
onPressed: _isRefreshing ? null : _refreshData,
tooltip: localizations.translate('refresh'),
),
],
);
}

SliverToBoxAdapter \_buildStatsSection(
DashboardData data, AppLocalizations localizations) {
return SliverToBoxAdapter(
child: Padding(
padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
child: LayoutBuilder(
builder: (context, constraints) {
final isTablet = constraints.maxWidth > 600;
final crossAxisCount = isTablet ? 4 : 2;

            // Use fixed height instead of aspect ratio for better control
            return GridView.count(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              crossAxisCount: crossAxisCount,
              crossAxisSpacing: 12,
              mainAxisSpacing: 12,
              childAspectRatio: 1.0, // Square cards
              padding: EdgeInsets.zero,
              children: [
                SizedBox(
                  height: 130, // Fixed height matching card height
                  child: SalesCard(
                    todaySales: data.salesSummary.todaysSales,
                    itemsSold: data.salesSummary.todaysOrders,
                    onTap: () => _navigateToSalesDetails(context),
                  ),
                ),
                SizedBox(
                  height: 130,
                  child: ProductsCard(
                    totalProducts: data.totalProducts.length,
                    totalItems: _getTotalItems(data.totalProducts),
                    totalCategories: _getTotalCategories(data.totalProducts),
                    onTap: () => _navigateToProducts(context),
                  ),
                ),
                SizedBox(
                  height: 130,
                  child: CustomersCard(
                    totalCustomers: _getTotalCustomers(data),
                    customersWithBalance: _getCustomersWithBalance(data),
                    onTap: () => _navigateToCustomers(context),
                  ),
                ),
                SizedBox(
                  height: 130,
                  child: RevenueCard(
                    totalRevenue: data.totalRevenue,
                    outstandingCredit:
                        data.creditSummary['totalOutstanding'] as double? ??
                            0.0,
                    onTap: () => _navigateToRevenueAnalytics(context),
                  ),
                ),
              ],
            );
          },
        ),
      ),
    );

}

SliverToBoxAdapter \_buildChartsSection(
DashboardData data, AppLocalizations localizations) {
return SliverToBoxAdapter(
child: Padding(
padding: const EdgeInsets.symmetric(
horizontal: 16, vertical: 12), // Reduced padding
child: SalesAnalyticsWidget(
salesData: data.salesSummary,
localizations: localizations,
),
),
);
}

Widget \_buildContentSection(
DashboardData data, AppLocalizations localizations) {
return SliverToBoxAdapter(
child: Padding(
padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 8),
child: Column(
children: [
_buildInsightsSection(data, localizations), // Add this line
const SizedBox(height: 20),
_buildPerformanceOverview(data, localizations),
const SizedBox(height: 20),
RecentSalesList(
sales: data.todaysSales,
localizations: localizations,
),
const SizedBox(height: 20),
StockAlertWidget(
products: data.lowStockProducts,
localizations: localizations,
),
const SizedBox(height: 20),
QuickActionsWidget(localizations: localizations),
],
),
),
);
}

Widget \_buildSalesDetailsDialog(BuildContext context) {
return AlertDialog(
title: const Text('Today\'s Sales Details'),
content: SizedBox(
width: double.maxFinite,
child: ListView(
shrinkWrap: true,
children: [
// Add sales details content here
const ListTile(
leading: Icon(Icons.shopping_cart, color: Color(0xFF10B981)),
title: Text('Total Sales'),
subtitle: Text('ETB 12,500.00'),
),
// Add more sales details...
],
),
),
actions: [
TextButton(
onPressed: () => Navigator.pop(context),
child: const Text('Close'),
),
],
);
}

// Revenue Analytics Dialog
Widget \_buildRevenueAnalyticsDialog(BuildContext context) {
return Dialog(
child: Container(
padding: const EdgeInsets.all(20),
width: MediaQuery.of(context).size.width _ 0.9,
height: MediaQuery.of(context).size.height _ 0.8,
child: Column(
children: [
const Text(
'Revenue Analytics',
style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
),
const SizedBox(height: 20),
Expanded(
child: SalesAnalyticsWidget(
salesData: SalesSummary(
todaysSales: 12500,
todaysOrders: 45,
totalSales: 125000,
totalOrders: 450,
weeklySales: 32500,
weeklyOrders: 120,
),
localizations: AppLocalizations.of(context),
),
),
],
),
),
);
}

Widget \_buildLiveDateTimeWidget(BuildContext context) {
return Consumer(
builder: (context, ref, child) {
final calendarType = ref.watch(calendarProvider);
final locale = ref.watch(languageProvider);
final currentTime = DateTime.now();

        return Container(
          margin: const EdgeInsets.symmetric(horizontal: 20, vertical: 8),
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            gradient: LinearGradient(
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
              colors: [
                Theme.of(context).colorScheme.primary.withOpacity(0.1),
                Theme.of(context).colorScheme.primary.withOpacity(0.05),
              ],
            ),
            borderRadius: BorderRadius.circular(16),
            border: Border.all(
              color: Theme.of(context).colorScheme.primary.withOpacity(0.2),
            ),
          ),
          child: Row(
            children: [
              Icon(
                Icons.calendar_today_rounded,
                color: Theme.of(context).colorScheme.primary,
                size: 24,
              ),
              const SizedBox(width: 12),
              // In your dashboard_screen.dart, update this section:
              // In your dashboard_screen.dart, update this section:
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      calendarType == CalendarType.ethiopian
                          ? '·ã®·ä¢·âµ·ãÆ·åµ·ã´ ·âÄ·äï ·âÜ·å†·à´'
                          : 'Ethiopian Calendar',
                      style: Theme.of(context).textTheme.labelSmall?.copyWith(
                            color: Theme.of(context).colorScheme.primary,
                            fontWeight: FontWeight.w600,
                          ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      AppDateUtils.getCurrentFullDate(
                          context, ref), // Add ref parameter
                      style: Theme.of(context).textTheme.titleMedium?.copyWith(
                            fontWeight: FontWeight.w700,
                            color: Theme.of(context).colorScheme.onBackground,
                          ),
                    ),
                    const SizedBox(height: 2),
                    Text(
                      DateFormat('HH:mm:ss').format(currentTime),
                      style: Theme.of(context).textTheme.bodySmall?.copyWith(
                            color: Theme.of(context).colorScheme.outline,
                            fontFamily: 'RobotoMono',
                          ),
                    ),
                  ],
                ),
              ),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                decoration: BoxDecoration(
                  color: Theme.of(context).colorScheme.primary.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Text(
                  calendarType == CalendarType.ethiopian ? 'ETH' : 'GREG',
                  style: Theme.of(context).textTheme.labelSmall?.copyWith(
                        color: Theme.of(context).colorScheme.primary,
                        fontWeight: FontWeight.w700,
                      ),
                ),
              ),
            ],
          ),
        );
      },
    );

}

Widget \_buildDesktopLayout(
DashboardData data, AppLocalizations localizations) {
return Row(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
// Main Content - 70%
Expanded(
flex: 7,
child: Column(
children: [
_buildPerformanceOverview(data, localizations),
const SizedBox(height: 20),
RecentSalesList(
sales: data.todaysSales,
localizations: localizations,
),
],
),
),
const SizedBox(width: 20),
// Sidebar - 30%
Expanded(
flex: 3,
child: Column(
children: [
StockAlertWidget(
products: data.lowStockProducts,
localizations: localizations,
),
const SizedBox(height: 20),
QuickActionsWidget(localizations: localizations),
],
),
),
],
);
}

Widget \_buildMobileLayout(
DashboardData data, AppLocalizations localizations) {
return Column(
children: [
_buildPerformanceOverview(data, localizations),
const SizedBox(height: 20),
RecentSalesList(
sales: data.todaysSales,
localizations: localizations,
),
const SizedBox(height: 20),
StockAlertWidget(
products: data.lowStockProducts,
localizations: localizations,
),
const SizedBox(height: 20),
QuickActionsWidget(localizations: localizations),
],
);
}

Widget \_buildPerformanceOverview(
DashboardData data, AppLocalizations localizations) {
return Card(
elevation: 0,
shape: RoundedRectangleBorder(
borderRadius: BorderRadius.circular(20),
side: BorderSide(
color: Theme.of(context).colorScheme.outline.withOpacity(0.1),
),
),
child: Padding(
padding: const EdgeInsets.all(24),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Row(
children: [
Container(
padding: const EdgeInsets.all(8),
decoration: BoxDecoration(
color:
Theme.of(context).colorScheme.primary.withOpacity(0.1),
borderRadius: BorderRadius.circular(12),
),
child: Icon(
Icons.analytics_rounded,
color: Theme.of(context).colorScheme.primary,
size: 24,
),
),
const SizedBox(width: 12),
Text(
localizations.translate('performanceOverview'),
style: Theme.of(context).textTheme.titleLarge?.copyWith(
fontWeight: FontWeight.w700,
),
),
],
),
const SizedBox(height: 24),
LayoutBuilder(
builder: (context, constraints) {
final isWide = constraints.maxWidth > 400;
return GridView.count(
shrinkWrap: true,
physics: const NeverScrollableScrollPhysics(),
crossAxisCount: isWide ? 2 : 1,
crossAxisSpacing: 16,
mainAxisSpacing: 16,
childAspectRatio: isWide ? 3.5 : 2.5,
children: [
MetricCard(
label: localizations.averageOrderValue,
value:
AppFormatters.formatCurrency(data.averageOrderValue),
icon: Icons.shopping_cart_rounded,
localizations: localizations,
),
MetricCard(
label: localizations.totalOrders,
value: data.salesSummary.totalOrders.toString(),
icon: Icons.receipt_long_rounded,
localizations: localizations,
),
MetricCard(
label: localizations.translate('customersWithBalance'),
value: (data.creditSummary['customersWithBalance'] ?? 0)
.toString(),
icon: Icons.people_alt_rounded,
localizations: localizations,
),
MetricCard(
label: localizations.translate('overdueAmount'),
value: AppFormatters.formatCurrency(
data.creditSummary['overdueAmount'] ?? 0),
icon: Icons.warning_amber_rounded,
isWarning: (data.creditSummary['overdueAmount'] ?? 0) > 0,
localizations: localizations,
),
],
);
},
),
],
),
),
);
}

Widget \_buildInsightsSection(
DashboardData data, AppLocalizations localizations) {
return PerformanceInsightsWidget(
data: data,
localizations: localizations,
);
}
}

// Dashboard Data Model
// In your dashboard_screen.dart - update DashboardData
class DashboardData {
final SalesSummary salesSummary;
final Map<String, dynamic> creditSummary;
final List<Sale> todaysSales;
final List<Product> lowStockProducts;
final List<Product> totalProducts;
final List<Customer> allCustomers;
final double totalRevenue;
final double averageOrderValue;
final double dailyGrowth;
final DateTime timestamp;

DashboardData({
required this.salesSummary,
required this.creditSummary,
required this.todaysSales,
required this.lowStockProducts,
required this.totalProducts,
required this.allCustomers,
required this.totalRevenue,
required this.averageOrderValue,
required this.dailyGrowth,
required this.timestamp,
});
}

class DashboardErrorWidget extends StatelessWidget {
final String error;
final VoidCallback onRetry;
final AppLocalizations localizations;

const DashboardErrorWidget({
super.key,
required this.error,
required this.onRetry,
required this.localizations,
});

@override
Widget build(BuildContext context) {
return Center(
child: Padding(
padding: const EdgeInsets.all(32),
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
Icon(
Icons.error_outline_rounded,
size: 64,
color: Theme.of(context).colorScheme.outline,
),
const SizedBox(height: 16),
Text(
localizations.translate('errorLoadingData'),
style: Theme.of(context).textTheme.titleLarge?.copyWith(
fontWeight: FontWeight.w700,
),
),
const SizedBox(height: 12),
Padding(
padding: const EdgeInsets.symmetric(horizontal: 20),
child: Text(
error.contains('DatabaseException')
? localizations.translate('databaseNeedsUpdate')
: error.length > 100
? '${error.substring(0, 100)}...'
: error,
style: Theme.of(context).textTheme.bodyMedium?.copyWith(
color: Theme.of(context).colorScheme.outline,
),
textAlign: TextAlign.center,
maxLines: 3,
),
),
const SizedBox(height: 24),
FilledButton.icon(
onPressed: onRetry,
icon: const Icon(Icons.refresh_rounded),
label: Text(localizations.translate('tryAgain')),
),
],
),
),
);
}
}

class DashboardShimmer extends StatelessWidget {
final AppLocalizations localizations;

const DashboardShimmer({
super.key,
required this.localizations,
});

@override
Widget build(BuildContext context) {
return CustomScrollView(
slivers: [
SliverToBoxAdapter(
child: Padding(
padding: const EdgeInsets.all(20),
child: GridView.count(
shrinkWrap: true,
physics: const NeverScrollableScrollPhysics(),
crossAxisCount: 2,
crossAxisSpacing: 16,
mainAxisSpacing: 16,
childAspectRatio: 1.4,
children: List.generate(
4,
(index) => const LoadingShimmer(
height: 100,
borderRadius: 16,
)),
),
),
),
const SliverToBoxAdapter(
child: Padding(
padding: EdgeInsets.symmetric(horizontal: 20),
child: LoadingShimmer(height: 200, borderRadius: 20),
),
),
SliverToBoxAdapter(
child: Padding(
padding: const EdgeInsets.all(20),
child: Column(
children: [
const LoadingShimmer(height: 180, borderRadius: 20),
const SizedBox(height: 20),
Row(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
const Expanded(
flex: 2,
child: LoadingShimmer(height: 300, borderRadius: 20),
),
const SizedBox(width: 20),
const Expanded(
flex: 1,
child: Column(
children: [
LoadingShimmer(height: 140, borderRadius: 20),
SizedBox(height: 20),
LoadingShimmer(height: 120, borderRadius: 20),
],
),
),
],
),
],
),
),
),
],
);
}
}
// Add these new widgets to your dashboard_screen.dart

class PerformanceInsightsWidget extends StatelessWidget {
final DashboardData data;
final AppLocalizations localizations;

const PerformanceInsightsWidget({
super.key,
required this.data,
required this.localizations,
});

@override
Widget build(BuildContext context) {
final insights = \_generateInsights(data);

    return Card(
      elevation: 0,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(20),
        side: BorderSide(
          color: Theme.of(context).colorScheme.outline.withOpacity(0.1),
        ),
      ),
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color:
                        Theme.of(context).colorScheme.primary.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Icon(
                    Icons.insights_rounded,
                    color: Theme.of(context).colorScheme.primary,
                    size: 24,
                  ),
                ),
                const SizedBox(width: 12),
                Text(
                  'Performance Insights',
                  style: Theme.of(context).textTheme.titleLarge?.copyWith(
                        fontWeight: FontWeight.w700,
                      ),
                ),
              ],
            ),
            const SizedBox(height: 20),
            ...insights.map((insight) => _buildInsightItem(context, insight)),
          ],
        ),
      ),
    );

}

List<DashboardInsight> \_generateInsights(DashboardData data) {
final insights = <DashboardInsight>[];

    // Sales performance insights
    if (data.salesSummary.todaysSales >
        data.salesSummary.weeklySales / 7 * 1.2) {
      insights.add(DashboardInsight(
        type: InsightType.positive,
        title: 'Strong Sales Today',
        message: 'Today\'s sales are 20% above daily average',
        icon: Icons.trending_up_rounded,
      ));
    }

    if (data.lowStockProducts.isNotEmpty) {
      insights.add(DashboardInsight(
        type: InsightType.warning,
        title: 'Low Stock Alert',
        message: '${data.lowStockProducts.length} products need restocking',
        icon: Icons.inventory_2_rounded,
      ));
    }

    // Credit risk insights
    final overdueAmount = data.creditSummary['overdueAmount'] as double? ?? 0.0;
    if (overdueAmount > 1000) {
      insights.add(DashboardInsight(
        type: InsightType.negative,
        title: 'High Overdue Amount',
        message: 'ETB ${overdueAmount.toStringAsFixed(0)} in overdue payments',
        icon: Icons.warning_amber_rounded,
      ));
    }

    // Customer growth insights
    final newCustomers = _getNewCustomersCount(data);
    if (newCustomers > 5) {
      insights.add(DashboardInsight(
        type: InsightType.positive,
        title: 'Customer Growth',
        message: '$newCustomers new customers this week',
        icon: Icons.people_alt_rounded,
      ));
    }

    return insights;

}

int \_getNewCustomersCount(DashboardData data) {
// Calculate new customers from the last 7 days
final weekAgo = DateTime.now().subtract(const Duration(days: 7));
return data.allCustomers
.where((customer) => customer.createdAt.isAfter(weekAgo))
.length;
}

Widget \_buildInsightItem(BuildContext context, DashboardInsight insight) {
Color backgroundColor;
Color textColor;

    switch (insight.type) {
      case InsightType.positive:
        backgroundColor = Colors.green.shade50;
        textColor = Colors.green.shade800;
        break;
      case InsightType.warning:
        backgroundColor = Colors.orange.shade50;
        textColor = Colors.orange.shade800;
        break;
      case InsightType.negative:
        backgroundColor = Colors.red.shade50;
        textColor = Colors.red.shade800;
        break;
    }

    return Container(
      margin: const EdgeInsets.only(bottom: 12),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: backgroundColor,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: textColor.withOpacity(0.2)),
      ),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.all(8),
            decoration: BoxDecoration(
              color: textColor.withOpacity(0.1),
              borderRadius: BorderRadius.circular(8),
            ),
            child: Icon(insight.icon, color: textColor, size: 20),
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  insight.title,
                  style: TextStyle(
                    fontWeight: FontWeight.w600,
                    color: textColor,
                    fontSize: 14,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  insight.message,
                  style: TextStyle(
                    color: textColor.withOpacity(0.8),
                    fontSize: 12,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );

}
}

class DashboardInsight {
final InsightType type;
final String title;
final String message;
final IconData icon;

const DashboardInsight({
required this.type,
required this.title,
required this.message,
required this.icon,
});
}

enum InsightType {
positive,
warning,
negative,
}

##

//lib/src/ui/screens/main_navigation.dart
// Main navigation screen with bottom navigation bar for primary app sections.
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
import 'dashboard_screen.dart';
import 'pos_screen.dart';
import 'sales_history_screen.dart';
import 'customer_management_screen.dart';
import 'product_management_screen.dart';
import 'category_management_screen.dart';
import 'package:andalus_smart_pos/src/ui/screens/account_settings_screen.dart';

class MainNavigation extends ConsumerStatefulWidget {
const MainNavigation({super.key});

@override
ConsumerState<MainNavigation> createState() => \_MainNavigationState();
}

class \_MainNavigationState extends ConsumerState<MainNavigation> {
int \_selectedIndex = 0;

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);

    final List<Widget> screens = [
      const DashboardScreen(),
      const PosScreen(),
      const SalesHistoryScreen(),
      const CustomerManagementScreen(),
      const ProductManagementScreen(),
      const CategoryManagementScreen(),
      const AccountSettingsScreen(), // Use the combined screen
    ];

    final List<BottomNavigationBarItem> navItems = [
      BottomNavigationBarItem(
        icon: const Icon(Icons.dashboard_outlined),
        activeIcon: const Icon(Icons.dashboard),
        label: localizations.dashboard,
      ),
      BottomNavigationBarItem(
        icon: const Icon(Icons.point_of_sale_outlined),
        activeIcon: const Icon(Icons.point_of_sale),
        label: localizations.pointOfSale,
      ),
      BottomNavigationBarItem(
        icon: const Icon(Icons.receipt_long_outlined),
        activeIcon: const Icon(Icons.receipt_long),
        label: localizations.salesHistory,
      ),
      BottomNavigationBarItem(
        icon: const Icon(Icons.people_outline),
        activeIcon: const Icon(Icons.people),
        label: localizations.customers,
      ),
      BottomNavigationBarItem(
        icon: const Icon(Icons.inventory_2_outlined),
        activeIcon: const Icon(Icons.inventory_2),
        label: localizations.products,
      ),
      BottomNavigationBarItem(
        icon: const Icon(Icons.category_outlined),
        activeIcon: const Icon(Icons.category),
        label: localizations.categories,
      ),
      BottomNavigationBarItem(
        icon: const Icon(Icons.settings_outlined),
        activeIcon: const Icon(Icons.settings),
        label: localizations.settings, // Now this shows both account & settings
      ),
    ];

    return Scaffold(
      body: screens[_selectedIndex],
      bottomNavigationBar: Container(
        decoration: BoxDecoration(
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.1),
              blurRadius: 8,
              offset: const Offset(0, -2),
            ),
          ],
        ),
        child: BottomNavigationBar(
          currentIndex: _selectedIndex,
          onTap: (index) => setState(() => _selectedIndex = index),
          type: BottomNavigationBarType.fixed,
          backgroundColor: Colors.white,
          selectedItemColor: const Color(0xFF10B981),
          unselectedItemColor: Colors.grey.shade600,
          selectedLabelStyle: const TextStyle(fontWeight: FontWeight.w500),
          unselectedLabelStyle: const TextStyle(fontWeight: FontWeight.w400),
          items: navItems,
        ),
      ),
    );

}
}

##

// lib/src/ui/screens/pos_screen.dart
// Point of Sale (POS) screen for managing product sales, cart, and printing receipts.
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/data/models/customer.dart';
import 'package:andalus_smart_pos/src/data/models/product.dart';
import 'package:andalus_smart_pos/src/data/models/sale.dart';
import 'package:andalus_smart_pos/src/data/models/sale_item.dart';
import 'package:andalus_smart_pos/src/data/models/cart_item.dart';
import 'package:andalus_smart_pos/src/data/repositories/customer_repository.dart';
import 'package:andalus_smart_pos/src/data/repositories/product_repository.dart';
import 'package:andalus_smart_pos/src/data/repositories/sale_repository.dart';
import 'package:andalus_smart_pos/src/providers/cart_provider.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
import 'package:andalus_smart_pos/src/utils/formatters.dart';
import 'package:andalus_smart_pos/src/utils/print_service.dart';
import 'package:andalus_smart_pos/src/ui/screens/printer_connection_screen.dart';
import 'package:andalus_smart_pos/src/widgets/common/custom_card.dart';
import 'package:andalus_smart_pos/src/widgets/common/loading_shimmer.dart';

class PosScreen extends ConsumerStatefulWidget {
const PosScreen({super.key});

@override
ConsumerState<PosScreen> createState() => \_PosScreenState();
}

class \_PosScreenState extends ConsumerState<PosScreen> {
final TextEditingController \_searchController = TextEditingController();
final TextEditingController \_barcodeController = TextEditingController();
final FocusNode \_barcodeFocusNode = FocusNode();

List<Product> \_filteredProducts = [];
List<Product> \_allProducts = [];
bool \_isLoading = true;
String \_selectedCategory = 'all';
bool \_isPrinting = false;

@override
void initState() {
super.initState();
\_loadProducts();
\_searchController.addListener(\_onSearchChanged);
}

@override
void dispose() {
\_searchController.dispose();
\_barcodeController.dispose();
\_barcodeFocusNode.dispose();
super.dispose();
}

Future<void> \_loadProducts() async {
setState(() => \_isLoading = true);
try {
final repository = ref.read(productRepositoryProvider);
final products = await repository.getAllProducts();
setState(() {
\_allProducts = products;
\_filteredProducts = products;
\_isLoading = false;
});
} catch (e) {
setState(() => \_isLoading = false);
if (mounted) {
\_showErrorSnackBar('Error loading products: $e');
}
}
}

void \_onSearchChanged() {
final query = \_searchController.text.toLowerCase();
setState(() {
\_filteredProducts = \_allProducts.where((product) {
final matchesSearch = product.name.toLowerCase().contains(query) ||
product.nameAm.toLowerCase().contains(query) ||
product.barcode.toLowerCase().contains(query);
final matchesCategory = \_selectedCategory == 'all' ||
product.categoryId == \_selectedCategory;
return matchesSearch && matchesCategory;
}).toList();
});
}

void \_addToCart(Product product) {
if (product.stockQuantity <= 0) {
\_showWarningSnackBar('${product.name} is out of stock');
return;
}

    ref.read(cartProvider.notifier).addProduct(
          productId: product.id!,
          productName: product.name,
          unitPrice: product.price,
        );

    _showSuccessSnackBar('Added ${product.name} to cart');

}

void \_scanBarcode() {
if (\_barcodeController.text.isNotEmpty) {
final barcode = \_barcodeController.text.trim();
final product = \_allProducts.firstWhere(
(p) => p.barcode == barcode,
orElse: () => Product(
id: -1,
productId: '',
name: '',
nameAm: '',
price: 0,
stockQuantity: 0,
barcode: '',
categoryId: '',
createdAt: DateTime.now(),
updatedAt: DateTime.now(),
),
);

      if (product.id != -1) {
        _addToCart(product);
        _barcodeController.clear();
        _barcodeFocusNode.requestFocus();
      } else {
        _showWarningSnackBar('Product not found');
      }
    }

}

// Snackbar helpers
void \_showSuccessSnackBar(String message) {
ScaffoldMessenger.of(context).showSnackBar(
SnackBar(
content: Row(
children: [
const Icon(Icons.check_circle, color: Colors.white, size: 20),
const SizedBox(width: 8),
Expanded(child: Text(message)),
],
),
backgroundColor: Theme.of(context).colorScheme.primary,
behavior: SnackBarBehavior.floating,
shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
duration: const Duration(seconds: 2),
),
);
}

void \_showErrorSnackBar(String message) {
ScaffoldMessenger.of(context).showSnackBar(
SnackBar(
content: Text(message),
backgroundColor: Theme.of(context).colorScheme.error,
),
);
}

void \_showWarningSnackBar(String message) {
ScaffoldMessenger.of(context).showSnackBar(
SnackBar(
content: Text(message),
backgroundColor: Colors.orange,
),
);
}

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);
final cart = ref.watch(cartProvider);
final cartNotifier = ref.read(cartProvider.notifier);

    return Scaffold(
      backgroundColor: theme.colorScheme.background,
      body: Column(
        children: [
          // FIXED: Proper Header with Search
          _buildHeaderSection(localizations, theme),

          // Main Content Area
          Expanded(
            child: Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Products Section
                Expanded(
                  flex: 3,
                  child: _buildProductsSection(localizations, theme),
                ),

                // Cart Panel
                _buildCartPanel(cart, cartNotifier, localizations, theme),
              ],
            ),
          ),
        ],
      ),
    );

}

// FIXED: Header with proper search box
Widget \_buildHeaderSection(AppLocalizations localizations, ThemeData theme) {
return Container(
decoration: BoxDecoration(
color: theme.colorScheme.primary,
boxShadow: [
BoxShadow(
color: theme.colorScheme.shadow.withOpacity(0.1),
blurRadius: 8,
offset: const Offset(0, 2),
),
],
),
child: SafeArea(
bottom: false,
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
children: [
// Title and Printer Status Row
Row(
children: [
// Title
Expanded(
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
localizations.pointOfSale,
style: theme.textTheme.titleLarge?.copyWith(
color: theme.colorScheme.onPrimary,
fontWeight: FontWeight.bold,
),
),
const SizedBox(height: 2),
Text(
localizations.searchProducts,
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.onPrimary.withOpacity(0.8),
),
),
],
),
),

                  // Printer Status
                  _buildPrinterStatus(theme, localizations),

                  const SizedBox(width: 12),

                  // Cart Badge
                  _buildCartBadge(localizations, theme),
                ],
              ),

              const SizedBox(height: 16),

              // FIXED: Search Box - Now properly visible
              _buildSearchBox(localizations, theme),
            ],
          ),
        ),
      ),
    );

}

// FIXED: Search Box Widget
Widget _buildSearchBox(AppLocalizations localizations, ThemeData theme) {
return Row(
children: [
// Search Field
Expanded(
child: Container(
decoration: BoxDecoration(
color: theme.colorScheme.onPrimary.withOpacity(0.1),
borderRadius: BorderRadius.circular(12),
),
child: TextField(
controller: \_searchController,
decoration: InputDecoration(
hintText: localizations.searchProducts,
hintStyle: TextStyle(
color: theme.colorScheme.onPrimary.withOpacity(0.7),
),
prefixIcon: Icon(
Icons.search,
color: theme.colorScheme.onPrimary.withOpacity(0.7),
),
border: InputBorder.none,
contentPadding: const EdgeInsets.symmetric(horizontal: 16),
),
style: TextStyle(
color: theme.colorScheme.onPrimary,
),
onChanged: (_) => \_onSearchChanged(),
),
),
),

        const SizedBox(width: 12),

        // Print Button - Now visible in header
        Tooltip(
          message: PrintService.isConnected
              ? 'Print Test Receipt'
              : 'Connect Printer First',
          child: Container(
            decoration: BoxDecoration(
              color: theme.colorScheme.onPrimary.withOpacity(0.2),
              borderRadius: BorderRadius.circular(12),
            ),
            child: IconButton(
              icon: Icon(
                Icons.print,
                color: PrintService.isConnected
                    ? theme.colorScheme.onPrimary
                    : theme.colorScheme.onPrimary.withOpacity(0.5),
              ),
              onPressed: PrintService.isConnected
                  ? _testPrint
                  : _navigateToPrinterConnection,
            ),
          ),
        ),
      ],
    );

}

Widget \_buildPrinterStatus(ThemeData theme, AppLocalizations localizations) {
return Tooltip(
message: PrintService.isConnected
? '${localizations.translate("connectedTo")} ${PrintService.connectedDeviceName}'
: localizations.translate("noPrinterConnected"),
child: Container(
padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
decoration: BoxDecoration(
color: theme.colorScheme.onPrimary.withOpacity(0.2),
borderRadius: BorderRadius.circular(20),
),
child: Row(
mainAxisSize: MainAxisSize.min,
children: [
Icon(
PrintService.isConnected ? Icons.print : Icons.print_disabled,
size: 16,
color: PrintService.isConnected
? theme.colorScheme.onPrimary
: Colors.amber[300],
),
const SizedBox(width: 6),
Text(
PrintService.isConnected ? 'Connected' : 'No Printer',
style: theme.textTheme.bodySmall?.copyWith(
color: theme.colorScheme.onPrimary,
fontWeight: FontWeight.w500,
),
),
],
),
),
);
}

Widget \_buildCartBadge(AppLocalizations localizations, ThemeData theme) {
final cart = ref.watch(cartProvider);
return Badge(
label: Text(
ref.read(cartProvider.notifier).totalItems.toString(),
style: TextStyle(
fontSize: 10,
color: theme.colorScheme.primary,
fontWeight: FontWeight.bold,
),
),
isLabelVisible: cart.isNotEmpty,
backgroundColor: theme.colorScheme.onPrimary,
child: IconButton(
icon: Icon(Icons.shopping_cart, color: theme.colorScheme.onPrimary),
onPressed: () {},
tooltip: localizations.shoppingCart,
),
);
}

Widget \_buildProductsSection(
AppLocalizations localizations, ThemeData theme) {
return Column(
children: [
// Barcode Scanner Section
\_buildBarcodeSection(localizations, theme),

        // Products Grid
        Expanded(
          child: _isLoading
              ? _buildProductsShimmer()
              : _filteredProducts.isEmpty
                  ? _buildEmptyProducts(localizations, theme)
                  : _buildProductsGrid(localizations, theme),
        ),
      ],
    );

}

Widget _buildBarcodeSection(AppLocalizations localizations, ThemeData theme) {
return CustomCard(
margin: const EdgeInsets.all(16),
padding: const EdgeInsets.all(16),
child: Row(
children: [
// Barcode Input
Expanded(
child: TextField(
controller: \_barcodeController,
focusNode: \_barcodeFocusNode,
decoration: InputDecoration(
labelText: localizations.translate('scanBarcode'),
border: OutlineInputBorder(
borderRadius: BorderRadius.circular(12),
),
contentPadding: const EdgeInsets.symmetric(horizontal: 16),
),
onSubmitted: (_) => \_scanBarcode(),
),
),
const SizedBox(width: 12),
// Scan Button
SizedBox(
height: 56,
child: ElevatedButton.icon(
onPressed: \_scanBarcode,
icon: const Icon(Icons.qr_code_scanner, size: 20),
label: Text(localizations.translate('scan')),
style: ElevatedButton.styleFrom(
backgroundColor: theme.colorScheme.primary,
foregroundColor: theme.colorScheme.onPrimary,
shape: RoundedRectangleBorder(
borderRadius: BorderRadius.circular(12),
),
),
),
),
],
),
);
}

Widget \_buildProductsShimmer() {
return GridView.builder(
padding: const EdgeInsets.all(16),
gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
crossAxisCount: 3,
crossAxisSpacing: 12,
mainAxisSpacing: 12,
childAspectRatio: 0.85,
),
itemCount: 9,
itemBuilder: (context, index) => const LoadingShimmer(
height: 120,
borderRadius: 12,
),
);
}

Widget \_buildProductsGrid(AppLocalizations localizations, ThemeData theme) {
return Column(
children: [
// Category Filter
SizedBox(
height: 60,
child: \_buildCategoryFilter(theme),
),

        // Products Grid
        Expanded(
          child: GridView.builder(
            padding: const EdgeInsets.all(16),
            gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: 3,
              crossAxisSpacing: 12,
              mainAxisSpacing: 12,
              childAspectRatio: 0.85,
            ),
            itemCount: _filteredProducts.length,
            itemBuilder: (context, index) {
              final product = _filteredProducts[index];
              return _ProductCard(
                product: product,
                onTap: () => _addToCart(product),
              );
            },
          ),
        ),
      ],
    );

}

Widget \_buildCategoryFilter(ThemeData theme) {
return ListView.separated(
padding: const EdgeInsets.symmetric(horizontal: 16),
scrollDirection: Axis.horizontal,
itemCount: \_getCategories().length,
separatorBuilder: (context, index) => const SizedBox(width: 8),
itemBuilder: (context, index) {
final category = \_getCategories()[index];
final isSelected = \_selectedCategory == category;
return FilterChip(
label: Text(category == 'all' ? 'All Categories' : category),
selected: isSelected,
onSelected: (selected) {
setState(() => \_selectedCategory = category);
\_onSearchChanged();
},
backgroundColor: theme.colorScheme.surface,
selectedColor: theme.colorScheme.primary.withOpacity(0.1),
checkmarkColor: theme.colorScheme.primary,
labelStyle: TextStyle(
color: isSelected
? theme.colorScheme.primary
: theme.colorScheme.onSurface,
),
side: BorderSide(
color: isSelected
? theme.colorScheme.primary
: theme.colorScheme.outline.withOpacity(0.3),
),
);
},
);
}

Widget \_buildCartPanel(List<CartItem> cart, CartNotifier cartNotifier,
AppLocalizations localizations, ThemeData theme) {
return Container(
width: 400,
margin: const EdgeInsets.all(16),
child: CustomCard(
margin: EdgeInsets.zero,
padding: EdgeInsets.zero,
child: Column(
children: [
// Cart Header
Container(
padding: const EdgeInsets.all(20),
decoration: BoxDecoration(
color: theme.colorScheme.primary,
borderRadius: const BorderRadius.only(
topLeft: Radius.circular(16),
topRight: Radius.circular(16),
),
),
child: Row(
children: [
Icon(Icons.shopping_cart, color: theme.colorScheme.onPrimary),
const SizedBox(width: 12),
Text(
localizations.translate('orderSummary'),
style: TextStyle(
color: theme.colorScheme.onPrimary,
fontSize: 18,
fontWeight: FontWeight.bold,
),
),
const Spacer(),
if (cart.isNotEmpty)
TextButton(
onPressed: () => cartNotifier.clearCart(),
style: TextButton.styleFrom(
foregroundColor: theme.colorScheme.onPrimary,
),
child: Text(localizations.clearAll),
),
Badge(
label: Text(cartNotifier.totalItems.toString()),
backgroundColor: theme.colorScheme.onPrimary,
textColor: theme.colorScheme.primary,
),
],
),
),

            // Cart Items
            Expanded(
              child: cart.isEmpty
                  ? _EmptyCart(localizations: localizations)
                  : ListView.builder(
                      padding: const EdgeInsets.all(16),
                      itemCount: cart.length,
                      itemBuilder: (context, index) {
                        final item = cart[index];
                        return _CartItem(
                          item: item,
                          onQuantityChanged: (newQuantity) {
                            if (newQuantity > 0) {
                              cartNotifier.updateQuantity(
                                  item.productId, newQuantity);
                            } else {
                              cartNotifier.removeProduct(item.productId);
                            }
                          },
                          onRemove: () {
                            cartNotifier.removeProduct(item.productId);
                          },
                        );
                      },
                    ),
            ),

            // Cart Footer with Print Button
            Container(
              padding: const EdgeInsets.all(20),
              decoration: BoxDecoration(
                border: Border(
                  top: BorderSide(
                      color: theme.colorScheme.outline.withOpacity(0.2)),
                ),
              ),
              child: Column(
                children: [
                  // Totals
                  _buildTotalRow(localizations.translate('subtotal'),
                      cartNotifier.subtotalAmount, theme),
                  const SizedBox(height: 8),
                  _buildTotalRow(localizations.translate('total'),
                      cartNotifier.totalAmount, theme,
                      isTotal: true),

                  const SizedBox(height: 16),

                  // FIXED: Action Buttons with Print Option
                  _buildActionButtons(cartNotifier, localizations, theme),
                ],
              ),
            ),
          ],
        ),
      ),
    );

}

Widget \_buildTotalRow(String label, double amount, ThemeData theme,
{bool isTotal = false}) {
return Row(
mainAxisAlignment: MainAxisAlignment.spaceBetween,
children: [
Text(
label,
style: TextStyle(
fontSize: isTotal ? 16 : 14,
fontWeight: isTotal ? FontWeight.bold : FontWeight.normal,
color: isTotal
? theme.colorScheme.onSurface
: theme.colorScheme.onSurface.withOpacity(0.7),
),
),
Text(
AppFormatters.formatCurrency(amount),
style: TextStyle(
fontSize: isTotal ? 18 : 14,
fontWeight: FontWeight.bold,
color: isTotal
? theme.colorScheme.primary
: theme.colorScheme.onSurface,
),
),
],
);
}

// FIXED: Action Buttons with Print Option
Widget \_buildActionButtons(CartNotifier cartNotifier,
AppLocalizations localizations, ThemeData theme) {
final cart = ref.watch(cartProvider);

    return Column(
      children: [
        // Complete Sale Button
        SizedBox(
          width: double.infinity,
          height: 56,
          child: ElevatedButton(
            onPressed: _completeSale,
            style: ElevatedButton.styleFrom(
              backgroundColor: theme.colorScheme.primary,
              foregroundColor: theme.colorScheme.onPrimary,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(12),
              ),
              elevation: 2,
            ),
            child: _isPrinting
                ? SizedBox(
                    height: 20,
                    width: 20,
                    child: CircularProgressIndicator(
                      strokeWidth: 2,
                      valueColor: AlwaysStoppedAnimation<Color>(
                          theme.colorScheme.onPrimary),
                    ),
                  )
                : Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      const Icon(Icons.payment, size: 20),
                      const SizedBox(width: 8),
                      Text(
                        localizations.completeSale,
                        style: const TextStyle(
                          fontSize: 16,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ],
                  ),
          ),
        ),

        if (cart.isNotEmpty) ...[
          const SizedBox(height: 8),

          // Print and Clear Buttons Row
          Row(
            children: [
              // Print Button
              Expanded(
                child: OutlinedButton.icon(
                  onPressed: _isPrinting ? null : _testPrint,
                  icon: Icon(
                    Icons.print,
                    size: 18,
                    color: theme.colorScheme.primary,
                  ),
                  label: Text(
                    localizations.translate('testPrint'),
                    style: TextStyle(color: theme.colorScheme.primary),
                  ),
                  style: OutlinedButton.styleFrom(
                    side: BorderSide(color: theme.colorScheme.primary),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                  ),
                ),
              ),
              const SizedBox(width: 8),

              // Clear Cart Button
              Expanded(
                child: OutlinedButton.icon(
                  onPressed: () => cartNotifier.clearCart(),
                  icon: Icon(
                    Icons.clear_all,
                    size: 18,
                    color: theme.colorScheme.error,
                  ),
                  label: Text(
                    localizations.clearAll,
                    style: TextStyle(color: theme.colorScheme.error),
                  ),
                  style: OutlinedButton.styleFrom(
                    side: BorderSide(color: theme.colorScheme.error),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                  ),
                ),
              ),
            ],
          ),
        ],
      ],
    );

}

Widget \_buildEmptyProducts(AppLocalizations localizations, ThemeData theme) {
return Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
Icon(Icons.search_off, size: 64, color: theme.colorScheme.outline),
const SizedBox(height: 16),
Text(
localizations.noProductsFound,
style: theme.textTheme.titleMedium?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.6),
),
),
const SizedBox(height: 8),
Text(
localizations.translate('tryAdjustingSearch'),
style: TextStyle(color: theme.colorScheme.outline),
textAlign: TextAlign.center,
),
],
),
);
}

List<String> \_getCategories() {
final categories = \_allProducts.map((p) => p.categoryId).toSet().toList();
return ['all', ...categories];
}

// Payment and Printing Methods
Future<void> \_completeSale() async {
final cart = ref.read(cartProvider);
if (cart.isEmpty) {
\_showWarningSnackBar('Please add products to cart first');
return;
}

    // Check stock availability
    for (final item in cart) {
      final product = _allProducts.firstWhere(
        (p) => p.id == item.productId,
        orElse: () => Product(
          id: -1,
          productId: '',
          name: '',
          nameAm: '',
          price: 0,
          stockQuantity: 0,
          barcode: '',
          categoryId: '',
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        ),
      );

      if (product.id != -1 && product.stockQuantity < item.quantity) {
        _showErrorSnackBar(
            'Insufficient stock for ${product.name}. Available: ${product.stockQuantity}');
        return;
      }
    }

    final total = ref.read(cartProvider.notifier).totalAmount;
    await _showPaymentMethodDialog(total, cart);

}

Future<void> \_showPaymentMethodDialog(
double total, List<CartItem> cart) async {
final result = await showDialog<Map<String, dynamic>>(
context: context,
builder: (context) => PaymentMethodDialog(total: total),
);

    if (result != null && mounted) {
      final paymentMethod = result['method'] as String;
      final customer = result['customer'] as Customer?;
      await _processSale(total, cart, paymentMethod, customer);
    }

}

Future<void> \_processSale(double total, List<CartItem> cart,
String paymentMethod, Customer? customer) async {
setState(() => \_isPrinting = true);

    try {
      final saleRepository = ref.read(saleRepositoryProvider);
      final customerRepository = ref.read(customerRepositoryProvider);

      // Create sale object
      final sale = Sale(
        localId: 'sale_${DateTime.now().millisecondsSinceEpoch}',
        totalAmount: total,
        finalAmount: total,
        paymentMethod: paymentMethod,
        paymentStatus: 'completed',
        userId: 1,
        shopId: 1,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
        saleId: 'SALE${DateTime.now().millisecondsSinceEpoch}',
      );

      // Convert cart items to sale items
      final saleItems = cart
          .map((cartItem) => SaleItem(
                saleId: "0",
                productId: cartItem.productId as String,
                productName: cartItem.productName,
                quantity: cartItem.quantity,
                unitPrice: cartItem.unitPrice,
                totalPrice: cartItem.totalPrice,
                createdAt: DateTime.now(),
              ))
          .toList();

      // Handle credit sale
      if (paymentMethod == 'credit' && customer != null) {
        final creditResult = await customerRepository.createCreditSale(
          customerId: customer.id!,
          amount: total,
          saleReference: sale.saleId,
          notes: 'POS Sale - ${cart.length} items',
        );

        if (!creditResult.success) {
          _showErrorSnackBar('Credit sale failed: ${creditResult.error}');
          return;
        }
      }

      // Save sale to database
      final saleId = await saleRepository.createSale(sale, saleItems);

      // Update product stock
      final productRepo = ref.read(productRepositoryProvider);
      for (final item in cart) {
        final product = _allProducts.firstWhere((p) => p.id == item.productId);
        if (product.trackInventory) {
          await productRepo.updateStockQuantity(
              item.productId, product.stockQuantity - item.quantity);
        }
      }

      // Print receipt
      final printSuccess = await _printReceipt(
        saleId: saleId,
        cart: cart,
        total: total,
        paymentMethod: paymentMethod,
        customer: customer,
      );

      // Clear cart
      ref.read(cartProvider.notifier).clearCart();

      // Show success message
      if (mounted) {
        _showSuccessSnackBar(
          'Sale #$saleId completed successfully!${printSuccess ? '' : ' (Receipt not printed)'}',
        );
      }

      // Reload products
      _loadProducts();
    } catch (e) {
      if (mounted) {
        _showErrorSnackBar('Error processing sale: $e');
      }
    } finally {
      setState(() => _isPrinting = false);
    }

}

Future<bool> \_printReceipt({
required int saleId,
required List<CartItem> cart,
required double total,
required String paymentMethod,
required Customer? customer,
}) async {
try {
final printItems = cart
.map((item) => {
'name': item.productName,
'quantity': item.quantity,
'price': item.unitPrice,
'total': item.totalPrice,
})
.toList();

      final subtotal = ref.read(cartProvider.notifier).subtotalAmount;

// In your pos*screen.dart, update the printReceipt call:
final success = await PrintService.printReceipt(
context: context,
shopName: 'Andalus Smart POS',
shopNameAm: '·ä†·äï·ã≥·àâ·àµ ·àµ·àõ·à≠·âµ ·çñ·àµ',
address: 'Addis Ababa, Ethiopia',
phone: '+251911223344',
tinNumber: '1234567890',
receiptNumber: 'REC-$saleId',
        dateTime: DateTime.now(),
        items: printItems,
        subtotal: subtotal,
        tax: 0.0,
        discount: 0.0,
        total: total,
        paymentMethod: paymentMethod,
        telebirrRef: paymentMethod == 'telebirr'
            ? 'TEL${DateTime.now().millisecondsSinceEpoch}'
: null,
sale: Sale(
saleId: 'REC-$saleId',
localId: 'local*${DateTime.now().millisecondsSinceEpoch}',
totalAmount: total,
finalAmount: total,
paymentMethod: paymentMethod,
userId: 1,
shopId: 1,
createdAt: DateTime.now(),
), // Add sale parameter
businessInfo: {
'shopName': 'Andalus Smart POS',
'shopNameAm': '·ä†·äï·ã≥·àâ·àµ ·àµ·àõ·à≠·âµ ·çñ·àµ',
'address': 'Addis Ababa, Ethiopia',
'phone': '+251911223344',
'tinNumber': '1234567890',
}, // Add businessInfo parameter
);
return success;
} catch (e) {
print('Printing error: $e');
return false;
}
}

void \_testPrint() async {
final cart = ref.read(cartProvider);
if (cart.isEmpty) {
\_showWarningSnackBar('Please add products to cart first');
return;
}

    setState(() => _isPrinting = true);
    final success = await _printReceipt(
      saleId: 999,
      cart: cart,
      total: ref.read(cartProvider.notifier).totalAmount,
      paymentMethod: 'cash',
      customer: null,
    );

    setState(() => _isPrinting = false);

    if (!success && mounted) {
      _showPrinterConnectionDialog();
    }

}

void \_showPrinterConnectionDialog() {
showDialog(
context: context,
builder: (context) => AlertDialog(
title: const Text('Printer Not Connected'),
content: const Text('Please connect a printer to print receipts.'),
actions: [
TextButton(
onPressed: () => Navigator.pop(context),
child: const Text('Cancel'),
),
TextButton(
onPressed: () {
Navigator.pop(context);
_navigateToPrinterConnection();
},
child: const Text('Connect Printer'),
),
],
),
);
}

void \_navigateToPrinterConnection() {
Navigator.push(
context,
MaterialPageRoute(builder: (context) => const PrinterConnectionScreen()),
);
}
}

// Keep the existing \_ProductCard, \_CartItem, \_EmptyCart, and PaymentMethodDialog classes...
// [The rest of the widget classes remain the same as in the previous implementation]
// Modern Product Card
class \_ProductCard extends StatelessWidget {
final Product product;
final VoidCallback onTap;

const \_ProductCard({
required this.product,
required this.onTap,
});

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);

    return CustomCard(
      margin: EdgeInsets.zero,
      onTap: onTap,
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Stock Status Badge
          if (product.isLowStock || product.isOutOfStock)
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
              decoration: BoxDecoration(
                color: product.isOutOfStock
                    ? theme.colorScheme.errorContainer
                    : Colors.orange.shade50,
                borderRadius: BorderRadius.circular(6),
                border: Border.all(
                  color: product.isOutOfStock
                      ? theme.colorScheme.error
                      : Colors.orange.shade200,
                ),
              ),
              child: Text(
                product.isOutOfStock ? 'OUT OF STOCK' : 'LOW STOCK',
                style: TextStyle(
                  fontSize: 10,
                  fontWeight: FontWeight.bold,
                  color: product.isOutOfStock
                      ? theme.colorScheme.error
                      : Colors.orange.shade700,
                ),
              ),
            )
          else
            const SizedBox(height: 20),

          const Spacer(),

          // Product Name
          Text(
            product.name,
            style: theme.textTheme.bodyLarge?.copyWith(
              fontWeight: FontWeight.w600,
              height: 1.2,
            ),
            maxLines: 2,
            overflow: TextOverflow.ellipsis,
          ),

          const SizedBox(height: 8),

          // Price
          Text(
            AppFormatters.formatCurrency(product.price),
            style: theme.textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.bold,
              color: theme.colorScheme.primary,
            ),
          ),

          const SizedBox(height: 4),

          // Stock and Barcode
          Text(
            'Stock: ${product.stockQuantity}',
            style: theme.textTheme.bodySmall?.copyWith(
              color: product.isLowStock
                  ? Colors.orange.shade700
                  : theme.colorScheme.onSurface.withOpacity(0.6),
              fontWeight:
                  product.isLowStock ? FontWeight.w600 : FontWeight.normal,
            ),
          ),
          if (product.barcode.isNotEmpty) ...[
            const SizedBox(height: 2),
            Text(
              'Barcode: ${product.barcode}',
              style: theme.textTheme.bodySmall?.copyWith(
                color: theme.colorScheme.onSurface.withOpacity(0.5),
              ),
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
            ),
          ],
        ],
      ),
    );

}
}

// Modern Cart Item
class \_CartItem extends StatelessWidget {
final CartItem item;
final Function(int) onQuantityChanged;
final VoidCallback onRemove;

const \_CartItem({
required this.item,
required this.onQuantityChanged,
required this.onRemove,
});

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);

    return Container(
      margin: const EdgeInsets.only(bottom: 12),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.colorScheme.surfaceVariant.withOpacity(0.3),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: theme.colorScheme.outline.withOpacity(0.2)),
      ),
      child: Row(
        children: [
          // Product Info
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  item.productName,
                  style: theme.textTheme.bodyLarge?.copyWith(
                    fontWeight: FontWeight.w600,
                  ),
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                ),
                const SizedBox(height: 4),
                Text(
                  AppFormatters.formatCurrency(item.unitPrice),
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: theme.colorScheme.onSurface.withOpacity(0.6),
                  ),
                ),
              ],
            ),
          ),

          const SizedBox(width: 12),

          // Quantity Controls
          Container(
            decoration: BoxDecoration(
              color: theme.colorScheme.surface,
              borderRadius: BorderRadius.circular(8),
              border:
                  Border.all(color: theme.colorScheme.outline.withOpacity(0.3)),
            ),
            child: Row(
              children: [
                IconButton(
                  icon: Icon(Icons.remove,
                      size: 18, color: theme.colorScheme.primary),
                  onPressed: () => onQuantityChanged(item.quantity - 1),
                  padding: const EdgeInsets.all(4),
                  constraints: const BoxConstraints(
                    minWidth: 32,
                    minHeight: 32,
                  ),
                ),
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 12),
                  child: Text(
                    item.quantity.toString(),
                    style: theme.textTheme.bodyLarge?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
                IconButton(
                  icon: Icon(Icons.add,
                      size: 18, color: theme.colorScheme.primary),
                  onPressed: () => onQuantityChanged(item.quantity + 1),
                  padding: const EdgeInsets.all(4),
                  constraints: const BoxConstraints(
                    minWidth: 32,
                    minHeight: 32,
                  ),
                ),
              ],
            ),
          ),

          const SizedBox(width: 12),

          // Total and Remove
          Column(
            crossAxisAlignment: CrossAxisAlignment.end,
            children: [
              Text(
                AppFormatters.formatCurrency(item.totalPrice),
                style: theme.textTheme.bodyLarge?.copyWith(
                  fontWeight: FontWeight.bold,
                  color: theme.colorScheme.primary,
                ),
              ),
              const SizedBox(height: 8),
              IconButton(
                icon: Icon(
                  Icons.delete_outline,
                  size: 18,
                  color: theme.colorScheme.onSurface.withOpacity(0.5),
                ),
                onPressed: onRemove,
                padding: EdgeInsets.zero,
                constraints: const BoxConstraints(
                  minWidth: 24,
                  minHeight: 24,
                ),
              ),
            ],
          ),
        ],
      ),
    );

}
}

// Empty Cart State
class \_EmptyCart extends StatelessWidget {
final AppLocalizations localizations;

const \_EmptyCart({required this.localizations});

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);

    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.shopping_cart_outlined,
            size: 64,
            color: theme.colorScheme.outline,
          ),
          const SizedBox(height: 16),
          Text(
            localizations.yourCartEmpty,
            style: theme.textTheme.titleMedium?.copyWith(
              color: theme.colorScheme.onSurface.withOpacity(0.6),
            ),
          ),
          const SizedBox(height: 8),
          Text(
            localizations.addProductsGetStarted,
            style: theme.textTheme.bodyMedium?.copyWith(
              color: theme.colorScheme.outline,
            ),
          ),
        ],
      ),
    );

}
}

// Payment Method Dialog
class PaymentMethodDialog extends ConsumerStatefulWidget {
final double total;

const PaymentMethodDialog({super.key, required this.total});

@override
ConsumerState<PaymentMethodDialog> createState() =>
\_PaymentMethodDialogState();
}

class \_PaymentMethodDialogState extends ConsumerState<PaymentMethodDialog> {
String \_selectedMethod = 'cash';
Customer? \_selectedCustomer;

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);
final localizations = AppLocalizations.of(context);

    return Dialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              localizations.selectPaymentMethod,
              style: theme.textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              '${localizations.totalAmount}: ${AppFormatters.formatCurrency(widget.total)}',
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.w600,
                color: theme.colorScheme.primary,
              ),
            ),
            const SizedBox(height: 24),

            // Payment Methods
            _buildPaymentMethodOption(
                'cash', localizations.cash, Icons.money, theme),
            _buildPaymentMethodOption(
                'telebirr', localizations.telebirr, Icons.qr_code, theme),
            _buildPaymentMethodOption(
                'card', localizations.card, Icons.credit_card, theme),
            _buildPaymentMethodOption(
                'credit', localizations.credit, Icons.credit_score, theme),

            // Customer Selection for Credit
            if (_selectedMethod == 'credit') ...[
              const SizedBox(height: 16),
              _buildCustomerSelector(localizations, theme),
            ],

            const SizedBox(height: 24),
            Row(
              children: [
                Expanded(
                  child: OutlinedButton(
                    onPressed: () => Navigator.pop(context),
                    child: Text(localizations.cancel),
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: ElevatedButton(
                    onPressed: _canProceed
                        ? () => Navigator.pop(context, {
                              'method': _selectedMethod,
                              'customer': _selectedCustomer,
                            })
                        : null,
                    style: ElevatedButton.styleFrom(
                      backgroundColor: theme.colorScheme.primary,
                      foregroundColor: theme.colorScheme.onPrimary,
                    ),
                    child: Text(localizations.confirm),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );

}

Widget \_buildPaymentMethodOption(
String value, String label, IconData icon, ThemeData theme) {
return RadioListTile<String>(
value: value,
groupValue: \_selectedMethod,
onChanged: (newValue) => setState(() => \_selectedMethod = newValue!),
title: Row(
children: [
Icon(icon, size: 20, color: theme.colorScheme.primary),
const SizedBox(width: 8),
Text(
label,
style: theme.textTheme.bodyLarge
?.copyWith(fontWeight: FontWeight.w500),
),
],
),
);
}

Widget \_buildCustomerSelector(
AppLocalizations localizations, ThemeData theme) {
return FutureBuilder<List<Customer>>(
future: ref
.read(customerRepositoryProvider)
.getAllCustomers(activeOnly: true),
builder: (context, snapshot) {
if (snapshot.connectionState == ConnectionState.waiting) {
return const Center(child: CircularProgressIndicator());
}

        if (snapshot.hasError || snapshot.data == null) {
          return Text(
            'Error loading customers',
            style: TextStyle(color: theme.colorScheme.error),
          );
        }

        final customers = snapshot.data!.where((c) => c.allowCredit).toList();

        if (customers.isEmpty) {
          return Text(
            'No credit customers found',
            style: TextStyle(color: Colors.orange.shade700),
          );
        }

        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              '${localizations.selectCustomer} *',
              style: theme.textTheme.bodyLarge
                  ?.copyWith(fontWeight: FontWeight.w500),
            ),
            const SizedBox(height: 8),
            DropdownButtonFormField<Customer>(
              value: _selectedCustomer,
              decoration: InputDecoration(
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(12),
                ),
                contentPadding: const EdgeInsets.symmetric(horizontal: 12),
              ),
              items: customers.map((customer) {
                return DropdownMenuItem(
                  value: customer,
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(customer.name),
                      Text(
                        '${localizations.creditAvailable}: ${AppFormatters.formatCurrency(customer.availableCredit)}',
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: theme.colorScheme.onSurface.withOpacity(0.6),
                        ),
                      ),
                    ],
                  ),
                );
              }).toList(),
              onChanged: (customer) =>
                  setState(() => _selectedCustomer = customer),
              validator: (value) {
                if (_selectedMethod == 'credit' && value == null) {
                  return 'Please select a customer';
                }
                return null;
              },
            ),
          ],
        );
      },
    );

}

bool get \_canProceed {
if (\_selectedMethod == 'credit') {
return \_selectedCustomer != null &&
\_selectedCustomer!.availableCredit >= widget.total;
}
return true;
}
}

##

// lib/src/ui/screens/printer_connection_screen.dart
// Screen for connecting to and managing Bluetooth printers.
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_blue_plus/flutter_blue_plus.dart';
import '../../utils/print_service.dart';
import '../../localization/app_localizations.dart';

class PrinterConnectionScreen extends ConsumerStatefulWidget {
const PrinterConnectionScreen({super.key});

@override
ConsumerState<PrinterConnectionScreen> createState() =>
\_PrinterConnectionScreenState();
}

class \_PrinterConnectionScreenState
extends ConsumerState<PrinterConnectionScreen> {
bool \_isScanning = false;

@override
void initState() {
super.initState();
\_startScan();
}

void \_startScan() {
setState(() {
\_isScanning = true;
});
PrintService.startScan();
}

void \_stopScan() {
setState(() {
\_isScanning = false;
});
PrintService.stopScan();
}

Future<void> \_connectToPrinter(BluetoothDevice device) async {
final success = await PrintService.connectToPrinter(device);
if (success && mounted) {
ScaffoldMessenger.of(context).showSnackBar(
SnackBar(
content: Text('Connected to ${device.localName}'),
backgroundColor: Colors.green,
),
);
} else if (mounted) {
ScaffoldMessenger.of(context).showSnackBar(
SnackBar(
content: Text('Failed to connect to ${device.localName}'),
backgroundColor: Colors.red,
),
);
}
}

Future<void> \_disconnectPrinter() async {
await PrintService.disconnect();
if (mounted) {
setState(() {});
}
}

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);

    return Scaffold(
      appBar: AppBar(
        title: Text(localizations.translate('printerSettings')),
        actions: [
          if (_isScanning)
            IconButton(
              icon: const Icon(Icons.stop),
              onPressed: _stopScan,
              tooltip: 'Stop Scan',
            )
          else
            IconButton(
              icon: const Icon(Icons.refresh),
              onPressed: _startScan,
              tooltip: 'Scan for Printers',
            ),
        ],
      ),
      body: Column(
        children: [
          // Connection Status
          ListTile(
            leading: Icon(
              PrintService.isConnected ? Icons.print : Icons.print_disabled,
              color: PrintService.isConnected ? Colors.green : Colors.red,
            ),
            title: Text(PrintService.isConnected
                ? 'Connected to ${PrintService.connectedDeviceName}'
                : 'No printer connected'),
            trailing: PrintService.isConnected
                ? IconButton(
                    icon: const Icon(Icons.link_off),
                    onPressed: _disconnectPrinter,
                    tooltip: 'Disconnect',
                  )
                : null,
          ),
          const Divider(),

          // Available Printers
          Expanded(
            child: StreamBuilder<List<BluetoothDevice>>(
              stream: PrintService.scanForPrinters(),
              builder: (context, snapshot) {
                if (!snapshot.hasData || snapshot.data!.isEmpty) {
                  return Center(
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Icon(Icons.search, size: 64, color: Colors.grey[400]),
                        const SizedBox(height: 16),
                        Text(
                          _isScanning
                              ? 'Searching for printers...'
                              : 'No printers found',
                          style: Theme.of(context).textTheme.bodyLarge,
                        ),
                      ],
                    ),
                  );
                }

                final printers = snapshot.data!;
                return ListView.builder(
                  itemCount: printers.length,
                  itemBuilder: (context, index) {
                    final device = printers[index];
                    return ListTile(
                      leading: const Icon(Icons.print),
                      title: Text(device.localName.isEmpty
                          ? 'Unknown Device'
                          : device.localName),
                      subtitle: Text(device.remoteId.toString()),
                      trailing: IconButton(
                        icon: const Icon(Icons.link),
                        onPressed: () => _connectToPrinter(device),
                        tooltip: 'Connect',
                      ),
                    );
                  },
                );
              },
            ),
          ),
        ],
      ),
    );

}

@override
void dispose() {
PrintService.stopScan();
super.dispose();
}
}

##

// lib/src/ui/screens/product_management_screen.dart
// Screen for managing products including viewing, searching, adding, editing, and filtering.
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/data/models/product.dart';
import 'package:andalus_smart_pos/src/data/repositories/product_repository.dart';
import 'package:andalus_smart_pos/src/data/repositories/category_repository.dart';
import 'package:andalus_smart_pos/src/data/models/category.dart';
import 'package:andalus_smart_pos/src/widgets/common/custom_card.dart';
import 'package:andalus_smart_pos/src/widgets/common/loading_shimmer.dart';
import 'package:andalus_smart_pos/src/utils/formatters.dart';

class ProductManagementScreen extends ConsumerStatefulWidget {
const ProductManagementScreen({super.key});

@override
ConsumerState<ProductManagementScreen> createState() =>
\_ProductManagementScreenState();
}

class \_ProductManagementScreenState
extends ConsumerState<ProductManagementScreen> {
final TextEditingController \_searchController = TextEditingController();
List<Product> \_filteredProducts = [];
List<Product> \_allProducts = [];
List<ProductCategory> \_categories = [];
bool \_isLoading = true;
String \_filter = 'all'; // 'all', 'active', 'low_stock', 'out_of_stock'
String \_categoryFilter = 'all';

@override
void initState() {
super.initState();
\_loadData();
\_searchController.addListener(\_onSearchChanged);
}

@override
void dispose() {
\_searchController.dispose();
super.dispose();
}

Future<void> \_loadData() async {
setState(() => \_isLoading = true);
try {
final productRepo = ref.read(productRepositoryProvider);
final categoryRepo = ref.read(categoryRepositoryProvider);

      // Load both products and categories concurrently
      final results = await Future.wait([
        productRepo.getAllProducts(),
        categoryRepo.getAllCategories(),
      ], eagerError: true); // eagerError: true will throw on first error

      // Type casting with null safety
      final products = results[0] as List<Product>? ?? [];
      final categories = results[1] as List<ProductCategory>? ?? [];

      // Ensure we have at least one category for the filter
      if (categories.isNotEmpty && _categoryFilter == 'all') {
        _categoryFilter = categories.first.categoryId;
      }

      setState(() {
        _allProducts = products;
        _categories = categories;
        _filteredProducts = _applyFilters(products, _filter, _categoryFilter);
        _isLoading = false;
      });
    } catch (e) {
      setState(() {
        _isLoading = false;
        _allProducts = [];
        _categories = [];
        _filteredProducts = [];
      });

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error loading data: $e'),
            backgroundColor: Colors.red,
            action: SnackBarAction(
              label: 'Retry',
              onPressed: _loadData,
            ),
          ),
        );
      }
    }

}

List<Product> _applyFilters(
List<Product> products, String statusFilter, String categoryFilter) {
return products.where((product) {
// Status filter
final statusMatch = switch (statusFilter) {
'active' => product.isActive,
'inactive' => !product.isActive,
'low_stock' => product.isLowStock,
'out_of_stock' => product.isOutOfStock,
_ => true,
};

      // Category filter
      final categoryMatch =
          categoryFilter == 'all' || product.categoryId == categoryFilter;

      return statusMatch && categoryMatch;
    }).toList();

}

void \_onSearchChanged() {
final query = \_searchController.text.toLowerCase();

    setState(() {
      if (query.isEmpty) {
        _filteredProducts =
            _applyFilters(_allProducts, _filter, _categoryFilter);
      } else {
        final searched = _allProducts.where((product) {
          return product.name.toLowerCase().contains(query) ||
              product.nameAm.toLowerCase().contains(query) ||
              product.barcode.toLowerCase().contains(query) ||
              product.sku?.toLowerCase().contains(query) == true;
        }).toList();
        _filteredProducts = _applyFilters(searched, _filter, _categoryFilter);
      }
    });

}

void \_changeStatusFilter(String newFilter) {
setState(() => \_filter = newFilter);
\_filteredProducts = \_applyFilters(\_allProducts, newFilter, \_categoryFilter);
}

void \_changeCategoryFilter(String newCategory) {
setState(() => \_categoryFilter = newCategory);
\_filteredProducts = \_applyFilters(\_allProducts, \_filter, newCategory);
}

void \_showAddProductDialog() {
showDialog(
context: context,
builder: (context) => AddProductDialog(
categories: \_categories,
onProductAdded: \_loadData,
),
);
}

void \_showEditProductDialog(Product product) {
showDialog(
context: context,
builder: (context) => EditProductDialog(
product: product,
categories: \_categories,
onProductUpdated: \_loadData,
),
);
}

Future<void> \_toggleProductStatus(Product product) async {
try {
final repository = ref.read(productRepositoryProvider);
await repository.updateProduct(
product.copyWith(isActive: !product.isActive),
);

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              '${product.name} ${product.isActive ? 'deactivated' : 'activated'} successfully',
            ),
            backgroundColor: const Color(0xFF10B981),
          ),
        );
      }
      _loadData();
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error updating product: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }

}

Future<void> \_updateStock(Product product, int newStock) async {
try {
final repository = ref.read(productRepositoryProvider);
await repository.updateStockQuantity(product.id!, newStock);

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Stock updated successfully'),
            backgroundColor: Color(0xFF10B981),
          ),
        );
      }
      _loadData();
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error updating stock: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }

}

// Statistics
int get \_totalProducts => \_allProducts.length;
int get \_activeProducts => \_allProducts.where((p) => p.isActive).length;
int get \_lowStockProducts => \_allProducts.where((p) => p.isLowStock).length;
int get \_outOfStockProducts =>
\_allProducts.where((p) => p.isOutOfStock).length;
double get \_totalInventoryValue => \_allProducts.fold(
0, (sum, product) => sum + (product.price \* product.stockQuantity));

@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(
title: const Text('Product Management'),
backgroundColor: const Color(0xFF10B981),
foregroundColor: Colors.white,
actions: [
IconButton(
icon: const Icon(Icons.add),
onPressed: _showAddProductDialog,
tooltip: 'Add Product',
),
IconButton(
icon: const Icon(Icons.refresh),
onPressed: _loadData,
tooltip: 'Refresh',
),
],
),
body: Column(
children: [
// Search and Filters
\_buildSearchSection(),

          // Statistics
          if (_allProducts.isNotEmpty) _buildStatisticsSection(),

          // Products List
          Expanded(
            child: _isLoading
                ? _buildLoadingState()
                : _filteredProducts.isEmpty
                    ? _buildEmptyState()
                    : _buildProductsList(),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _showAddProductDialog,
        backgroundColor: const Color(0xFF10B981),
        foregroundColor: Colors.white,
        child: const Icon(Icons.add),
      ),
    );

}

Widget \_buildSearchSection() {
return CustomCard(
margin: const EdgeInsets.all(16),
padding: const EdgeInsets.all(16),
child: Column(
children: [
// Search Bar
TextField(
controller: \_searchController,
decoration: InputDecoration(
labelText: 'Search products...',
prefixIcon: const Icon(Icons.search),
border: OutlineInputBorder(
borderRadius: BorderRadius.circular(12),
),
contentPadding: const EdgeInsets.symmetric(horizontal: 16),
),
),
const SizedBox(height: 12),

          // Filters Row
          Row(
            children: [
              // Status Filter
              Expanded(
                child: DropdownButtonFormField<String>(
                  value: _filter,
                  decoration: const InputDecoration(
                    labelText: 'Status',
                    border: OutlineInputBorder(),
                    contentPadding: EdgeInsets.symmetric(horizontal: 12),
                  ),
                  items: const [
                    DropdownMenuItem(value: 'all', child: Text('All Products')),
                    DropdownMenuItem(
                        value: 'active', child: Text('Active Only')),
                    DropdownMenuItem(
                        value: 'inactive', child: Text('Inactive')),
                    DropdownMenuItem(
                        value: 'low_stock', child: Text('Low Stock')),
                    DropdownMenuItem(
                        value: 'out_of_stock', child: Text('Out of Stock')),
                  ],
                  onChanged: (value) => _changeStatusFilter(value!),
                ),
              ),
              const SizedBox(width: 12),

              // Category Filter
              Expanded(
                child: DropdownButtonFormField<String>(
                  value: _categoryFilter,
                  decoration: const InputDecoration(
                    labelText: 'Category',
                    border: OutlineInputBorder(),
                    contentPadding: EdgeInsets.symmetric(horizontal: 12),
                  ),
                  items: [
                    const DropdownMenuItem(
                        value: 'all', child: Text('All Categories')),
                    ..._categories.map((category) {
                      return DropdownMenuItem(
                        value: category.categoryId,
                        child: Text(category.name),
                      );
                    }),
                  ],
                  onChanged: (value) => _changeCategoryFilter(value!),
                ),
              ),
            ],
          ),
        ],
      ),
    );

}

Widget \_buildStatisticsSection() {
return CustomCard(
margin: const EdgeInsets.fromLTRB(16, 0, 16, 16),
padding: const EdgeInsets.all(20),
child: Column(
children: [
// Main Stats
Row(
mainAxisAlignment: MainAxisAlignment.spaceAround,
children: [
_buildStatItem('Total', _totalProducts.toString(),
Icons.inventory_2, const Color(0xFF10B981)),
_buildStatItem('Active', _activeProducts.toString(),
Icons.check_circle, Colors.green),
_buildStatItem('Low Stock', _lowStockProducts.toString(),
Icons.warning, Colors.orange),
_buildStatItem('Out of Stock', _outOfStockProducts.toString(),
Icons.error, Colors.red),
],
),
const SizedBox(height: 12),

          // Inventory Value
          Container(
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: const Color(0xFF10B981).withOpacity(0.1),
              borderRadius: BorderRadius.circular(8),
            ),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Icon(Icons.attach_money,
                    color: Color(0xFF10B981), size: 16),
                const SizedBox(width: 8),
                Text(
                  'Total Inventory Value: ${AppFormatters.formatCurrency(_totalInventoryValue)}',
                  style: const TextStyle(
                    fontWeight: FontWeight.bold,
                    color: Color(0xFF10B981),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );

}

Widget \_buildStatItem(
String title, String value, IconData icon, Color color) {
return Column(
children: [
Container(
padding: const EdgeInsets.all(8),
decoration: BoxDecoration(
color: color.withOpacity(0.1),
borderRadius: BorderRadius.circular(8),
),
child: Icon(icon, color: color, size: 20),
),
const SizedBox(height: 8),
Text(
value,
style: TextStyle(
fontSize: 16,
fontWeight: FontWeight.bold,
color: color,
),
),
Text(
title,
style: const TextStyle(
fontSize: 10,
color: Colors.grey,
),
),
],
);
}

Widget \_buildLoadingState() {
return ListView.builder(
padding: const EdgeInsets.all(16),
itemCount: 6,
itemBuilder: (context, index) => const Padding(
padding: EdgeInsets.only(bottom: 12),
child: LoadingShimmer(height: 120, borderRadius: 12),
),
);
}

Widget \_buildEmptyState() {
return Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
Icon(Icons.inventory_2, size: 64, color: Colors.grey.shade400),
const SizedBox(height: 16),
Text(
'No products found',
style: Theme.of(context).textTheme.titleMedium?.copyWith(
color: Colors.grey.shade600,
),
),
const SizedBox(height: 8),
Text(
_getEmptyStateMessage(),
style: TextStyle(color: Colors.grey.shade500),
textAlign: TextAlign.center,
),
const SizedBox(height: 24),
ElevatedButton.icon(
onPressed: _showAddProductDialog,
icon: const Icon(Icons.add),
label: const Text('Add First Product'),
style: ElevatedButton.styleFrom(
backgroundColor: const Color(0xFF10B981),
foregroundColor: Colors.white,
),
),
],
),
);
}

String \_getEmptyStateMessage() {
if (\_searchController.text.isNotEmpty) {
return 'No products match your search criteria.\nTry adjusting your search terms.';
}

    switch (_filter) {
      case 'active':
        return 'No active products found.';
      case 'inactive':
        return 'No inactive products found.';
      case 'low_stock':
        return 'No low stock products.\nGreat job managing inventory!';
      case 'out_of_stock':
        return 'No out of stock products.';
      default:
        return 'No products in inventory.\nAdd your first product to get started!';
    }

}

Widget \_buildProductsList() {
return ListView.builder(
padding: const EdgeInsets.all(16),
itemCount: \_filteredProducts.length,
itemBuilder: (context, index) {
final product = \_filteredProducts[index];
return \_buildProductCard(product);
},
);
}

Widget \_buildProductCard(Product product) {
final category = \_categories.firstWhere(
(c) => c.categoryId == product.categoryId,
orElse: () => ProductCategory(
categoryId: '',
name: 'Unknown',
nameAm: 'Unknown',
createdAt: DateTime.now(),
updatedAt: DateTime.now(),
),
);

    return CustomCard(
      margin: const EdgeInsets.only(bottom: 12),
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Product Info
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        Expanded(
                          child: Text(
                            product.name,
                            style: const TextStyle(
                              fontWeight: FontWeight.bold,
                              fontSize: 16,
                            ),
                            maxLines: 2,
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                        // Status Badges
                        Row(
                          children: [
                            if (!product.isActive)
                              _buildStatusBadge('INACTIVE', Colors.grey),
                            if (product.isOutOfStock)
                              _buildStatusBadge('OUT OF STOCK', Colors.red),
                            if (product.isLowStock)
                              _buildStatusBadge('LOW STOCK', Colors.orange),
                          ],
                        ),
                      ],
                    ),
                    const SizedBox(height: 4),
                    Text(
                      category.name,
                      style: TextStyle(
                        color: Colors.grey.shade600,
                        fontSize: 14,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),

          // Details
          Row(
            children: [
              // Product Details
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      AppFormatters.formatCurrency(product.price),
                      style: const TextStyle(
                        fontWeight: FontWeight.bold,
                        fontSize: 16,
                        color: Color(0xFF10B981),
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      'Stock: ${product.stockQuantity}',
                      style: TextStyle(
                        color:
                            product.isLowStock ? Colors.orange : Colors.green,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                    if (product.barcode.isNotEmpty) ...[
                      const SizedBox(height: 2),
                      Text(
                        'Barcode: ${product.barcode}',
                        style: TextStyle(
                          fontSize: 12,
                          color: Colors.grey.shade600,
                        ),
                      ),
                    ],
                    if (product.sku != null) ...[
                      const SizedBox(height: 2),
                      Text(
                        'SKU: ${product.sku}',
                        style: TextStyle(
                          fontSize: 12,
                          color: Colors.grey.shade600,
                        ),
                      ),
                    ],
                  ],
                ),
              ),

              // Action Buttons
              Column(
                children: [
                  // Stock Update Button
                  OutlinedButton(
                    onPressed: () => _showStockUpdateDialog(product),
                    style: OutlinedButton.styleFrom(
                      foregroundColor: const Color(0xFF10B981),
                      side: const BorderSide(color: Color(0xFF10B981)),
                      padding: const EdgeInsets.symmetric(horizontal: 12),
                    ),
                    child: const Text('Update Stock'),
                  ),
                  const SizedBox(height: 8),

                  // Edit and Toggle Buttons
                  Row(
                    children: [
                      IconButton(
                        icon: const Icon(Icons.edit, size: 18),
                        onPressed: () => _showEditProductDialog(product),
                        tooltip: 'Edit Product',
                      ),
                      IconButton(
                        icon: Icon(
                          product.isActive ? Icons.toggle_on : Icons.toggle_off,
                          size: 18,
                          color: product.isActive
                              ? const Color(0xFF10B981)
                              : Colors.grey,
                        ),
                        onPressed: () => _toggleProductStatus(product),
                        tooltip: product.isActive ? 'Deactivate' : 'Activate',
                      ),
                    ],
                  ),
                ],
              ),
            ],
          ),
        ],
      ),
    );

}

Widget \_buildStatusBadge(String text, Color color) {
return Container(
margin: const EdgeInsets.only(left: 4),
padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
decoration: BoxDecoration(
color: color.withOpacity(0.1),
borderRadius: BorderRadius.circular(4),
border: Border.all(color: color.withOpacity(0.3)),
),
child: Text(
text,
style: TextStyle(
fontSize: 8,
color: color,
fontWeight: FontWeight.bold,
),
),
);
}

void \_showStockUpdateDialog(Product product) {
final stockController =
TextEditingController(text: product.stockQuantity.toString());

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Update Stock'),
        content: TextField(
          controller: stockController,
          decoration: const InputDecoration(
            labelText: 'New Stock Quantity',
            border: OutlineInputBorder(),
          ),
          keyboardType: TextInputType.number,
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () {
              final newStock = int.tryParse(stockController.text);
              if (newStock != null && newStock >= 0) {
                Navigator.pop(context);
                _updateStock(product, newStock);
              } else {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(
                    content: Text('Please enter a valid stock quantity'),
                    backgroundColor: Colors.orange,
                  ),
                );
              }
            },
            style: ElevatedButton.styleFrom(
              backgroundColor: const Color(0xFF10B981),
            ),
            child: const Text('Update'),
          ),
        ],
      ),
    );

}
}

// Add Product Dialog
class AddProductDialog extends ConsumerStatefulWidget {
final List<ProductCategory> categories;
final VoidCallback onProductAdded;

const AddProductDialog({
super.key,
required this.categories,
required this.onProductAdded,
});

@override
ConsumerState<AddProductDialog> createState() => \_AddProductDialogState();
}

class \_AddProductDialogState extends ConsumerState<AddProductDialog> {
final \_formKey = GlobalKey<FormState>();
final \_nameController = TextEditingController();
final \_nameAmController = TextEditingController();
final \_priceController = TextEditingController();
final \_costPriceController = TextEditingController();
final \_stockController = TextEditingController(text: '0');
final \_minStockController = TextEditingController(text: '10');
final \_barcodeController = TextEditingController();
final \_skuController = TextEditingController();
final \_descriptionController = TextEditingController();
final \_unitController = TextEditingController();
final \_brandController = TextEditingController();
final \_supplierController = TextEditingController();

String \_selectedCategory = '';
bool \_trackInventory = true;

@override
void initState() {
super.initState();
if (widget.categories.isNotEmpty) {
\_selectedCategory = widget.categories.first.categoryId;
}
}

@override
void dispose() {
\_nameController.dispose();
\_nameAmController.dispose();
\_priceController.dispose();
\_costPriceController.dispose();
\_stockController.dispose();
\_minStockController.dispose();
\_barcodeController.dispose();
\_skuController.dispose();
\_descriptionController.dispose();
\_unitController.dispose();
\_brandController.dispose();
\_supplierController.dispose();
super.dispose();
}

Future<void> \_addProduct() async {
if (!\_formKey.currentState!.validate()) return;

    try {
      final repository = ref.read(productRepositoryProvider);

      final product = Product(
        productId: 'prod_${DateTime.now().millisecondsSinceEpoch}',
        name: _nameController.text.trim(),
        nameAm: _nameAmController.text.trim(),
        description: _descriptionController.text.trim().isEmpty
            ? null
            : _descriptionController.text.trim(),
        price: double.parse(_priceController.text),
        costPrice: _costPriceController.text.isEmpty
            ? null
            : double.parse(_costPriceController.text),
        stockQuantity: int.parse(_stockController.text),
        minStockLevel: _minStockController.text.isEmpty
            ? null
            : int.parse(_minStockController.text),
        barcode: _barcodeController.text.trim(),
        sku: _skuController.text.trim().isEmpty
            ? null
            : _skuController.text.trim(),
        categoryId: _selectedCategory,
        unit: _unitController.text.trim().isEmpty
            ? null
            : _unitController.text.trim(),
        brand: _brandController.text.trim().isEmpty
            ? null
            : _brandController.text.trim(),
        supplier: _supplierController.text.trim().isEmpty
            ? null
            : _supplierController.text.trim(),
        trackInventory: _trackInventory,
        isActive: true,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      await repository.createProduct(product);

      if (mounted) {
        Navigator.pop(context);
        widget.onProductAdded();
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Product added successfully!'),
            backgroundColor: Color(0xFF10B981),
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error adding product: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }

}

@override
Widget build(BuildContext context) {
return Dialog(
shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
child: SingleChildScrollView(
padding: const EdgeInsets.all(24),
child: Form(
key: \_formKey,
child: Column(
mainAxisSize: MainAxisSize.min,
crossAxisAlignment: CrossAxisAlignment.start,
children: [
const Row(
children: [
Icon(Icons.add, color: Color(0xFF10B981)),
SizedBox(width: 8),
Text(
'Add New Product',
style: TextStyle(
fontSize: 18,
fontWeight: FontWeight.bold,
),
),
],
),
const SizedBox(height: 20),

              // Basic Information
              const Text(
                'Basic Information',
                style: TextStyle(fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 8),
              _buildTextField(_nameController, 'Product Name (English) *',
                  validator: _validateRequired),
              const SizedBox(height: 12),
              _buildTextField(_nameAmController, 'Product Name (Amharic) *',
                  validator: _validateRequired),
              const SizedBox(height: 12),
              _buildTextField(_descriptionController, 'Description',
                  maxLines: 2),

              const SizedBox(height: 20),
              const Text(
                'Pricing & Inventory',
                style: TextStyle(fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 8),
              Row(
                children: [
                  Expanded(
                      child: _buildTextField(_priceController, 'Price (ETB) *',
                          keyboardType: TextInputType.number,
                          validator: _validatePrice)),
                  const SizedBox(width: 12),
                  Expanded(
                      child: _buildTextField(
                          _costPriceController, 'Cost Price (ETB)',
                          keyboardType: TextInputType.number)),
                ],
              ),
              const SizedBox(height: 12),
              Row(
                children: [
                  Expanded(
                      child: _buildTextField(
                          _stockController, 'Stock Quantity *',
                          keyboardType: TextInputType.number,
                          validator: _validateStock)),
                  const SizedBox(width: 12),
                  Expanded(
                      child: _buildTextField(
                          _minStockController, 'Min Stock Level',
                          keyboardType: TextInputType.number)),
                ],
              ),

              const SizedBox(height: 12),
              SwitchListTile(
                title: const Text('Track Inventory'),
                value: _trackInventory,
                onChanged: (value) => setState(() => _trackInventory = value),
              ),

              const SizedBox(height: 20),
              const Text(
                'Categorization',
                style: TextStyle(fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 8),
              DropdownButtonFormField<String>(
                value: _selectedCategory,
                decoration: const InputDecoration(
                  labelText: 'Category *',
                  border: OutlineInputBorder(),
                ),
                items: widget.categories.map((category) {
                  return DropdownMenuItem(
                    value: category.categoryId,
                    child: Text(category.name),
                  );
                }).toList(),
                onChanged: (value) =>
                    setState(() => _selectedCategory = value!),
                validator: (value) =>
                    value == null ? 'Please select a category' : null,
              ),

              const SizedBox(height: 20),
              const Text(
                'Additional Information',
                style: TextStyle(fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 8),
              Row(
                children: [
                  Expanded(
                      child: _buildTextField(_barcodeController, 'Barcode')),
                  const SizedBox(width: 12),
                  Expanded(child: _buildTextField(_skuController, 'SKU')),
                ],
              ),
              const SizedBox(height: 12),
              Row(
                children: [
                  Expanded(
                      child: _buildTextField(
                          _unitController, 'Unit (e.g., pcs, kg)')),
                  const SizedBox(width: 12),
                  Expanded(child: _buildTextField(_brandController, 'Brand')),
                ],
              ),
              const SizedBox(height: 12),
              _buildTextField(_supplierController, 'Supplier'),

              const SizedBox(height: 24),
              Row(
                children: [
                  Expanded(
                    child: OutlinedButton(
                      onPressed: () => Navigator.pop(context),
                      child: const Text('Cancel'),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: ElevatedButton(
                      onPressed: _addProduct,
                      style: ElevatedButton.styleFrom(
                        backgroundColor: const Color(0xFF10B981),
                        foregroundColor: Colors.white,
                      ),
                      child: const Text('Add Product'),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );

}

Widget \_buildTextField(
TextEditingController controller,
String label, {
TextInputType keyboardType = TextInputType.text,
int maxLines = 1,
String? Function(String?)? validator,
}) {
return TextFormField(
controller: controller,
decoration: InputDecoration(
labelText: label,
border: const OutlineInputBorder(),
),
keyboardType: keyboardType,
maxLines: maxLines,
validator: validator,
);
}

String? \_validateRequired(String? value) {
if (value == null || value.trim().isEmpty) {
return 'This field is required';
}
return null;
}

String? \_validatePrice(String? value) {
if (value == null || value.trim().isEmpty) {
return 'Price is required';
}
final price = double.tryParse(value);
if (price == null || price < 0) {
return 'Please enter a valid price';
}
return null;
}

String? \_validateStock(String? value) {
if (value == null || value.trim().isEmpty) {
return 'Stock quantity is required';
}
final stock = int.tryParse(value);
if (stock == null || stock < 0) {
return 'Please enter a valid stock quantity';
}
return null;
}
}

// Edit Product Dialog (similar structure but for editing)
class EditProductDialog extends ConsumerStatefulWidget {
final Product product;
final List<ProductCategory> categories;
final VoidCallback onProductUpdated;

const EditProductDialog({
super.key,
required this.product,
required this.categories,
required this.onProductUpdated,
});

@override
ConsumerState<EditProductDialog> createState() => \_EditProductDialogState();
}

class \_EditProductDialogState extends ConsumerState<EditProductDialog> {
// Similar structure to AddProductDialog but pre-filled with product data
// Implementation follows same pattern as AddProductDialog
@override
Widget build(BuildContext context) {
return AlertDialog(
title: const Text('Edit Product'),
content: const Text('Edit product form goes here...'),
actions: [
TextButton(
onPressed: () => Navigator.pop(context),
child: const Text('Cancel'),
),
ElevatedButton(
onPressed: () {
// Save changes logic
},
child: const Text('Save Changes'),
),
],
);
}
}

##

// lib/src/ui/screens/reports_screen.dart
// Screen for viewing detailed reports and analytics on sales, products, customers, and financials.
import 'package:andalus_smart_pos/src/data/models/subscription.dart';
import 'package:andalus_smart_pos/src/utils/reports_data_calculator.dart';
import 'package:andalus_smart_pos/src/widgets/reports/advanced_product_analytics.dart';
import 'package:andalus_smart_pos/src/widgets/reports/advanced_sales_charts.dart';
import 'package:andalus_smart_pos/src/widgets/reports/customer_analytics_section.dart';
import 'package:andalus_smart_pos/src/widgets/reports/customers_overview_card.dart';
import 'package:andalus_smart_pos/src/widgets/reports/financial_ratios_section.dart';
import 'package:andalus_smart_pos/src/widgets/reports/inventory_analysis_section.dart';
import 'package:andalus_smart_pos/src/widgets/reports/outstanding_balance_chart.dart';
import 'package:andalus_smart_pos/src/widgets/reports/products_overview_card.dart';
import 'package:andalus_smart_pos/src/widgets/reports/revenue_by_day_chart.dart';
import 'package:andalus_smart_pos/src/widgets/reports/top_customers_chart.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import '../../controllers/reports_controller.dart';
import '../../localization/app_localizations.dart';
import '../../widgets/common/date_range_picker.dart';
import '../../widgets/common/custom_card.dart';
import '../../widgets/reports/sales_overview_card.dart';
import '../../widgets/reports/sales_trend_chart.dart';
import '../../widgets/reports/payment_method_chart.dart';
import '../../widgets/reports/top_products_chart.dart';
import '../../widgets/reports/customer_report_section.dart';
import '../../widgets/reports/financial_report_section.dart';
import '../../widgets/reports/subscription_info_card.dart';
import 'package:andalus_smart_pos/src/widgets/reports/top_products_chart.dart';

class ReportsScreen extends ConsumerStatefulWidget {
const ReportsScreen({super.key});

@override
ConsumerState<ReportsScreen> createState() => \_ReportsScreenState();
}

class \_ReportsScreenState extends ConsumerState<ReportsScreen>
with SingleTickerProviderStateMixin {
late TabController \_tabController;

@override
void initState() {
super.initState();
\_tabController = TabController(length: 4, vsync: this);
}

@override
void dispose() {
\_tabController.dispose();
super.dispose();
}

@override
Widget build(BuildContext context) {
final state = ref.watch(reportsControllerProvider);
final controller = ref.read(reportsControllerProvider.notifier);
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);

    return Scaffold(
      appBar: AppBar(
        title: Text(localizations.reports),
        backgroundColor: theme.colorScheme.primary,
        foregroundColor: theme.colorScheme.onPrimary,
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: controller.refresh,
            tooltip: localizations.refresh,
          ),
          _buildReportTypeMenu(localizations, controller, state),
        ],
        bottom: state.currentPlan.id != 'basic'
            ? _buildTabBar(localizations, state)
            : null,
      ),
      body: state.isLoading
          ? _buildLoadingState()
          : state.error != null
              ? _buildErrorState(state.error!, controller)
              : _buildContent(state, localizations, theme),
    );

}

Widget \_buildReportTypeMenu(AppLocalizations localizations,
ReportsController controller, ReportsState state) {
return PopupMenuButton<ReportType>(
onSelected: (type) {
controller.setReportType(type);
\_tabController.animateTo(\_getTabIndex(type));
},
itemBuilder: (context) => [
PopupMenuItem(
value: ReportType.sales,
child: Text(localizations.salesAnalytics),
),
PopupMenuItem(
value: ReportType.products,
enabled: state.currentPlan.id != 'basic',
child: Text(localizations.productsReport),
),
PopupMenuItem(
value: ReportType.customers,
enabled: state.currentPlan.id != 'basic',
child: Text(localizations.customersReport),
),
PopupMenuItem(
value: ReportType.financial,
enabled: state.currentPlan.id == 'enterprise',
child: Text(localizations.financialReport),
),
],
);
}

TabBar \_buildTabBar(AppLocalizations localizations, ReportsState state) {
return TabBar(
controller: \_tabController,
tabs: [
Tab(text: localizations.salesAnalytics),
Tab(text: localizations.productsReport),
Tab(text: localizations.customersReport),
if (state.currentPlan.id == 'enterprise')
Tab(text: localizations.financialReport),
],
);
}

Widget \_buildLoadingState() {
return Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
CircularProgressIndicator(),
SizedBox(height: 16),
Text('Loading reports...'),
],
),
);
}

Widget \_buildErrorState(String error, ReportsController controller) {
return Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
Icon(Icons.error_outline, size: 64, color: Colors.red),
SizedBox(height: 16),
Text('Error loading reports', style: TextStyle(fontSize: 18)),
SizedBox(height: 8),
Text(error, textAlign: TextAlign.center),
SizedBox(height: 16),
ElevatedButton(
onPressed: controller.refresh,
child: Text('Try Again'),
),
],
),
);
}

Widget \_buildContent(
ReportsState state, AppLocalizations localizations, ThemeData theme) {
return Column(
children: [
_buildFiltersSection(localizations, theme, state, ref),
SubscriptionInfoCard(plan: state.currentPlan),
Expanded(
child: state.currentPlan.id != 'basic'
? _buildTabbedView(state, localizations, theme)
: _buildBasicView(state, localizations, theme),
),
],
);
}

Widget \_buildFiltersSection(AppLocalizations localizations, ThemeData theme,
ReportsState state, WidgetRef ref) {
final controller = ref.read(reportsControllerProvider.notifier);

    return CustomCard(
      margin: const EdgeInsets.all(16),
      padding: const EdgeInsets.all(16),
      child: Column(
        children: [
          ProfessionalDateRangePicker(
            initialDateRange: state.dateRange,
            onDateRangeSelected: controller.setDateRange,
            title: localizations.selectDateRange,
          ),
        ],
      ),
    );

}

Widget \_buildTabbedView(
ReportsState state, AppLocalizations localizations, ThemeData theme) {
return TabBarView(
controller: \_tabController,
children: [
SalesReportSection(
salesData: state.salesData!, plan: state.currentPlan),
ProductsReportSection(
productsData: state.productsData!, plan: state.currentPlan),
CustomersReportSection(
customersData: state.customersData!, plan: state.currentPlan),
if (state.currentPlan.id == 'enterprise')
FinancialReportSection(financialData: state.financialData!),
],
);
}

Widget \_buildBasicView(
ReportsState state, AppLocalizations localizations, ThemeData theme) {
return SalesReportSection(
salesData: state.salesData!, plan: state.currentPlan);
}

int \_getTabIndex(ReportType type) {
switch (type) {
case ReportType.sales:
return 0;
case ReportType.products:
return 1;
case ReportType.customers:
return 2;
case ReportType.financial:
return 3;
}
}
}

// Modular report sections
class SalesReportSection extends StatelessWidget {
final SalesReportData salesData;
final SubscriptionPlan plan;

const SalesReportSection({
super.key,
required this.salesData,
required this.plan,
});

@override
Widget build(BuildContext context) {
return ListView(
padding: const EdgeInsets.all(16),
children: [
SalesOverviewCard(salesData: salesData),
const SizedBox(height: 16),
SalesTrendChart(dailySales: salesData.dailySalesTrend),
const SizedBox(height: 16),
PaymentMethodChart(paymentMethods: salesData.salesByPaymentMethod),
if (plan.id != 'basic') ...[
const SizedBox(height: 16),
RevenueByDayChart(revenueByDay: salesData.revenueByDay),
],
if (plan.id == 'enterprise') ...[
const SizedBox(height: 16),
AdvancedSalesCharts(salesData: salesData),
],
],
);
}
}

class ProductsReportSection extends StatelessWidget {
final ProductsReportData productsData;
final SubscriptionPlan plan;

const ProductsReportSection({
super.key,
required this.productsData,
required this.plan,
});

@override
Widget build(BuildContext context) {
return ListView(
padding: const EdgeInsets.all(16),
children: [
ProductsOverviewCard(productsData: productsData),
const SizedBox(height: 16),
TopProductsChart(products: productsData.topSellingProducts),
if (plan.id != 'basic') ...[
const SizedBox(height: 16),
InventoryAnalysisSection(productsData: productsData),
],
if (plan.id == 'enterprise') ...[
const SizedBox(height: 16),
AdvancedProductAnalytics(productsData: productsData),
],
],
);
}
}

class CustomersReportSection extends StatelessWidget {
final CustomersReportData customersData;
final SubscriptionPlan plan;

const CustomersReportSection({
super.key,
required this.customersData,
required this.plan,
});

@override
Widget build(BuildContext context) {
return ListView(
padding: const EdgeInsets.all(16),
children: [
CustomersOverviewCard(customersData: customersData),
const SizedBox(height: 16),
TopCustomersChart(customers: customersData.topCustomers),
const SizedBox(height: 16),
OutstandingBalanceChart(customersData: customersData),
if (plan.id == 'enterprise') ...[
const SizedBox(height: 16),
CustomerAnalyticsSection(customersData: customersData),
],
],
);
}
}

class FinancialReportSection extends StatelessWidget {
final FinancialReportData financialData;

const FinancialReportSection({super.key, required this.financialData});

@override
Widget build(BuildContext context) {
return ListView(
padding: const EdgeInsets.all(16),
children: [
FinancialKPICards(financialData: financialData),
const SizedBox(height: 16),
ProfitMarginTrendChart(financialData: financialData),
const SizedBox(height: 16),
CashFlowAnalysisChart(financialData: financialData),
const SizedBox(height: 16),
FinancialRatiosSection(financialData: financialData),
],
);
}
}

enum ReportType { sales, products, customers, financial }

##

// lib/src/ui/screens/sales_history_screen.dart
// Screen for viewing and managing sales history, including filtering, analytics, and detailed sale information.
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/data/repositories/sale_repository.dart';
import 'package:andalus_smart_pos/src/data/models/sale.dart';
import 'package:andalus_smart_pos/src/widgets/common/custom_card.dart';
import 'package:andalus_smart_pos/src/widgets/common/loading_shimmer.dart';
import 'package:andalus_smart_pos/src/utils/date_utils.dart';
import 'package:andalus_smart_pos/src/utils/formatters.dart';

class SalesHistoryScreen extends ConsumerStatefulWidget {
const SalesHistoryScreen({super.key});

@override
ConsumerState<SalesHistoryScreen> createState() => \_SalesHistoryScreenState();
}

class \_SalesHistoryScreenState extends ConsumerState<SalesHistoryScreen> {
List<Sale> \_sales = [];
bool \_isLoading = true;
String \_filter = 'today'; // 'today', 'week', 'month', 'all', 'custom'
DateTimeRange? \_selectedDateRange;
SaleWithItems? \_selectedSale;

@override
void initState() {
super.initState();
\_loadSales();
}

Future<void> \_loadSales() async {
setState(() => \_isLoading = true);

    try {
      final saleRepository = ref.read(saleRepositoryProvider);
      List<Sale> sales;

      final now = DateTime.now();
      switch (_filter) {
        case 'today':
          sales = await saleRepository.getTodaysSales();
          break;
        case 'week':
          final weekAgo = now.subtract(const Duration(days: 7));
          final allSales = await saleRepository.getAllSales();
          sales = allSales
              .where((sale) => sale.createdAt.isAfter(weekAgo))
              .toList();
          break;
        case 'month':
          final monthAgo = DateTime(now.year, now.month - 1, now.day);
          final allSales = await saleRepository.getAllSales();
          sales = allSales
              .where((sale) => sale.createdAt.isAfter(monthAgo))
              .toList();
          break;
        case 'custom':
          if (_selectedDateRange != null) {
            final allSales = await saleRepository.getAllSales();
            sales = allSales
                .where((sale) =>
                    sale.createdAt.isAfter(_selectedDateRange!.start) &&
                    sale.createdAt.isBefore(_selectedDateRange!.end))
                .toList();
          } else {
            sales = await saleRepository.getAllSales();
          }
          break;
        default:
          sales = await saleRepository.getAllSales();
      }

      // Sort by date (newest first)
      sales.sort((a, b) => b.createdAt.compareTo(a.createdAt));

      setState(() {
        _sales = sales;
        _isLoading = false;
      });
    } catch (e) {
      setState(() => _isLoading = false);
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error loading sales: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }

}

Future<void> \_loadSaleDetails(int saleId) async {
try {
final saleRepository = ref.read(saleRepositoryProvider);
final saleWithItems = await saleRepository.getSaleById(saleId);

      setState(() => _selectedSale = saleWithItems);
      _showSaleDetailsDialog();
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error loading sale details: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }

}

void \_showSaleDetailsDialog() {
if (\_selectedSale == null) return;

    showDialog(
      context: context,
      builder: (context) => Dialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
        elevation: 4,
        child: _buildSaleDetailsContent(),
      ),
    );

}

Widget \_buildSaleDetailsContent() {
final sale = \_selectedSale!.sale;
final items = \_selectedSale!.items;
final theme = Theme.of(context);
final colorScheme = theme.colorScheme;

    return SingleChildScrollView(
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Header
            Row(
              children: [
                Icon(Icons.receipt_long, color: colorScheme.primary, size: 28),
                const SizedBox(width: 12),
                Text(
                  'Sale #${sale.id}',
                  style: theme.textTheme.titleLarge?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const Spacer(),
                IconButton(
                  icon: const Icon(Icons.close),
                  onPressed: () => Navigator.pop(context),
                ),
              ],
            ),
            const SizedBox(height: 24),

            // Sale Information
            Card(
              elevation: 0,
              color: colorScheme.surfaceVariant.withOpacity(0.3),
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(16)),
              margin: const EdgeInsets.only(bottom: 16),
              child: Padding(
                padding: const EdgeInsets.all(16),
                child: Column(
                  children: [
                    _buildDetailRow('Date',
                        '${AppDateUtils.formatDate(sale.createdAt)} ${AppDateUtils.formatTime(sale.createdAt)}'),
                    _buildDetailRow('Payment Method',
                        _formatPaymentMethod(sale.paymentMethod)),
                    _buildDetailRow(
                        'Status', _formatStatus(sale.paymentStatus)),
                    if (sale.taxAmount > 0)
                      _buildDetailRow('Tax Amount',
                          AppFormatters.formatCurrency(sale.taxAmount)),
                    if (sale.discountAmount > 0)
                      _buildDetailRow('Discount',
                          AppFormatters.formatCurrency(sale.discountAmount)),
                  ],
                ),
              ),
            ),
            const SizedBox(height: 16),

            // Items Header
            Text(
              'Items',
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 12),

            // Items List
            Card(
              elevation: 0,
              color: colorScheme.surfaceVariant.withOpacity(0.3),
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(16)),
              margin: const EdgeInsets.only(bottom: 16),
              child: Padding(
                padding: const EdgeInsets.all(16),
                child: Column(
                  children: [
                    ...items.map((item) => Padding(
                          padding: const EdgeInsets.symmetric(vertical: 8),
                          child: Row(
                            children: [
                              Expanded(
                                flex: 3,
                                child: Text(
                                  item.productName,
                                  style: theme.textTheme.bodyLarge?.copyWith(
                                    fontWeight: FontWeight.w600,
                                  ),
                                ),
                              ),
                              Expanded(
                                child: Text(
                                  'x${item.quantity}',
                                  style: theme.textTheme.bodyMedium?.copyWith(
                                    color: colorScheme.onSurfaceVariant,
                                  ),
                                  textAlign: TextAlign.center,
                                ),
                              ),
                              Expanded(
                                child: Text(
                                  AppFormatters.formatCurrency(item.unitPrice),
                                  style: theme.textTheme.bodyMedium?.copyWith(
                                    color: colorScheme.onSurfaceVariant,
                                  ),
                                  textAlign: TextAlign.right,
                                ),
                              ),
                              Expanded(
                                child: Text(
                                  AppFormatters.formatCurrency(item.totalPrice),
                                  style: theme.textTheme.bodyLarge?.copyWith(
                                    fontWeight: FontWeight.bold,
                                    color: colorScheme.primary,
                                  ),
                                  textAlign: TextAlign.right,
                                ),
                              ),
                            ],
                          ),
                        )),
                  ],
                ),
              ),
            ),
            const SizedBox(height: 16),

            // Total
            Container(
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: colorScheme.primary.withOpacity(0.1),
                borderRadius: BorderRadius.circular(16),
                border: Border.all(color: colorScheme.primary.withOpacity(0.2)),
              ),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(
                    'TOTAL AMOUNT:',
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  Text(
                    AppFormatters.formatCurrency(sale.finalAmount),
                    style: theme.textTheme.titleLarge?.copyWith(
                      fontWeight: FontWeight.bold,
                      color: colorScheme.primary,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );

}

Widget \_buildDetailRow(String label, String value) {
final theme = Theme.of(context);
final colorScheme = theme.colorScheme;

    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(
            label,
            style: theme.textTheme.bodyMedium?.copyWith(
              color: colorScheme.onSurfaceVariant,
              fontWeight: FontWeight.w500,
            ),
          ),
          Text(
            value,
            style: theme.textTheme.bodyMedium?.copyWith(
              fontWeight: FontWeight.w600,
            ),
          ),
        ],
      ),
    );

}

String \_formatPaymentMethod(String method) {
switch (method) {
case 'cash':
return 'Cash';
case 'telebirr':
return 'Telebirr';
case 'card':
return 'Card';
case 'credit':
return 'Credit';
default:
return method.toUpperCase();
}
}

String \_formatStatus(String status) {
switch (status) {
case 'completed':
return 'Completed';
case 'pending':
return 'Pending';
case 'refunded':
return 'Refunded';
default:
return status.capitalize();
}
}

void \_changeFilter(String newFilter) {
setState(() => \_filter = newFilter);
\_loadSales();
}

Future<void> \_selectDateRange() async {
final DateTimeRange? picked = await showDateRangePicker(
context: context,
firstDate: DateTime(2020),
lastDate: DateTime.now().add(const Duration(days: 365)),
initialEntryMode: DatePickerEntryMode.calendarOnly,
helpText: 'Select Date Range',
confirmText: 'Apply',
cancelText: 'Cancel',
);

    if (picked != null) {
      setState(() {
        _selectedDateRange = picked;
        _filter = 'custom';
      });
      _loadSales();
    }

}

// Analytics calculations
double get \_totalSalesAmount =>
\_sales.fold(0, (sum, sale) => sum + sale.finalAmount);
int get \_totalOrders => \_sales.length;
double get \_averageOrderValue =>
\_totalOrders > 0 ? \_totalSalesAmount / \_totalOrders : 0;

Map<String, double> get \_paymentMethodBreakdown {
final breakdown = <String, double>{};
for (final sale in \_sales) {
breakdown.update(
sale.paymentMethod,
(value) => value + sale.finalAmount,
ifAbsent: () => sale.finalAmount,
);
}
return breakdown;
}

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);
final colorScheme = theme.colorScheme;

    return Scaffold(
      appBar: AppBar(
        title: const Text('Sales History'),
        backgroundColor: colorScheme.primary,
        foregroundColor: colorScheme.onPrimary,
        elevation: 0,
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: _loadSales,
            tooltip: 'Refresh',
          ),
        ],
      ),
      body: Column(
        children: [
          // Filter Section
          _buildFilterSection(),

          // Analytics Summary
          if (_sales.isNotEmpty && !_isLoading) _buildAnalyticsSummary(),

          // Sales List
          Expanded(
            child: _isLoading
                ? _buildLoadingState()
                : _sales.isEmpty
                    ? _buildEmptyState()
                    : _buildSalesList(),
          ),
        ],
      ),
    );

}

Widget \_buildFilterSection() {
final theme = Theme.of(context);
final colorScheme = theme.colorScheme;

    return Card(
      elevation: 2,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      margin: const EdgeInsets.all(16),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            // Quick Filters
            SingleChildScrollView(
              scrollDirection: Axis.horizontal,
              child: Row(
                children: [
                  _buildFilterChip('Today', 'today'),
                  const SizedBox(width: 8),
                  _buildFilterChip('This Week', 'week'),
                  const SizedBox(width: 8),
                  _buildFilterChip('This Month', 'month'),
                  const SizedBox(width: 8),
                  _buildFilterChip('All Time', 'all'),
                  const SizedBox(width: 8),
                  _buildDateRangeChip(),
                ],
              ),
            ),

            // Selected Date Range
            if (_filter == 'custom' && _selectedDateRange != null) ...[
              const SizedBox(height: 12),
              Text(
                '${AppDateUtils.formatDate(_selectedDateRange!.start)} - ${AppDateUtils.formatDate(_selectedDateRange!.end)}',
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: colorScheme.onSurfaceVariant,
                  fontWeight: FontWeight.w500,
                ),
              ),
            ],
          ],
        ),
      ),
    );

}

Widget \_buildFilterChip(String label, String value) {
final isSelected = \_filter == value;
final theme = Theme.of(context);
final colorScheme = theme.colorScheme;

    return FilterChip(
      label: Text(label),
      selected: isSelected,
      onSelected: (selected) => _changeFilter(value),
      backgroundColor: colorScheme.surface,
      selectedColor: colorScheme.primary,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
      side: BorderSide(
        color: colorScheme.primary.withOpacity(isSelected ? 0 : 0.2),
      ),
      labelStyle: TextStyle(
        color: isSelected ? colorScheme.onPrimary : colorScheme.primary,
        fontWeight: FontWeight.w600,
      ),
      elevation: isSelected ? 2 : 0,
      pressElevation: 4,
    );

}

Widget \_buildDateRangeChip() {
final isSelected = \_filter == 'custom';
final theme = Theme.of(context);
final colorScheme = theme.colorScheme;

    return FilterChip(
      label: const Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(Icons.calendar_today, size: 16),
          SizedBox(width: 4),
          Text('Custom Range'),
        ],
      ),
      selected: isSelected,
      onSelected: (_) => _selectDateRange(),
      backgroundColor: colorScheme.surface,
      selectedColor: colorScheme.primary,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
      side: BorderSide(
        color: colorScheme.primary.withOpacity(isSelected ? 0 : 0.2),
      ),
      labelStyle: TextStyle(
        color: isSelected ? colorScheme.onPrimary : colorScheme.primary,
        fontWeight: FontWeight.w600,
      ),
      elevation: isSelected ? 2 : 0,
      pressElevation: 4,
    );

}

Widget \_buildAnalyticsSummary() {
final theme = Theme.of(context);
final colorScheme = theme.colorScheme;

    return Card(
      elevation: 2,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      margin: const EdgeInsets.fromLTRB(16, 0, 16, 16),
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          children: [
            // Main Stats
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceAround,
              children: [
                _buildAnalyticsItem(
                  'Total Sales',
                  AppFormatters.formatCurrency(_totalSalesAmount),
                  Icons.attach_money,
                ),
                _buildAnalyticsItem(
                  'Total Orders',
                  _totalOrders.toString(),
                  Icons.receipt_long,
                ),
                _buildAnalyticsItem(
                  'Avg. Order',
                  AppFormatters.formatCurrency(_averageOrderValue),
                  Icons.trending_up,
                ),
              ],
            ),
            const SizedBox(height: 24),

            // Payment Methods Breakdown
            if (_paymentMethodBreakdown.isNotEmpty) ...[
              Divider(color: colorScheme.outline.withOpacity(0.5)),
              const SizedBox(height: 12),
              Text(
                'Payment Methods',
                style: theme.textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 12),
              Wrap(
                spacing: 12,
                runSpacing: 8,
                children: _paymentMethodBreakdown.entries.map((entry) {
                  final percentage = (entry.value / _totalSalesAmount * 100);
                  return Chip(
                    label: Text(
                      '${_formatPaymentMethod(entry.key)}: ${percentage.toStringAsFixed(1)}%',
                    ),
                    backgroundColor: colorScheme.primary.withOpacity(0.1),
                    labelStyle: TextStyle(
                      color: colorScheme.primary,
                      fontWeight: FontWeight.w600,
                    ),
                    shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(20)),
                    elevation: 1,
                  );
                }).toList(),
              ),
            ],
          ],
        ),
      ),
    );

}

Widget \_buildAnalyticsItem(String title, String value, IconData icon) {
final theme = Theme.of(context);
final colorScheme = theme.colorScheme;

    return Column(
      children: [
        Container(
          padding: const EdgeInsets.all(12),
          decoration: BoxDecoration(
            color: colorScheme.primary.withOpacity(0.1),
            borderRadius: BorderRadius.circular(12),
          ),
          child: Icon(icon, color: colorScheme.primary, size: 28),
        ),
        const SizedBox(height: 8),
        Text(
          value,
          style: theme.textTheme.titleMedium?.copyWith(
            fontWeight: FontWeight.bold,
            color: colorScheme.onSurface,
          ),
        ),
        const SizedBox(height: 4),
        Text(
          title,
          style: theme.textTheme.bodySmall?.copyWith(
            color: colorScheme.onSurfaceVariant,
          ),
        ),
      ],
    );

}

Widget \_buildLoadingState() {
return ListView.builder(
padding: const EdgeInsets.all(16),
itemCount: 6,
itemBuilder: (context, index) => const Padding(
padding: EdgeInsets.only(bottom: 12),
child: LoadingShimmer(height: 120, borderRadius: 16),
),
);
}

Widget \_buildEmptyState() {
final theme = Theme.of(context);
final colorScheme = theme.colorScheme;

    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.receipt_long,
              size: 80, color: colorScheme.onSurfaceVariant),
          const SizedBox(height: 16),
          Text(
            'No sales found',
            style: theme.textTheme.titleLarge?.copyWith(
              color: colorScheme.onSurfaceVariant,
            ),
          ),
          const SizedBox(height: 8),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 32),
            child: Text(
              _getEmptyStateMessage(),
              style: theme.textTheme.bodyMedium?.copyWith(
                color: colorScheme.onSurfaceVariant,
              ),
              textAlign: TextAlign.center,
            ),
          ),
          const SizedBox(height: 24),
          ElevatedButton.icon(
            onPressed: () => Navigator.pop(context),
            icon: const Icon(Icons.point_of_sale),
            label: const Text('Start Selling'),
            style: ElevatedButton.styleFrom(
              backgroundColor: colorScheme.primary,
              foregroundColor: colorScheme.onPrimary,
              elevation: 2,
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(20)),
              padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
            ),
          ),
        ],
      ),
    );

}

String \_getEmptyStateMessage() {
switch (\_filter) {
case 'today':
return 'No sales made today yet.\nComplete your first sale to see it here!';
case 'week':
return 'No sales in the last 7 days.';
case 'month':
return 'No sales this month.';
case 'custom':
return 'No sales found in the selected date range.';
default:
return 'No sales recorded yet.\nComplete your first sale to see it here!';
}
}

Widget \_buildSalesList() {
return RefreshIndicator(
onRefresh: \_loadSales,
child: ListView.builder(
padding: const EdgeInsets.all(16),
itemCount: \_sales.length,
itemBuilder: (context, index) {
final sale = \_sales[index];
return \_buildSaleCard(sale);
},
),
);
}

Widget \_buildSaleCard(Sale sale) {
final theme = Theme.of(context);
final colorScheme = theme.colorScheme;

    return Card(
      elevation: 2,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      margin: const EdgeInsets.only(bottom: 12),
      child: InkWell(
        onTap: () => _loadSaleDetails(sale.id!),
        borderRadius: BorderRadius.circular(16),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Expanded(
                    child: Text(
                      'Sale #${sale.id}',
                      style: theme.textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                  Chip(
                    label: Text(
                      _formatPaymentMethod(sale.paymentMethod),
                      style: const TextStyle(
                        color: Colors.white,
                        fontSize: 12,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    backgroundColor: _getPaymentMethodColor(sale.paymentMethod),
                    shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(20)),
                  ),
                ],
              ),
              const SizedBox(height: 12),

              // Details
              Row(
                children: [
                  // Date and Time
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Row(
                          children: [
                            Icon(Icons.calendar_today,
                                size: 16, color: colorScheme.onSurfaceVariant),
                            const SizedBox(width: 6),
                            Text(
                              AppDateUtils.formatDate(sale.createdAt),
                              style: theme.textTheme.bodyMedium?.copyWith(
                                  color: colorScheme.onSurfaceVariant),
                            ),
                          ],
                        ),
                        const SizedBox(height: 4),
                        Row(
                          children: [
                            Icon(Icons.access_time,
                                size: 16, color: colorScheme.onSurfaceVariant),
                            const SizedBox(width: 6),
                            Text(
                              AppDateUtils.formatTime(sale.createdAt),
                              style: theme.textTheme.bodyMedium?.copyWith(
                                  color: colorScheme.onSurfaceVariant),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ),

                  // Amount
                  Column(
                    crossAxisAlignment: CrossAxisAlignment.end,
                    children: [
                      Text(
                        AppFormatters.formatCurrency(sale.finalAmount),
                        style: theme.textTheme.titleLarge?.copyWith(
                          fontWeight: FontWeight.bold,
                          color: colorScheme.primary,
                        ),
                      ),
                      const SizedBox(height: 4),
                      Text(
                        'Tap for details',
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: colorScheme.onSurfaceVariant,
                          fontStyle: FontStyle.italic,
                        ),
                      ),
                    ],
                  ),
                ],
              ),

              // Sync Status
              if (!sale.isSynced) ...[
                const SizedBox(height: 12),
                Row(
                  children: [
                    Icon(Icons.sync, size: 16, color: Colors.orange.shade600),
                    const SizedBox(width: 6),
                    Text(
                      'Pending sync',
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: Colors.orange.shade600,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ],
                ),
              ],
            ],
          ),
        ),
      ),
    );

}

Color \_getPaymentMethodColor(String method) {
switch (method) {
case 'cash':
return const Color(0xFF10B981);
case 'telebirr':
return const Color(0xFF3B82F6);
case 'card':
return const Color(0xFF8B5CF6);
case 'credit':
return const Color(0xFFF59E0B);
default:
return const Color(0xFF6B7280);
}
}
}

extension StringExtension on String {
String capitalize() {
return "${this[0].toUpperCase()}${substring(1)}";
}
}

##

// lib/src/ui/screens/splash_screen.dart
// Splash screen with animated logo and initial setup flow for language and theme selection.
// After setup, navigates to authentication or main app screen.
// Implements smooth animations and responsive design.

import 'package:andalus_smart_pos/src/providers/language_provider.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/providers/auth_provider.dart';
import 'package:andalus_smart_pos/src/providers/theme_provider.dart';
import 'package:andalus_smart_pos/src/ui/screens/auth/phone_login_screen.dart';
import 'package:andalus_smart_pos/src/ui/screens/main_navigation.dart';

class SplashScreen extends ConsumerStatefulWidget {
const SplashScreen({super.key});

@override
ConsumerState<SplashScreen> createState() => \_SplashScreenState();
}

class \_SplashScreenState extends ConsumerState<SplashScreen>
with SingleTickerProviderStateMixin {
late AnimationController \_animationController;
late Animation<double> \_fadeAnimation;
late Animation<double> \_scaleAnimation;

int \_currentStep = 0;
bool \_showSettings = false;

final List<Map<String, dynamic>> \_languages = [
{
'code': 'en',
'name': 'English',
'nativeName': 'English',
'flag': 'üá∫üá∏',
'description': 'English'
},
{
'code': 'am',
'name': 'Amharic',
'nativeName': '·ä†·àõ·à≠·äõ',
'flag': 'üá™üáπ',
'description': 'Amharic'
},
];

final List<Map<String, dynamic>> \_themes = [
{
'mode': ThemeMode.light,
'name': 'Light',
'description': 'Bright theme',
'icon': Icons.light_mode_outlined,
'selectedIcon': Icons.light_mode,
},
{
'mode': ThemeMode.dark,
'name': 'Dark',
'description': 'Dark theme',
'icon': Icons.dark_mode_outlined,
'selectedIcon': Icons.dark_mode,
},
{
'mode': ThemeMode.system,
'name': 'System',
'description': 'Follow device',
'icon': Icons.settings_outlined,
'selectedIcon': Icons.settings,
},
];

@override
void initState() {
super.initState();
\_initializeAnimations();
\_initializeApp();
}

void \_initializeAnimations() {
\_animationController = AnimationController(
vsync: this,
duration: const Duration(milliseconds: 1200),
);

    _fadeAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(
        parent: _animationController,
        curve: const Interval(0.0, 0.6, curve: Curves.easeInOut),
      ),
    );

    _scaleAnimation = Tween<double>(begin: 0.8, end: 1.0).animate(
      CurvedAnimation(
        parent: _animationController,
        curve: const Interval(0.3, 1.0, curve: Curves.elasticOut),
      ),
    );

    _animationController.forward();

}

Future<void> \_initializeApp() async {
// Initial loading delay
await Future.delayed(const Duration(milliseconds: 1800));

    if (mounted) {
      setState(() {
        _showSettings = true;
        _currentStep = 1;
      });
    }

}

void \_selectLanguage(String languageCode) {
ref.read(languageProvider.notifier).setLanguage(languageCode);
\_nextStep();
}

void \_selectTheme(ThemeMode themeMode) {
ref.read(themeProvider.notifier).setTheme(themeMode);
\_nextStep();
}

void \_nextStep() {
if (\_currentStep < 3) {
setState(() => \_currentStep++);
} else {
\_proceedToApp();
}
}

void \_previousStep() {
if (\_currentStep > 1) {
setState(() => \_currentStep--);
}
}

void \_skipToApp() {
\_proceedToApp();
}

void \_proceedToApp() {
final authState = ref.read(authProvider);
Navigator.of(context).pushReplacement(
MaterialPageRoute(
builder: (context) => authState.isAuthenticated
? const MainNavigation()
// : const PhoneLoginScreen(),
: const MainNavigation(),
),
);
}

@override
void dispose() {
\_animationController.dispose();
super.dispose();
}

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);
final locale = ref.watch(languageProvider);
final isEnglish = locale.languageCode == 'en';

    return Scaffold(
      backgroundColor: theme.colorScheme.primary,
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            children: [
              // Progress Indicator
              if (_showSettings && _currentStep > 0 && _currentStep < 3)
                _buildProgressIndicator(),

              // Main Content
              Expanded(
                child: AnimatedSwitcher(
                  duration: const Duration(milliseconds: 400),
                  child: _showSettings
                      ? _buildSettingsFlow(isEnglish)
                      : _buildWelcomeScreen(),
                ),
              ),

              // Navigation Buttons
              if (_showSettings && _currentStep > 0 && _currentStep < 3)
                _buildNavigationButtons(isEnglish),
            ],
          ),
        ),
      ),
    );

}

Widget \_buildWelcomeScreen() {
return FadeTransition(
opacity: \_fadeAnimation,
child: ScaleTransition(
scale: \_scaleAnimation,
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
// App Logo with gradient
Container(
width: 140,
height: 140,
decoration: BoxDecoration(
gradient: LinearGradient(
begin: Alignment.topLeft,
end: Alignment.bottomRight,
colors: [
Colors.white.withOpacity(0.9),
Colors.white.withOpacity(0.7),
],
),
borderRadius: BorderRadius.circular(28),
boxShadow: [
BoxShadow(
color: Colors.black.withOpacity(0.15),
blurRadius: 20,
offset: const Offset(0, 10),
),
],
),
child: Icon(
Icons.point_of_sale_rounded,
size: 70,
color: Theme.of(context).colorScheme.primary,
),
),
const SizedBox(height: 32),

            // App Name
            Text(
              'Andalus POS',
              style: TextStyle(
                color: Colors.white,
                fontSize: 32,
                fontWeight: FontWeight.w800,
                letterSpacing: -0.5,
              ),
            ),
            const SizedBox(height: 12),

            // Subtitle
            Text(
              'Smart Point of Sale for Ethiopian Businesses',
              style: TextStyle(
                color: Colors.white.withOpacity(0.8),
                fontSize: 16,
                fontWeight: FontWeight.w400,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 40),

            // Loading Indicator
            SizedBox(
              width: 32,
              height: 32,
              child: CircularProgressIndicator(
                strokeWidth: 2.5,
                valueColor: AlwaysStoppedAnimation<Color>(
                    Colors.white.withOpacity(0.8)),
              ),
            ),
            const SizedBox(height: 20),

            // Loading Text
            Text(
              'Initializing...',
              style: TextStyle(
                color: Colors.white.withOpacity(0.7),
                fontSize: 14,
                fontWeight: FontWeight.w500,
              ),
            ),
          ],
        ),
      ),
    );

}

Widget \_buildSettingsFlow(bool isEnglish) {
switch (\_currentStep) {
case 1:
return \_buildLanguageStep(isEnglish);
case 2:
return \_buildThemeStep(isEnglish);
case 3:
return \_buildReadyStep(isEnglish);
default:
return \_buildWelcomeScreen();
}
}

Widget \_buildProgressIndicator() {
return Padding(
padding: const EdgeInsets.only(bottom: 32),
child: Column(
children: [
// Step Indicators
Row(
mainAxisAlignment: MainAxisAlignment.center,
children: List.generate(2, (index) {
return Container(
width: _currentStep == index + 1 ? 24 : 12,
height: 4,
margin: const EdgeInsets.symmetric(horizontal: 4),
decoration: BoxDecoration(
borderRadius: BorderRadius.circular(2),
color: _currentStep >= index + 1
? Colors.white
: Colors.white.withOpacity(0.3),
),
);
}),
),
const SizedBox(height: 12),
// Step Text
Text(
'$_currentStep of 2',
style: TextStyle(
color: Colors.white.withOpacity(0.7),
fontSize: 12,
fontWeight: FontWeight.w500,
),
),
],
),
);
}

Widget \_buildLanguageStep(bool isEnglish) {
return SingleChildScrollView(
child: Padding(
padding: const EdgeInsets.symmetric(vertical: 20),
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
// Icon
Icon(
Icons.language_rounded,
size: 64,
color: Colors.white,
),
const SizedBox(height: 24),

            // Title
            Text(
              isEnglish ? 'Choose Language' : '·âã·äï·âã ·ã≠·àù·à®·å°',
              style: const TextStyle(
                color: Colors.white,
                fontSize: 28,
                fontWeight: FontWeight.w700,
              ),
            ),
            const SizedBox(height: 8),

            // Subtitle
            Text(
              isEnglish ? 'Select your preferred language' : '·ã®·àö·çà·àç·åâ·âµ·äï ·âã·äï·âã ·ã≠·àù·à®·å°',
              style: TextStyle(
                color: Colors.white.withOpacity(0.7),
                fontSize: 16,
                fontWeight: FontWeight.w400,
              ),
            ),
            const SizedBox(height: 40),

            // Language Options
            Column(
              children: _languages
                  .map((language) => _buildLanguageOption(language, isEnglish))
                  .toList(),
            ),
          ],
        ),
      ),
    );

}

Widget \_buildLanguageOption(Map<String, dynamic> language, bool isEnglish) {
final isSelected =
ref.watch(languageProvider).languageCode == language['code'];

    return Container(
      margin: const EdgeInsets.only(bottom: 12),
      child: Material(
        color: isSelected ? Colors.white : Colors.white.withOpacity(0.1),
        borderRadius: BorderRadius.circular(16),
        child: InkWell(
          onTap: () => _selectLanguage(language['code']),
          borderRadius: BorderRadius.circular(16),
          child: Container(
            padding: const EdgeInsets.all(20),
            child: Row(
              children: [
                // Flag
                Text(
                  language['flag'],
                  style: const TextStyle(fontSize: 28),
                ),
                const SizedBox(width: 16),

                // Language Info
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        language['nativeName'],
                        style: TextStyle(
                          fontSize: 18,
                          fontWeight: FontWeight.w600,
                          color: isSelected
                              ? Theme.of(context).colorScheme.primary
                              : Colors.white,
                        ),
                      ),
                      const SizedBox(height: 4),
                      Text(
                        language['name'],
                        style: TextStyle(
                          fontSize: 14,
                          color: isSelected
                              ? Theme.of(context)
                                  .colorScheme
                                  .primary
                                  .withOpacity(0.7)
                              : Colors.white.withOpacity(0.7),
                        ),
                      ),
                    ],
                  ),
                ),

                // Selection Indicator
                if (isSelected)
                  Icon(
                    Icons.check_circle_rounded,
                    color: Theme.of(context).colorScheme.primary,
                    size: 24,
                  ),
              ],
            ),
          ),
        ),
      ),
    );

}

Widget \_buildThemeStep(bool isEnglish) {
return SingleChildScrollView(
child: Padding(
padding: const EdgeInsets.symmetric(vertical: 20),
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
// Icon
Icon(
Icons.palette_rounded,
size: 64,
color: Colors.white,
),
const SizedBox(height: 24),

            // Title
            Text(
              isEnglish ? 'Choose Theme' : '·åà·åΩ·â≥ ·ã≠·àù·à®·å°',
              style: const TextStyle(
                color: Colors.white,
                fontSize: 28,
                fontWeight: FontWeight.w700,
              ),
            ),
            const SizedBox(height: 8),

            // Subtitle
            Text(
              isEnglish
                  ? 'Select your preferred appearance'
                  : '·ã®·àö·çà·àç·åâ·âµ·äï ·åà·åΩ·â≥ ·ã≠·àù·à®·å°',
              style: TextStyle(
                color: Colors.white.withOpacity(0.7),
                fontSize: 16,
                fontWeight: FontWeight.w400,
              ),
            ),
            const SizedBox(height: 40),

            // Theme Options
            Wrap(
              spacing: 16,
              runSpacing: 16,
              alignment: WrapAlignment.center,
              children: _themes
                  .map((theme) => _buildThemeOption(theme, isEnglish))
                  .toList(),
            ),
          ],
        ),
      ),
    );

}

Widget \_buildThemeOption(Map<String, dynamic> theme, bool isEnglish) {
final isSelected = ref.watch(themeProvider) == theme['mode'];

    return Material(
      color: isSelected ? Colors.white : Colors.white.withOpacity(0.1),
      borderRadius: BorderRadius.circular(20),
      child: InkWell(
        onTap: () => _selectTheme(theme['mode']),
        borderRadius: BorderRadius.circular(20),
        child: Container(
          width: 140,
          height: 140,
          padding: const EdgeInsets.all(20),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              // Icon
              Icon(
                isSelected ? theme['selectedIcon'] : theme['icon'],
                size: 36,
                color: isSelected
                    ? Theme.of(context).colorScheme.primary
                    : Colors.white.withOpacity(0.8),
              ),
              const SizedBox(height: 12),

              // Theme Name
              Text(
                _getThemeDisplayName(theme['mode'], isEnglish),
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w600,
                  color: isSelected
                      ? Theme.of(context).colorScheme.primary
                      : Colors.white,
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 4),

              // Description
              Text(
                theme['description'],
                style: TextStyle(
                  fontSize: 12,
                  color: isSelected
                      ? Theme.of(context).colorScheme.primary.withOpacity(0.7)
                      : Colors.white.withOpacity(0.6),
                ),
                textAlign: TextAlign.center,
              ),
            ],
          ),
        ),
      ),
    );

}

Widget \_buildReadyStep(bool isEnglish) {
return Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
// Success Icon
Container(
width: 100,
height: 100,
decoration: BoxDecoration(
color: Colors.white,
borderRadius: BorderRadius.circular(50),
boxShadow: [
BoxShadow(
color: Colors.black.withOpacity(0.1),
blurRadius: 20,
offset: const Offset(0, 10),
),
],
),
child: Icon(
Icons.check_rounded,
size: 48,
color: Theme.of(context).colorScheme.primary,
),
),
const SizedBox(height: 32),

        // Title
        Text(
          isEnglish ? 'You\'re All Set!' : '·àÅ·àâ·àù ·äê·åà·à≠ ·ãù·åç·åÅ ·äê·ãç!',
          style: const TextStyle(
            color: Colors.white,
            fontSize: 32,
            fontWeight: FontWeight.w700,
          ),
        ),
        const SizedBox(height: 16),

        // Message
        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 20),
          child: Text(
            isEnglish
                ? 'Your preferences have been saved. Welcome to Andalus Smart POS!'
                : '·àù·à≠·å´·ãé·âΩ·ãé ·â∞·âÄ·àù·å†·ãã·àç·ç¢ ·ãà·ã∞ ·ä†·äï·ã≥·àâ·àµ ·àõ·à≠·â≤·äï ·çñ·àµ ·ä•·äï·ä≥·äï ·â†·ã∞·àÖ·äì ·àò·å°!',
            style: TextStyle(
              color: Colors.white.withOpacity(0.8),
              fontSize: 16,
              fontWeight: FontWeight.w400,
            ),
            textAlign: TextAlign.center,
          ),
        ),
        const SizedBox(height: 40),

        // Continue Button
        SizedBox(
          width: double.infinity,
          child: ElevatedButton(
            onPressed: _proceedToApp,
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.white,
              foregroundColor: Theme.of(context).colorScheme.primary,
              padding: const EdgeInsets.symmetric(vertical: 16),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(16),
              ),
              elevation: 0,
            ),
            child: Text(
              isEnglish ? 'Get Started' : '·åÄ·àù·à≠',
              style: const TextStyle(
                fontSize: 16,
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
        ),
      ],
    );

}

Widget \_buildNavigationButtons(bool isEnglish) {
return Container(
padding: const EdgeInsets.only(top: 20),
child: Row(
children: [
if (_currentStep > 1)
Expanded(
child: OutlinedButton(
onPressed: _previousStep,
style: OutlinedButton.styleFrom(
foregroundColor: Colors.white,
side: const BorderSide(color: Colors.white),
padding: const EdgeInsets.symmetric(vertical: 16),
shape: RoundedRectangleBorder(
borderRadius: BorderRadius.circular(16),
),
),
child: Text(isEnglish ? 'Back' : '·â∞·àò·àà·àµ'),
),
),
if (_currentStep > 1) const SizedBox(width: 12),
Expanded(
child: ElevatedButton(
onPressed: _nextStep,
style: ElevatedButton.styleFrom(
backgroundColor: Colors.white,
foregroundColor: Theme.of(context).colorScheme.primary,
padding: const EdgeInsets.symmetric(vertical: 16),
shape: RoundedRectangleBorder(
borderRadius: BorderRadius.circular(16),
),
elevation: 0,
),
child: Text(
isEnglish ? 'Continue' : '·âÄ·å£·ã≠',
style: const TextStyle(
fontWeight: FontWeight.w600,
),
),
),
),
],
),
);
}

String \_getThemeDisplayName(ThemeMode themeMode, bool isEnglish) {
switch (themeMode) {
case ThemeMode.light:
return isEnglish ? 'Light' : '·â•·à≠·àÉ·äï';
case ThemeMode.dark:
return isEnglish ? 'Dark' : '·å®·àà·àõ';
case ThemeMode.system:
return isEnglish ? 'System' : '·àµ·à≠·ä†·âµ';
}
}
}

// ui/screens/subscription_plans_screen.dart
// Screen for displaying and managing subscription plans.
import 'package:andalus_smart_pos/src/widgets/common/custom_card.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/data/models/subscription.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
import 'package:andalus_smart_pos/src/utils/formatters.dart';

class SubscriptionPlansScreen extends ConsumerStatefulWidget {
const SubscriptionPlansScreen({super.key});

@override
ConsumerState<SubscriptionPlansScreen> createState() =>
\_SubscriptionPlansScreenState();
}

class \_SubscriptionPlansScreenState
extends ConsumerState<SubscriptionPlansScreen> {
SubscriptionPlan? \_selectedPlan;
BillingCycle \_billingCycle = BillingCycle.monthly;
PaymentMethod \_selectedPaymentMethod = PaymentMethod.telebirr;

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);

    return Scaffold(
      appBar: AppBar(
        title: Text(localizations.translate('subscriptionPlans')),
        backgroundColor: theme.colorScheme.primary,
        foregroundColor: theme.colorScheme.onPrimary,
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildHeaderSection(localizations, theme),
            const SizedBox(height: 24),
            _buildBillingCycleSelector(localizations, theme),
            const SizedBox(height: 24),
            ..._buildPlanCards(localizations, theme),
            const SizedBox(height: 32),
            if (_selectedPlan != null)
              _buildPaymentSection(localizations, theme),
          ],
        ),
      ),
    );

}

Widget \_buildHeaderSection(AppLocalizations localizations, ThemeData theme) {
return Container(
width: double.infinity,
padding: const EdgeInsets.all(20),
decoration: BoxDecoration(
gradient: LinearGradient(
begin: Alignment.topLeft,
end: Alignment.bottomRight,
colors: [
theme.colorScheme.primary.withOpacity(0.1),
theme.colorScheme.primary.withOpacity(0.05),
]),
borderRadius: BorderRadius.circular(16),
),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Icon(Icons.workspace_premium,
size: 48, color: theme.colorScheme.primary),
const SizedBox(height: 16),
Text(
localizations.translate('choosePerfectPlan'),
style: theme.textTheme.headlineSmall
?.copyWith(fontWeight: FontWeight.bold),
),
const SizedBox(height: 8),
Text(
localizations.translate('startWithFreeTrial'),
style: theme.textTheme.bodyMedium
?.copyWith(color: theme.colorScheme.outline),
),
],
),
);
}

Widget \_buildBillingCycleSelector(
AppLocalizations localizations, ThemeData theme) {
return Row(
mainAxisAlignment: MainAxisAlignment.center,
children: [
_buildBillingOption(
BillingCycle.monthly,
localizations.translate('monthly'),
theme,
),
const SizedBox(width: 16),
_buildBillingOption(
BillingCycle.yearly,
localizations.translate('yearly'),
theme,
),
],
);
}

Widget \_buildBillingOption(
BillingCycle cycle, String label, ThemeData theme) {
final isSelected = \_billingCycle == cycle;
return Expanded(
child: GestureDetector(
onTap: () => setState(() => \_billingCycle = cycle),
child: Container(
padding: const EdgeInsets.all(16),
decoration: BoxDecoration(
color: isSelected
? theme.colorScheme.primary
: theme.colorScheme.surface,
border: Border.all(
color: isSelected
? theme.colorScheme.primary
: theme.colorScheme.outline.withOpacity(0.3),
),
borderRadius: BorderRadius.circular(12),
),
child: Column(
children: [
Text(
label,
style: TextStyle(
fontWeight: FontWeight.bold,
color: isSelected
? theme.colorScheme.onPrimary
: theme.colorScheme.onSurface,
),
),
if (cycle == BillingCycle.yearly) ...[
const SizedBox(height: 4),
Text(
// localizations.translate('performanceOverview')
'Save 20%',
style: TextStyle(
fontSize: 12,
color: isSelected
? theme.colorScheme.onPrimary
: theme.colorScheme.primary,
),
),
],
],
),
),
),
);
}

List<Widget> \_buildPlanCards(
AppLocalizations localizations, ThemeData theme) {
return SubscriptionPlan.all
.map((plan) => \_buildPlanCard(plan, localizations, theme))
.toList();
}

Widget \_buildPlanCard(
SubscriptionPlan plan, AppLocalizations localizations, ThemeData theme) {
final isSelected = \_selectedPlan == plan;
final isPopular = plan.id == 'professional';

    return Container(
      margin: const EdgeInsets.only(bottom: 16),
      decoration: BoxDecoration(
        border: Border.all(
          color: isSelected ? theme.colorScheme.primary : Colors.transparent,
          width: 2,
        ),
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          if (isSelected || isPopular)
            BoxShadow(
              color: theme.colorScheme.primary.withOpacity(0.1),
              blurRadius: 8,
              offset: const Offset(0, 4),
            ),
        ],
      ),
      child: Stack(
        children: [
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header
              Container(
                width: double.infinity,
                padding: const EdgeInsets.all(20),
                decoration: BoxDecoration(
                  color: _getPlanColor(plan, theme).withOpacity(0.1),
                  borderRadius: const BorderRadius.only(
                    topLeft: Radius.circular(16),
                    topRight: Radius.circular(16),
                  ),
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Text(plan.name,
                            style: theme.textTheme.titleLarge?.copyWith(
                              fontWeight: FontWeight.bold,
                              color: _getPlanColor(plan, theme),
                            )),
                        if (isPopular)
                          Container(
                            padding: const EdgeInsets.symmetric(
                                horizontal: 12, vertical: 6),
                            decoration: BoxDecoration(
                              color: _getPlanColor(plan, theme),
                              borderRadius: BorderRadius.circular(12),
                            ),
                            child: Text(
                              localizations.translate('popular'),
                              style: const TextStyle(
                                  color: Colors.white,
                                  fontSize: 12,
                                  fontWeight: FontWeight.bold),
                            ),
                          ),
                      ],
                    ),
                    const SizedBox(height: 8),
                    Text(plan.description, style: theme.textTheme.bodyMedium),
                    const SizedBox(height: 16),
                    Text(
                      plan.getFormattedPrice(_billingCycle),
                      style: theme.textTheme.headlineSmall?.copyWith(
                        fontWeight: FontWeight.bold,
                        color: _getPlanColor(plan, theme),
                      ),
                    ),
                    if (_billingCycle == BillingCycle.yearly) ...[
                      const SizedBox(height: 4),
                      Text(
                        plan.savingsInfo,
                        style: theme.textTheme.bodySmall
                            ?.copyWith(color: Colors.green),
                      ),
                    ],
                  ],
                ),
              ),

              // Features
              Padding(
                padding: const EdgeInsets.all(20),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    ...plan.features.map((feature) => Padding(
                          padding: const EdgeInsets.symmetric(vertical: 4),
                          child: Row(
                            children: [
                              Icon(Icons.check_circle,
                                  color: _getPlanColor(plan, theme), size: 16),
                              const SizedBox(width: 8),
                              Expanded(
                                  child: Text(feature,
                                      style: theme.textTheme.bodyMedium)),
                            ],
                          ),
                        )),
                    const SizedBox(height: 20),
                    SizedBox(
                      width: double.infinity,
                      child: ElevatedButton(
                        onPressed: () => setState(() => _selectedPlan = plan),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: isSelected
                              ? _getPlanColor(plan, theme)
                              : Colors.transparent,
                          foregroundColor: isSelected
                              ? Colors.white
                              : _getPlanColor(plan, theme),
                          side: BorderSide(color: _getPlanColor(plan, theme)),
                        ),
                        child: Text(isSelected
                            ? localizations.translate('selected')
                            : localizations.translate('selectPlan')),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ],
      ),
    );

}

Widget \_buildPaymentSection(AppLocalizations localizations, ThemeData theme) {
return Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(localizations.translate('paymentMethod'),
style: theme.textTheme.titleMedium),
const SizedBox(height: 16),
_buildPaymentMethodSelector(localizations, theme),
const SizedBox(height: 24),
_buildOrderSummary(localizations, theme),
const SizedBox(height: 24),
SizedBox(
width: double.infinity,
child: ElevatedButton(
onPressed: _processPayment,
style: ElevatedButton.styleFrom(
backgroundColor: theme.colorScheme.primary,
foregroundColor: theme.colorScheme.onPrimary,
padding: const EdgeInsets.symmetric(vertical: 16),
),
child: Text(localizations.translate('subscribeNow')),
),
),
],
);
}

Widget \_buildPaymentMethodSelector(
AppLocalizations localizations, ThemeData theme) {
return Wrap(
spacing: 12,
runSpacing: 12,
children: PaymentMethod.values
.map((method) =>
\_buildPaymentMethodOption(method, localizations, theme))
.toList(),
);
}

Widget \_buildPaymentMethodOption(
PaymentMethod method, AppLocalizations localizations, ThemeData theme) {
final isSelected = \_selectedPaymentMethod == method;
return GestureDetector(
onTap: () => setState(() => \_selectedPaymentMethod = method),
child: Container(
padding: const EdgeInsets.all(16),
decoration: BoxDecoration(
color: isSelected
? theme.colorScheme.primary.withOpacity(0.1)
: theme.colorScheme.surface,
border: Border.all(
color: isSelected
? theme.colorScheme.primary
: theme.colorScheme.outline.withOpacity(0.3),
),
borderRadius: BorderRadius.circular(12),
),
child: Row(
mainAxisSize: MainAxisSize.min,
children: [
Icon(_getPaymentMethodIcon(method),
color: _getPaymentMethodColor(method)),
const SizedBox(width: 8),
Text(_getPaymentMethodName(method, localizations)),
],
),
),
);
}

Widget \_buildOrderSummary(AppLocalizations localizations, ThemeData theme) {
final price = \_selectedPlan!.getPrice(\_billingCycle);
final tax = price \* 0.15; // 15% tax
final total = price + tax;

    return CustomCard(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(localizations.translate('orderSummary'),
                style: theme.textTheme.titleMedium),
            const SizedBox(height: 16),
            _buildOrderRow(localizations.translate('plan'),
                '${_selectedPlan!.name} (${_billingCycle.displayName})'),
            _buildOrderRow(localizations.translate('price'),
                AppFormatters.formatCurrency(price)),
            _buildOrderRow(localizations.translate('tax'),
                AppFormatters.formatCurrency(tax)),
            const Divider(),
            _buildOrderRow(localizations.translate('total'),
                AppFormatters.formatCurrency(total),
                isTotal: true),
          ],
        ),
      ),
    );

}

Widget \_buildOrderRow(String label, String value, {bool isTotal = false}) {
return Padding(
padding: const EdgeInsets.symmetric(vertical: 8),
child: Row(
mainAxisAlignment: MainAxisAlignment.spaceBetween,
children: [
Text(label,
style: TextStyle(
fontWeight: isTotal ? FontWeight.bold : FontWeight.normal,
)),
Text(value,
style: TextStyle(
fontWeight: isTotal ? FontWeight.bold : FontWeight.normal,
)),
],
),
);
}

Future<void> \_processPayment() async {
if (\_selectedPlan == null) return;

    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => const PaymentProcessingDialog(),
    );

    try {
      // Simulate payment processing
      await Future.delayed(const Duration(seconds: 2));

      Navigator.pop(context); // Close loading dialog

      // Show success dialog
      _showPaymentSuccessDialog();
    } catch (e) {
      Navigator.pop(context); // Close loading dialog
      _showPaymentErrorDialog(e.toString());
    }

}

void \_showPaymentSuccessDialog() {
showDialog(
context: context,
builder: (context) => AlertDialog(
title: const Text('Payment Successful'),
content:
const Text('Your subscription has been activated successfully.'),
actions: [
TextButton(
onPressed: () {
Navigator.pop(context);
Navigator.pop(context); // Go back to reports screen
},
child: const Text('Continue'),
),
],
),
);
}

void \_showPaymentErrorDialog(String error) {
showDialog(
context: context,
builder: (context) => AlertDialog(
title: const Text('Payment Failed'),
content: Text('Error: $error'),
actions: [
TextButton(
onPressed: () => Navigator.pop(context),
child: const Text('Try Again'),
),
],
),
);
}

// Helper methods
Color \_getPlanColor(SubscriptionPlan plan, ThemeData theme) {
switch (plan.id) {
case 'basic':
return theme.colorScheme.primary;
case 'professional':
return Colors.green;
case 'enterprise':
return Colors.purple;
default:
return theme.colorScheme.outline;
}
}

IconData \_getPaymentMethodIcon(PaymentMethod method) {
switch (method) {
case PaymentMethod.telebirr:
return Icons.phone_android;
case PaymentMethod.bank:
return Icons.account_balance;
case PaymentMethod.cash:
return Icons.money;
case PaymentMethod.card:
return Icons.credit_card;
}
}

Color \_getPaymentMethodColor(PaymentMethod method) {
switch (method) {
case PaymentMethod.telebirr:
return Colors.green;
case PaymentMethod.bank:
return Colors.blue;
case PaymentMethod.cash:
return Colors.orange;
case PaymentMethod.card:
return Colors.purple;
}
}

String \_getPaymentMethodName(
PaymentMethod method, AppLocalizations localizations) {
switch (method) {
case PaymentMethod.telebirr:
return 'Telebirr';
case PaymentMethod.bank:
return localizations.translate('bankTransfer');
case PaymentMethod.cash:
return localizations.translate('cash');
case PaymentMethod.card:
return localizations.translate('card');
}
}
}

class PaymentProcessingDialog extends StatelessWidget {
const PaymentProcessingDialog({super.key});

@override
Widget build(BuildContext context) {
return Dialog(
child: Padding(
padding: const EdgeInsets.all(24),
child: Column(
mainAxisSize: MainAxisSize.min,
children: [
CircularProgressIndicator(),
const SizedBox(height: 16),
Text('Processing Payment...'),
],
),
),
);
}
}

enum PaymentMethod { telebirr, bank, cash, card }

##

// src/utils/calendar_utils.dart
// Utility functions and state management for handling Gregorian and Ethiopian calendars,
// including date conversions, formatting, and user preferences.
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'dart:convert';

enum CalendarType {
gregorian('Gregorian', '·åç·à™·åé·à≠·ã´·äï'),
ethiopian('Ethiopian', '·ä¢·âµ·ãÆ·åµ·ã´·ãä');

final String englishName;
final String amharicName;

const CalendarType(this.englishName, this.amharicName);
}

class CalendarSettings {
final CalendarType calendarType;
final double fontSizeScale;

const CalendarSettings({
this.calendarType = CalendarType.gregorian,
this.fontSizeScale = 1.0,
});

CalendarSettings copyWith({
CalendarType? calendarType,
double? fontSizeScale,
}) {
return CalendarSettings(
calendarType: calendarType ?? this.calendarType,
fontSizeScale: fontSizeScale ?? this.fontSizeScale,
);
}

Map<String, dynamic> toMap() {
return {
'calendar_type': calendarType.name,
'font_size_scale': fontSizeScale,
};
}

factory CalendarSettings.fromMap(Map<String, dynamic> map) {
return CalendarSettings(
calendarType: CalendarType.values.firstWhere(
(e) => e.name == map['calendar_type'],
orElse: () => CalendarType.gregorian,
),
fontSizeScale: map['font_size_scale']?.toDouble() ?? 1.0,
);
}
}

final calendarProvider =
StateNotifierProvider<CalendarNotifier, CalendarSettings>(
(ref) => CalendarNotifier(),
);

class CalendarNotifier extends StateNotifier<CalendarSettings> {
CalendarNotifier() : super(const CalendarSettings()) {
\_loadSettings();
}

static const String \_settingsKey = 'calendar_settings';

Future<void> \_loadSettings() async {
try {
final prefs = await SharedPreferences.getInstance();
final settingsString = prefs.getString(\_settingsKey);

      if (settingsString != null && settingsString.isNotEmpty) {
        try {
          final settingsMap =
              Map<String, dynamic>.from(json.decode(settingsString));
          state = CalendarSettings.fromMap(settingsMap);
        } catch (e) {
          print('Error parsing calendar settings: $e');
          // Fallback to default settings
          final calendarIndex = prefs.getInt('preferred_calendar') ?? 0;
          state = CalendarSettings(
            calendarType: CalendarType.values[calendarIndex],
            fontSizeScale: 1.0,
          );
        }
      } else {
        // Legacy support for old preference format
        final calendarIndex = prefs.getInt('preferred_calendar') ?? 0;
        state = CalendarSettings(
          calendarType: CalendarType.values[calendarIndex],
          fontSizeScale: 1.0,
        );
      }
    } catch (e) {
      print('Error loading calendar settings: $e');
      state = const CalendarSettings();
    }

}

Future<void> setCalendarType(CalendarType type) async {
state = state.copyWith(calendarType: type);
await \_saveSettings();
}

Future<void> setFontSizeScale(double scale) async {
state = state.copyWith(fontSizeScale: scale.clamp(0.8, 1.5));
await \_saveSettings();
}

Future<void> \_saveSettings() async {
try {
final prefs = await SharedPreferences.getInstance();
await prefs.setString(\_settingsKey, json.encode(state.toMap()));
// Also save legacy format for compatibility
await prefs.setInt('preferred_calendar', state.calendarType.index);
} catch (e) {
print('Error saving calendar settings: $e');
}
}
}

// Ethiopian Date Implementation
class EthiopianDateTime {
final int year;
final int month;
final int day;

EthiopianDateTime(
{required this.year, required this.month, required this.day});

// Convert Gregorian to Ethiopian date
// This is a simplified conversion algorithm
factory EthiopianDateTime.fromGregorian(DateTime gregorianDate) {
final gYear = gregorianDate.year;
final gMonth = gregorianDate.month;
final gDay = gregorianDate.day;

    // Ethiopian calendar starts on September 11/12 in Gregorian calendar
    final ethiopianYear = gYear - 8;

    int ethiopianMonth;
    int ethiopianDay;

    if (gMonth >= 9) {
      // September to December
      if (gMonth == 9) {
        if (gDay >= 11) {
          ethiopianMonth = 1; // Meskerem
          ethiopianDay = gDay - 10;
        } else {
          ethiopianMonth = 13; // Pagume (previous year)
          ethiopianDay = gDay + 5; // Approximate
          // Note: This is simplified - actual Pagume has 5-6 days
        }
      } else {
        ethiopianMonth = gMonth - 8;
        ethiopianDay = gDay;
      }
    } else {
      // January to August
      if (gMonth == 1) {
        if (gDay <= 10) {
          ethiopianMonth = 5; // Tir
          ethiopianDay = gDay + 20; // Approximate
        } else {
          ethiopianMonth = 6; // Yekatit
          ethiopianDay = gDay - 10;
        }
      } else {
        ethiopianMonth = gMonth + 4;
        ethiopianDay = gDay;
      }
    }

    // Adjust for edge cases (simplified)
    if (ethiopianDay > 30) {
      ethiopianDay -= 30;
      ethiopianMonth += 1;
    }

    if (ethiopianMonth > 13) {
      ethiopianMonth = 1;
      // Note: Year adjustment would go here in a complete implementation
    }

    return EthiopianDateTime(
      year: ethiopianYear,
      month: ethiopianMonth,
      day: ethiopianDay,
    );

}

// Convert Ethiopian to Gregorian date
DateTime toGregorian() {
// Simplified conversion back to Gregorian
final gregorianYear = year + 8;

    int gregorianMonth;
    int gregorianDay;

    if (month <= 4) {
      gregorianMonth = month + 8;
      gregorianDay = day;
    } else {
      gregorianMonth = month - 4;
      gregorianDay = day;
    }

    // Adjust for edge cases
    if (gregorianMonth > 12) {
      gregorianMonth -= 12;
      // Note: Year adjustment would go here
    }

    return DateTime(gregorianYear, gregorianMonth, gregorianDay);

}

@override
String toString() {
return 'EthiopianDateTime{year: $year, month: $month, day: $day}';
}
}

class CalendarUtils {
static CalendarType get currentCalendar {
return CalendarType.gregorian; // Default, will be overridden by provider
}

static Future<void> setCalendarType(CalendarType type) async {
final prefs = await SharedPreferences.getInstance();
await prefs.setInt('preferred_calendar', type.index);
}

// Date conversion utilities
static EthiopianDateTime toEthiopian(DateTime gregorianDate) {
return EthiopianDateTime.fromGregorian(gregorianDate);
}

static DateTime toGregorian(EthiopianDateTime ethiopianDate) {
return ethiopianDate.toGregorian();
}

// Format date based on selected calendar
static String formatDate(
DateTime date, CalendarType calendarType, BuildContext context) {
final locale = Localizations.localeOf(context);

    if (calendarType == CalendarType.ethiopian) {
      final ethiopianDate = toEthiopian(date);
      return '${ethiopianDate.day}/${ethiopianDate.month}/${ethiopianDate.year}';
    } else {
      return DateFormat('dd/MM/yyyy', locale.languageCode).format(date);
    }

}

static String formatFullDate(
DateTime date, CalendarType calendarType, BuildContext context) {
final locale = Localizations.localeOf(context);

    if (calendarType == CalendarType.ethiopian) {
      final ethiopianDate = toEthiopian(date);
      final monthNames = getEthiopianMonthNames(locale.languageCode);
      final weekdayNames = getEthiopianWeekdayNames(locale.languageCode);

      return '${weekdayNames[date.weekday - 1]}, ${ethiopianDate.day} ${monthNames[ethiopianDate.month - 1]} ${ethiopianDate.year}';
    } else {
      return DateFormat('EEEE, MMMM d, y', locale.languageCode).format(date);
    }

}

static String formatDateTime(
DateTime date, CalendarType calendarType, BuildContext context) {
final locale = Localizations.localeOf(context);
final timeFormat = DateFormat('HH:mm', locale.languageCode);

    if (calendarType == CalendarType.ethiopian) {
      final ethiopianDate = toEthiopian(date);
      return '${ethiopianDate.day}/${ethiopianDate.month}/${ethiopianDate.year} ${timeFormat.format(date)}';
    } else {
      return DateFormat('dd/MM/yyyy HH:mm', locale.languageCode).format(date);
    }

}

// Get current date in selected calendar
static String getCurrentDate(
CalendarType calendarType, BuildContext context) {
return formatDate(DateTime.now(), calendarType, context);
}

static String getCurrentFullDate(
CalendarType calendarType, BuildContext context) {
return formatFullDate(DateTime.now(), calendarType, context);
}

// Ethiopian calendar names
static List<String> getEthiopianMonthNames(String languageCode) {
if (languageCode == 'am') {
return [
'·àò·àµ·ä®·à®·àù',
'·å•·âÖ·àù·âµ',
'·äÖ·ã≥·à≠',
'·â≥·àÖ·à£·à•',
'·å•·à≠',
'·ã®·ä´·â≤·âµ',
'·àò·åã·â¢·âµ',
'·àö·ã´·ãù·ã´',
'·åç·äï·â¶·âµ',
'·à∞·äî',
'·àê·àù·àå',
'·äê·àê·à¥',
'·å≥·åâ·àú'
];
} else {
return [
'Meskerem',
'Tikimit',
'Hidar',
'Tahsas',
'Tir',
'Yekatit',
'Megabit',
'Miyazya',
'Ginbot',
'Sene',
'Hamle',
'Nehase',
'Pagume'
];
}
}

static List<String> getEthiopianWeekdayNames(String languageCode) {
if (languageCode == 'am') {
return ['·à∞·äû', '·àõ·ä≠·à∞·äû', '·à®·â°·ãï', '·àê·àô·àµ', '·ãì·à≠·â•', '·âÖ·ã≥·àú', '·ä•·àë·ãµ'];
} else {
return [
'Monday',
'Tuesday',
'Wednesday',
'Thursday',
'Friday',
'Saturday',
'Sunday'
];
}
}

// Date range utilities
static Map<String, DateTime> getDateRange(
CalendarType calendarType, String rangeType) {
final now = DateTime.now();

    switch (rangeType) {
      case 'today':
        return {
          'start': DateTime(now.year, now.month, now.day),
          'end': DateTime(now.year, now.month, now.day, 23, 59, 59),
        };
      case 'week':
        final start = now.subtract(Duration(days: now.weekday - 1));
        return {
          'start': DateTime(start.year, start.month, start.day),
          'end': DateTime(now.year, now.month, now.day, 23, 59, 59),
        };
      case 'month':
        return {
          'start': DateTime(now.year, now.month, 1),
          'end': DateTime(now.year, now.month + 1, 0, 23, 59, 59),
        };
      default:
        return {
          'start': DateTime(now.year, now.month, now.day),
          'end': DateTime(now.year, now.month, now.day, 23, 59, 59),
        };
    }

}

// Validation for Ethiopian dates
static bool isValidEthiopianDate(int year, int month, int day) {
if (month < 1 || month > 13) return false;
if (day < 1 || day > 30) return false;
// Pagume (13th month) has 5-6 days in leap years
if (month == 13 && day > 6) return false;
return true;
}

// Get display name for calendar type
static String getCalendarDisplayName(CalendarType type, String languageCode) {
if (languageCode == 'am') {
return type.amharicName;
} else {
return type.englishName;
}
}

// Check if date is Ethiopian New Year (September 11)
static bool isEthiopianNewYear(DateTime date) {
return date.month == 9 && date.day == 11;
}

// Get Ethiopian year from Gregorian date
static int getEthiopianYear(DateTime gregorianDate) {
final ethDate = toEthiopian(gregorianDate);
return ethDate.year;
}
}

// JSON utility for encoding/decoding

// Extension for easy JSON serialization
extension CalendarSettingsJson on CalendarSettings {
String toJson() => json.encode(toMap());

static CalendarSettings fromJson(String jsonString) {
return CalendarSettings.fromMap(json.decode(jsonString));
}
}

##

// lib/src/utils/chart_formatters.dart
// Utility class for formatting numbers in charts, including currency and percentage formats.
import 'package:intl/intl.dart';

class ChartFormatters {
static NumberFormat get currencyFormat {
return NumberFormat.currency(
symbol: 'ETB ',
decimalDigits: 2,
);
}

static NumberFormat get compactCurrency {
return NumberFormat.compactCurrency(
symbol: 'ETB ',
decimalDigits: 0,
);
}

static NumberFormat get percentageFormat {
return NumberFormat.percentPattern();
}
}

##

// lib/src/utils/database_init.dart
// Utility for initializing the database with default data such as business profile and admin user.
import 'package:andalus_smart_pos/src/data/local/database.dart';
import 'package:andalus_smart_pos/src/data/models/user.dart';
import 'package:crypto/crypto.dart';
import 'dart:convert';

import 'package:sqflite/sqflite.dart';

class DatabaseInitializer {
static Future<void> initializeDefaultData() async {
final db = await AppDatabase.database;

    // First, create a default business profile if it doesn't exist
    await _createDefaultBusiness(db);

    // Then create default admin user
    await _createDefaultAdminUser(db);

}

static Future<void> \_createDefaultBusiness(Database db) async {
final businesses = await db.query('business_profile');
if (businesses.isEmpty) {
final now = DateTime.now().millisecondsSinceEpoch;
await db.insert('business_profile', {
'business_id': 'business_001',
'name': 'Andalus POS Shop',
'name_am': '·ä†·äï·ã∞·àâ·àµ ·çñ·àµ ·à±·âÖ',
'business_type': 'Retail',
'phone': '+251911223344',
'email': 'info@andaluspos.com',
'address': 'Addis Ababa, Ethiopia',
'city': 'Addis Ababa',
'region': 'Addis Ababa',
'tin_number': '0000000000',
'vat_number': 'VAT000000',
'business_license': 'LIC001',
'owner_name': 'Admin User',
'owner_phone': '+251911223344',
'owner_email': 'admin@andaluspos.com',
'currency': 'ETB',
'logo_path': null,
'receipt_header':
'Andalus Smart POS\nMobile-first POS for Ethiopian Shops',
'receipt_footer': 'Thank you for your business!',
'is_active': 1,
'created_at': now,
'updated_at': now,
});
print('Default business profile created');
}
}

static Future<void> \_createDefaultAdminUser(Database db) async {
final users = await db.query('users');
if (users.isEmpty) {
// Create default admin user with password hash
final adminUser = User(
id: 'admin_001',
name: 'Admin User',
phone: '+911223344', // Change this to your admin phone
email: 'admin@andaluspos.com',
role: UserRole.owner,
createdAt: DateTime.now(),
isActive: true,
isVerified: true,
businessId: 'business_001',
passwordHash: \_hashPassword('admin123'), // Set password hash directly
);

      await db.insert('users', adminUser.toMap());
      print(
          'Default admin user created with phone: ${adminUser.phone} and password: admin123');
    }

}

static String \_hashPassword(String password) {
// Simple hashing for demo - in production use more secure hashing
final bytes = utf8.encode(password);
final digest = sha256.convert(bytes);
return digest.toString();
}
}

##

// src/utils/date_utils.dart
// Utility class for date and time formatting, conversions, and calculations,
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import 'package:andalus_smart_pos/src/providers/calendar_provider.dart';
import 'package:andalus_smart_pos/src/providers/language_provider.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart'; // Import the actual AppLocalizations
import 'ethiopian_calendar.dart';

class AppDateUtils {
// Date formats
static final DateFormat \_dateFormat = DateFormat('dd/MM/yyyy');
static final DateFormat \_timeFormat = DateFormat('HH:mm');
static final DateFormat \_dateTimeFormat = DateFormat('dd/MM/yyyy HH:mm');
static final DateFormat \_fullDateFormat = DateFormat('EEEE, MMMM d, y');
static final DateFormat \_monthYearFormat = DateFormat('MMMM y');
static final DateFormat \_weekdayFormat = DateFormat('EEEE');
static final DateFormat \_shortDateFormat = DateFormat('MMM d, y');

// Ethiopian date formats (Amharic)
static final DateFormat \_ethiopianDateFormat =
DateFormat('dd/MM/yyyy', 'am_ET');
static final DateFormat \_ethiopianDateTimeFormat =
DateFormat('dd/MM/yyyy HH:mm', 'am_ET');

// Basic date formatting
static String formatDate(DateTime date) {
return \_dateFormat.format(date);
}

static String formatTime(DateTime date) {
return \_timeFormat.format(date);
}

static String formatDateTime(DateTime date) {
return \_dateTimeFormat.format(date);
}

static String formatFullDate(DateTime date) {
return \_fullDateFormat.format(date);
}

static String formatMonthYear(DateTime date) {
return \_monthYearFormat.format(date);
}

static String formatWeekday(DateTime date) {
return \_weekdayFormat.format(date);
}

static String formatShortDate(DateTime date) {
return \_shortDateFormat.format(date);
}

// Ethiopian date formatting
static String formatEthiopianDate(DateTime date) {
return \_ethiopianDateFormat.format(date);
}

static String formatEthiopianDateTime(DateTime date) {
return \_ethiopianDateTimeFormat.format(date);
}

// Get current date in selected calendar
static String getCurrentDate(BuildContext context, WidgetRef ref) {
final calendarSettings = ref.read(calendarProvider);
final now = DateTime.now();

    if (calendarSettings.calendarType == CalendarType.ethiopian) {
      final ethDate = EthiopianCalendar.gregorianToEthiopian(now);
      return '${ethDate.day}/${ethDate.month}/${ethDate.year}';
    } else {
      return formatDate(now);
    }

}

static String getCurrentFullDate(BuildContext context, WidgetRef ref) {
final calendarSettings = ref.read(calendarProvider);
final now = DateTime.now();
final locale = Localizations.localeOf(context);

    if (calendarSettings.calendarType == CalendarType.ethiopian) {
      final ethDate = EthiopianCalendar.gregorianToEthiopian(now);
      return EthiopianCalendar.formatDate(ethDate, locale.languageCode);
    } else {
      return formatFullDate(now);
    }

}

static String getCurrentDateDisplay(WidgetRef ref) {
final now = DateTime.now();
final calendarSettings = ref.read(calendarProvider);
final locale = ref.read(languageProvider);

    if (calendarSettings.calendarType == CalendarType.ethiopian) {
      final ethDate = EthiopianCalendar.gregorianToEthiopian(now);
      return '${ethDate.day}/${ethDate.month}/${ethDate.year}';
    } else {
      return formatDate(now);
    }

}

static String formatLiveTime(DateTime time, WidgetRef ref) {
return DateFormat('HH:mm:ss').format(time);
}

static String formatDateBasedOnCalendar(
DateTime date, CalendarType calendarType, BuildContext context) {
if (calendarType == CalendarType.ethiopian) {
final ethDate = EthiopianCalendar.gregorianToEthiopian(date);
return '${ethDate.day}/${ethDate.month}/${ethDate.year}';
} else {
return formatDate(date);
}
}

static String formatFullDateBasedOnCalendar(
DateTime date, CalendarType calendarType, BuildContext context) {
if (calendarType == CalendarType.ethiopian) {
final ethDate = EthiopianCalendar.gregorianToEthiopian(date);
final locale = Localizations.localeOf(context);
return EthiopianCalendar.formatDate(ethDate, locale.languageCode);
} else {
return formatFullDate(date);
}
}

// Get live date time with proper ref
static String getLiveDateTime(BuildContext context, WidgetRef ref) {
final now = DateTime.now();
final calendarSettings = ref.read(calendarProvider);
final timeFormat = DateFormat('HH:mm:ss');

    if (calendarSettings.calendarType == CalendarType.ethiopian) {
      final ethDate = EthiopianCalendar.gregorianToEthiopian(now);
      return '${ethDate.day}/${ethDate.month}/${ethDate.year} ${timeFormat.format(now)}';
    } else {
      return DateFormat('dd/MM/yyyy HH:mm:ss').format(now);
    }

}

// Relative time formatting
static String formatRelativeTime(DateTime date) {
final now = DateTime.now();
final difference = now.difference(date);

    if (difference.inSeconds < 60) {
      return 'Just now';
    } else if (difference.inMinutes < 60) {
      return '${difference.inMinutes} min ago';
    } else if (difference.inHours < 24) {
      return '${difference.inHours} hr ago';
    } else if (difference.inDays < 7) {
      return '${difference.inDays} days ago';
    } else {
      return formatDate(date);
    }

}

// Business date utilities
static DateTime get startOfToday {
final now = DateTime.now();
return DateTime(now.year, now.month, now.day);
}

static DateTime get endOfToday {
final now = DateTime.now();
return DateTime(now.year, now.month, now.day, 23, 59, 59, 999);
}

static DateTime get startOfWeek {
final now = DateTime.now();
final weekday = now.weekday;
return DateTime(now.year, now.month, now.day - weekday + 1);
}

static DateTime get endOfWeek {
final now = DateTime.now();
final weekday = now.weekday;
return DateTime(
now.year, now.month, now.day + (7 - weekday), 23, 59, 59, 999);
}

static DateTime get startOfMonth {
final now = DateTime.now();
return DateTime(now.year, now.month, 1);
}

static DateTime get endOfMonth {
final now = DateTime.now();
return DateTime(now.year, now.month + 1, 0, 23, 59, 59, 999);
}

static DateTime get startOfYear {
final now = DateTime.now();
return DateTime(now.year, 1, 1);
}

static DateTime get endOfYear {
final now = DateTime.now();
return DateTime(now.year, 12, 31, 23, 59, 59, 999);
}

// Date range utilities
static List<DateTime> getLast7Days() {
final List<DateTime> days = [];
for (int i = 6; i >= 0; i--) {
days.add(DateTime.now().subtract(Duration(days: i)));
}
return days;
}

static List<DateTime> getLast30Days() {
final List<DateTime> days = [];
for (int i = 29; i >= 0; i--) {
days.add(DateTime.now().subtract(Duration(days: i)));
}
return days;
}

static List<DateTime> getLast90Days() {
final List<DateTime> days = [];
for (int i = 89; i >= 0; i--) {
days.add(DateTime.now().subtract(Duration(days: i)));
}
return days;
}

static List<DateTime> getLast365Days() {
final List<DateTime> days = [];
for (int i = 364; i >= 0; i--) {
days.add(DateTime.now().subtract(Duration(days: i)));
}
return days;
}

// Validation utilities
static bool isToday(DateTime date) {
final now = DateTime.now();
return date.year == now.year &&
date.month == now.month &&
date.day == now.day;
}

static bool isYesterday(DateTime date) {
final yesterday = DateTime.now().subtract(const Duration(days: 1));
return date.year == yesterday.year &&
date.month == yesterday.month &&
date.day == yesterday.day;
}

static bool isThisWeek(DateTime date) {
final now = DateTime.now();
final startOfWeek =
DateTime(now.year, now.month, now.day - now.weekday + 1);
final endOfWeek =
DateTime(now.year, now.month, now.day + (7 - now.weekday), 23, 59, 59);
return date.isAfter(startOfWeek) && date.isBefore(endOfWeek);
}

static bool isThisMonth(DateTime date) {
final now = DateTime.now();
return date.year == now.year && date.month == now.month;
}

static bool isThisYear(DateTime date) {
final now = DateTime.now();
return date.year == now.year;
}

// Age calculation
static int calculateAge(DateTime birthDate) {
final now = DateTime.now();
int age = now.year - birthDate.year;
if (now.month < birthDate.month ||
(now.month == birthDate.month && now.day < birthDate.day)) {
age--;
}
return age;
}

// Due date calculations for credit management
static DateTime calculateDueDate(DateTime fromDate, int days) {
return fromDate.add(Duration(days: days));
}

static bool isOverdue(DateTime dueDate) {
return DateTime.now().isAfter(dueDate);
}

static int daysUntilDue(DateTime dueDate) {
final now = DateTime.now();
final difference = dueDate.difference(now);
return difference.inDays;
}

static int daysOverdue(DateTime dueDate) {
final now = DateTime.now();
final difference = now.difference(dueDate);
return difference.inDays;
}

static String formatDueDate(DateTime dueDate) {
if (isOverdue(dueDate)) {
final int overdueDays = daysOverdue(dueDate);

      return '$overdueDays days overdue';
    } else {
      final daysUntil = daysUntilDue(dueDate);
      return 'Due in $daysUntil days';
    }

}

// Sales period formatting
static String formatSalesPeriod(DateTime start, DateTime end) {
if (isToday(start) && isToday(end)) {
return 'Today';
} else if (isThisWeek(start) && isThisWeek(end)) {
return 'This Week';
} else if (isThisMonth(start) && isThisMonth(end)) {
return 'This Month';
} else {
return '${formatDate(start)} - ${formatDate(end)}';
}
}

// Ethiopian calendar utilities
static EthiopianDate toEthiopianDate(DateTime gregorianDate) {
return EthiopianCalendar.gregorianToEthiopian(gregorianDate);
}

static DateTime toGregorianDate(EthiopianDate ethiopianDate) {
return EthiopianCalendar.ethiopianToGregorian(ethiopianDate);
}

// Time utility for business hours
static bool isBusinessHours(DateTime time) {
final hour = time.hour;
return hour >= 8 && hour <= 20; // 8 AM to 8 PM
}

static String formatBusinessHours(DateTime time) {
if (isBusinessHours(time)) {
return 'Open';
} else {
return 'Closed';
}
}

// Duration formatting
static String formatDuration(Duration duration) {
if (duration.inDays > 0) {
return '${duration.inDays}d ${duration.inHours.remainder(24)}h ${duration.inMinutes.remainder(60)}m';
    } else if (duration.inHours > 0) {
      return '${duration.inHours}h ${duration.inMinutes.remainder(60)}m';
    } else if (duration.inMinutes > 0) {
      return '${duration.inMinutes}m';
} else {
return '${duration.inSeconds}s';
}
}

static String formatDurationShort(Duration duration) {
if (duration.inDays > 0) {
return '${duration.inDays}d';
    } else if (duration.inHours > 0) {
      return '${duration.inHours}h';
} else if (duration.inMinutes > 0) {
return '${duration.inMinutes}m';
    } else {
      return '${duration.inSeconds}s';
}
}

// Date comparison for sorting
static int compareDates(DateTime a, DateTime b) {
return b.compareTo(a); // Descending order (newest first)
}

static int compareDatesAscending(DateTime a, DateTime b) {
return a.compareTo(b); // Ascending order (oldest first)
}

// Get readable time ago string
static String getTimeAgo(DateTime date) {
final now = DateTime.now();
final difference = now.difference(date);

    if (difference.inDays > 365) {
      final years = (difference.inDays / 365).floor();
      return '$years year${years > 1 ? 's' : ''} ago';
    } else if (difference.inDays > 30) {
      final months = (difference.inDays / 30).floor();
      return '$months month${months > 1 ? 's' : ''} ago';
    } else if (difference.inDays > 0) {
      return '${difference.inDays} day${difference.inDays > 1 ? 's' : ''} ago';
    } else if (difference.inHours > 0) {
      return '${difference.inHours} hour${difference.inHours > 1 ? 's' : ''} ago';
    } else if (difference.inMinutes > 0) {
      return '${difference.inMinutes} minute${difference.inMinutes > 1 ? 's' : ''} ago';
    } else {
      return 'Just now';
    }

}

// Quick date presets for reports and analytics
static Map<String, DateTimeRange> getDatePresets() {
final now = DateTime.now();
return {
'today': DateTimeRange(
start: DateTime(now.year, now.month, now.day),
end: DateTime(now.year, now.month, now.day, 23, 59, 59),
),
'yesterday': DateTimeRange(
start: DateTime(now.year, now.month, now.day - 1),
end: DateTime(now.year, now.month, now.day - 1, 23, 59, 59),
),
'this_week': DateTimeRange(
start: DateTime(now.year, now.month, now.day - now.weekday + 1),
end: DateTime(now.year, now.month, now.day, 23, 59, 59),
),
'last_week': DateTimeRange(
start: DateTime(now.year, now.month, now.day - now.weekday - 6),
end: DateTime(now.year, now.month, now.day - now.weekday, 23, 59, 59),
),
'this_month': DateTimeRange(
start: DateTime(now.year, now.month, 1),
end: DateTime(now.year, now.month + 1, 0, 23, 59, 59),
),
'last_month': DateTimeRange(
start: DateTime(now.year, now.month - 1, 1),
end: DateTime(now.year, now.month, 0, 23, 59, 59),
),
'last_3_months': DateTimeRange(
start: DateTime(now.year, now.month - 3, 1),
end: DateTime(now.year, now.month, 0, 23, 59, 59),
),
'last_6_months': DateTimeRange(
start: DateTime(now.year, now.month - 6, 1),
end: DateTime(now.year, now.month, 0, 23, 59, 59),
),
'this_year': DateTimeRange(
start: DateTime(now.year, 1, 1),
end: DateTime(now.year, 12, 31, 23, 59, 59),
),
'last_year': DateTimeRange(
start: DateTime(now.year - 1, 1, 1),
end: DateTime(now.year - 1, 12, 31, 23, 59, 59),
),
};
}

// Get display name for date presets
static String getDatePresetDisplayName(
String presetKey, BuildContext context) {
final localizations = AppLocalizations.of(context);

    switch (presetKey) {
      case 'today':
        return localizations.today;
      case 'yesterday':
        return localizations.translate('yesterday');
      case 'this_week':
        return localizations.translate('thisWeek');
      case 'last_week':
        return localizations.translate('lastWeek');
      case 'this_month':
        return localizations.thisMonth;
      case 'last_month':
        return localizations.translate('lastMonth');
      case 'last_3_months':
        return localizations.translate('last3Months');
      case 'last_6_months':
        return localizations.translate('last6Months');
      case 'this_year':
        return localizations.translate('thisYear');
      case 'last_year':
        return localizations.translate('lastYear');
      default:
        return presetKey;
    }

}

// Date range calculations
static int getDaysBetween(DateTime from, DateTime to) {
return to.difference(from).inDays;
}

static int getMonthsBetween(DateTime from, DateTime to) {
return (to.year - from.year) \* 12 + to.month - from.month;
}

static int getYearsBetween(DateTime from, DateTime to) {
return to.year - from.year;
}

// Ethiopian calendar specific utilities
static bool isEthiopianLeapYear(int ethYear) {
return EthiopianCalendar.isEthiopianLeapYear(ethYear);
}

static String getEthiopianMonthName(int month, String languageCode) {
final monthNames = EthiopianCalendar.getMonthNames(languageCode);
return monthNames[month - 1];
}

static String getEthiopianWeekdayName(int weekday, String languageCode) {
final weekdayNames = EthiopianCalendar.getWeekdayNames(languageCode);
return weekdayNames[weekday - 1];
}

// Date validation
static bool isValidDate(int year, int month, int day) {
try {
DateTime(year, month, day);
return true;
} catch (e) {
return false;
}
}

static bool isValidEthiopianDate(int year, int month, int day) {
return EthiopianCalendar.isValidEthiopianDate(year, month, day);
}

// Date manipulation
static DateTime addDays(DateTime date, int days) {
return date.add(Duration(days: days));
}

static DateTime subtractDays(DateTime date, int days) {
return date.subtract(Duration(days: days));
}

static DateTime addMonths(DateTime date, int months) {
return DateTime(date.year, date.month + months, date.day);
}

static DateTime subtractMonths(DateTime date, int months) {
return DateTime(date.year, date.month - months, date.day);
}

static DateTime addYears(DateTime date, int years) {
return DateTime(date.year + years, date.month, date.day);
}

static DateTime subtractYears(DateTime date, int years) {
return DateTime(date.year - years, date.month, date.day);
}

// First and last day of month
static DateTime getFirstDayOfMonth(DateTime date) {
return DateTime(date.year, date.month, 1);
}

static DateTime getLastDayOfMonth(DateTime date) {
return DateTime(date.year, date.month + 1, 0);
}

// Week number calculations
static int getWeekNumber(DateTime date) {
final firstDayOfYear = DateTime(date.year, 1, 1);
final days = date.difference(firstDayOfYear).inDays;
return ((days + firstDayOfYear.weekday - 1) / 7).floor() + 1;
}

// Quarter calculations
static int getQuarter(DateTime date) {
return ((date.month - 1) / 3).floor() + 1;
}

static DateTime getFirstDayOfQuarter(DateTime date) {
final quarter = getQuarter(date);
final month = (quarter - 1) \* 3 + 1;
return DateTime(date.year, month, 1);
}

static DateTime getLastDayOfQuarter(DateTime date) {
final quarter = getQuarter(date);
final month = quarter \* 3;
return DateTime(date.year, month + 1, 0);
}

// Ethiopian calendar quarter calculations
static int getEthiopianQuarter(EthiopianDate ethDate) {
return ((ethDate.month - 1) / 3).floor() + 1;
}

static EthiopianDate getFirstDayOfEthiopianQuarter(EthiopianDate ethDate) {
final quarter = getEthiopianQuarter(ethDate);
final month = (quarter - 1) \* 3 + 1;
return EthiopianDate(year: ethDate.year, month: month, day: 1);
}

static EthiopianDate getLastDayOfEthiopianQuarter(EthiopianDate ethDate) {
final quarter = getEthiopianQuarter(ethDate);
final month = quarter \* 3;
return EthiopianDate(year: ethDate.year, month: month, day: 30);
}

// Date range string for display
static String formatDateRange(
DateTimeRange range, BuildContext context, WidgetRef ref) {
final calendarSettings = ref.read(calendarProvider);

    final start = formatDateBasedOnCalendar(
        range.start, calendarSettings.calendarType, context);
    final end = formatDateBasedOnCalendar(
        range.end, calendarSettings.calendarType, context);

    return '$start - $end';

}

// Check if date is within range
static bool isDateInRange(DateTime date, DateTimeRange range) {
return (date.isAfter(range.start) || date.isAtSameMomentAs(range.start)) &&
(date.isBefore(range.end) || date.isAtSameMomentAs(range.end));
}

// Get current Ethiopian date
static EthiopianDate getCurrentEthiopianDate() {
return EthiopianCalendar.getCurrentEthiopianDate();
}

// Format Ethiopian date for display
static String formatEthiopianDateForDisplay(
EthiopianDate ethDate, String languageCode) {
return ethDate.toFormattedString(languageCode);
}

// Get Ethiopian date components
static Map<String, dynamic> getEthiopianDateComponents(
DateTime gregorianDate) {
final ethDate = EthiopianCalendar.gregorianToEthiopian(gregorianDate);
return {
'year': ethDate.year,
'month': ethDate.month,
'day': ethDate.day,
'month_name_en': EthiopianCalendar.getMonthNames('en')[ethDate.month - 1],
'month_name_am': EthiopianCalendar.getMonthNames('am')[ethDate.month - 1],
'weekday_en':
EthiopianCalendar.getWeekdayNames('en')[gregorianDate.weekday - 1],
'weekday_am':
EthiopianCalendar.getWeekdayNames('am')[gregorianDate.weekday - 1],
};
}
}

##

// utils/ethiopian_calendar.dart
// Utility class for Ethiopian calendar conversions and date handling.
// Provides functions to convert between Gregorian and Ethiopian dates,
// check leap years, and format Ethiopian dates.

class EthiopianCalendar {
// Accurate Ethiopian calendar conversion constants
static const int ETHIOPIAN_YEAR_OFFSET = 8;
static const int JDN_OFFSET = 1723856;
static const int ETHIOPIAN_EPOCH = 1724221; // JD of 1 M√§sk√§r√§m 1 ETH

static const List<int> MONTH_DAYS = [
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
5
];
static const List<String> MONTH_NAMES_EN = [
'Meskerem',
'Tikimit',
'Hidar',
'Tahsas',
'Tir',
'Yekatit',
'Megabit',
'Miyazya',
'Ginbot',
'Sene',
'Hamle',
'Nehase',
'Pagume'
];
static const List<String> MONTH_NAMES_AM = [
'·àò·àµ·ä®·à®·àù',
'·å•·âÖ·àù·âµ',
'·äÖ·ã≥·à≠',
'·â≥·àÖ·à£·à•',
'·å•·à≠',
'·ã®·ä´·â≤·âµ',
'·àò·åã·â¢·âµ',
'·àö·ã´·ãù·ã´',
'·åç·äï·â¶·âµ',
'·à∞·äî',
'·àê·àù·àå',
'·äê·àÉ·à¥',
'·å≥·åâ·àú'
];
static const List<String> WEEKDAY_NAMES_EN = [
'Monday',
'Tuesday',
'Wednesday',
'Thursday',
'Friday',
'Saturday',
'Sunday'
];
static const List<String> WEEKDAY_NAMES_AM = [
'·à∞·äû',
'·àõ·ä≠·à∞·äû',
'·à®·â°·ãï',
'·àê·àô·àµ',
'·ãì·à≠·â•',
'·âÖ·ã≥·àú',
'·ä•·àë·ãµ'
];

// Convert Gregorian to Julian Day Number
static int \_toJulianDay(DateTime gregorianDate) {
int year = gregorianDate.year;
int month = gregorianDate.month;
int day = gregorianDate.day;

    int a = (14 - month) ~/ 12;
    int y = year + 4800 - a;
    int m = month + 12 * a - 3;

    return day +
        (153 * m + 2) ~/ 5 +
        365 * y +
        y ~/ 4 -
        y ~/ 100 +
        y ~/ 400 -
        32045;

}

// Convert Julian Day Number to Gregorian
static DateTime \_fromJulianDay(int jd) {
int a = jd + 32044;
int b = (4 _ a + 3) ~/ 146097;
int c = a - (146097 _ b) ~/ 4;
int d = (4 _ c + 3) ~/ 1461;
int e = c - (1461 _ d) ~/ 4;
int m = (5 \* e + 2) ~/ 153;

    int day = e - (153 * m + 2) ~/ 5 + 1;
    int month = m + 3 - 12 * (m ~/ 10);
    int year = 100 * b + d - 4800 + (m ~/ 10);

    return DateTime(year, month, day);

}

// Convert Gregorian to Ethiopian date (ACCURATE)
static EthiopianDate gregorianToEthiopian(DateTime gregorianDate) {
int jd = \_toJulianDay(gregorianDate);

    // Calculate Ethiopian date from Julian Day
    int n = jd - ETHIOPIAN_EPOCH;
    int year = 4 * n ~/ 1461;
    int remainder = n - 1461 * year ~/ 4;
    int month = remainder ~/ 30 + 1;
    int day = remainder % 30 + 1;

    return EthiopianDate(year: year + 1, month: month, day: day);

}

// Convert Ethiopian to Gregorian date (ACCURATE)
static DateTime ethiopianToGregorian(EthiopianDate ethDate) {
int jd = ETHIOPIAN*EPOCH +
365 * (ethDate.year - 1) +
(ethDate.year - 1) ~/ 4 +
30 \_ (ethDate.month - 1) +
(ethDate.day - 1);

    return _fromJulianDay(jd);

}

// Check if Ethiopian year is leap year
static bool isEthiopianLeapYear(int ethYear) {
return (ethYear % 4) == 3;
}

// Get month names
static List<String> getMonthNames(String languageCode) {
return languageCode == 'am' ? MONTH_NAMES_AM : MONTH_NAMES_EN;
}

// Get weekday names
static List<String> getWeekdayNames(String languageCode) {
return languageCode == 'am' ? WEEKDAY_NAMES_AM : WEEKDAY_NAMES_EN;
}

// Format Ethiopian date
static String formatDate(EthiopianDate ethDate, String languageCode) {
final monthNames = getMonthNames(languageCode);
final weekdayNames = getWeekdayNames(languageCode);

    final gregorianDate = ethiopianToGregorian(ethDate);
    final weekday = gregorianDate.weekday - 1;

    return '${weekdayNames[weekday]}, ${ethDate.day} ${monthNames[ethDate.month - 1]} ${ethDate.year}';

}

// Get current Ethiopian date
static EthiopianDate getCurrentEthiopianDate() {
return gregorianToEthiopian(DateTime.now());
}

// Validate Ethiopian date
static bool isValidEthiopianDate(int year, int month, int day) {
if (month < 1 || month > 13) return false;
if (day < 1) return false;

    if (month == 13) {
      // Pagume has 5-6 days
      int maxDays = isEthiopianLeapYear(year) ? 6 : 5;
      return day <= maxDays;
    } else {
      return day <= 30;
    }

}
}

class EthiopianDate {
final int year;
final int month;
final int day;

const EthiopianDate({
required this.year,
required this.month,
required this.day,
});

@override
String toString() {
return '$day/$month/$year';
}

String toFormattedString(String languageCode) {
final monthNames = EthiopianCalendar.getMonthNames(languageCode);
return '${day} ${monthNames[month - 1]} ${year}';
}
}

##

// lib/src/utils/formatters.dart
// Utility class for various formatting needs across the app,

import 'package:intl/intl.dart';

class AppFormatters {
// Currency formatting for Ethiopian Birr
static final NumberFormat \_currencyFormat = NumberFormat.currency(
symbol: 'ETB ',
decimalDigits: 2,
);

static final NumberFormat \_compactCurrency = NumberFormat.compactCurrency(
symbol: 'ETB ',
decimalDigits: 0,
);

// Number formatting
static final NumberFormat \_numberFormat = NumberFormat('#,##0');
static final NumberFormat \_decimalFormat = NumberFormat('#,##0.00');

static String formatCurrency(double amount) {
return \_currencyFormat.format(amount);
}

static String formatCompactCurrency(double amount) {
return \_compactCurrency.format(amount);
}

static String formatNumber(int number) {
return \_numberFormat.format(number);
}

static String formatDecimal(double number) {
return \_decimalFormat.format(number);
}

static String formatPercentage(double value) {
return '${(value \* 100).toStringAsFixed(1)}%';
}

// Phone number formatting for Ethiopia
static String formatPhoneNumber(String phone) {
if (phone.startsWith('+251')) {
return phone.replaceFirstMapped(RegExp(r'(\+251)(\d{2})(\d{3})(\d{4})'),
(match) => '${match[1]} ${match[2]} ${match[3]} ${match[4]}');
    } else if (phone.startsWith('251')) {
      return phone.replaceFirstMapped(RegExp(r'(251)(\d{2})(\d{3})(\d{4})'),
          (match) => '+${match[1]} ${match[2]} ${match[3]} ${match[4]}');
} else if (phone.startsWith('0')) {
return phone.replaceFirstMapped(RegExp(r'(0)(\d{2})(\d{3})(\d{4})'),
(match) => '+251 ${match[2]} ${match[3]} ${match[4]}');
}
return phone;
}

// TIN number formatting
static String formatTIN(String tin) {
if (tin.length == 10) {
return '${tin.substring(0, 3)}-${tin.substring(3, 6)}-${tin.substring(6)}';
}
return tin;
}

// Text capitalization
static String capitalize(String text) {
if (text.isEmpty) return text;
return text[0].toUpperCase() + text.substring(1).toLowerCase();
}

static String titleCase(String text) {
if (text.isEmpty) return text;
return text.split(' ').map((word) => capitalize(word)).join(' ');
}
}

##

// lib/src/utils/print_service.dart
// Service for managing Bluetooth printer connections and printing receipts using ESC/POS commands.
// Supports scanning for printers, connecting, and printing formatted receipts.
import 'package:andalus_smart_pos/src/data/models/sale.dart';
import 'package:esc_pos_utils_plus/esc_pos_utils_plus.dart';
import 'package:flutter/material.dart';
import 'package:flutter_blue_plus/flutter_blue_plus.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
// import 'package:esc_pos_utils/esc_pos_utils.dart';
import '../localization/app_localizations.dart';
import '../utils/formatters.dart';

class PrintService {
static BluetoothDevice? \_connectedDevice;
static BluetoothCharacteristic? \_printCharacteristic;
final printServiceProvider = Provider<PrintService>((ref) {
return PrintService();
});

// Scan for Bluetooth printers
static Stream<List<BluetoothDevice>> scanForPrinters() {
return FlutterBluePlus.scanResults.map((results) => results
.where((r) => \_isPotentialPrinter(r.device))
.map((r) => r.device)
.toList());
}

static bool \_isPotentialPrinter(BluetoothDevice device) {
// Thermal printers often have these in their name
final printerNames = [
'printer',
'print',
'pos',
'thermal',
'bt',
'bluetooth'
];
return printerNames
.any((name) => device.localName.toLowerCase().contains(name));
}

static Future<void> startScan() async {
await FlutterBluePlus.startScan(timeout: const Duration(seconds: 10));
}

static Future<void> stopScan() async {
await FlutterBluePlus.stopScan();
}

// Connect to a printer
static Future<bool> connectToPrinter(BluetoothDevice device) async {
try {
await device.connect();
final services = await device.discoverServices();

      for (var service in services) {
        for (var characteristic in service.characteristics) {
          // Look for the characteristic that supports writing (printing)
          if (characteristic.properties.write) {
            _printCharacteristic = characteristic;
            _connectedDevice = device;
            return true;
          }
        }
      }
      return false;
    } catch (e) {
      print('Connection error: $e');
      return false;
    }

}

// Disconnect from printer
static Future<void> disconnect() async {
if (\_connectedDevice != null) {
await \_connectedDevice!.disconnect();
\_connectedDevice = null;
\_printCharacteristic = null;
}
}

// Main print function
static Future<bool> printReceipt({
required BuildContext context,
required String shopName,
required String shopNameAm,
required String address,
required String phone,
required String tinNumber,
required String receiptNumber,
required DateTime dateTime,
required List<Map<String, dynamic>> items,
required double subtotal,
required double tax,
required double discount,
required double total,
required String paymentMethod,
String? telebirrRef,
required Sale sale,
required Map<String, String> businessInfo,
}) async {
if (\_printCharacteristic == null) {
\_showError(context, 'No printer connected');
return false;
}

    try {
      // Generate ESC/POS commands
      final bytes = await _generateReceiptBytes(
        context: context,
        shopName: shopName,
        shopNameAm: shopNameAm,
        address: address,
        phone: phone,
        tinNumber: tinNumber,
        receiptNumber: receiptNumber,
        dateTime: dateTime,
        items: items,
        subtotal: subtotal,
        tax: tax,
        discount: discount,
        total: total,
        paymentMethod: paymentMethod,
        telebirrRef: telebirrRef,
      );

      // Send to printer
      await _printCharacteristic!.write(bytes, withoutResponse: true);

      _showSuccess(context, 'Receipt printed successfully');
      return true;
    } catch (e) {
      _showError(context, 'Printing failed: $e');
      return false;
    }

}

static Future<List<int>> \_generateReceiptBytes({
required BuildContext context,
required String shopName,
required String shopNameAm,
required String address,
required String phone,
required String tinNumber,
required String receiptNumber,
required DateTime dateTime,
required List<Map<String, dynamic>> items,
required double subtotal,
required double tax,
required double discount,
required double total,
required String paymentMethod,
String? telebirrRef,
}) async {
final profile = await CapabilityProfile.load();
final generator = Generator(PaperSize.mm80, profile);
List<int> bytes = [];

    // Header
    bytes += generator.text(shopName,
        styles: const PosStyles(
            align: PosAlign.center, bold: true, height: PosTextSize.size2));
    bytes += generator.text(shopNameAm,
        styles: const PosStyles(align: PosAlign.center));
    bytes += generator.text(address,
        styles: const PosStyles(align: PosAlign.center));
    bytes += generator.text('Tel: ${AppFormatters.formatPhoneNumber(phone)}',
        styles: const PosStyles(align: PosAlign.center));
    bytes += generator.text('TIN: ${AppFormatters.formatTIN(tinNumber)}',
        styles: const PosStyles(align: PosAlign.center));

    bytes += generator.hr();

    // Receipt info
    bytes += generator.text('Receipt: $receiptNumber');
    bytes += generator.text('Date: ${_formatDate(dateTime)}');
    bytes += generator.text('Time: ${_formatTime(dateTime)}');

    bytes += generator.hr();

    // Items header
    bytes += generator.row([
      PosColumn(text: 'Item', width: 8, styles: const PosStyles(bold: true)),
      PosColumn(text: 'Qty', width: 2, styles: const PosStyles(bold: true)),
      PosColumn(text: 'Price', width: 4, styles: const PosStyles(bold: true)),
      PosColumn(text: 'Total', width: 6, styles: const PosStyles(bold: true)),
    ]);

    bytes += generator.hr();

    // Items
    for (final item in items) {
      final name = (item['name'] as String).length > 16
          ? '${(item['name'] as String).substring(0, 16)}.'
          : item['name'] as String;

      bytes += generator.row([
        PosColumn(text: name, width: 8),
        PosColumn(text: '${item['quantity']}', width: 2),
        PosColumn(
            text: '${(item['price'] as double).toStringAsFixed(2)}', width: 4),
        PosColumn(
            text: '${(item['total'] as double).toStringAsFixed(2)}', width: 6),
      ]);
    }

    bytes += generator.hr();

    // Totals
    bytes += generator.row([
      PosColumn(text: 'Subtotal:', width: 10),
      PosColumn(text: 'ETB ${subtotal.toStringAsFixed(2)}', width: 10),
    ]);

    if (tax > 0) {
      bytes += generator.row([
        PosColumn(text: 'Tax:', width: 10),
        PosColumn(text: 'ETB ${tax.toStringAsFixed(2)}', width: 10),
      ]);
    }

    if (discount > 0) {
      bytes += generator.row([
        PosColumn(text: 'Discount:', width: 10),
        PosColumn(text: '-ETB ${discount.toStringAsFixed(2)}', width: 10),
      ]);
    }

    bytes += generator.hr();

    bytes += generator.row([
      PosColumn(text: 'TOTAL:', width: 10, styles: const PosStyles(bold: true)),
      PosColumn(
          text: 'ETB ${total.toStringAsFixed(2)}',
          width: 10,
          styles: const PosStyles(bold: true)),
    ]);

    bytes += generator.hr();

    // Payment info
    bytes += generator.text(
        'Payment: ${_getPaymentMethodName(paymentMethod, AppLocalizations.of(context))}');

    if (telebirrRef != null) {
      bytes += generator.text('Ref: $telebirrRef');
    }

    bytes += generator.text('');
    bytes += generator.text('Thank you for your business!',
        styles: const PosStyles(align: PosAlign.center, bold: true));
    bytes += generator.text('·ä•·äì·àò·à∞·åç·äì·àà·äï!',
        styles: const PosStyles(align: PosAlign.center));

    bytes += generator.text('');
    bytes += generator.text('');

    // Cut paper
    bytes += generator.cut();

    return bytes;

}

static String \_getPaymentMethodName(
String method, AppLocalizations localizations) {
switch (method.toLowerCase()) {
case 'cash':
return localizations.cash;
case 'telebirr':
return localizations.telebirr;
case 'card':
return localizations.card;
case 'credit':
return localizations.credit;
case 'bank_transfer':
return localizations.bankTransfer;
default:
return method;
}
}

static String \_formatDate(DateTime date) {
return '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';
}

static String \_formatTime(DateTime date) {
return '${date.hour.toString().padLeft(2, '0')}:${date.minute.toString().padLeft(2, '0')}';
}

static void \_showError(BuildContext context, String message) {
ScaffoldMessenger.of(context).showSnackBar(
SnackBar(
content: Text(message),
backgroundColor: Colors.red,
),
);
}

static void \_showSuccess(BuildContext context, String message) {
ScaffoldMessenger.of(context).showSnackBar(
SnackBar(
content: Text(message),
backgroundColor: Colors.green,
),
);
}

// Get connection status
static bool get isConnected => \_connectedDevice != null;

static String get connectedDeviceName =>
\_connectedDevice?.localName ?? 'No printer connected';
}

##

// lib/src/utils/reports_data_calculator.dart
// Utility class for calculating and generating various reports data
// such as sales, products, customers, and financial summaries.
// It processes data from repositories and applies business logic
// based on the subscription plan to provide insights and analytics.
// It supports advanced analytics for higher-tier subscription plans.
// It is used by the ReportsController to fetch and prepare data for reporting screens.
// It includes methods for filtering sales by date range, calculating top-selling products,
// customer retention rates, inventory turnover, and financial metrics.
// It returns structured data models for easy consumption by the UI.
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../data/models/sale.dart';
import '../data/models/product.dart';
import '../data/models/customer.dart';
import '../data/models/subscription.dart';
import '../data/repositories/sale_repository.dart';
import '../data/repositories/product_repository.dart';
import '../data/repositories/customer_repository.dart';

class ReportsDataCalculator {
static Future<ReportsData> generateReports({
required Ref ref,
required DateTimeRange dateRange,
required SubscriptionPlan plan,
}) async {
final saleRepo = ref.read(saleRepositoryProvider);
final productRepo = ref.read(productRepositoryProvider);
final customerRepo = ref.read(customerRepositoryProvider);

    final sales = await saleRepo.getAllSales();
    final products = await productRepo.getAllProducts();
    final customers = await customerRepo.getAllCustomers();

    final filteredSales = _filterSalesByDateRange(sales, dateRange);

    return ReportsData(
      salesData: await _generateSalesReport(filteredSales, plan),
      productsData:
          await _generateProductsReport(products, filteredSales, plan),
      customersData:
          await _generateCustomersReport(customers, filteredSales, plan),
      financialData: await _generateFinancialReport(filteredSales, plan),
    );

}

static List<Sale> \_filterSalesByDateRange(
List<Sale> sales, DateTimeRange range) {
return sales
.where((sale) =>
sale.createdAt.isAfter(range.start) &&
sale.createdAt.isBefore(range.end.add(const Duration(days: 1))))
.toList();
}

static Future<SalesReportData> \_generateSalesReport(
List<Sale> sales, SubscriptionPlan plan) async {
final totalSales = sales.fold(0.0, (sum, sale) => sum + sale.finalAmount);
final totalOrders = sales.length;
final averageOrderValue = totalOrders > 0 ? totalSales / totalOrders : 0.0;

    final salesByPaymentMethod = _calculateSalesByPaymentMethod(sales);
    final revenueByDay = _calculateRevenueByDay(sales);
    final dailySalesTrend = _calculateDailySalesTrend(sales);
    final topSellingHours = _calculateTopSellingHours(sales);

    // Advanced analytics for higher plans
    final customerRetention =
        plan.id != 'basic' ? _calculateCustomerRetentionRate(sales) : null;
    final salesVelocity =
        plan.id == 'enterprise' ? _calculateSalesVelocity(sales) : null;

    return SalesReportData(
      totalSales: totalSales,
      totalOrders: totalOrders,
      averageOrderValue: averageOrderValue,
      salesByPaymentMethod: salesByPaymentMethod,
      revenueByDay: revenueByDay,
      dailySalesTrend: dailySalesTrend,
      topSellingHours: topSellingHours,
      customerRetention: customerRetention,
      salesVelocity: salesVelocity,
    );

}

static Map<String, double> \_calculateSalesByPaymentMethod(List<Sale> sales) {
final methodSales = <String, double>{};
for (final sale in sales) {
methodSales.update(
sale.paymentMethod,
(value) => value + sale.finalAmount,
ifAbsent: () => sale.finalAmount,
);
}
return methodSales;
}

static Map<String, double> \_calculateRevenueByDay(List<Sale> sales) {
final revenueByDay = <String, double>{};
final days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];

    // Initialize with zeros
    for (final day in days) {
      revenueByDay[day] = 0.0;
    }

    for (final sale in sales) {
      final dayName = _getDayName(sale.createdAt.weekday);
      revenueByDay[dayName] = (revenueByDay[dayName] ?? 0) + sale.finalAmount;
    }

    return revenueByDay;

}

static List<DailySalesData> \_calculateDailySalesTrend(List<Sale> sales) {
final dailySales = <DateTime, double>{};

    for (final sale in sales) {
      final date = DateTime(
          sale.createdAt.year, sale.createdAt.month, sale.createdAt.day);
      dailySales.update(
        date,
        (value) => value + sale.finalAmount,
        ifAbsent: () => sale.finalAmount,
      );
    }

    return dailySales.entries
        .map((entry) => DailySalesData(date: entry.key, amount: entry.value))
        .toList()
      ..sort((a, b) => a.date.compareTo(b.date));

}

static List<HourlySalesData> \_calculateTopSellingHours(List<Sale> sales) {
final hourSales = <int, double>{};

    for (final sale in sales) {
      final hour = sale.createdAt.hour;
      hourSales.update(
        hour,
        (value) => value + sale.finalAmount,
        ifAbsent: () => sale.finalAmount,
      );
    }

    return hourSales.entries
        .map((entry) => HourlySalesData(hour: entry.key, amount: entry.value))
        .toList()
      ..sort((a, b) => b.amount.compareTo(a.amount));

}

static double \_calculateCustomerRetentionRate(List<Sale> sales) {
// Simplified retention calculation
if (sales.isEmpty) return 0.0;

    final customerSales = <String, int>{};
    for (final sale in sales) {
      if (sale.customerId != null) {
        customerSales.update(
          sale.customerId! as String,
          (value) => value + 1,
          ifAbsent: () => 1,
        );
      }
    }

    final repeatCustomers =
        customerSales.values.where((count) => count > 1).length;
    final totalCustomers = customerSales.length;

    return totalCustomers > 0 ? (repeatCustomers / totalCustomers) * 100 : 0.0;

}

static double \_calculateSalesVelocity(List<Sale> sales) {
if (sales.length < 2) return 0.0;

    final sortedSales = List<Sale>.from(sales)
      ..sort((a, b) => a.createdAt.compareTo(b.createdAt));

    final firstSale = sortedSales.first;
    final lastSale = sortedSales.last;
    final daysBetween =
        lastSale.createdAt.difference(firstSale.createdAt).inDays;

    return daysBetween > 0
        ? sales.length / daysBetween
        : sales.length.toDouble();

}

static Future<ProductsReportData> \_generateProductsReport(
List<Product> products, List<Sale> sales, SubscriptionPlan plan) async {
final totalProducts = products.length;
final lowStockCount = products.where((p) => p.isLowStock).length;
final outOfStockCount = products.where((p) => p.isOutOfStock).length;

    final topSellingProducts =
        await _calculateTopSellingProducts(products, sales);
    final stockValue = _calculateStockValue(products);
    final profitMarginSummary = _calculateProfitMarginSummary(products, sales);

    // Advanced analytics
    final inventoryTurnover = plan.id != 'basic'
        ? _calculateInventoryTurnover(products, sales)
        : null;
    final abcAnalysis =
        plan.id == 'enterprise' ? _calculateABCAnalysis(products, sales) : null;

    return ProductsReportData(
      totalProducts: totalProducts,
      lowStockCount: lowStockCount,
      outOfStockCount: outOfStockCount,
      topSellingProducts: topSellingProducts,
      stockValue: stockValue,
      profitMarginSummary: profitMarginSummary,
      inventoryTurnover: inventoryTurnover,
      abcAnalysis: abcAnalysis,
    );

}

static Future<CustomersReportData> \_generateCustomersReport(
List<Customer> customers, List<Sale> sales, SubscriptionPlan plan) async {
final totalCustomers = customers.length;
final customersWithBalance =
customers.where((c) => c.currentBalance > 0).length;
final overdueCustomers = customers.where((c) => c.isOverdue).length;
final totalOutstanding =
customers.fold(0.0, (sum, c) => sum + c.currentBalance);

    final topCustomers = _calculateTopCustomers(customers, sales);
    final averageCustomerValue =
        _calculateAverageCustomerValue(customers, sales);

    return CustomersReportData(
      totalCustomers: totalCustomers,
      customersWithBalance: customersWithBalance,
      overdueCustomers: overdueCustomers,
      totalOutstanding: totalOutstanding,
      topCustomers: topCustomers,
      averageCustomerValue: averageCustomerValue,
    );

}

static Future<FinancialReportData> \_generateFinancialReport(
List<Sale> sales, SubscriptionPlan plan) async {
final totalRevenue = sales.fold(0.0, (sum, sale) => sum + sale.finalAmount);
final totalTax =
sales.fold(0.0, (sum, sale) => sum + (sale.taxAmount ?? 0.0));
final totalDiscount =
sales.fold(0.0, (sum, sale) => sum + (sale.discountAmount ?? 0.0));
final netRevenue = totalRevenue - totalTax;
final profitMargin = \_calculateProfitMargin(sales);

    return FinancialReportData(
      totalRevenue: totalRevenue,
      totalTax: totalTax,
      totalDiscount: totalDiscount,
      netRevenue: netRevenue,
      profitMargin: profitMargin,
    );

}

static String \_getDayName(int weekday) {
switch (weekday) {
case 1:
return 'Mon';
case 2:
return 'Tue';
case 3:
return 'Wed';
case 4:
return 'Thu';
case 5:
return 'Fri';
case 6:
return 'Sat';
case 7:
return 'Sun';
default:
return 'Mon';
}
}

// Additional calculation methods...
static Future<List<TopSellingProduct>> \_calculateTopSellingProducts(
List<Product> products, List<Sale> sales) async {
// Implementation for top selling products
return [];
}

static double \_calculateStockValue(List<Product> products) {
return products.fold(0.0, (sum, product) {
final cost = product.costPrice ?? product.price _ 0.6;
return sum + (cost _ product.stockQuantity);
});
}

static double \_calculateProfitMargin(List<Sale> sales) {
if (sales.isEmpty) return 0.0;
// Simplified profit margin calculation
return 25.0; // Example value
}

static Map<String, dynamic> \_calculateProfitMarginSummary(
List<Product> products, List<Sale> sales) {
return {};
}

static double? \_calculateInventoryTurnover(
List<Product> products, List<Sale> sales) {
return null;
}

static Map<String, dynamic>? \_calculateABCAnalysis(
List<Product> products, List<Sale> sales) {
return null;
}

static List<TopCustomer> \_calculateTopCustomers(
List<Customer> customers, List<Sale> sales) {
return [];
}

static double \_calculateAverageCustomerValue(
List<Customer> customers, List<Sale> sales) {
return 0.0;
}
}

// Data models for reports
class ReportsData {
final SalesReportData salesData;
final ProductsReportData productsData;
final CustomersReportData customersData;
final FinancialReportData financialData;

const ReportsData({
required this.salesData,
required this.productsData,
required this.customersData,
required this.financialData,
});
}

class SalesReportData {
final double totalSales;
final int totalOrders;
final double averageOrderValue;
final Map<String, double> salesByPaymentMethod;
final Map<String, double> revenueByDay;
final List<DailySalesData> dailySalesTrend;
final List<HourlySalesData> topSellingHours;
final double? customerRetention;
final double? salesVelocity;

const SalesReportData({
required this.totalSales,
required this.totalOrders,
required this.averageOrderValue,
required this.salesByPaymentMethod,
required this.revenueByDay,
required this.dailySalesTrend,
required this.topSellingHours,
this.customerRetention,
this.salesVelocity,
});
}

class ProductsReportData {
final int totalProducts;
final int lowStockCount;
final int outOfStockCount;
final List<TopSellingProduct> topSellingProducts;
final double stockValue;
final Map<String, dynamic> profitMarginSummary;
final double? inventoryTurnover;
final Map<String, dynamic>? abcAnalysis;

const ProductsReportData({
required this.totalProducts,
required this.lowStockCount,
required this.outOfStockCount,
required this.topSellingProducts,
required this.stockValue,
required this.profitMarginSummary,
this.inventoryTurnover,
this.abcAnalysis,
});
}

class CustomersReportData {
final int totalCustomers;
final int customersWithBalance;
final int overdueCustomers;
final double totalOutstanding;
final List<TopCustomer> topCustomers;
final double averageCustomerValue;

const CustomersReportData({
required this.totalCustomers,
required this.customersWithBalance,
required this.overdueCustomers,
required this.totalOutstanding,
required this.topCustomers,
required this.averageCustomerValue,
});
}

class FinancialReportData {
final double totalRevenue;
final double totalTax;
final double totalDiscount;
final double netRevenue;
final double profitMargin;

const FinancialReportData({
required this.totalRevenue,
required this.totalTax,
required this.totalDiscount,
required this.netRevenue,
required this.profitMargin,
});
}

class DailySalesData {
final DateTime date;
final double amount;

const DailySalesData({required this.date, required this.amount});
}

class HourlySalesData {
final int hour;
final double amount;

const HourlySalesData({required this.hour, required this.amount});
}

class TopSellingProduct {
final String id;
final String name;
final double revenue;
final int quantitySold;
final double profitMargin;

const TopSellingProduct({
required this.id,
required this.name,
required this.revenue,
required this.quantitySold,
required this.profitMargin,
});
}

class TopCustomer {
final String id;
final String name;
final double totalSpent;
final int orderCount;
final DateTime lastPurchase;

const TopCustomer({
required this.id,
required this.name,
required this.totalSpent,
required this.orderCount,
required this.lastPurchase,
});
}

##

// utils/sync_manager.dart
// Utility class for managing data synchronization between local database and remote server.
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'dart:async';
import 'package:sqflite/sqflite.dart';
import '../data/local/database.dart';
import '../data/remote/api_client.dart';

final syncManagerProvider = Provider<SyncManager>((ref) {
final syncManager = SyncManager(ref);
syncManager.initialize();
return syncManager;
});

class SyncManager {
final Ref ref;
Timer? \_syncTimer;
bool \_isSyncing = false;

SyncManager(this.ref);

Future<void> initialize() async {
// Start periodic sync every 5 minutes
\_syncTimer = Timer.periodic(const Duration(minutes: 5), (timer) async {
if (!\_isSyncing) {
await syncPendingRecords();
}
});
}

Future<void> syncPendingRecords() async {
if (\_isSyncing) return;

    _isSyncing = true;
    try {
      await _uploadPendingRecords();
      await _downloadUpdates();
    } catch (e) {
      // Log error but don't throw - sync will retry
      print('Sync error: $e');
    } finally {
      _isSyncing = false;
    }

}

Future<void> \_uploadPendingRecords() async {
final db = await AppDatabase.database;

    try {
      // Get unsynced sales
      final unsyncedSales = await db.query(
        'sales',
        where: 'is_synced = ?',
        whereArgs: [0],
        limit: 50,
      );

      if (unsyncedSales.isEmpty) return;

      // Get sale items for each unsynced sale
      final salesWithItems = <Map<String, dynamic>>[];

      for (final sale in unsyncedSales) {
        final saleItems = await db.query(
          'sale_items',
          where: 'sale_id = ?',
          whereArgs: [sale['id']],
        );

        salesWithItems.add({
          'sale': sale,
          'items': saleItems,
        });
      }

      // Upload to server (simplified - implement your API call)
      // await _uploadToServer(salesWithItems);

      // Mark as synced
      final batch = db.batch();
      for (final sale in unsyncedSales) {
        batch.update(
          'sales',
          {
            'is_synced': 1,
            'updated_at': DateTime.now().millisecondsSinceEpoch,
          },
          where: 'id = ?',
          whereArgs: [sale['id']],
        );
      }
      await batch.commit();

      print('Successfully synced ${unsyncedSales.length} sales');
    } catch (e) {
      print('Upload error: $e');
      rethrow;
    }

}

Future<void> \_downloadUpdates() async {
try {
final lastSync = await \_getLastSyncTimestamp();
print('Downloading updates since: $lastSync');

      // Implement your download logic here
      // final updates = await ref.read(apiClientProvider).downloadUpdates(lastSync);
      // await _applyServerUpdates(updates);
    } catch (e) {
      print('Download updates error: $e');
    }

}

Future<int> \_getLastSyncTimestamp() async {
final db = await AppDatabase.database;
final result = await db.rawQuery('''
SELECT MAX(updated_at) as last_sync FROM sales
WHERE is_synced = 1
''');

    return result.first['last_sync'] as int? ?? 0;

}

Future<void> forceSync() async {
await syncPendingRecords();
}

Future<Map<String, dynamic>> getSyncStatus() async {
final db = await AppDatabase.database;

    final pendingResult = await db.rawQuery('''
      SELECT COUNT(*) as count FROM sales WHERE is_synced = 0
    ''');

    return {
      'pending': pendingResult.first['count'] as int,
      'isSyncing': _isSyncing,
      'lastSync': await _getLastSyncTimestamp(),
    };

}

void dispose() {
\_syncTimer?.cancel();
}
}

##

// lib/src/utils/validators.dart
// Utility class for validating various input fields such as product details, customer information, and sales data.
import 'package:intl/intl.dart';

class Validators {
// === PRODUCT VALIDATION ===
static String? validateProductName(String? value) {
if (value == null || value.isEmpty) {
return 'Product name is required';
}
if (value.length < 2) {
return 'Product name must be at least 2 characters';
}
if (value.length > 100) {
return 'Product name cannot exceed 100 characters';
}
return null;
}

static String? validatePrice(String? value) {
if (value == null || value.isEmpty) {
return 'Price is required';
}

    final price = double.tryParse(value);
    if (price == null) {
      return 'Please enter a valid number';
    }
    if (price < 0) {
      return 'Price cannot be negative';
    }
    if (price > 10000000) {
      return 'Price cannot exceed 10,000,000';
    }
    return null;

}

static String? validateBarcode(String? value) {
if (value == null || value.isEmpty) {
return 'Barcode is required';
}

    value = value.trim();

    // Check length
    if (value.length < 8 || value.length > 14) {
      return 'Barcode must be 8-14 digits';
    }

    // Check if all digits
    if (!RegExp(r'^[0-9]+$').hasMatch(value)) {
      return 'Barcode must contain only numbers';
    }

    // Validate check digit for EAN-13
    if (value.length == 13) {
      if (!_validateEAN13CheckDigit(value)) {
        return 'Invalid EAN-13 barcode (check digit mismatch)';
      }
    }

    return null;

}

static bool \_validateEAN13CheckDigit(String code) {
if (code.length != 13) return false;

    int sum = 0;
    for (int i = 0; i < 12; i++) {
      int digit = int.parse(code[i]);
      sum += (i % 2 == 0) ? digit : digit * 3;
    }

    int checkDigit = (10 - (sum % 10)) % 10;
    return checkDigit == int.parse(code[12]);

}

static String? validateStock(String? value) {
if (value == null || value.isEmpty) {
return 'Stock quantity is required';
}

    final stock = int.tryParse(value);
    if (stock == null) {
      return 'Please enter a valid number';
    }
    if (stock < 0) {
      return 'Stock cannot be negative';
    }
    if (stock > 1000000) {
      return 'Stock cannot exceed 1,000,000';
    }
    return null;

}

// === CUSTOMER VALIDATION ===
static String? validatePhoneNumber(String? value, {bool isEthiopian = true}) {
if (value == null || value.isEmpty) {
return 'Phone number is required';
}

    // Clean the number
    String cleaned = value.replaceAll(RegExp(r'[^\d+]'), '');

    if (isEthiopian) {
      // Ethiopian phone validation
      if (!cleaned.startsWith('+251') &&
          !cleaned.startsWith('251') &&
          !cleaned.startsWith('0')) {
        return 'Please enter a valid Ethiopian phone number';
      }

      // Standardize to +251 format
      if (cleaned.startsWith('0')) {
        cleaned = '+251${cleaned.substring(1)}';
      } else if (cleaned.startsWith('251')) {
        cleaned = '+$cleaned';
      }

      // Check length
      if (cleaned.length != 13) {
        // +251XXXXXXXXX
        return 'Phone number must be 9 digits after +251';
      }
    }

    return null;

}

static String? validateEmail(String? value) {
if (value == null || value.isEmpty) {
return null; // Email is optional
}

    final emailRegex = RegExp(
      r'^[a-zA-Z0-9.!#$%&‚Äô*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$',
    );

    if (!emailRegex.hasMatch(value)) {
      return 'Please enter a valid email address';
    }

    return null;

}

static String? validateTIN(String? value) {
if (value == null || value.isEmpty) {
return 'TIN number is required';
}

    // Ethiopian TIN validation (basic)
    if (!RegExp(r'^\d{9,10}$').hasMatch(value)) {
      return 'TIN must be 9 or 10 digits';
    }

    return null;

}

// === SALE VALIDATION ===
static String? validatePaymentAmount(String? value, double maxAmount) {
if (value == null || value.isEmpty) {
return 'Amount is required';
}

    final amount = double.tryParse(value);
    if (amount == null) {
      return 'Please enter a valid number';
    }
    if (amount <= 0) {
      return 'Amount must be greater than 0';
    }
    if (amount > maxAmount) {
      return 'Amount cannot exceed ${NumberFormat.currency(symbol: 'ETB ').format(maxAmount)}';
    }
    return null;

}

static String? validateCreditLimit(String? value) {
if (value == null || value.isEmpty) {
return 'Credit limit is required';
}

    final limit = double.tryParse(value);
    if (limit == null) {
      return 'Please enter a valid number';
    }
    if (limit < 0) {
      return 'Credit limit cannot be negative';
    }
    if (limit > 1000000) {
      return 'Credit limit cannot exceed 1,000,000';
    }
    return null;

}

// === GENERAL VALIDATION ===
static String? validateRequired(String? value, String fieldName) {
if (value == null || value.trim().isEmpty) {
return '$fieldName is required';
}
return null;
}

static String? validateLength(
String? value, int min, int max, String fieldName) {
if (value == null) return null;

    if (value.length < min) {
      return '$fieldName must be at least $min characters';
    }
    if (value.length > max) {
      return '$fieldName cannot exceed $max characters';
    }
    return null;

}

static String? validateNumberRange(
String? value, double min, double max, String fieldName) {
if (value == null || value.isEmpty) {
return '$fieldName is required';
}

    final number = double.tryParse(value);
    if (number == null) {
      return 'Please enter a valid number';
    }
    if (number < min) {
      return '$fieldName must be at least $min';
    }
    if (number > max) {
      return '$fieldName cannot exceed $max';
    }
    return null;

}

// === DATE VALIDATION ===
static String? validateDate(String? value) {
if (value == null || value.isEmpty) {
return 'Date is required';
}

    try {
      DateTime.parse(value);
      return null;
    } catch (e) {
      return 'Please enter a valid date';
    }

}

static bool isValidDate(DateTime? date) {
if (date == null) return false;
return date
.isBefore(DateTime.now().add(const Duration(days: 1))); // Not in future
}

// === PASSWORD VALIDATION ===
static String? validatePassword(String? value) {
if (value == null || value.isEmpty) {
return 'Password is required';
}

    if (value.length < 6) {
      return 'Password must be at least 6 characters';
    }

    // Optional: Add complexity requirements
    // if (!RegExp(r'^(?=.*[A-Z])(?=.*[!@#$%^&*(),.?":{}|<>]).+$').hasMatch(value)) {
    //   return 'Password must contain uppercase and special characters';
    // }

    return null;

}

static String? validateConfirmPassword(
String? value, String? originalPassword) {
if (value == null || value.isEmpty) {
return 'Please confirm your password';
}

    if (value != originalPassword) {
      return 'Passwords do not match';
    }

    return null;

}

// === BATCH VALIDATION ===
static Map<String, String?> validateProductData(Map<String, dynamic> data) {
return {
'name': validateProductName(data['name']),
'price': validatePrice(data['price']?.toString()),
'barcode': validateBarcode(data['barcode']),
'stock': validateStock(data['stock']?.toString()),
'categoryId': validateRequired(data['categoryId'], 'Category'),
};
}

static Map<String, String?> validateCustomerData(Map<String, dynamic> data) {
return {
'name': validateRequired(data['name'], 'Name'),
'phone': validatePhoneNumber(data['phone']),
'email': validateEmail(data['email']),
'creditLimit': validateCreditLimit(data['creditLimit']?.toString()),
};
}

// === UTILITY METHODS ===
static bool hasValidationErrors(Map<String, String?> errors) {
return errors.values.any((error) => error != null);
}

static String getFirstError(Map<String, String?> errors) {
final error =
errors.values.firstWhere((error) => error != null, orElse: () => null);
return error ?? '';
}

static String formatValidationErrors(Map<String, String?> errors) {
final errorMessages =
errors.values.where((error) => error != null).toList();
return errorMessages.join('\n');
}
}

##

// src/ui/widgets/app_button.dart
// A reusable button widget with loading state and multiple styles (primary, secondary, outlined).
import 'package:flutter/material.dart';

class AppButton extends StatelessWidget {
final VoidCallback? onPressed;
final Widget child;
final bool isLoading;
final ButtonType type;

const AppButton({
super.key,
required this.onPressed,
required this.child,
this.isLoading = false,
this.type = ButtonType.primary,
});

// Add this factory constructor for outlined button
factory AppButton.outlined({
required VoidCallback? onPressed,
required Widget child,
bool isLoading = false,
}) {
return AppButton(
onPressed: onPressed,
child: child,
isLoading: isLoading,
type: ButtonType.outlined,
);
}

factory AppButton.primary({
required VoidCallback? onPressed,
required Widget child,
bool isLoading = false,
}) {
return AppButton(
onPressed: onPressed,
child: child,
isLoading: isLoading,
type: ButtonType.primary,
);
}

factory AppButton.secondary({
required VoidCallback? onPressed,
required Widget child,
bool isLoading = false,
}) {
return AppButton(
onPressed: onPressed,
child: child,
isLoading: isLoading,
type: ButtonType.secondary,
);
}

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);

    return ElevatedButton(
      onPressed: isLoading ? null : onPressed,
      style: _getButtonStyle(theme),
      child: isLoading
          ? SizedBox(
              height: 20,
              width: 20,
              child: CircularProgressIndicator(
                strokeWidth: 2,
                color: _getLoadingColor(theme),
              ),
            )
          : child,
    );

}

ButtonStyle \_getButtonStyle(ThemeData theme) {
switch (type) {
case ButtonType.primary:
return ElevatedButton.styleFrom(
backgroundColor: theme.colorScheme.primary,
foregroundColor: theme.colorScheme.onPrimary,
);
case ButtonType.secondary:
return ElevatedButton.styleFrom(
backgroundColor: theme.colorScheme.surface,
foregroundColor: theme.colorScheme.onSurface,
);
case ButtonType.outlined: // ADD THIS CASE
return ElevatedButton.styleFrom(
backgroundColor: Colors.transparent,
foregroundColor: theme.colorScheme.primary,
side: BorderSide(color: theme.colorScheme.primary),
elevation: 0,
);
}
}

Color \_getLoadingColor(ThemeData theme) {
switch (type) {
case ButtonType.primary:
return theme.colorScheme.onPrimary;
case ButtonType.secondary:
return theme.colorScheme.onSurface;
case ButtonType.outlined:
return theme.colorScheme.primary;
}
}
}

// Update the enum to include outlined
enum ButtonType {
primary,
secondary,
outlined,
}

##

// src/ui/widgets/app_text_field.dart
// A reusable text field widget with various customization options.
import 'package:flutter/material.dart';

class AppTextField extends StatelessWidget {
final TextEditingController? controller;
final String label;
final String? hintText;
final String? helperText;
final String? prefixText;
final Widget? prefixIcon;
final Widget? suffixIcon;
final TextInputType? keyboardType;
final bool obscureText;
final bool autocorrect;
final bool enableSuggestions;
final TextInputAction? textInputAction;
final int? maxLines;
final int? minLines;
final int? maxLength;
final String? Function(String?)? validator;
final void Function(String)? onChanged;
final void Function(String)? onSubmitted;
final FocusNode? focusNode;
final bool enabled;
final bool readOnly;
final VoidCallback? onTap;
final String? initialValue; // Add this

const AppTextField({
super.key,
this.controller,
required this.label,
this.hintText,
this.helperText,
this.prefixText,
this.prefixIcon,
this.suffixIcon,
this.keyboardType,
this.obscureText = false,
this.autocorrect = true,
this.enableSuggestions = true,
this.textInputAction,
this.maxLines = 1,
this.minLines,
this.maxLength,
this.validator,
this.onChanged,
this.onSubmitted,
this.focusNode,
this.enabled = true,
this.readOnly = false,
this.onTap,
this.initialValue, // Add this
}) : assert(controller == null || initialValue == null,
'Cannot provide both a controller and an initialValue');

@override
Widget build(BuildContext context) {
return TextFormField(
controller: controller,
initialValue: initialValue,
focusNode: focusNode,
decoration: InputDecoration(
labelText: label,
hintText: hintText,
helperText: helperText,
prefixText: prefixText,
prefixIcon: prefixIcon,
suffixIcon: suffixIcon,
border: const OutlineInputBorder(),
contentPadding:
const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
counterText: maxLength != null ? null : '',
enabled: enabled,
),
keyboardType: keyboardType,
obscureText: obscureText,
autocorrect: autocorrect,
enableSuggestions: enableSuggestions,
textInputAction: textInputAction,
maxLines: maxLines,
minLines: minLines,
maxLength: maxLength,
validator: validator,
onChanged: onChanged,
onFieldSubmitted: onSubmitted,
enabled: enabled,
readOnly: readOnly,
onTap: onTap,
);
}
}

##

// src/ui/widgets/common/custom_card.dart
// A customizable card widget with tap and long-press functionality, padding, margin, and styling
import 'package:flutter/material.dart';

class CustomCard extends StatelessWidget {
final Widget child;
final EdgeInsetsGeometry padding;
final VoidCallback? onTap;
final VoidCallback? onLongPress;
final Color? backgroundColor;
final double elevation;
final BorderRadiusGeometry borderRadius;
final EdgeInsetsGeometry? margin;
final bool showBorder;
final Color? borderColor;
final double? width;
final double? height;

const CustomCard({
super.key,
required this.child,
this.padding = const EdgeInsets.all(16),
this.onTap,
this.onLongPress,
this.backgroundColor,
this.elevation = 2,
this.borderRadius = const BorderRadius.all(Radius.circular(16)),
this.margin,
this.showBorder = false,
this.borderColor,
this.width,
this.height,
});

@override
Widget build(BuildContext context) {
return Container(
margin: margin,
width: width,
height: height,
child: Card(
elevation: elevation,
color: backgroundColor ?? Theme.of(context).colorScheme.surface,
surfaceTintColor: Theme.of(context).colorScheme.surfaceTint,
shape: RoundedRectangleBorder(
borderRadius: borderRadius,
side: showBorder
? BorderSide(
color: borderColor ??
Theme.of(context).colorScheme.outline.withOpacity(0.2),
width: 1,
)
: BorderSide.none,
),
child: InkWell(
onTap: onTap,
onLongPress: onLongPress,
borderRadius: \_getBorderRadius(borderRadius),
child: Padding(
padding: padding,
child: child,
),
),
),
);
}

BorderRadius \_getBorderRadius(BorderRadiusGeometry borderRadius) {
if (borderRadius is BorderRadius) {
return borderRadius;
} else if (borderRadius is RoundedRectangleBorder) {
// return (borderRadius.borderRadius as BorderRadius?) ??
// BorderRadius.circular(16);
return BorderRadius.circular(16);
} else {
return BorderRadius.circular(16);
}
}
}

##

// widgets/common/date_range_picker.dart
// A date range picker widget that supports both Gregorian and Ethiopian calendars,
// allowing users to select a date range with proper formatting and validation.√•√•
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/providers/calendar_provider.dart';
import 'package:andalus_smart_pos/src/utils/ethiopian_calendar.dart';

class ProfessionalDateRangePicker extends ConsumerWidget {
final DateTimeRange? initialDateRange;
final Function(DateTimeRange) onDateRangeSelected;
final String? title;

const ProfessionalDateRangePicker({
super.key,
this.initialDateRange,
required this.onDateRangeSelected,
this.title,
});

@override
Widget build(BuildContext context, WidgetRef ref) {
final calendarSettings = ref.watch(calendarProvider);

    Future<void> _selectDateRange(BuildContext context) async {
      final DateTimeRange? picked = await showDateRangePicker(
        context: context,
        firstDate: DateTime(2020),
        lastDate: DateTime.now().add(const Duration(days: 365)),
        currentDate: DateTime.now(),
        saveText: 'Apply',
        builder: (context, child) {
          return Theme(
            data: Theme.of(context).copyWith(
              colorScheme: ColorScheme.light(
                primary: Theme.of(context).colorScheme.primary,
                onPrimary: Colors.white,
                surface: Theme.of(context).cardColor,
                onSurface: Theme.of(context).colorScheme.onBackground,
              ),
            ),
            child: child!,
          );
        },
      );

      if (picked != null) {
        onDateRangeSelected(picked);
      }
    }

    String _formatSingleDate(DateTime date, CalendarType calendarType) {
      if (calendarType == CalendarType.ethiopian) {
        final ethDate = EthiopianCalendar.gregorianToEthiopian(date);
        return '${ethDate.day}/${ethDate.month}/${ethDate.year}';
      } else {
        return '${date.day}/${date.month}/${date.year}';
      }
    }

    String _formatDateRange(DateTimeRange range) {
      final start =
          _formatSingleDate(range.start, calendarSettings.calendarType);
      final end = _formatSingleDate(range.end, calendarSettings.calendarType);
      return '$start - $end';
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        if (title != null) ...[
          Text(
            title!,
            style: Theme.of(context).textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.w600,
                ),
          ),
          const SizedBox(height: 8),
        ],
        Container(
          decoration: BoxDecoration(
            border: Border.all(
              color: Theme.of(context).colorScheme.outline.withOpacity(0.3),
            ),
            borderRadius: BorderRadius.circular(12),
          ),
          child: ListTile(
            leading: Icon(
              Icons.calendar_today,
              color: Theme.of(context).colorScheme.primary,
            ),
            title: Text(
              initialDateRange != null
                  ? _formatDateRange(initialDateRange!)
                  : 'Select Date Range',
              style: Theme.of(context).textTheme.bodyMedium,
            ),
            trailing: const Icon(Icons.arrow_drop_down),
            onTap: () => _selectDateRange(context),
          ),
        ),
      ],
    );

}
}

##

// lib/src/widgets/common/loading_shimmer.dart
// A customizable loading shimmer widget for indicating loading states in the UI.
import 'package:flutter/material.dart';

class LoadingShimmer extends StatelessWidget {
final double height;
final double width;
final double borderRadius;
final EdgeInsetsGeometry margin;

const LoadingShimmer({
super.key,
this.height = 60,
this.width = double.infinity,
this.borderRadius = 8,
this.margin = EdgeInsets.zero,
});

@override
Widget build(BuildContext context) {
return Container(
margin: margin,
height: height,
width: width,
decoration: BoxDecoration(
color: Colors.grey.shade300,
borderRadius: BorderRadius.circular(borderRadius),
),
child: ClipRRect(
borderRadius: BorderRadius.circular(borderRadius),
child: ShimmerLoader(),
),
);
}
}

class ShimmerLoader extends StatefulWidget {
const ShimmerLoader({super.key});

@override
State<ShimmerLoader> createState() => \_ShimmerLoaderState();
}

class \_ShimmerLoaderState extends State<ShimmerLoader>
with SingleTickerProviderStateMixin {
late AnimationController \_controller;

@override
void initState() {
super.initState();
\_controller = AnimationController(
vsync: this,
duration: const Duration(milliseconds: 1500),
)..repeat();
}

@override
void dispose() {
\_controller.dispose();
super.dispose();
}

@override
Widget build(BuildContext context) {
return AnimatedBuilder(
animation: \_controller,
builder: (context, child) {
return CustomPaint(
painter: ShimmerPainter(\_controller.value),
);
},
);
}
}

class ShimmerPainter extends CustomPainter {
final double progress;

ShimmerPainter(this.progress);

@override
void paint(Canvas canvas, Size size) {
final gradient = LinearGradient(
colors: [
Colors.grey.shade300!,
Colors.grey.shade100!,
Colors.grey.shade300!,
],
stops: const [0.0, 0.5, 1.0],
);

    final rect = Rect.fromLTWH(-size.width, 0, size.width * 3, size.height);
    final paint = Paint()
      ..shader = gradient.createShader(rect)
      ..maskFilter = MaskFilter.blur(BlurStyle.solid, 4);

    final x = size.width * progress * 2 - size.width;
    final shimmerRect = Rect.fromLTWH(x, 0, size.width * 0.3, size.height);

    canvas.drawRect(shimmerRect, paint);

}

@override
bool shouldRepaint(covariant ShimmerPainter oldDelegate) {
return oldDelegate.progress != progress;
}
}

// Pre-built shimmer components for common use cases
class ListItemShimmer extends StatelessWidget {
final bool hasLeading;
final bool hasTrailing;

const ListItemShimmer({
super.key,
this.hasLeading = true,
this.hasTrailing = true,
});

@override
Widget build(BuildContext context) {
return Container(
padding: const EdgeInsets.all(16),
child: Row(
children: [
if (hasLeading)
Container(
width: 48,
height: 48,
margin: const EdgeInsets.only(right: 16),
decoration: BoxDecoration(
color: Colors.grey.shade300,
borderRadius: BorderRadius.circular(24),
),
),
Expanded(
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Container(
width: double.infinity,
height: 16,
margin: const EdgeInsets.only(bottom: 8),
decoration: BoxDecoration(
color: Colors.grey.shade300,
borderRadius: BorderRadius.circular(4),
),
),
Container(
width: 120,
height: 14,
decoration: BoxDecoration(
color: Colors.grey.shade300,
borderRadius: BorderRadius.circular(4),
),
),
],
),
),
if (hasTrailing)
Container(
width: 60,
height: 16,
margin: const EdgeInsets.only(left: 16),
decoration: BoxDecoration(
color: Colors.grey.shade300,
borderRadius: BorderRadius.circular(4),
),
),
],
),
);
}
}

class GridShimmer extends StatelessWidget {
final int crossAxisCount;
final double childAspectRatio;
final int itemCount;

const GridShimmer({
super.key,
this.crossAxisCount = 2,
this.childAspectRatio = 1.0,
this.itemCount = 4,
});

@override
Widget build(BuildContext context) {
return GridView.builder(
shrinkWrap: true,
physics: const NeverScrollableScrollPhysics(),
gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
crossAxisCount: crossAxisCount,
crossAxisSpacing: 16,
mainAxisSpacing: 16,
childAspectRatio: childAspectRatio,
),
itemCount: itemCount,
itemBuilder: (context, index) {
return const LoadingShimmer(
height: 120,
borderRadius: 12,
);
},
);
}
}

class CardShimmer extends StatelessWidget {
final bool hasImage;
final bool hasActions;

const CardShimmer({
super.key,
this.hasImage = false,
this.hasActions = true,
});

@override
Widget build(BuildContext context) {
return Container(
padding: const EdgeInsets.all(16),
decoration: BoxDecoration(
color: Colors.white,
borderRadius: BorderRadius.circular(12),
boxShadow: [
BoxShadow(
color: Colors.black.withOpacity(0.1),
blurRadius: 4,
offset: const Offset(0, 2),
),
],
),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
if (hasImage)
Container(
width: double.infinity,
height: 120,
margin: const EdgeInsets.only(bottom: 12),
decoration: BoxDecoration(
color: Colors.grey.shade300,
borderRadius: BorderRadius.circular(8),
),
),
Container(
width: double.infinity,
height: 20,
margin: const EdgeInsets.only(bottom: 8),
decoration: BoxDecoration(
color: Colors.grey.shade300,
borderRadius: BorderRadius.circular(4),
),
),
Container(
width: 160,
height: 16,
margin: const EdgeInsets.only(bottom: 12),
decoration: BoxDecoration(
color: Colors.grey.shade300,
borderRadius: BorderRadius.circular(4),
),
),
if (hasActions)
Row(
children: [
Container(
width: 80,
height: 36,
margin: const EdgeInsets.only(right: 8),
decoration: BoxDecoration(
color: Colors.grey.shade300,
borderRadius: BorderRadius.circular(8),
),
),
Container(
width: 80,
height: 36,
decoration: BoxDecoration(
color: Colors.grey.shade300,
borderRadius: BorderRadius.circular(8),
),
),
],
),
],
),
);
}
}

##

// lib/src/widgets/common/search_field.dart
// A reusable search field widget with customizable hint text and callbacks.
import 'package:flutter/material.dart';

class SearchField extends StatelessWidget {
final TextEditingController controller;
final String hintText;
final Function(String)? onChanged;
final Function(String)? onSubmitted;

const SearchField({
super.key,
required this.controller,
required this.hintText,
this.onChanged,
this.onSubmitted,
});

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);

    return TextField(
      controller: controller,
      decoration: InputDecoration(
        labelText: hintText,
        prefixIcon: const Icon(Icons.search),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
        ),
        contentPadding: const EdgeInsets.symmetric(horizontal: 16),
        filled: true,
        fillColor: theme.colorScheme.surface,
      ),
      onChanged: onChanged,
      onSubmitted: onSubmitted,
    );

}
}

##

// widgets/dashboard/dashboard_cards.dart
// Dashboard cards displaying key metrics like sales, products, customers, and revenue.
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
import 'package:andalus_smart_pos/src/utils/formatters.dart';

class DashboardCard extends StatelessWidget {
final String title;
final String value;
final String subtitle;
final IconData icon;
final Color color;
final VoidCallback onTap;
final bool isWarning;

const DashboardCard({
super.key,
required this.title,
required this.value,
required this.subtitle,
required this.icon,
required this.color,
required this.onTap,
this.isWarning = false,
});

@override
Widget build(BuildContext context) {
return Card(
elevation: 0,
shape: RoundedRectangleBorder(
borderRadius: BorderRadius.circular(16),
side: BorderSide(
color: Theme.of(context).colorScheme.outline.withOpacity(0.1),
),
),
child: InkWell(
onTap: onTap,
borderRadius: BorderRadius.circular(16),
child: Container(
padding: const EdgeInsets.all(16),
height: 130, // Reduced fixed height
decoration: BoxDecoration(
gradient: LinearGradient(
begin: Alignment.topLeft,
end: Alignment.bottomRight,
colors: [
color.withOpacity(0.05),
color.withOpacity(0.02),
],
),
borderRadius: BorderRadius.circular(16),
),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
// Top row with icon and arrow - Fixed height
SizedBox(
height: 32, // Fixed height for top row
child: Row(
mainAxisAlignment: MainAxisAlignment.spaceBetween,
children: [
Container(
padding: const EdgeInsets.all(6), // Smaller padding
decoration: BoxDecoration(
color: color.withOpacity(0.1),
borderRadius: BorderRadius.circular(8),
),
child: Icon(icon, color: color, size: 18), // Smaller icon
),
Icon(
Icons.arrow_forward_ios_rounded,
color: color.withOpacity(0.6),
size: 12, // Smaller arrow
),
],
),
),

              const Spacer(),

              // Content area with strict height constraints
              SizedBox(
                height: 60, // Fixed height for content
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                  children: [
                    // Main value - with strict constraints
                    SizedBox(
                      height: 24, // Fixed height for main value
                      child: FittedBox(
                        fit: BoxFit.scaleDown,
                        alignment: Alignment.centerLeft,
                        child: Text(
                          value,
                          style: Theme.of(context)
                              .textTheme
                              .titleLarge
                              ?.copyWith(
                                fontWeight: FontWeight.w700,
                                color: isWarning
                                    ? const Color(0xFFEF4444)
                                    : Theme.of(context).colorScheme.onSurface,
                                fontSize: 16, // Smaller font
                              ),
                          maxLines: 1,
                        ),
                      ),
                    ),

                    // Subtitle - with strict constraints
                    SizedBox(
                      height: 16, // Fixed height for subtitle
                      child: Text(
                        subtitle,
                        style: Theme.of(context).textTheme.bodySmall?.copyWith(
                              color: Theme.of(context).colorScheme.outline,
                              fontWeight: FontWeight.w500,
                              fontSize: 11, // Smaller font
                              height: 1.2, // Tighter line height
                            ),
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),

                    // Title - with strict constraints
                    SizedBox(
                      height: 16, // Fixed height for title
                      child: Text(
                        title,
                        style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                              color: Theme.of(context).colorScheme.outline,
                              fontWeight: FontWeight.w600,
                              fontSize: 12, // Smaller font
                              height: 1.2, // Tighter line height
                            ),
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );

}
}

class SalesCard extends ConsumerWidget {
final double todaySales;
final int itemsSold;
final VoidCallback onTap;

const SalesCard({
super.key,
required this.todaySales,
required this.itemsSold,
required this.onTap,
});

@override
Widget build(BuildContext context, WidgetRef ref) {
final localizations = AppLocalizations.of(context);

    return DashboardCard(
      title: localizations.translate('Sales'),
      value: AppFormatters.formatCurrency(todaySales),
      subtitle: '$itemsSold ${localizations.translate('items sold')}',
      icon: Icons.shopping_cart_rounded,
      color: const Color(0xFF10B981),
      onTap: onTap,
    );

}
}

class ProductsCard extends ConsumerWidget {
final int totalProducts;
final int totalItems;
final int totalCategories;
final VoidCallback onTap;

const ProductsCard({
super.key,
required this.totalProducts,
required this.totalItems,
required this.totalCategories,
required this.onTap,
});

@override
Widget build(BuildContext context, WidgetRef ref) {
final localizations = AppLocalizations.of(context);

    // Use shorter text to prevent overflow
    final subtitle = '$totalItems items ‚Ä¢ $totalCategories cats';

    return DashboardCard(
      title: localizations.translate('Products'),
      value: totalProducts.toString(),
      subtitle: subtitle,
      icon: Icons.inventory_2_rounded,
      color: const Color(0xFF3B82F6),
      onTap: onTap,
    );

}
}

class CustomersCard extends ConsumerWidget {
final int totalCustomers;
final int customersWithBalance;
final VoidCallback onTap;

const CustomersCard({
super.key,
required this.totalCustomers,
required this.customersWithBalance,
required this.onTap,
});

@override
Widget build(BuildContext context, WidgetRef ref) {
final localizations = AppLocalizations.of(context);

    // Use shorter text
    final subtitle = '$customersWithBalance with balance';

    return DashboardCard(
      title: localizations.translate('Customers'),
      value: totalCustomers.toString(),
      subtitle: subtitle,
      icon: Icons.people_alt_rounded,
      color: const Color(0xFF8B5CF6),
      onTap: onTap,
    );

}
}

class RevenueCard extends ConsumerWidget {
final double totalRevenue;
final double outstandingCredit;
final VoidCallback onTap;

const RevenueCard({
super.key,
required this.totalRevenue,
required this.outstandingCredit,
required this.onTap,
});

@override
Widget build(BuildContext context, WidgetRef ref) {
final localizations = AppLocalizations.of(context);

    // Use compact format for large numbers
    final formattedRevenue = totalRevenue > 10000
        ? AppFormatters.formatCompactCurrency(totalRevenue)
        : AppFormatters.formatCurrency(totalRevenue);

    final formattedCredit = outstandingCredit > 10000
        ? AppFormatters.formatCompactCurrency(outstandingCredit)
        : AppFormatters.formatCurrency(outstandingCredit);

    // Use shorter text
    final subtitle = 'Out: $formattedCredit';

    return DashboardCard(
      title: localizations.translate('Revenue'),
      value: formattedRevenue,
      subtitle: subtitle,
      icon: Icons.attach_money_rounded,
      color: outstandingCredit > 0
          ? const Color(0xFFF59E0B)
          : const Color(0xFF10B981),
      onTap: onTap,
      isWarning: outstandingCredit > 0,
    );

}
}

##

// lib/src/widgets/dashboard/enhanced_dashboard.dart - SIMPLIFIED VERSION
// An enhanced dashboard widget with tabs for overview, sales analytics, and performance metrics.
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import '../../localization/app_localizations.dart';
import '../../controllers/sale_controller.dart';

class EnhancedDashboard extends ConsumerStatefulWidget {
const EnhancedDashboard({super.key});

@override
ConsumerState<EnhancedDashboard> createState() => \_EnhancedDashboardState();
}

class \_EnhancedDashboardState extends ConsumerState<EnhancedDashboard>
with SingleTickerProviderStateMixin {
late TabController \_tabController;

@override
void initState() {
super.initState();
\_tabController = TabController(length: 3, vsync: this);
}

@override
Widget build(BuildContext context) {
final salesState = ref.watch(saleControllerProvider);
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);

    return Scaffold(
      body: NestedScrollView(
        headerSliverBuilder: (context, innerBoxIsScrolled) {
          return [
            SliverAppBar(
              title: Text(localizations.dashboard),
              floating: true,
              snap: true,
              actions: [
                IconButton(
                  icon: const Icon(Icons.refresh),
                  onPressed: () {},
                  tooltip: localizations.refresh,
                ),
              ],
              bottom: TabBar(
                controller: _tabController,
                tabs: [
                  Tab(text: localizations.translate('overview')),
                  Tab(text: localizations.salesAnalytics),
                  Tab(text: localizations.translate('performance')),
                ],
              ),
            ),
          ];
        },
        body: TabBarView(
          controller: _tabController,
          children: [
            _buildOverviewTab(salesState, localizations, theme),
            _buildAnalyticsTab(localizations, theme),
            _buildPerformanceTab(localizations, theme),
          ],
        ),
      ),
    );

}

Widget \_buildOverviewTab(
SaleState salesState, AppLocalizations localizations, ThemeData theme) {
return CustomScrollView(
slivers: [
SliverToBoxAdapter(
child: Padding(
padding: const EdgeInsets.all(16),
child: GridView.count(
shrinkWrap: true,
physics: const NeverScrollableScrollPhysics(),
crossAxisCount: 2,
crossAxisSpacing: 16,
mainAxisSpacing: 16,
children: [
_buildStatCard(
title: localizations.todayRevenue,
value: 'ETB ${salesState.total.toStringAsFixed(2)}',
icon: Icons.trending_up,
color: Colors.green,
context: context,
),
_buildStatCard(
title: localizations.todayOrders,
value: salesState.cartItems.length
.toString(), // FIXED: Use cartItems.length
icon: Icons.shopping_cart,
color: Colors.blue,
context: context,
),
_buildStatCard(
title: 'Products',
value: '125',
icon: Icons.inventory,
color: Colors.orange,
context: context,
),
_buildStatCard(
title: 'Customers',
value: '45',
icon: Icons.people,
color: Colors.purple,
context: context,
),
],
),
),
),
],
);
}

Widget \_buildAnalyticsTab(AppLocalizations localizations, ThemeData theme) {
return Center(
child: Text(
'Sales Analytics - Coming Soon',
style: theme.textTheme.titleLarge,
),
);
}

Widget \_buildPerformanceTab(AppLocalizations localizations, ThemeData theme) {
return Center(
child: Text(
'Performance Metrics - Coming Soon',
style: theme.textTheme.titleLarge,
),
);
}

Widget \_buildStatCard({
required String title,
required String value,
required IconData icon,
required Color color,
required BuildContext context,
}) {
return Card(
elevation: 2,
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
Icon(icon, size: 32, color: color),
const SizedBox(height: 8),
Text(
value,
style: Theme.of(context).textTheme.headlineSmall?.copyWith(
fontWeight: FontWeight.bold,
color: color,
),
),
const SizedBox(height: 4),
Text(
title,
style: Theme.of(context).textTheme.bodySmall?.copyWith(
color: Colors.grey.shade600,
),
textAlign: TextAlign.center,
),
],
),
),
);
}
}

// Remove or comment out the SalesData class if not needed

##

// widgets/dashboard/live_datetime_widget.dart
// A live date and time widget that displays the current date and time,
// supporting both Gregorian and Ethiopian calendars with localization.
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/utils/date_utils.dart';
import 'package:andalus_smart_pos/src/providers/calendar_provider.dart';
import 'package:andalus_smart_pos/src/providers/language_provider.dart';
import 'package:andalus_smart_pos/src/utils/ethiopian_calendar.dart';
import 'package:intl/intl.dart';

class LiveDateTimeWidget extends ConsumerStatefulWidget {
const LiveDateTimeWidget({super.key});

@override
ConsumerState<LiveDateTimeWidget> createState() => \_LiveDateTimeWidgetState();
}

class \_LiveDateTimeWidgetState extends ConsumerState<LiveDateTimeWidget> {
late Timer \_timer;
DateTime \_currentTime = DateTime.now();

@override
void initState() {
super.initState();
\_timer = Timer.periodic(const Duration(seconds: 1), (timer) {
setState(() {
\_currentTime = DateTime.now();
});
});
}

@override
void dispose() {
\_timer.cancel();
super.dispose();
}

String \_getEthiopianDate() {
final ethDate = EthiopianCalendar.gregorianToEthiopian(\_currentTime);
final isAmharic = ref.read(languageProvider).languageCode == 'am';
return EthiopianCalendar.formatDate(ethDate, isAmharic ? 'am' : 'en');
}

String \_getCalendarLabel() {
final calendarSettings = ref.read(calendarProvider);
final isAmharic = ref.read(languageProvider).languageCode == 'am';

    if (calendarSettings.calendarType == CalendarType.ethiopian) {
      return isAmharic ? '·ä¢·âµ·ãÆ·åµ·ã´·ãä ·âÄ·äï ·àò·âÅ·å†·à™·ã´' : 'Ethiopian Calendar';
    } else {
      return isAmharic ? '·åç·à™·åé·à≠·ã´·äï ·âÄ·äï ·àò·âÅ·å†·à™·ã´' : 'Gregorian Calendar';
    }

}

@override
Widget build(BuildContext context) {
final calendarSettings = ref.read(calendarProvider);
final isAmharic = ref.read(languageProvider).languageCode == 'am';

    return Container(
      margin: const EdgeInsets.symmetric(horizontal: 20, vertical: 8),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        gradient: LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [
            Theme.of(context).colorScheme.primary.withOpacity(0.1),
            Theme.of(context).colorScheme.primary.withOpacity(0.05),
          ],
        ),
        borderRadius: BorderRadius.circular(16),
        border: Border.all(
          color: Theme.of(context).colorScheme.primary.withOpacity(0.2),
        ),
      ),
      child: Row(
        children: [
          Icon(
            Icons.calendar_today_rounded,
            color: Theme.of(context).colorScheme.primary,
            size: 24,
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  _getCalendarLabel(),
                  style: Theme.of(context).textTheme.labelSmall?.copyWith(
                        color: Theme.of(context).colorScheme.primary,
                        fontWeight: FontWeight.w600,
                      ),
                ),
                const SizedBox(height: 4),
                Text(
                  calendarSettings.calendarType == CalendarType.ethiopian
                      ? _getEthiopianDate()
                      : AppDateUtils.getCurrentFullDate(context, ref),
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.w700,
                        color: Theme.of(context).colorScheme.onBackground,
                      ),
                ),
                const SizedBox(height: 2),
                Text(
                  DateFormat('HH:mm:ss').format(_currentTime),
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                        color: Theme.of(context).colorScheme.outline,
                        fontFamily: 'RobotoMono',
                      ),
                ),
              ],
            ),
          ),
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
            decoration: BoxDecoration(
              color: Theme.of(context).colorScheme.primary.withOpacity(0.1),
              borderRadius: BorderRadius.circular(8),
            ),
            child: Text(
              calendarSettings.calendarType == CalendarType.ethiopian
                  ? 'ETH'
                  : 'GREG',
              style: Theme.of(context).textTheme.labelSmall?.copyWith(
                    color: Theme.of(context).colorScheme.primary,
                    fontWeight: FontWeight.w700,
                  ),
            ),
          ),
        ],
      ),
    );

}
}

##

// mobile/lib/src/widgets/dashboard/metric_card.dart
// A reusable metric card widget for displaying key performance indicators on the dashboard.
import 'package:flutter/material.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';

class MetricCard extends StatelessWidget {
final String label;
final String value;
final IconData icon;
final bool isWarning;
final AppLocalizations localizations;

const MetricCard({
super.key,
required this.label,
required this.value,
required this.icon,
this.isWarning = false,
required this.localizations,
});

@override
Widget build(BuildContext context) {
return Container(
padding: const EdgeInsets.all(16),
decoration: BoxDecoration(
color: Theme.of(context).colorScheme.surfaceVariant.withOpacity(0.3),
borderRadius: BorderRadius.circular(16),
border: Border.all(
color: Theme.of(context).colorScheme.outline.withOpacity(0.1),
),
),
child: Row(
children: [
Icon(
icon,
size: 20,
color: isWarning
? const Color(0xFFEF4444)
: Theme.of(context).colorScheme.primary,
),
const SizedBox(width: 12),
Expanded(
child: Text(
label,
style: Theme.of(context).textTheme.bodyMedium?.copyWith(
color: Theme.of(context).colorScheme.onSurfaceVariant,
fontWeight: FontWeight.w500,
),
),
),
Text(
value,
style: Theme.of(context).textTheme.bodyLarge?.copyWith(
fontWeight: FontWeight.w700,
color: isWarning
? const Color(0xFFEF4444)
: Theme.of(context).colorScheme.onSurface,
),
),
],
),
);
}
}

##

// mobile/lib/src/widgets/dashboard/quick_actions_widget.dart
// A quick actions widget providing shortcuts to common tasks on the dashboard.
import 'package:flutter/material.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';

class QuickActionsWidget extends StatelessWidget {
final AppLocalizations localizations;

const QuickActionsWidget({
super.key,
required this.localizations,
});

@override
Widget build(BuildContext context) {
final actions = [
{
'icon': Icons.point_of_sale_rounded,
'label': localizations.translate('newSale'),
'route': '/pos',
'color': const Color(0xFF10B981),
},
{
'icon': Icons.inventory_2_rounded,
'label': localizations.translate('addProduct'),
'route': '/products',
'color': const Color(0xFF3B82F6),
},
{
'icon': Icons.people_rounded,
'label': localizations.translate('addCustomer'),
'route': '/customers',
'color': const Color(0xFF8B5CF6),
},
{
'icon': Icons.bar_chart_rounded,
'label': localizations.translate('reports'),
'route': '/reports',
'color': const Color(0xFFF59E0B),
},
];

    return Card(
      elevation: 0,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(20),
        side: BorderSide(
          color: Theme.of(context).colorScheme.outline.withOpacity(0.1),
        ),
      ),
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              localizations.translate('quickActions'),
              style: Theme.of(context).textTheme.titleLarge?.copyWith(
                    fontWeight: FontWeight.w700,
                  ),
            ),
            const SizedBox(height: 16),
            Wrap(
              spacing: 12,
              runSpacing: 12,
              children: actions
                  .map((action) => _buildActionChip(context, action))
                  .toList(),
            ),
          ],
        ),
      ),
    );

}

Widget \_buildActionChip(BuildContext context, Map<String, dynamic> action) {
return ActionChip(
avatar: Container(
padding: const EdgeInsets.all(4),
decoration: BoxDecoration(
color: action['color'].withOpacity(0.1),
borderRadius: BorderRadius.circular(8),
),
child: Icon(
action['icon'],
size: 16,
color: action['color'],
),
),
label: Text(
action['label'],
style: TextStyle(
fontSize: 12,
fontWeight: FontWeight.w600,
color: action['color'],
),
),
onPressed: () => Navigator.pushNamed(context, action['route']),
backgroundColor: action['color'].withOpacity(0.05),
side: BorderSide(
color: action['color'].withOpacity(0.2),
),
);
}
}

##

// mobile/lib/src/widgets/dashboard/recent_sales_list.dart
// A recent sales list widget displaying the latest sales transactions on the dashboard.
import 'package:flutter/material.dart';
import 'package:andalus_smart_pos/src/data/models/sale.dart';
import 'package:andalus_smart_pos/src/utils/date_utils.dart';
import 'package:andalus_smart_pos/src/utils/formatters.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';

class RecentSalesList extends StatelessWidget {
final List<Sale> sales;
final AppLocalizations localizations;

const RecentSalesList({
super.key,
required this.sales,
required this.localizations,
});

@override
Widget build(BuildContext context) {
return Card(
elevation: 0,
shape: RoundedRectangleBorder(
borderRadius: BorderRadius.circular(20),
side: BorderSide(
color: Theme.of(context).colorScheme.outline.withOpacity(0.1),
),
),
child: Padding(
padding: const EdgeInsets.all(24),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Row(
children: [
Container(
padding: const EdgeInsets.all(8),
decoration: BoxDecoration(
color:
Theme.of(context).colorScheme.primary.withOpacity(0.1),
borderRadius: BorderRadius.circular(12),
),
child: Icon(
Icons.receipt_long_rounded,
color: Theme.of(context).colorScheme.primary,
size: 24,
),
),
const SizedBox(width: 12),
Text(
localizations.translate('recentSales'),
style: Theme.of(context).textTheme.titleLarge?.copyWith(
fontWeight: FontWeight.w700,
),
),
const Spacer(),
Container(
padding:
const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
decoration: BoxDecoration(
color:
Theme.of(context).colorScheme.primary.withOpacity(0.1),
borderRadius: BorderRadius.circular(8),
),
child: Text(
localizations.translate('today'),
style: Theme.of(context).textTheme.bodySmall?.copyWith(
color: Theme.of(context).colorScheme.primary,
fontWeight: FontWeight.w600,
),
),
),
],
),
const SizedBox(height: 20),
if (sales.isEmpty)
\_buildEmptyState(context)
else
Column(
children: sales
.take(5)
.map((sale) => \_buildSaleItem(context, sale))
.toList(),
),
],
),
),
);
}

Widget \_buildSaleItem(BuildContext context, Sale sale) {
final paymentColor = \_getPaymentMethodColor(sale.paymentMethod);
final idString = sale.id?.toString();
final displayId = idString == null
? 'N/A' // Handle null case
: (idString.length <= 6
? idString // If 6 chars or less, show the whole string
: idString.substring(idString.length - 6));
return Container(
margin: const EdgeInsets.only(bottom: 12),
padding: const EdgeInsets.all(16),
decoration: BoxDecoration(
color: Theme.of(context).colorScheme.surfaceVariant.withOpacity(0.3),
borderRadius: BorderRadius.circular(16),
),
child: Row(
children: [
Container(
width: 44,
height: 44,
decoration: BoxDecoration(
color: paymentColor.withOpacity(0.1),
borderRadius: BorderRadius.circular(12),
),
child: Icon(
\_getPaymentMethodIcon(sale.paymentMethod),
color: paymentColor,
size: 20,
),
),
const SizedBox(width: 16),
Expanded(
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
// Text(
// '${localizations.translate('sale')} #${sale.id?.substring(sale.id!.length - 6) ?? 'N/A'}',
// style: Theme.of(context).textTheme.bodyLarge?.copyWith(
// fontWeight: FontWeight.w600,
// ),
// ),
Text(
'${localizations.translate('sale')} #$displayId',
style: Theme.of(context).textTheme.bodyLarge?.copyWith(
fontWeight: FontWeight.w600,
),
),
const SizedBox(height: 2),
Text(
'${AppDateUtils.formatTime(sale.createdAt)} ‚Ä¢ ${_formatPaymentMethod(sale.paymentMethod, localizations)}',
style: Theme.of(context).textTheme.bodySmall?.copyWith(
color: Theme.of(context).colorScheme.outline,
),
),
],
),
),
Column(
crossAxisAlignment: CrossAxisAlignment.end,
children: [
Text(
sale.formattedTotal,
style: Theme.of(context).textTheme.bodyLarge?.copyWith(
fontWeight: FontWeight.w700,
color: Theme.of(context).colorScheme.primary,
),
),
Text(
AppDateUtils.formatDate(sale.createdAt),
style: Theme.of(context).textTheme.bodySmall?.copyWith(
color: Theme.of(context).colorScheme.outline,
),
),
],
),
],
),
);
}

Widget \_buildEmptyState(BuildContext context) {
return Column(
children: [
const SizedBox(height: 20),
Icon(
Icons.receipt_long_outlined,
size: 64,
color: Theme.of(context).colorScheme.outline.withOpacity(0.5),
),
const SizedBox(height: 16),
Text(
localizations.translate('noSalesToday'),
style: Theme.of(context).textTheme.titleMedium?.copyWith(
fontWeight: FontWeight.w600,
),
),
const SizedBox(height: 8),
Text(
localizations.translate('completeFirstSale'),
style: Theme.of(context).textTheme.bodyMedium?.copyWith(
color: Theme.of(context).colorScheme.outline,
),
textAlign: TextAlign.center,
),
],
);
}

Color \_getPaymentMethodColor(String method) {
switch (method.toLowerCase()) {
case 'cash':
return const Color(0xFF10B981);
case 'telebirr':
return const Color(0xFF3B82F6);
case 'card':
return const Color(0xFF8B5CF6);
case 'credit':
return const Color(0xFFF59E0B);
default:
return const Color(0xFF6B7280);
}
}

IconData \_getPaymentMethodIcon(String method) {
switch (method.toLowerCase()) {
case 'cash':
return Icons.money_rounded;
case 'telebirr':
return Icons.qr_code_rounded;
case 'card':
return Icons.credit_card_rounded;
case 'credit':
return Icons.credit_score_rounded;
default:
return Icons.payment_rounded;
}
}

String \_formatPaymentMethod(String method, AppLocalizations localizations) {
switch (method.toLowerCase()) {
case 'cash':
return localizations.translate('cash');
case 'telebirr':
return localizations.translate('telebirr');
case 'card':
return localizations.translate('card');
case 'credit':
return localizations.translate('credit');
default:
return method;
}
}
}

##

// widgets/dashboard/sales_analytics.dart
// A sales analytics widget displaying sales data with charts and statistics on the dashboard.
import 'package:andalus_smart_pos/src/data/repositories/sale_repository.dart';
import 'package:flutter/material.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
import 'package:andalus_smart_pos/src/utils/formatters.dart';

class SalesAnalyticsWidget extends ConsumerStatefulWidget {
final SalesSummary salesData;
final AppLocalizations localizations;

const SalesAnalyticsWidget({
super.key,
required this.salesData,
required this.localizations,
});

@override
ConsumerState<SalesAnalyticsWidget> createState() =>
\_SalesAnalyticsWidgetState();
}

class \_SalesAnalyticsWidgetState extends ConsumerState<SalesAnalyticsWidget> {
int \_selectedChartIndex = 0;
final List<String> \_chartTypes = ['daily', 'weekly', 'monthly'];

@override
Widget build(BuildContext context) {
return Card(
elevation: 0,
shape: RoundedRectangleBorder(
borderRadius: BorderRadius.circular(16), // Smaller radius
side: BorderSide(
color: Theme.of(context).colorScheme.outline.withOpacity(0.1),
),
),
child: Container(
padding: const EdgeInsets.all(16), // Reduced padding
constraints: const BoxConstraints(
minHeight: 320, // Fixed minimum height
),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
mainAxisSize: MainAxisSize.min,
children: [
// Header - More compact
Row(
children: [
Container(
padding: const EdgeInsets.all(6), // Smaller
decoration: BoxDecoration(
color:
Theme.of(context).colorScheme.primary.withOpacity(0.1),
borderRadius: BorderRadius.circular(8),
),
child: Icon(
Icons.analytics_rounded,
color: Theme.of(context).colorScheme.primary,
size: 20, // Smaller icon
),
),
const SizedBox(width: 8),
Expanded(
child: Text(
widget.localizations.translate('salesAnalytics'),
style: Theme.of(context).textTheme.titleMedium?.copyWith(
fontWeight: FontWeight.w700,
),
maxLines: 1,
overflow: TextOverflow.ellipsis,
),
),
const SizedBox(width: 8),
// Chart Type Selector - More compact
Container(
padding:
const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
decoration: BoxDecoration(
color: Theme.of(context).colorScheme.surface,
borderRadius: BorderRadius.circular(8),
border: Border.all(
color: Theme.of(context)
.colorScheme
.outline
.withOpacity(0.2),
),
),
child: DropdownButton<int>(
value: _selectedChartIndex,
underline: const SizedBox(),
icon: Icon(
Icons.arrow_drop_down_rounded,
color: Theme.of(context).colorScheme.primary,
size: 16,
),
items: _chartTypes.asMap().entries.map((entry) {
return DropdownMenuItem<int>(
value: entry.key,
child: Text(
_getChartTypeName(entry.value),
style: TextStyle(
fontSize: 10,
color: Theme.of(context).colorScheme.onSurface,
),
),
);
}).toList(),
onChanged: (value) {
setState(() {
_selectedChartIndex = value!;
});
},
),
),
],
),
const SizedBox(height: 16),

            // Chart - Fixed height
            SizedBox(
              height: 160, // Reduced height
              child: _buildSalesChart(),
            ),
            const SizedBox(height: 12),

            // Statistics - More compact
            _buildStatistics(),
          ],
        ),
      ),
    );

}

String \_getChartTypeName(String type) {
switch (type) {
case 'daily':
return widget.localizations.translate('today');
case 'weekly':
return widget.localizations.translate('weeklySales');
case 'monthly':
return widget.localizations.translate('thisMonth');
default:
return type;
}
}

Widget \_buildSalesChart() {
final chartData = \_getChartData();

    return LineChart(
      LineChartData(
        gridData: FlGridData(
          show: true,
          drawVerticalLine: false, // Remove vertical lines for cleaner look
          horizontalInterval: _getHorizontalInterval(chartData),
          getDrawingHorizontalLine: (value) {
            return FlLine(
              color: Theme.of(context).colorScheme.outline.withOpacity(0.1),
              strokeWidth: 1,
            );
          },
        ),
        titlesData: FlTitlesData(
          show: true,
          rightTitles: const AxisTitles(
            sideTitles: SideTitles(showTitles: false),
          ),
          topTitles: const AxisTitles(
            sideTitles: SideTitles(showTitles: false),
          ),
          bottomTitles: AxisTitles(
            sideTitles: SideTitles(
              showTitles: true,
              reservedSize: 20, // Smaller reserved size
              interval: 1,
              getTitlesWidget: (value, meta) {
                if (value.toInt() >= chartData.length) return const SizedBox();
                return Padding(
                  padding: const EdgeInsets.only(top: 4.0),
                  child: Text(
                    _getBottomTitle(value.toInt(), chartData.length),
                    style: TextStyle(
                      fontSize: 9, // Smaller font
                      color: Theme.of(context).colorScheme.outline,
                    ),
                  ),
                );
              },
            ),
          ),
          leftTitles: AxisTitles(
            sideTitles: SideTitles(
              showTitles: true,
              interval: _getHorizontalInterval(chartData),
              reservedSize: 32, // Smaller reserved size
              getTitlesWidget: (value, meta) {
                return Text(
                  AppFormatters.formatCompactCurrency(value),
                  style: TextStyle(
                    fontSize: 9, // Smaller font
                    color: Theme.of(context).colorScheme.outline,
                  ),
                );
              },
            ),
          ),
        ),
        borderData: FlBorderData(
          show: false, // Remove border for cleaner look
        ),
        minX: 0,
        maxX: chartData.length > 0 ? (chartData.length - 1).toDouble() : 0,
        minY: 0,
        maxY: chartData.isNotEmpty
            ? chartData.reduce((a, b) => a > b ? a : b) * 1.1
            : 1000,
        lineBarsData: [
          LineChartBarData(
            spots: chartData.asMap().entries.map((entry) {
              return FlSpot(entry.key.toDouble(), entry.value);
            }).toList(),
            isCurved: true,
            color: Theme.of(context).colorScheme.primary,
            barWidth: 2, // Thinner line
            isStrokeCapRound: true,
            dotData: const FlDotData(show: false),
            belowBarData: BarAreaData(
              show: true,
              color: Theme.of(context)
                  .colorScheme
                  .primary
                  .withOpacity(0.05), // Lighter fill
            ),
          ),
        ],
      ),
    );

}

List<double> \_getChartData() {
switch (\_chartTypes[_selectedChartIndex]) {
case 'daily':
// Simulate hourly data for today - smaller values
return [
300,
500,
800,
600,
900,
1200,
1000,
1400,
1600,
1800,
2000,
2200
];
case 'weekly':
// Last 7 days data - smaller values
return [
widget.salesData.weeklySales * 0.08,
widget.salesData.weeklySales * 0.12,
widget.salesData.weeklySales * 0.15,
widget.salesData.weeklySales * 0.20,
widget.salesData.weeklySales * 0.18,
widget.salesData.weeklySales * 0.15,
widget.salesData.weeklySales * 0.12,
];
case 'monthly':
// Last 30 days aggregated by week - smaller values
return [
widget.salesData.totalSales * 0.08,
widget.salesData.totalSales * 0.12,
widget.salesData.totalSales * 0.20,
widget.salesData.totalSales * 0.25,
widget.salesData.totalSales * 0.18,
];
default:
return [0, 0, 0, 0, 0];
}
}

double \_getHorizontalInterval(List<double> data) {
if (data.isEmpty) return 1000;
final maxValue = data.reduce((a, b) => a > b ? a : b);
if (maxValue > 10000) return 5000;
if (maxValue > 5000) return 2000;
if (maxValue > 1000) return 500;
if (maxValue > 500) return 200;
return 100;
}

String \_getBottomTitle(int index, int total) {
switch (\_chartTypes[_selectedChartIndex]) {
case 'daily':
final hours = ['6', '8', '10', '12', '2', '4', '6', '8', '10'];
return index < hours.length ? hours[index] : '';
case 'weekly':
final days = ['M', 'T', 'W', 'T', 'F', 'S', 'S'];
return index < days.length ? days[index] : '';
case 'monthly':
final weeks = ['W1', 'W2', 'W3', 'W4', 'W5'];
return index < weeks.length ? weeks[index] : '';
default:
return index.toString();
}
}

Widget \_buildStatistics() {
return Container(
padding: const EdgeInsets.all(12), // Reduced padding
decoration: BoxDecoration(
color: Theme.of(context).colorScheme.surface,
borderRadius: BorderRadius.circular(8), // Smaller radius
border: Border.all(
color: Theme.of(context).colorScheme.outline.withOpacity(0.1),
),
),
child: Row(
mainAxisAlignment: MainAxisAlignment.spaceAround,
children: [
_buildStatItem(
widget.localizations.translate('todayRevenue'),
AppFormatters.formatCurrency(widget.salesData.todaysSales),
Icons.today_rounded,
const Color(0xFF10B981),
),
_buildStatItem(
widget.localizations.translate('weeklySales'),
AppFormatters.formatCurrency(widget.salesData.weeklySales),
Icons.calendar_view_week_rounded,
const Color(0xFF3B82F6),
),
_buildStatItem(
widget.localizations.translate('totalRevenue'),
AppFormatters.formatCompactCurrency(widget.salesData.totalSales),
Icons.bar_chart_rounded,
const Color(0xFF8B5CF6),
),
],
),
);
}

Widget \_buildStatItem(
String label, String value, IconData icon, Color color) {
return Expanded(
child: Column(
mainAxisSize: MainAxisSize.min,
children: [
Container(
padding: const EdgeInsets.all(6), // Smaller
decoration: BoxDecoration(
color: color.withOpacity(0.1),
borderRadius: BorderRadius.circular(6),
),
child: Icon(icon, color: color, size: 16), // Smaller icon
),
const SizedBox(height: 6),
FittedBox(
fit: BoxFit.scaleDown,
child: Text(
value,
style: Theme.of(context).textTheme.bodyMedium?.copyWith(
fontWeight: FontWeight.w700,
color: Theme.of(context).colorScheme.onSurface,
fontSize: 12, // Smaller font
),
maxLines: 1,
textAlign: TextAlign.center,
),
),
const SizedBox(height: 2),
Text(
label,
style: Theme.of(context).textTheme.bodySmall?.copyWith(
color: Theme.of(context).colorScheme.outline,
fontSize: 9, // Smaller font
),
maxLines: 1,
overflow: TextOverflow.ellipsis,
textAlign: TextAlign.center,
),
],
),
);
}
}

##

// mobile/lib/src/widgets/dashboard/sales_charts.dart
// A sales analytics widget displaying sales data with charts and statistics on the dashboard.
import 'package:andalus_smart_pos/src/data/repositories/sale_repository.dart';
import 'package:flutter/material.dart';
import 'package:andalus_smart_pos/src/data/models/sale.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';

class SalesChartsWidget extends StatelessWidget {
final SalesSummary salesData;
final AppLocalizations localizations;

const SalesChartsWidget({
super.key,
required this.salesData,
required this.localizations,
});

@override
Widget build(BuildContext context) {
return Card(
elevation: 0,
shape: RoundedRectangleBorder(
borderRadius: BorderRadius.circular(20),
side: BorderSide(
color: Theme.of(context).colorScheme.outline.withOpacity(0.1),
),
),
child: Padding(
padding: const EdgeInsets.all(24),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
localizations.translate('salesAnalytics'),
style: Theme.of(context).textTheme.titleLarge?.copyWith(
fontWeight: FontWeight.w700,
),
),
const SizedBox(height: 16),
Container(
height: 200,
decoration: BoxDecoration(
color: Theme.of(context)
.colorScheme
.surfaceVariant
.withOpacity(0.3),
borderRadius: BorderRadius.circular(16),
),
child: Center(
child: Column(
mainAxisAlignment: MainAxisAlignment.center,
children: [
Icon(
Icons.bar_chart_rounded,
size: 48,
color: Theme.of(context)
.colorScheme
.outline
.withOpacity(0.5),
),
const SizedBox(height: 12),
Text(
localizations.translate('chartsComingSoon'),
style: Theme.of(context).textTheme.bodyMedium?.copyWith(
color: Theme.of(context).colorScheme.outline,
),
),
Text(
localizations.translate('installFlChart'),
style: Theme.of(context).textTheme.bodySmall?.copyWith(
color: Theme.of(context).colorScheme.outline,
),
),
],
),
),
),
],
),
),
);
}
}

##

// mobile/lib/src/widgets/dashboard/stat_card.dart
// A reusable stat card widget for displaying key statistics on the dashboard.
import 'package:flutter/material.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';

class StatCard extends StatelessWidget {
final String title;
final String value;
final IconData icon;
final Color color;
final int? trend;
final String? subtitle;
final bool isWarning;
final AppLocalizations localizations;

const StatCard({
super.key,
required this.title,
required this.value,
required this.icon,
required this.color,
this.trend,
this.subtitle,
this.isWarning = false,
required this.localizations,
});

@override
Widget build(BuildContext context) {
return Card(
elevation: 0,
shape: RoundedRectangleBorder(
borderRadius: BorderRadius.circular(16),
side: BorderSide(
color: Theme.of(context).colorScheme.outline.withOpacity(0.1),
),
),
child: Padding(
padding: const EdgeInsets.all(20),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
mainAxisAlignment: MainAxisAlignment.spaceBetween,
children: [
Row(
mainAxisAlignment: MainAxisAlignment.spaceBetween,
children: [
Container(
padding: const EdgeInsets.all(8),
decoration: BoxDecoration(
color: color.withOpacity(0.1),
borderRadius: BorderRadius.circular(12),
),
child: Icon(icon, color: color, size: 20),
),
if (trend != null) ...[
Container(
padding:
const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
decoration: BoxDecoration(
color: trend! > 0
? Colors.green.withOpacity(0.1)
: Colors.red.withOpacity(0.1),
borderRadius: BorderRadius.circular(8),
),
child: Row(
children: [
Icon(
trend! > 0 ? Icons.trending_up : Icons.trending_down,
color: trend! > 0 ? Colors.green : Colors.red,
size: 14,
),
const SizedBox(width: 2),
Text(
trend! > 0
? localizations.translate('up')
: localizations.translate('down'),
style: TextStyle(
fontSize: 10,
fontWeight: FontWeight.w600,
color: trend! > 0 ? Colors.green : Colors.red,
),
),
],
),
),
],
],
),
Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
value,
style: Theme.of(context).textTheme.headlineSmall?.copyWith(
fontWeight: FontWeight.w700,
color: isWarning
? const Color(0xFFEF4444)
: Theme.of(context).colorScheme.onSurface,
),
maxLines: 1,
overflow: TextOverflow.ellipsis,
),
if (subtitle != null) ...[
const SizedBox(height: 4),
Text(
subtitle!,
style: Theme.of(context).textTheme.bodySmall?.copyWith(
color: Theme.of(context).colorScheme.outline,
),
),
],
const SizedBox(height: 4),
Text(
title,
style: Theme.of(context).textTheme.bodyMedium?.copyWith(
color: Theme.of(context).colorScheme.outline,
fontWeight: FontWeight.w500,
),
),
],
),
],
),
),
);
}
}

##

// mobile/lib/src/widgets/dashboard/stock_alert_widget.dart
// A stock alert widget that notifies about low stock products on the dashboard.
import 'package:flutter/material.dart';
import 'package:andalus_smart_pos/src/data/models/product.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';

class StockAlertWidget extends StatelessWidget {
final List<Product> products;
final AppLocalizations localizations;

const StockAlertWidget({
super.key,
required this.products,
required this.localizations,
});

@override
Widget build(BuildContext context) {
final hasLowStock = products.isNotEmpty;

    return Card(
      elevation: 0,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(20),
        side: BorderSide(
          color: hasLowStock
              ? const Color(0xFFEF4444).withOpacity(0.2)
              : Theme.of(context).colorScheme.outline.withOpacity(0.1),
        ),
      ),
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Container(
                  padding: const EdgeInsets.all(6),
                  decoration: BoxDecoration(
                    color: hasLowStock
                        ? const Color(0xFFEF4444).withOpacity(0.1)
                        : const Color(0xFF10B981).withOpacity(0.1),
                    borderRadius: BorderRadius.circular(10),
                  ),
                  child: Icon(
                    hasLowStock
                        ? Icons.warning_amber_rounded
                        : Icons.inventory_2_rounded,
                    color: hasLowStock
                        ? const Color(0xFFEF4444)
                        : const Color(0xFF10B981),
                    size: 20,
                  ),
                ),
                const SizedBox(width: 12),
                Text(
                  localizations.translate('stockAlert'),
                  style: Theme.of(context).textTheme.titleLarge?.copyWith(
                        fontWeight: FontWeight.w700,
                      ),
                ),
              ],
            ),
            const SizedBox(height: 16),
            if (products.isEmpty)
              Text(
                localizations.translate('allProductsWellStocked'),
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                      color: Theme.of(context).colorScheme.outline,
                    ),
              )
            else
              Column(
                children: products
                    .take(4)
                    .map((product) => _buildProductItem(context, product))
                    .toList(),
              ),
            if (products.length > 4) ...[
              const SizedBox(height: 8),
              Text(
                localizations.translate('moreProducts',
                    params: {'count': (products.length - 4).toString()}),
                style: Theme.of(context).textTheme.bodySmall?.copyWith(
                      color: Theme.of(context).colorScheme.outline,
                      fontStyle: FontStyle.italic,
                    ),
              ),
            ],
          ],
        ),
      ),
    );

}

Widget \_buildProductItem(BuildContext context, Product product) {
return Container(
margin: const EdgeInsets.only(bottom: 8),
padding: const EdgeInsets.all(12),
decoration: BoxDecoration(
color: const Color(0xFFFEF3F2),
borderRadius: BorderRadius.circular(12),
border: Border.all(
color: const Color(0xFFFECDCA),
),
),
child: Row(
children: [
Expanded(
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
product.name,
style: Theme.of(context).textTheme.bodyMedium?.copyWith(
fontWeight: FontWeight.w600,
),
maxLines: 1,
overflow: TextOverflow.ellipsis,
),
const SizedBox(height: 2),
Text(
'SKU: ${product.sku ?? 'N/A'}',
style: Theme.of(context).textTheme.bodySmall?.copyWith(
color: Theme.of(context).colorScheme.outline,
),
),
],
),
),
Container(
padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
decoration: BoxDecoration(
color: const Color(0xFFEF4444).withOpacity(0.1),
borderRadius: BorderRadius.circular(8),
),
child: Text(
'${product.stockQuantity} ${localizations.translate('left')}',
style: const TextStyle(
fontSize: 12,
fontWeight: FontWeight.w700,
color: Color(0xFFEF4444),
),
),
),
],
),
);
}
}

##

// lib/src/widgets/reports/advanced_product_analytics.dart
// Advanced product analytics widget displaying detailed product performance metrics.
// This includes ABC analysis and profit margin distribution charts.
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import '../../localization/app_localizations.dart';
import '../../utils/reports_data_calculator.dart';
import '../common/custom_card.dart';

class AdvancedProductAnalytics extends StatelessWidget {
final ProductsReportData productsData;

const AdvancedProductAnalytics({super.key, required this.productsData});

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);

    return Column(
      children: [
        // ABC Analysis Chart
        CustomCard(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'ABC Analysis - Product Segmentation',
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                SizedBox(
                  height: 300,
                  child: SfCartesianChart(
                    primaryXAxis: const CategoryAxis(),
                    primaryYAxis: NumericAxis(
                      numberFormat: NumberFormat.percentPattern(),
                    ),
                    series: <CartesianSeries<ABCAnalysisData, String>>[
                      BarSeries<ABCAnalysisData, String>(
                        dataSource: _generateABCAnalysisData(),
                        xValueMapper: (data, _) => data.category,
                        yValueMapper: (data, _) => data.percentage,
                        dataLabelSettings:
                            const DataLabelSettings(isVisible: true),
                      )
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
        const SizedBox(height: 16),

        // Profit Margin Distribution
        CustomCard(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Profit Margin Distribution',
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                SizedBox(
                  height: 250,
                  child: SfCircularChart(
                    series: <CircularSeries>[
                      PieSeries<MarginDistributionData, String>(
                        dataSource: _generateMarginDistributionData(),
                        xValueMapper: (data, _) => data.range,
                        yValueMapper: (data, _) => data.count,
                        dataLabelSettings:
                            const DataLabelSettings(isVisible: true),
                      )
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ],
    );

}

List<ABCAnalysisData> \_generateABCAnalysisData() {
return [
ABCAnalysisData('A - High Value (20%)', 0.75),
ABCAnalysisData('B - Medium Value (30%)', 0.20),
ABCAnalysisData('C - Low Value (50%)', 0.05),
];
}

List<MarginDistributionData> \_generateMarginDistributionData() {
return [
MarginDistributionData('0-10%', 5),
MarginDistributionData('10-20%', 12),
MarginDistributionData('20-30%', 25),
MarginDistributionData('30-40%', 18),
MarginDistributionData('40%+', 8),
];
}
}

class ABCAnalysisData {
final String category;
final double percentage;

ABCAnalysisData(this.category, this.percentage);
}

class MarginDistributionData {
final String range;
final int count;

MarginDistributionData(this.range, this.count);
}

##

// lib/src/widgets/reports/advanced_sales_charts.dart
// Advanced sales analytics widget displaying detailed sales performance metrics.
// This includes sales velocity and customer retention charts.
import 'package:flutter/material.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import '../../localization/app_localizations.dart';
import '../../utils/reports_data_calculator.dart';
import '../common/custom_card.dart';

class AdvancedSalesCharts extends StatelessWidget {
final SalesReportData salesData;

const AdvancedSalesCharts({super.key, required this.salesData});

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);

    return Column(
      children: [
        // Sales Velocity Chart
        CustomCard(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Sales Velocity',
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                SizedBox(
                  height: 250,
                  child: SfCartesianChart(
                    primaryXAxis: const CategoryAxis(),
                    primaryYAxis: NumericAxis(
                      title: AxisTitle(text: 'Sales per Day'),
                    ),
                    series: <CartesianSeries<SalesVelocityData, String>>[
                      LineSeries<SalesVelocityData, String>(
                        dataSource: _generateSalesVelocityData(),
                        xValueMapper: (data, _) => data.period,
                        yValueMapper: (data, _) => data.velocity,
                        markerSettings: const MarkerSettings(isVisible: true),
                        animationDuration: 1000,
                      )
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
        const SizedBox(height: 16),

        // Customer Retention Chart
        CustomCard(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Customer Retention',
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                SizedBox(
                  height: 250,
                  child: SfCircularChart(
                    series: <CircularSeries>[
                      DoughnutSeries<RetentionData, String>(
                        dataSource: _generateRetentionData(),
                        xValueMapper: (data, _) => data.category,
                        yValueMapper: (data, _) => data.value,
                        dataLabelSettings:
                            const DataLabelSettings(isVisible: true),
                      )
                    ],
                    legend: Legend(isVisible: true),
                  ),
                ),
              ],
            ),
          ),
        ),
      ],
    );

}

List<SalesVelocityData> \_generateSalesVelocityData() {
return [
SalesVelocityData('Week 1', 15.2),
SalesVelocityData('Week 2', 18.5),
SalesVelocityData('Week 3', 16.8),
SalesVelocityData('Week 4', 22.1),
];
}

List<RetentionData> \_generateRetentionData() {
return [
RetentionData('Repeat Customers', 65),
RetentionData('New Customers', 25),
RetentionData('Lost Customers', 10),
];
}
}

class SalesVelocityData {
final String period;
final double velocity;

SalesVelocityData(this.period, this.velocity);
}

class RetentionData {
final String category;
final double value;

RetentionData(this.category, this.value);
}

##

// lib/src/widgets/reports/customer_analytics_section.dart
// Customer analytics widget displaying customer behavior and lifetime value metrics.
// This includes customer lifetime value and churn risk analysis charts.
import 'package:flutter/material.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import '../../localization/app_localizations.dart';
import '../../utils/reports_data_calculator.dart';
import '../common/custom_card.dart';

class CustomerAnalyticsSection extends StatelessWidget {
final CustomersReportData customersData;

const CustomerAnalyticsSection({super.key, required this.customersData});

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);

    return Column(
      children: [
        // Customer Lifetime Value
        CustomCard(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Customer Lifetime Value Analysis',
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                SizedBox(
                  height: 300,
                  child: SfCartesianChart(
                    primaryXAxis: const CategoryAxis(),
                    primaryYAxis: NumericAxis(
                      title: AxisTitle(text: 'Lifetime Value (ETB)'),
                    ),
                    series: <CartesianSeries<LTVData, String>>[
                      BarSeries<LTVData, String>(
                        dataSource: _generateLTVData(),
                        xValueMapper: (data, _) => data.segment,
                        yValueMapper: (data, _) => data.value,
                        dataLabelSettings:
                            const DataLabelSettings(isVisible: true),
                      )
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
        const SizedBox(height: 16),

        // Churn Risk Analysis
        CustomCard(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Customer Churn Risk Analysis',
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                SizedBox(
                  height: 250,
                  child: SfCircularChart(
                    series: <CircularSeries>[
                      DoughnutSeries<ChurnData, String>(
                        dataSource: _generateChurnData(),
                        xValueMapper: (data, _) => data.risk,
                        yValueMapper: (data, _) => data.percentage,
                        dataLabelSettings:
                            const DataLabelSettings(isVisible: true),
                      )
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ],
    );

}

List<LTVData> \_generateLTVData() {
return [
LTVData('High Value', 12500),
LTVData('Medium Value', 6500),
LTVData('Low Value', 1800),
LTVData('New Customers', 500),
];
}

List<ChurnData> \_generateChurnData() {
return [
ChurnData('Low Risk', 60),
ChurnData('Medium Risk', 25),
ChurnData('High Risk', 15),
];
}
}

class LTVData {
final String segment;
final double value;

LTVData(this.segment, this.value);
}

class ChurnData {
final String risk;
final double percentage;

ChurnData(this.risk, this.percentage);
}

##

// lib/src/widgets/reports/customer_report_section.dart
// Customer report section widget displaying key customer metrics and charts.
// This includes overview stats, top customers, and outstanding balance analysis.
import 'package:andalus_smart_pos/src/data/models/subscription.dart';
import 'package:andalus_smart_pos/src/utils/chart_formatters.dart';
import 'package:flutter/material.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import '../../localization/app_localizations.dart';
import '../../utils/formatters.dart';
import '../../utils/reports_data_calculator.dart';
import '../common/custom_card.dart';

class CustomerReportSection extends StatelessWidget {
final CustomersReportData customersData;
final SubscriptionPlan plan;

const CustomerReportSection({
super.key,
required this.customersData,
required this.plan,
});

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);

    return ListView(
      padding: const EdgeInsets.all(16),
      children: [
        _buildCustomersOverview(localizations, theme),
        const SizedBox(height: 16),
        _buildTopCustomersChart(localizations, theme),
        const SizedBox(height: 16),
        _buildOutstandingBalanceChart(localizations, theme),
        if (plan.id == 'enterprise') ...[
          const SizedBox(height: 16),
          _buildAdvancedCustomerAnalytics(localizations, theme),
        ],
      ],
    );

}

Widget \_buildCustomersOverview(
AppLocalizations localizations, ThemeData theme) {
return CustomCard(
child: Padding(
padding: const EdgeInsets.all(20),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
localizations.customersOverview,
style: theme.textTheme.titleLarge?.copyWith(
fontWeight: FontWeight.bold,
color: theme.colorScheme.primary,
),
),
const SizedBox(height: 16),
GridView.count(
shrinkWrap: true,
physics: const NeverScrollableScrollPhysics(),
crossAxisCount: 2,
crossAxisSpacing: 16,
mainAxisSpacing: 16,
children: [
_buildMetricCard(
theme,
// localizations.totalCustomers,
localizations.translate('total_customers'),
customersData.totalCustomers.toString(),
Icons.people,
Colors.blue,
),
_buildMetricCard(
theme,
localizations.customersWithBalance,
customersData.customersWithBalance.toString(),
Icons.credit_card,
Colors.orange,
),
_buildMetricCard(
theme,
localizations.overdue,
customersData.overdueCustomers.toString(),
Icons.warning,
Colors.red,
),
_buildMetricCard(
theme,
localizations.outstandingCredit,
AppFormatters.formatCurrency(customersData.totalOutstanding),
Icons.money_off,
Colors.purple,
),
],
),
],
),
),
);
}

Widget \_buildMetricCard(
ThemeData theme, String title, String value, IconData icon, Color color) {
return Container(
decoration: BoxDecoration(
color: theme.colorScheme.surface,
borderRadius: BorderRadius.circular(12),
border: Border.all(color: theme.colorScheme.outline.withOpacity(0.2)),
),
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Row(
children: [
Container(
padding: const EdgeInsets.all(8),
decoration: BoxDecoration(
color: color.withOpacity(0.1),
borderRadius: BorderRadius.circular(8),
),
child: Icon(icon, color: color, size: 20),
),
const Spacer(),
Text(
value,
style: theme.textTheme.titleLarge?.copyWith(
fontWeight: FontWeight.bold,
),
),
],
),
const SizedBox(height: 8),
Text(
title,
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.7),
),
),
],
),
),
);
}

Widget _buildTopCustomersChart(
AppLocalizations localizations, ThemeData theme) {
return CustomCard(
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
localizations.topCustomers,
style: theme.textTheme.titleMedium?.copyWith(
fontWeight: FontWeight.bold,
),
),
const SizedBox(height: 16),
SizedBox(
height: 300,
child: customersData.topCustomers.isNotEmpty
? SfCartesianChart(
primaryXAxis: CategoryAxis(
labelRotation: -45,
majorGridLines: const MajorGridLines(width: 0),
),
primaryYAxis: NumericAxis(
numberFormat: ChartFormatters.currencyFormat,
),
series: <CartesianSeries<TopCustomer, String>>[
BarSeries<TopCustomer, String>(
dataSource:
customersData.topCustomers.take(8).toList(),
xValueMapper: (customer, _) => customer.name,
yValueMapper: (customer, \_) => customer.totalSpent,
color: theme.colorScheme.secondary,
dataLabelSettings:
const DataLabelSettings(isVisible: true),
)
],
)
: Center(
child: Text(
'No customer data available',
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.outline,
),
),
),
),
],
),
),
);
}

Widget \_buildOutstandingBalanceChart(
AppLocalizations localizations, ThemeData theme) {
// Simplified implementation - you can enhance this with real data
return CustomCard(
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
'Outstanding Balance Analysis',
style: theme.textTheme.titleMedium?.copyWith(
fontWeight: FontWeight.bold,
),
),
const SizedBox(height: 16),
Container(
height: 200,
alignment: Alignment.center,
child: Text(
'Advanced customer analytics available in Enterprise plan',
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.outline,
),
textAlign: TextAlign.center,
),
),
],
),
),
);
}

Widget \_buildAdvancedCustomerAnalytics(
AppLocalizations localizations, ThemeData theme) {
return CustomCard(
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Text(
'Advanced Customer Analytics',
style: theme.textTheme.titleMedium?.copyWith(
fontWeight: FontWeight.bold,
),
),
const SizedBox(height: 16),
// Add enterprise-level customer analytics here
Text(
'Customer Lifetime Value, Churn Analysis, Segmentation',
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.outline,
),
),
],
),
),
);
}
}

##

// lib/src/widgets/reports/customers_overview_card.dart
// Customers overview card widget displaying key customer metrics.
import 'package:flutter/material.dart';
import '../../localization/app_localizations.dart';
import '../../utils/formatters.dart';
import '../../utils/reports_data_calculator.dart';
import '../common/custom_card.dart';

class CustomersOverviewCard extends StatelessWidget {
final CustomersReportData customersData;

const CustomersOverviewCard({super.key, required this.customersData});

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);

    return CustomCard(
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              localizations.customersOverview,
              style: theme.textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
                color: theme.colorScheme.primary,
              ),
            ),
            const SizedBox(height: 16),
            GridView.count(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              crossAxisCount: 2,
              crossAxisSpacing: 16,
              mainAxisSpacing: 16,
              children: [
                _buildMetricCard(
                  theme,
                  // localizations.totalCustomers,
                  localizations.translate('total_customers'),
                  AppFormatters.formatNumber(customersData.totalCustomers),
                  Icons.people,
                  Colors.blue,
                ),
                _buildMetricCard(
                  theme,
                  localizations.translate('customers_with_balance'),
                  AppFormatters.formatNumber(
                      customersData.customersWithBalance),
                  Icons.credit_card,
                  Colors.orange,
                ),
                _buildMetricCard(
                  theme,
                  localizations.overdue,
                  AppFormatters.formatNumber(customersData.overdueCustomers),
                  Icons.warning,
                  Colors.red,
                ),
                _buildMetricCard(
                  theme,
                  'Avg Customer Value',
                  AppFormatters.formatCurrency(
                      customersData.averageCustomerValue),
                  Icons.attach_money,
                  Colors.green,
                ),
              ],
            ),
          ],
        ),
      ),
    );

}

Widget \_buildMetricCard(
ThemeData theme, String title, String value, IconData icon, Color color) {
return Container(
decoration: BoxDecoration(
color: theme.colorScheme.surface,
borderRadius: BorderRadius.circular(12),
border: Border.all(color: theme.colorScheme.outline.withOpacity(0.2)),
),
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Row(
children: [
Container(
padding: const EdgeInsets.all(8),
decoration: BoxDecoration(
color: color.withOpacity(0.1),
borderRadius: BorderRadius.circular(8),
),
child: Icon(icon, color: color, size: 20),
),
const Spacer(),
Text(
value,
style: theme.textTheme.titleLarge?.copyWith(
fontWeight: FontWeight.bold,
),
),
],
),
const SizedBox(height: 8),
Text(
title,
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.7),
),
),
],
),
),
);
}
}

##

// lib/src/widgets/reports/financial_ratios_section.dart
// Financial ratios widget displaying key financial metrics and break-even analysis charts.
import 'package:flutter/material.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import '../../localization/app_localizations.dart';
import '../../utils/reports_data_calculator.dart';
import '../common/custom_card.dart';

class FinancialRatiosSection extends StatelessWidget {
final FinancialReportData financialData;

const FinancialRatiosSection({super.key, required this.financialData});

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);

    return Column(
      children: [
        // Key Financial Ratios
        CustomCard(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Key Financial Ratios',
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                SizedBox(
                  height: 300,
                  child: SfCartesianChart(
                    primaryXAxis: const CategoryAxis(),
                    primaryYAxis: NumericAxis(),
                    series: <CartesianSeries<FinancialRatio, String>>[
                      BarSeries<FinancialRatio, String>(
                        dataSource: _generateFinancialRatios(),
                        xValueMapper: (data, _) => data.ratio,
                        yValueMapper: (data, _) => data.value,
                        dataLabelSettings:
                            const DataLabelSettings(isVisible: true),
                      )
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
        const SizedBox(height: 16),

        // Break-Even Analysis
        CustomCard(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Break-Even Analysis',
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                SizedBox(
                  height: 250,
                  child: SfCartesianChart(
                    primaryXAxis: const CategoryAxis(),
                    primaryYAxis: NumericAxis(
                      title: AxisTitle(text: 'Amount (ETB)'),
                    ),
                    series: <CartesianSeries<BreakEvenData, String>>[
                      LineSeries<BreakEvenData, String>(
                        dataSource: _generateBreakEvenData(),
                        xValueMapper: (data, _) => data.month,
                        yValueMapper: (data, _) => data.revenue,
                        name: 'Revenue',
                        markerSettings: const MarkerSettings(isVisible: true),
                      ),
                      LineSeries<BreakEvenData, String>(
                        dataSource: _generateBreakEvenData(),
                        xValueMapper: (data, _) => data.month,
                        yValueMapper: (data, _) => data.costs,
                        name: 'Total Costs',
                        markerSettings: const MarkerSettings(isVisible: true),
                      ),
                    ],
                    legend: Legend(isVisible: true),
                  ),
                ),
              ],
            ),
          ),
        ),
      ],
    );

}

List<FinancialRatio> \_generateFinancialRatios() {
return [
FinancialRatio('Gross Margin', 35.2),
FinancialRatio('Net Margin', 22.8),
FinancialRatio('ROI', 18.5),
FinancialRatio('Current Ratio', 2.1),
FinancialRatio('Quick Ratio', 1.5),
];
}

List<BreakEvenData> \_generateBreakEvenData() {
return [
BreakEvenData('Jan', 80000, 95000),
BreakEvenData('Feb', 95000, 92000),
BreakEvenData('Mar', 110000, 98000),
BreakEvenData('Apr', 125000, 105000),
BreakEvenData('May', 140000, 110000),
BreakEvenData('Jun', 155000, 115000),
];
}
}

class FinancialRatio {
final String ratio;
final double value;

FinancialRatio(this.ratio, this.value);
}

class BreakEvenData {
final String month;
final double revenue;
final double costs;

BreakEvenData(this.month, this.revenue, this.costs);
}

##

// lib/src/widgets/reports/financial_report_section.dart
// Financial report section widget displaying key financial metrics and charts.
// This includes financial KPIs, profit margin trends, and cash flow analysis.
import 'package:andalus_smart_pos/src/utils/chart_formatters.dart';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import '../../localization/app_localizations.dart';
import '../../utils/formatters.dart';
import '../../utils/reports_data_calculator.dart';
import '../common/custom_card.dart';

class FinancialReportSection extends StatelessWidget {
final FinancialReportData financialData;

const FinancialReportSection({super.key, required this.financialData});

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);

    return ListView(
      padding: const EdgeInsets.all(16),
      children: [
        FinancialKPICards(financialData: financialData),
        const SizedBox(height: 16),
        ProfitMarginTrendChart(financialData: financialData),
        const SizedBox(height: 16),
        CashFlowAnalysisChart(financialData: financialData),
      ],
    );

}
}

class FinancialKPICards extends StatelessWidget {
final FinancialReportData financialData;

const FinancialKPICards({super.key, required this.financialData});

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);

    return CustomCard(
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Financial KPIs',
              style: theme.textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
                color: theme.colorScheme.primary,
              ),
            ),
            const SizedBox(height: 16),
            GridView.count(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              crossAxisCount: 2,
              crossAxisSpacing: 16,
              mainAxisSpacing: 16,
              children: [
                _buildKPICard(
                  theme,
                  'Total Revenue',
                  AppFormatters.formatCurrency(financialData.totalRevenue),
                  Icons.attach_money,
                  Colors.green,
                ),
                _buildKPICard(
                  theme,
                  'Net Revenue',
                  AppFormatters.formatCurrency(financialData.netRevenue),
                  Icons.account_balance,
                  Colors.blue,
                ),
                _buildKPICard(
                  theme,
                  'Profit Margin',
                  '${financialData.profitMargin.toStringAsFixed(1)}%',
                  Icons.trending_up,
                  Colors.orange,
                ),
                _buildKPICard(
                  theme,
                  'Total Tax',
                  AppFormatters.formatCurrency(financialData.totalTax),
                  Icons.receipt,
                  Colors.purple,
                ),
              ],
            ),
          ],
        ),
      ),
    );

}

Widget \_buildKPICard(
ThemeData theme, String title, String value, IconData icon, Color color) {
return Container(
decoration: BoxDecoration(
color: theme.colorScheme.surface,
borderRadius: BorderRadius.circular(12),
border: Border.all(color: theme.colorScheme.outline.withOpacity(0.2)),
),
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Row(
children: [
Container(
padding: const EdgeInsets.all(8),
decoration: BoxDecoration(
color: color.withOpacity(0.1),
borderRadius: BorderRadius.circular(8),
),
child: Icon(icon, color: color, size: 20),
),
const Spacer(),
Text(
value,
style: theme.textTheme.titleLarge?.copyWith(
fontWeight: FontWeight.bold,
),
),
],
),
const SizedBox(height: 8),
Text(
title,
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.7),
),
),
],
),
),
);
}
}

class ProfitMarginTrendChart extends StatelessWidget {
final FinancialReportData financialData;

const ProfitMarginTrendChart({super.key, required this.financialData});

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);

    return CustomCard(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Profit Margin Trend',
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            SizedBox(
              height: 300,
              child: SfCartesianChart(
                primaryXAxis: const CategoryAxis(),
                primaryYAxis: NumericAxis(
                  numberFormat:
                      NumberFormat.decimalPercentPattern(decimalDigits: 1),
                ),
                series: <CartesianSeries<ProfitData, String>>[
                  LineSeries<ProfitData, String>(
                    dataSource: _generateSampleProfitData(),
                    xValueMapper: (data, _) => data.period,
                    yValueMapper: (data, _) => data.margin,
                    markerSettings: const MarkerSettings(isVisible: true),
                    animationDuration: 1000,
                  )
                ],
              ),
            ),
          ],
        ),
      ),
    );

}

List<ProfitData> \_generateSampleProfitData() {
return [
ProfitData('Jan', 22.5),
ProfitData('Feb', 24.1),
ProfitData('Mar', 23.8),
ProfitData('Apr', 25.2),
ProfitData('May', 26.0),
ProfitData('Jun', 25.5),
];
}
}

class CashFlowAnalysisChart extends StatelessWidget {
final FinancialReportData financialData;

const CashFlowAnalysisChart({super.key, required this.financialData});

@override
Widget build(BuildContext context) {
final theme = Theme.of(context);

    return CustomCard(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Cash Flow Analysis',
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            SizedBox(
              height: 300,
              child: SfCartesianChart(
                primaryXAxis: const CategoryAxis(),
                primaryYAxis: NumericAxis(
                  numberFormat: ChartFormatters.currencyFormat,
                ),
                series: <CartesianSeries<CashFlowData, String>>[
                  ColumnSeries<CashFlowData, String>(
                    dataSource: _generateSampleCashFlowData(),
                    xValueMapper: (data, _) => data.period,
                    yValueMapper: (data, _) => data.amount,
                    animationDuration: 1000,
                  )
                ],
              ),
            ),
          ],
        ),
      ),
    );

}

List<CashFlowData> \_generateSampleCashFlowData() {
return [
CashFlowData('Jan', 150000),
CashFlowData('Feb', 165000),
CashFlowData('Mar', 142000),
CashFlowData('Apr', 178000),
CashFlowData('May', 195000),
CashFlowData('Jun', 210000),
];
}
}

class ProfitData {
final String period;
final double margin;

ProfitData(this.period, this.margin);
}

class CashFlowData {
final String period;
final double amount;

CashFlowData(this.period, this.amount);
}

##

// lib/src/widgets/reports/inventory_analysis_section.dart
// Inventory analysis section widget displaying key inventory metrics and charts.
// This includes inventory turnover ratios and stock aging analysis.
import 'package:flutter/material.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import '../../localization/app_localizations.dart';
import '../../utils/reports_data_calculator.dart';
import '../common/custom_card.dart';

class InventoryAnalysisSection extends StatelessWidget {
final ProductsReportData productsData;

const InventoryAnalysisSection({super.key, required this.productsData});

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);

    return Column(
      children: [
        // Inventory Turnover Chart
        CustomCard(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Inventory Turnover Analysis',
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                SizedBox(
                  height: 300,
                  child: SfCartesianChart(
                    primaryXAxis: const CategoryAxis(),
                    primaryYAxis: NumericAxis(
                      title: AxisTitle(text: 'Turnover Ratio'),
                    ),
                    series: <CartesianSeries<TurnoverData, String>>[
                      ColumnSeries<TurnoverData, String>(
                        dataSource: _generateTurnoverData(),
                        xValueMapper: (data, _) => data.category,
                        yValueMapper: (data, _) => data.ratio,
                        dataLabelSettings:
                            const DataLabelSettings(isVisible: true),
                      )
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
        const SizedBox(height: 16),

        // Stock Movement Analysis
        CustomCard(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Stock Movement Analysis',
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                SizedBox(
                  height: 250,
                  child: SfCartesianChart(
                    primaryXAxis: const CategoryAxis(),
                    primaryYAxis: NumericAxis(title: AxisTitle(text: 'Units')),
                    series: <CartesianSeries<StockMovementData, String>>[
                      LineSeries<StockMovementData, String>(
                        dataSource: _generateStockMovementData(),
                        xValueMapper: (data, _) => data.period,
                        yValueMapper: (data, _) => data.units,
                        markerSettings: const MarkerSettings(isVisible: true),
                      )
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ],
    );

}

List<TurnoverData> \_generateTurnoverData() {
return [
TurnoverData('Fast Moving', 8.5),
TurnoverData('Medium Moving', 4.2),
TurnoverData('Slow Moving', 1.8),
];
}

List<StockMovementData> \_generateStockMovementData() {
return [
StockMovementData('Jan', 450),
StockMovementData('Feb', 520),
StockMovementData('Mar', 480),
StockMovementData('Apr', 610),
StockMovementData('May', 580),
StockMovementData('Jun', 720),
];
}
}

class TurnoverData {
final String category;
final double ratio;

TurnoverData(this.category, this.ratio);
}

class StockMovementData {
final String period;
final int units;

StockMovementData(this.period, this.units);
}

##

// lib/src/widgets/reports/outstanding_balance_chart.dart
// Outstanding balance chart widget displaying analysis of customer balances.
// This includes a breakdown of outstanding balances by range.
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import '../../localization/app_localizations.dart';
import '../../utils/formatters.dart';
import '../../utils/reports_data_calculator.dart';
import '../common/custom_card.dart';

class OutstandingBalanceChart extends StatelessWidget {
final CustomersReportData customersData;

const OutstandingBalanceChart({super.key, required this.customersData});

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);

    return CustomCard(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Outstanding Balance Analysis',
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            SizedBox(
              height: 300,
              child: SfCartesianChart(
                primaryXAxis: const CategoryAxis(),
                primaryYAxis: NumericAxis(
                  numberFormat: NumberFormat.currency(symbol: 'ETB '),
                ),
                series: <CartesianSeries<BalanceData, String>>[
                  ColumnSeries<BalanceData, String>(
                    dataSource: _generateBalanceData(),
                    xValueMapper: (data, _) => data.range,
                    yValueMapper: (data, _) => data.amount,
                    dataLabelSettings: const DataLabelSettings(isVisible: true),
                  )
                ],
              ),
            ),
          ],
        ),
      ),
    );

}

List<BalanceData> \_generateBalanceData() {
return [
BalanceData('0-1,000', 45000),
BalanceData('1,000-5,000', 125000),
BalanceData('5,000-10,000', 85000),
BalanceData('10,000+', 250000),
];
}
}

class BalanceData {
final String range;
final double amount;

BalanceData(this.range, this.amount);
}

##

// lib/src/widgets/reports/outstanding_balance_chart.dart
// Outstanding balance chart widget displaying analysis of customer balances.
// This includes a breakdown of outstanding balances by range.
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import '../../localization/app_localizations.dart';
import '../../utils/formatters.dart';
import '../../utils/reports_data_calculator.dart';
import '../common/custom_card.dart';

class OutstandingBalanceChart extends StatelessWidget {
final CustomersReportData customersData;

const OutstandingBalanceChart({super.key, required this.customersData});

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);

    return CustomCard(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Outstanding Balance Analysis',
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            SizedBox(
              height: 300,
              child: SfCartesianChart(
                primaryXAxis: const CategoryAxis(),
                primaryYAxis: NumericAxis(
                  numberFormat: NumberFormat.currency(symbol: 'ETB '),
                ),
                series: <CartesianSeries<BalanceData, String>>[
                  ColumnSeries<BalanceData, String>(
                    dataSource: _generateBalanceData(),
                    xValueMapper: (data, _) => data.range,
                    yValueMapper: (data, _) => data.amount,
                    dataLabelSettings: const DataLabelSettings(isVisible: true),
                  )
                ],
              ),
            ),
          ],
        ),
      ),
    );

}

List<BalanceData> \_generateBalanceData() {
return [
BalanceData('0-1,000', 45000),
BalanceData('1,000-5,000', 125000),
BalanceData('5,000-10,000', 85000),
BalanceData('10,000+', 250000),
];
}
}

class BalanceData {
final String range;
final double amount;

BalanceData(this.range, this.amount);
}

##

// lib/src/widgets/reports/payment_method_chart.dart
// Payment method chart widget displaying sales distribution by payment methods.
// This includes a doughnut chart visualizing the breakdown of sales by different payment types.
import 'package:flutter/material.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import '../../localization/app_localizations.dart';
import '../common/custom_card.dart';

class PaymentMethodChart extends StatelessWidget {
final Map<String, double> paymentMethods;

const PaymentMethodChart({super.key, required this.paymentMethods});

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);

    final chartData = paymentMethods.entries
        .map((entry) => _ChartData(
            _getPaymentMethodName(entry.key, localizations), entry.value))
        .toList();

    return CustomCard(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              localizations.salesByPaymentMethod,
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            SizedBox(
              height: 300,
              child: SfCircularChart(
                palette: [
                  theme.colorScheme.primary,
                  theme.colorScheme.secondary,
                  theme.colorScheme.tertiary,
                  Colors.amber,
                  Colors.teal,
                ],
                series: <CircularSeries>[
                  DoughnutSeries<_ChartData, String>(
                    dataSource: chartData,
                    xValueMapper: (_ChartData data, _) => data.x,
                    yValueMapper: (_ChartData data, _) => data.y,
                    dataLabelSettings: DataLabelSettings(
                      isVisible: true,
                      labelPosition: ChartDataLabelPosition.outside,
                      textStyle: theme.textTheme.bodySmall,
                      labelIntersectAction: LabelIntersectAction.shift,
                    ),
                    animationDuration: 1000,
                  )
                ],
                legend: Legend(
                  isVisible: true,
                  position: LegendPosition.bottom,
                  overflowMode: LegendItemOverflowMode.wrap,
                  textStyle: theme.textTheme.bodyMedium,
                ),
                tooltipBehavior: TooltipBehavior(
                  enable: true,
                  format: 'point.x : ETB point.y',
                ),
              ),
            ),
          ],
        ),
      ),
    );

}

String \_getPaymentMethodName(String method, AppLocalizations localizations) {
switch (method.toLowerCase()) {
case 'cash':
return localizations.cash;
case 'telebirr':
return localizations.telebirr;
case 'card':
return localizations.card;
case 'credit':
return localizations.credit;
case 'bank_transfer':
return localizations.bankTransfer;
default:
return method;
}
}
}

class \_ChartData {
final String x;
final double y;

\_ChartData(this.x, this.y);
}

##

// lib/src/widgets/reports/products_overview_card.dart
// Products overview card widget displaying key product metrics.
import 'package:flutter/material.dart';
import '../../localization/app_localizations.dart';
import '../../utils/formatters.dart';
import '../../utils/reports_data_calculator.dart';
import '../common/custom_card.dart';

class ProductsOverviewCard extends StatelessWidget {
final ProductsReportData productsData;

const ProductsOverviewCard({super.key, required this.productsData});

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);

    return CustomCard(
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              localizations.productsOverview,
              style: theme.textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
                color: theme.colorScheme.primary,
              ),
            ),
            const SizedBox(height: 16),
            GridView.count(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              crossAxisCount: 2,
              crossAxisSpacing: 16,
              mainAxisSpacing: 16,
              children: [
                _buildMetricCard(
                  theme,
                  localizations.totalProducts,
                  AppFormatters.formatNumber(productsData.totalProducts),
                  Icons.inventory_2,
                  Colors.blue,
                ),
                _buildMetricCard(
                  theme,
                  localizations.lowStock,
                  AppFormatters.formatNumber(productsData.lowStockCount),
                  Icons.warning,
                  Colors.orange,
                ),
                _buildMetricCard(
                  theme,
                  localizations.outOfStock,
                  AppFormatters.formatNumber(productsData.outOfStockCount),
                  Icons.error,
                  Colors.red,
                ),
                _buildMetricCard(
                  theme,
                  'Stock Value',
                  AppFormatters.formatCurrency(productsData.stockValue),
                  Icons.warehouse,
                  Colors.green,
                ),
              ],
            ),
          ],
        ),
      ),
    );

}

Widget \_buildMetricCard(
ThemeData theme, String title, String value, IconData icon, Color color) {
return Container(
decoration: BoxDecoration(
color: theme.colorScheme.surface,
borderRadius: BorderRadius.circular(12),
border: Border.all(color: theme.colorScheme.outline.withOpacity(0.2)),
),
child: Padding(
padding: const EdgeInsets.all(16),
child: Column(
crossAxisAlignment: CrossAxisAlignment.start,
children: [
Row(
children: [
Container(
padding: const EdgeInsets.all(8),
decoration: BoxDecoration(
color: color.withOpacity(0.1),
borderRadius: BorderRadius.circular(8),
),
child: Icon(icon, color: color, size: 20),
),
const Spacer(),
Text(
value,
style: theme.textTheme.titleLarge?.copyWith(
fontWeight: FontWeight.bold,
),
),
],
),
const SizedBox(height: 8),
Text(
title,
style: theme.textTheme.bodyMedium?.copyWith(
color: theme.colorScheme.onSurface.withOpacity(0.7),
),
),
],
),
),
);
}
}

##

// lib/src/widgets/reports/revenue_by_day_chart.dart
// Revenue by day chart widget displaying daily revenue trends.
// This includes a bar chart visualizing revenue for each day of the week.
import 'package:flutter/material.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import 'package:intl/intl.dart';
import '../../localization/app_localizations.dart';
import '../common/custom_card.dart';

class RevenueByDayChart extends StatelessWidget {
final Map<String, double> revenueByDay;

const RevenueByDayChart({super.key, required this.revenueByDay});

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);

    final chartData = _getOrderedChartData();

    return CustomCard(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              localizations.revenueByDay,
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            SizedBox(
              height: 300,
              child: SfCartesianChart(
                primaryXAxis: CategoryAxis(
                  majorGridLines: const MajorGridLines(width: 0),
                ),
                primaryYAxis: NumericAxis(
                  numberFormat: NumberFormat.currency(symbol: 'ETB '),
                  majorGridLines: const MajorGridLines(width: 0.5),
                ),
                series: <CartesianSeries<_ChartData, String>>[
                  ColumnSeries<_ChartData, String>(
                    dataSource: chartData,
                    xValueMapper: (data, _) => data.x,
                    yValueMapper: (data, _) => data.y,
                    color: theme.colorScheme.secondary,
                    dataLabelSettings: DataLabelSettings(
                      isVisible: true,
                      textStyle: theme.textTheme.bodySmall,
                    ),
                    animationDuration: 1000,
                  )
                ],
                tooltipBehavior: TooltipBehavior(
                  enable: true,
                  format: 'point.x : ETB point.y',
                ),
              ),
            ),
          ],
        ),
      ),
    );

}

List<\_ChartData> \_getOrderedChartData() {
const dayOrder = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
return dayOrder
.map(
(day) => \_ChartData(\_getFullDayName(day), revenueByDay[day] ?? 0.0))
.toList();
}

String \_getFullDayName(String shortDay) {
switch (shortDay) {
case 'Mon':
return 'Monday';
case 'Tue':
return 'Tuesday';
case 'Wed':
return 'Wednesday';
case 'Thu':
return 'Thursday';
case 'Fri':
return 'Friday';
case 'Sat':
return 'Saturday';
case 'Sun':
return 'Sunday';
default:
return shortDay;
}
}
}

class \_ChartData {
final String x;
final double y;

\_ChartData(this.x, this.y);
}

##

// lib/src/widgets/reports/sales_overview_card.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../localization/app_localizations.dart';
import '../../utils/formatters.dart';
import '../../utils/reports_data_calculator.dart';
import '../common/custom_card.dart';

class SalesOverviewCard extends ConsumerWidget {
final SalesReportData salesData;

const SalesOverviewCard({super.key, required this.salesData});

@override
Widget build(BuildContext context, WidgetRef ref) {
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);

    return CustomCard(
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              localizations.salesOverview,
              style: theme.textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
                color: theme.colorScheme.primary,
              ),
            ),
            const SizedBox(height: 16),
            GridView.count(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              crossAxisCount: 2,
              crossAxisSpacing: 16,
              mainAxisSpacing: 16,
              children: [
                _buildMetricCard(
                  context,
                  localizations.totalRevenue,
                  AppFormatters.formatCurrency(salesData.totalSales),
                  Icons.attach_money,
                  Colors.green,
                ),
                _buildMetricCard(
                  context,
                  localizations.totalOrders,
                  salesData.totalOrders.toString(),
                  Icons.shopping_cart,
                  Colors.blue,
                ),
                _buildMetricCard(
                  context,
                  localizations.averageOrderValue,
                  AppFormatters.formatCurrency(salesData.averageOrderValue),
                  Icons.trending_up,
                  Colors.orange,
                ),
                _buildMetricCard(
                  context,
                  'Growth Rate',
                  '+12.5%',
                  Icons.analytics,
                  Colors.purple,
                ),
              ],
            ),
          ],
        ),
      ),
    );

}

Widget \_buildMetricCard(
BuildContext context,
String title,
String value,
IconData icon,
Color color,
) {
final theme = Theme.of(context);

    return Container(
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: theme.colorScheme.outline.withOpacity(0.2)),
        boxShadow: [
          BoxShadow(
            color: theme.colorScheme.shadow.withOpacity(0.1),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: color.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Icon(icon, color: color, size: 20),
                ),
                const Spacer(),
                Text(
                  value,
                  style: theme.textTheme.titleLarge?.copyWith(
                    fontWeight: FontWeight.bold,
                    color: theme.colorScheme.onSurface,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 8),
            Text(
              title,
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.onSurface.withOpacity(0.7),
              ),
            ),
          ],
        ),
      ),
    );

}
}

##

// lib/src/widgets/reports/subscription_info_card.dart
// Subscription info card widget displaying current subscription plan details.
import 'package:flutter/material.dart';
import '../../localization/app_localizations.dart';
import '../../data/models/subscription.dart';
import '../common/custom_card.dart';

class SubscriptionInfoCard extends StatelessWidget {
final SubscriptionPlan plan;

const SubscriptionInfoCard({super.key, required this.plan});

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);

    final planColor = _getPlanColor(theme);
    final planDescription = _getPlanDescription(localizations);

    return Container(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: CustomCard(
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              Icon(Icons.workspace_premium, color: planColor, size: 24),
              const SizedBox(width: 12),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      '${plan.name} ${localizations.plan}',
                      style: TextStyle(
                        fontWeight: FontWeight.bold,
                        color: planColor,
                        fontSize: 16,
                      ),
                    ),
                    Text(
                      planDescription,
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: theme.colorScheme.outline,
                      ),
                    ),
                    if (plan.id == 'basic') ...[
                      const SizedBox(height: 4),
                      Text(
                        localizations.upgradeForAdvancedReports,
                        style: TextStyle(
                          fontSize: 12,
                          color: planColor,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ],
                  ],
                ),
              ),
              if (plan.id == 'basic')
                TextButton(
                  onPressed: () => _showUpgradeDialog(context),
                  child: Text(localizations.upgrade),
                ),
            ],
          ),
        ),
      ),
    );

}

Color \_getPlanColor(ThemeData theme) {
switch (plan.id) {
case 'basic':
return theme.colorScheme.primary;
case 'professional':
return Colors.green;
case 'enterprise':
return Colors.purple;
default:
return theme.colorScheme.outline;
}
}

String \_getPlanDescription(AppLocalizations localizations) {
switch (plan.id) {
case 'basic':
return localizations.basicReportsDescription;
case 'professional':
return localizations.professionalReportsDescription;
case 'enterprise':
return localizations.enterpriseReportsDescription;
default:
return localizations.basicReportsDescription;
}
}

void \_showUpgradeDialog(BuildContext context) {
final localizations = AppLocalizations.of(context);
showDialog(
context: context,
builder: (context) => AlertDialog(
title: Text(localizations.upgradeYourPlan),
content: Text(localizations.upgradeForAdvancedAnalytics),
actions: [
TextButton(
onPressed: () => Navigator.pop(context),
child: Text(localizations.cancel),
),
ElevatedButton(
onPressed: () {
Navigator.pop(context);
// Navigate to subscription plans screen
},
child: Text(localizations.viewPlans),
),
],
),
);
}
}

##

// lib/src/widgets/reports/top_customers_chart.dart
// Top customers chart widget displaying the highest spending customers.
import 'package:flutter/material.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import 'package:intl/intl.dart';
import '../../localization/app_localizations.dart';
import '../../utils/formatters.dart';
import '../../utils/reports_data_calculator.dart';
import '../common/custom_card.dart';

class TopCustomersChart extends StatelessWidget {
final List<TopCustomer> customers;

const TopCustomersChart({super.key, required this.customers});

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);

    return CustomCard(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              localizations.topCustomers,
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            SizedBox(
              height: 400,
              child: customers.isNotEmpty
                  ? SfCartesianChart(
                      primaryXAxis: CategoryAxis(
                        labelRotation: -45,
                        majorGridLines: const MajorGridLines(width: 0),
                      ),
                      primaryYAxis: NumericAxis(
                        numberFormat: NumberFormat.currency(symbol: 'ETB '),
                        majorGridLines: const MajorGridLines(width: 0.5),
                      ),
                      series: <CartesianSeries<TopCustomer, String>>[
                        BarSeries<TopCustomer, String>(
                          dataSource: customers.take(10).toList(),
                          xValueMapper: (customer, _) =>
                              _truncateName(customer.name),
                          yValueMapper: (customer, _) => customer.totalSpent,
                          color: theme.colorScheme.primary,
                          width: 0.6,
                          dataLabelSettings: DataLabelSettings(
                            isVisible: true,
                            labelAlignment: ChartDataLabelAlignment.outer,
                            textStyle: theme.textTheme.bodySmall,
                          ),
                          animationDuration: 1000,
                        )
                      ],
                      tooltipBehavior: TooltipBehavior(
                        enable: true,
                        format: 'point.x : ETB point.y',
                      ),
                    )
                  : Container(
                      height: 200,
                      alignment: Alignment.center,
                      child: Text(
                        'No customer data available',
                        style: theme.textTheme.bodyMedium?.copyWith(
                          color: theme.colorScheme.outline,
                        ),
                      ),
                    ),
            ),
          ],
        ),
      ),
    );

}

String \_truncateName(String name) {
return name.length > 15 ? '${name.substring(0, 15)}...' : name;
}
}

##

// lib/src/widgets/reports/top_products_chart.dart
// Top products chart widget displaying the highest revenue-generating products.
import 'package:andalus_smart_pos/src/utils/chart_formatters.dart';
import 'package:flutter/material.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import '../../localization/app_localizations.dart';
import '../../utils/formatters.dart';
import '../../utils/reports_data_calculator.dart';
import '../common/custom_card.dart';

class TopProductsChart extends StatelessWidget {
final List<TopSellingProduct> products;

const TopProductsChart({super.key, required this.products});

@override
Widget build(BuildContext context) {
final localizations = AppLocalizations.of(context);
final theme = Theme.of(context);

    return CustomCard(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              localizations.topSellingProducts,
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            SizedBox(
              height: 400,
              child: SfCartesianChart(
                primaryXAxis: CategoryAxis(
                  labelRotation: -45,
                  majorGridLines: const MajorGridLines(width: 0),
                ),
                primaryYAxis: NumericAxis(
                  numberFormat: ChartFormatters.currencyFormat,
                  majorGridLines: const MajorGridLines(width: 0.5),
                ),
                series: <CartesianSeries<TopSellingProduct, String>>[
                  BarSeries<TopSellingProduct, String>(
                    dataSource: products.take(10).toList(),
                    xValueMapper: (product, _) => product.name,
                    yValueMapper: (product, _) => product.revenue,
                    color: theme.colorScheme.primary,
                    width: 0.6,
                    dataLabelSettings: DataLabelSettings(
                      isVisible: true,
                      labelAlignment: ChartDataLabelAlignment.outer,
                      textStyle: theme.textTheme.bodySmall,
                    ),
                    animationDuration: 1000,
                  )
                ],
                tooltipBehavior: TooltipBehavior(
                  enable: true,
                  format: 'point.x : ETB point.y',
                ),
              ),
            ),
            if (products.isEmpty)
              Container(
                height: 200,
                alignment: Alignment.center,
                child: Text(
                  'No product data available',
                  style: theme.textTheme.bodyMedium?.copyWith(
                    color: theme.colorScheme.outline,
                  ),
                ),
              ),
          ],
        ),
      ),
    );

}
}

##

// mobile/lib/src/app.dart
// Main application widget for Andalus Smart POS.
import 'package:andalus_smart_pos/src/ui/screens/ReportsScreen.dart';
import 'package:andalus_smart_pos/src/ui/screens/auth/registration_screen.dart';
import 'package:andalus_smart_pos/src/ui/screens/customer_management_screen.dart';
import 'package:andalus_smart_pos/src/ui/screens/onboarding/onboarding_screen.dart';
import 'package:andalus_smart_pos/src/ui/screens/pos_screen.dart';
import 'package:andalus_smart_pos/src/ui/screens/product_management_screen.dart';
import 'package:andalus_smart_pos/src/ui/screens/splash_screen.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:andalus_smart_pos/src/config/app_theme.dart';
import 'package:andalus_smart_pos/src/ui/screens/main_navigation.dart';
import 'package:andalus_smart_pos/src/providers/theme_provider.dart';
import 'package:andalus_smart_pos/src/providers/language_provider.dart';
import 'package:andalus_smart_pos/src/localization/app_localizations.dart';
import 'package:andalus_smart_pos/src/providers/auth_provider.dart';
import 'package:andalus_smart_pos/src/ui/screens/auth/phone_login_screen.dart';

// Updated AndalusApp widget
class AndalusApp extends ConsumerWidget {
const AndalusApp({super.key});

@override
Widget build(BuildContext context, WidgetRef ref) {
final themeMode = ref.watch(themeProvider);
final locale = ref.watch(languageProvider);
final fontTheme = ref.watch(fontThemeProvider);

    return MaterialApp(
      title: 'Andalus Smart POS',
      theme: AppTheme.lightTheme(ref),
      darkTheme: AppTheme.darkTheme(ref),
      themeMode: themeMode,
      locale: locale,
      localizationsDelegates: const [
        AppLocalizations.delegate,
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [
        Locale('en', 'US'),
        Locale('am', 'ET'),
      ],
      home: const SplashScreen(),
      debugShowCheckedModeBanner: false,
      routes: {
        '/pos': (context) => const PosScreen(),
        '/products': (context) => const ProductManagementScreen(),
        '/customers': (context) => const CustomerManagementScreen(),
        '/reports': (context) => const ReportsScreen(),
        '/register': (context) => const OnboardingScreen(),
      },
    );

}
}

##

// mobile/lib/main.dart
// Main entry point for Andalus Smart POS application.
import 'dart:ui';

import 'package:andalus_smart_pos/src/data/local/database.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'src/app.dart';
import 'src/utils/database_init.dart';

void main() async {
WidgetsFlutterBinding.ensureInitialized();

FlutterError.onError = (FlutterErrorDetails details) {
FlutterError.presentError(details);
print('Flutter Error: ${details.exception}');
};
PlatformDispatcher.instance.onError = (error, stack) {
print('Platform Error: $error');
return true;
};
// Initialize and migrate database
try {
await AppDatabase.migrateDatabase();
await AppDatabase.verifyOTPTable();
await AppDatabase.migrateSalesTable();
await DatabaseInitializer.initializeDefaultData();
print('App initialization completed successfully');
} catch (e) {
print('App initialization error: $e');
}

runApp(const ProviderScope(child: AndalusApp()));
}

> > > > > > > 0bf26c0 (Read me filled)
